<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.0.0_0_dev" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg># Base reactive interfaces</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061145Z" creationid="pingfangx" creationdate="20190618T061145Z">
        <seg># 基本响应接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052054Z" creationid="pingfangx" creationdate="20190618T052054Z">
        <seg># 内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Creating backpressured datasources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015345Z" creationid="pingfangx" creationdate="20190624T015345Z">
        <seg># 创建背压数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Entering the reactive world</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094146Z" creationid="pingfangx" creationdate="20190618T094146Z">
        <seg># 进入响应世界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Introduction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T062104Z" creationid="pingfangx" creationdate="20190621T062104Z">
        <seg># 介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Leaving the reactive world</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094913Z" creationid="pingfangx" creationdate="20190618T094913Z">
        <seg># 离开响应世界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Maven address and base package</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052542Z" creationid="pingfangx" creationdate="20190618T052542Z">
        <seg># Maven 地址和基础包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Miscellaneous changes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114733Z" creationid="pingfangx" creationdate="20190618T114733Z">
        <seg># 杂项更改</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Observable and Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053023Z" creationid="pingfangx" creationdate="20190618T053023Z">
        <seg># Observable 和 Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Operator differences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T103142Z" creationid="pingfangx" creationdate="20190618T103142Z">
        <seg># 操作符差异</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Other classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063638Z" creationid="pingfangx" creationdate="20190618T063638Z">
        <seg># 其他类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># RxJava: Reactive Extensions for the JVM</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103322Z" creationid="pingfangx" creationdate="20190617T103322Z">
        <seg># RxJava: Reactive Extensions for the JVM
原文 [ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The onBackpressureXXX operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084603Z" creationid="pingfangx" creationdate="20190621T084603Z">
        <seg># onBackpressureXXX 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## 1.x Observable to 2.x Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111342Z" creationid="pingfangx" creationdate="20190618T111342Z">
        <seg>## 1.x Observable 到 2.x Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Batching/skipping values with standard operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091136Z" creationid="pingfangx" creationdate="20190621T091136Z">
        <seg>## 使用标准操作符批处理/跳过值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Binaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105435Z" creationid="pingfangx" creationdate="20190617T105435Z">
        <seg>## 二进制文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Bugs and Feedback</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105627Z" creationid="pingfangx" creationdate="20190617T105627Z">
        <seg>## 错误和反馈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Build</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105554Z" creationid="pingfangx" creationdate="20190617T105554Z">
        <seg>## 构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Communication</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104636Z" creationid="pingfangx" creationdate="20190617T104636Z">
        <seg>## 沟通</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Full Documentation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105421Z" creationid="pingfangx" creationdate="20190617T105421Z">
        <seg>## 完整文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Getting started</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065829Z" creationid="pingfangx" creationdate="20190617T065829Z">
        <seg>## 入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Increasing the buffer sizes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090231Z" creationid="pingfangx" creationdate="20190621T090231Z">
        <seg>## 增加缓冲区大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Testing an async source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101814Z" creationid="pingfangx" creationdate="20190618T101814Z">
        <seg>## 测试异步源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Versioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104645Z" creationid="pingfangx" creationdate="20190617T104645Z">
        <seg>## 版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Which type to use?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053516Z" creationid="pingfangx" creationdate="20190618T053516Z">
        <seg>## 使用哪种类型？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## cancel and request upfront</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101647Z" creationid="pingfangx" creationdate="20190618T101647Z">
        <seg>## 取消并提前请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Base classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070028Z" creationid="pingfangx" creationdate="20190617T065921Z">
        <seg>### 基类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Calling request from onSubscribe/onStart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070914Z" creationid="pingfangx" creationdate="20190618T070914Z">
        <seg>### 从 onSubscribe/onStart 调用请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Concurrency within a flow</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075248Z" creationid="pingfangx" creationdate="20190617T075248Z">
        <seg>### Concurrency within a flow (流中的并发)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Different return types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060112Z" creationid="pingfangx" creationdate="20190619T060112Z">
        <seg>### 不同的返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Factory methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111351Z" creationid="pingfangx" creationdate="20190618T111351Z">
        <seg>### 工厂方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Further reading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104614Z" creationid="pingfangx" creationdate="20190617T104614Z">
        <seg>### 扩展阅读</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Instance methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114532Z" creationid="pingfangx" creationdate="20190618T114532Z">
        <seg>### 实例方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Notable new assert methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100029Z" creationid="pingfangx" creationdate="20190618T100029Z">
        <seg>### 值得注意的新断言方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Operator naming conventions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100918Z" creationid="pingfangx" creationdate="20190617T100918Z">
        <seg>### 运算符命名约定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Parallel processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075735Z" creationid="pingfangx" creationdate="20190617T075735Z">
        <seg>### Parallel processing (并行处理)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Removals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061504Z" creationid="pingfangx" creationdate="20190619T061504Z">
        <seg>### 移除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava Libraries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113636Z" creationid="pingfangx" creationdate="20190617T113636Z">
        <seg>### RxJava 库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava is Lightweight</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113501Z" creationid="pingfangx" creationdate="20190617T113501Z">
        <seg>### RxJava 是轻量级的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava is a Polyglot Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113532Z" creationid="pingfangx" creationdate="20190617T113532Z">
        <seg>### RxJava 是一个多语言实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072905Z" creationid="pingfangx" creationdate="20190617T072905Z">
        <seg>### Schedulers (调度器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Setting up the dependency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065800Z" creationid="pingfangx" creationdate="20190617T065800Z">
        <seg>### 设置依赖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Simple background computation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072223Z" creationid="pingfangx" creationdate="20190617T072223Z">
        <seg>### 简单的后台计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Some terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070420Z" creationid="pingfangx" creationdate="20190617T070420Z">
        <seg>### 一些术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Type conversions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092701Z" creationid="pingfangx" creationdate="20190617T092701Z">
        <seg>### Type conversions (类型转换)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### When to use Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054920Z" creationid="pingfangx" creationdate="20190618T054920Z">
        <seg>### 何时使用 Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### When to use Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053650Z" creationid="pingfangx" creationdate="20190618T053650Z">
        <seg>### 何时使用 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Assembly time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092336Z" creationid="pingfangx" creationdate="20190617T072124Z">
        <seg>#### Assembly time (编译时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Backpressure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071620Z" creationid="pingfangx" creationdate="20190617T071124Z">
        <seg>#### Backpressure (背压)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Converting to the desired type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092851Z" creationid="pingfangx" creationdate="20190617T092851Z">
        <seg>#### 转换为所需类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Error handling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103119Z" creationid="pingfangx" creationdate="20190617T103119Z">
        <seg>#### 错误处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Objects in motion</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071614Z" creationid="pingfangx" creationdate="20190617T071032Z">
        <seg>#### Objects in motion (运动中的对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Runtime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072154Z" creationid="pingfangx" creationdate="20190617T072154Z">
        <seg>#### Runtime (运行时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Subscription time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092347Z" creationid="pingfangx" creationdate="20190617T072132Z">
        <seg>#### Subscription time (订阅时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Type ambiguities</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102207Z" creationid="pingfangx" creationdate="20190617T102207Z">
        <seg>#### 类型歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Type erasure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101921Z" creationid="pingfangx" creationdate="20190617T101921Z">
        <seg>#### 类型擦除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Unusable keywords</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101509Z" creationid="pingfangx" creationdate="20190617T101509Z">
        <seg>#### 不可用的关键字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Upstream, downstream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071556Z" creationid="pingfangx" creationdate="20190617T070428Z">
        <seg>#### Upstream, downstream (上游，下游)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Using an overload with the desired type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100644Z" creationid="pingfangx" creationdate="20190617T100644Z">
        <seg>#### 使用所需类型的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the source Observable does not emit any values, the &lt;c1&gt;AsyncSubject&lt;/c1&gt; also completes without emitting any values.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083942Z" creationid="pingfangx" creationdate="20190620T083942Z">
        <seg>(如果源 Observable 未发射任何值，则 &lt;c1&gt;AsyncSubject&lt;/c1&gt; 也会完成而不会发射任何值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The Reactive-Streams specification allows throwing `NullPointerException` if the `onSubscribe`, `onNext` or `onError` receives a `null` value, but RxJava doesn't let `null`s in any way.) This means the following code is no longer legal:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095546Z" creationid="pingfangx" creationdate="20190618T095546Z">
        <seg>（如果 `onSubscribe`，`onNext` 或 `onError` 接收到 `null` 值，Reactive-Streams 规范允许抛出 `NullPointerException`，但 RxJava 不以任何方式接受 `null`。这意味着以下代码不再合法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The reason for this is twofold: performance and ease of use of the library as a synchronous Java 8 Streams-like processor.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095320Z" creationid="pingfangx" creationdate="20190618T095320Z">
        <seg>(原因有两个：作为同步 Java 8 Streams 类似处理器的库的性能和易用性。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The same approach works with `GroupedFlowable` as well.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064010Z" creationid="pingfangx" creationdate="20190618T064010Z">
        <seg>(同样的方法也适用于 `GroupedFlowable`。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is understandable because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091144Z" creationid="pingfangx" creationdate="20190617T091144Z">
        <seg>(这是可以理解的，因为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We never had a use for it in 1.x and the original `Subject&lt;T, R&gt;` came from .NET where there is a `Subject&lt;T&gt;` overload because .NET allows the same class name with a different number of type arguments.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062556Z" creationid="pingfangx" creationdate="20190618T062556Z">
        <seg>(我们从来没有在 1.x 中使用它，原来的 `Subject&lt;T, R&gt;` 来自 .NET，其中有一个 `Subject&lt;T&gt;` 重载，因为 .NET 允许相同的类名具有不同数量的类型参数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(b)  Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021729Z" creationid="pingfangx" creationdate="20190828T021729Z">
        <seg>(b) 确定已经确认了报文段所占用的所有序列号(例如，从重发队列中删除该报文段)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(c)  Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021745Z" creationid="pingfangx" creationdate="20190828T021745Z">
        <seg>(c) 确定传入报文段包含预期的序列号(即，报文段“重叠”接收窗口)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*(Remark: this is "experimental" in RC2 and RC3 to see how it feels to program with such mixed-type sequences and whether or not there has to be too much `toObservable`/`toFlowable` back-conversion.)*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060231Z" creationid="pingfangx" creationdate="20190619T060231Z">
        <seg>*(注：这在 RC2 和 RC3 中是“实验性的”，看看用这种混合型序列编程感觉如何，以及是否必须有太多 `toObservable`/`toFlowable` 反向转换。)*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*(You could also consider IxJava which is optimized for Iterable flows supporting Java 6+)*.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054849Z" creationid="pingfangx" creationdate="20190618T054849Z">
        <seg>*(您还可以考虑 IxJava，它针对支持 Java 6+ 的 Iterable 流程进行了优化)*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**Backpressure** is when in an `Flowable` processing pipeline, some asynchronous stages can't process the values fast enough and need a way to tell the upstream producer to slow down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T062429Z" creationid="pingfangx" creationdate="20190621T062429Z">
        <seg>**Backpressure (背压)** 是在 `Flowable` 外理管道中，某些异步阶段无法足够快地处理这些值，需要一种方法来告诉上游生产者减速。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** dropped, use `ignoreElements`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054007Z" creationid="pingfangx" creationdate="20190619T054007Z">
        <seg>**RC3** 删除，请使用 `ignoreElements`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** dropped, use `single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054042Z" creationid="pingfangx" creationdate="20190619T054042Z">
        <seg>**RC3** 已删除，请使用 `single(T)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** no longer signals NoSuchElementException if the source is shorter than the index</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052611Z" creationid="pingfangx" creationdate="20190619T052611Z">
        <seg>如果源短于索引，**RC3** 不再发出 NoSuchElementException 信号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `firstElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052939Z" creationid="pingfangx" creationdate="20190619T052939Z">
        <seg>**RC3** 重命名为 `firstElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `lastElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053135Z" creationid="pingfangx" creationdate="20190619T053135Z">
        <seg>**RC3** 重命名为 `lastElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `singleElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053608Z" creationid="pingfangx" creationdate="20190619T053608Z">
        <seg>**RC3** 重命名为 `singleElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Completable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053116Z" creationid="pingfangx" creationdate="20190619T053116Z">
        <seg>**RC3** 返回 `Completable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053323Z" creationid="pingfangx" creationdate="20190619T053323Z">
        <seg>**RC3** 返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Boolean&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053123Z" creationid="pingfangx" creationdate="20190619T053123Z">
        <seg>**RC3** 返回 `Single&lt;Boolean&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Boolean&gt;` now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115702Z" creationid="pingfangx" creationdate="20190618T115702Z">
        <seg>**RC3** 现在返回 `Single&lt;Boolean&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;List&lt;T&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054014Z" creationid="pingfangx" creationdate="20190619T054014Z">
        <seg>**RC3** 返回 `Single&lt;List&lt;T&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Long&gt;` now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052201Z" creationid="pingfangx" creationdate="20190619T052201Z">
        <seg>**RC3** 现直返回 `Single&lt;Long&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054027Z" creationid="pingfangx" creationdate="20190619T054027Z">
        <seg>**RC3** 返回 `Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Map&lt;K, V&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054020Z" creationid="pingfangx" creationdate="20190619T054020Z">
        <seg>**RC3** 返回 `Single&lt;Map&lt;K, V&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;U&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115759Z" creationid="pingfangx" creationdate="20190618T115759Z">
        <seg>**RC3** 返回 `Single&lt;U&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**The `Flowable`-based sources and operators are, as of 2.0.7, fully Reactive-Streams version 1.0.0 specification compliant.**</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073813Z" creationid="pingfangx" creationdate="20190618T073813Z">
        <seg>**从 2.0.7 开始，基于 `Flowable` 的源和运算符完全符合 Reactive-Streams 版本 1.0.0 规范。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Dealing with 10k+ of elements that are generated in some fashion somewhere and thus the chain can tell the source to limit the amount it generates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055019Z" creationid="pingfangx" creationdate="20190618T055019Z">
        <seg>- 处理以某种方式在某处生成的 10k+ 元素，因此链可以告诉源限制它产生的量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Java 8 lambda-friendly API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065159Z" creationid="pingfangx" creationdate="20190617T065159Z">
        <seg>- Java 8 lambda 友好的 API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Many blocking and/or pull-based data sources which may eventually get a non-blocking reactive API/driver in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055442Z" creationid="pingfangx" creationdate="20190618T055442Z">
        <seg>- 许多阻塞和/或基于拉的数据源，最终可能会在未来获得非阻塞的响应 API/驱动程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Network (Streaming) IO where either the network helps or the protocol used supports requesting some logical amount.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055402Z" creationid="pingfangx" creationdate="20190618T055402Z">
        <seg>- 网络(流)IO，其中网络帮助或使用的协议支持请求一些逻辑量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Reading (parsing) files from disk is inherently blocking and pull-based which works well with backpressure as you control, for example, how many lines you read from this for a specified request amount).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055258Z" creationid="pingfangx" creationdate="20190618T055258Z">
        <seg>- 从磁盘读取（解析）文件本质上是阻塞和基于拉取的，当您控制时，它可以很好地处理背压，例如，您为指定的请求数量控制读取多少行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Reading from a database through JDBC is also blocking and pull-based and is controlled by you by calling `ResultSet.next()` for likely each downstream request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055324Z" creationid="pingfangx" creationdate="20190618T055324Z">
        <seg>- 通过 JDBC 从数据库读取也是阻塞和基于拉取的，并且可以通过调用 `ResultSet.next()` 来控制每个下游请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- You deal with GUI events such as mouse moves or touch events: these can rarely be backpressured reasonably and aren't that frequent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054621Z" creationid="pingfangx" creationdate="20190618T054621Z">
        <seg>- 您处理 GUI 事件，例如鼠标移动或触摸事件：这些事件很少能够合理地背压并且不那么频繁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- You have a flow of no more than 1000 elements at its longest: i.e., you have so few elements over time that there is practically no chance for OOME in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054407Z" creationid="pingfangx" creationdate="20190618T054407Z">
        <seg>- 最长流不超过 1000 个元素：即，随着时间的推移元素会很少，因此在您的应用程序中几乎不会出现 OOME。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Your flow is essentially synchronous but your platform doesn't support Java Streams or you miss features from it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054808Z" creationid="pingfangx" creationdate="20190618T054808Z">
        <seg>- 您的流基本上是同步的，但您的平台不支持 Java Streams，或者您错过了它的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Base reactive interfaces](#base-reactive-interfaces)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052438Z" creationid="pingfangx" creationdate="20190618T052438Z">
        <seg>- [基本响应接口](#base-reactive-interfaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Maven address and base package](#maven-address-and-base-package)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052409Z" creationid="pingfangx" creationdate="20190618T052409Z">
        <seg>- [Maven 地址和基础包](#maven-address-and-base-package)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Miscellaneous changes](#miscellaneous-changes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052533Z" creationid="pingfangx" creationdate="20190618T052533Z">
        <seg>- [杂项更改](#miscellaneous-changes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Observable and Flowable](#observable-and-flowable)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052413Z" creationid="pingfangx" creationdate="20190618T052413Z">
        <seg>- [Observable 和 Flowable](#observable-and-flowable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Other classes](#other-classes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052452Z" creationid="pingfangx" creationdate="20190618T052452Z">
        <seg>- [其他类](#other-classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Subjects and Processors](#subjects-and-processors)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052444Z" creationid="pingfangx" creationdate="20190618T052444Z">
        <seg>- [Subjects 和 Processors](#subjects-and-processors)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): a flow without items but only a completion or error signal,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070349Z" creationid="pingfangx" creationdate="20190617T070349Z">
        <seg>- [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): 没有项目但只有完成或错误信号的流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Flowable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html): 0..N flows, supporting Reactive-Streams and backpressure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070240Z" creationid="pingfangx" creationdate="20190617T070240Z">
        <seg>- [`io.reactivex.Flowable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html): 0..N 流，支持响应式流和背压</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): a flow with no items, exactly one item or an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070416Z" creationid="pingfangx" creationdate="20190617T070416Z">
        <seg>- [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): 没有项目，只有一个项目或错误的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N flows, no backpressure,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070329Z" creationid="pingfangx" creationdate="20190617T070250Z">
        <seg>- [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N 流，无背压，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): a flow of exactly 1 item or an error,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070327Z" creationid="pingfangx" creationdate="20190617T070319Z">
        <seg>- [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): 仅 1 个项目或错误的流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `CompositeSubscription` to `CompositeDisposable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073146Z" creationid="pingfangx" creationdate="20190618T073146Z">
        <seg>- `CompositeSubscription` 变为 `CompositeDisposable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DEFAULT`: currently it is the same as `ON_OVERFLOW_ERROR`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014531Z" creationid="pingfangx" creationdate="20190624T014531Z">
        <seg>- `ON_OVERFLOW_DEFAULT`：目前它与 `ON_OVERFLOW_ERROR` 相同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DROP_LATEST` : if an overflow would happen, the current value will be simply ignored and only the old values will be delivered once the downstream requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014549Z" creationid="pingfangx" creationdate="20190624T014549Z">
        <seg>- `ON_OVERFLOW_DROP_LATEST`：如果发生溢出，将简单地忽略当前值，并且只有下游请求才会传递旧值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DROP_OLDEST` : drops the oldest element in the buffer and adds the current value to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014614Z" creationid="pingfangx" creationdate="20190624T014614Z">
        <seg>- `ON_OVERFLOW_DROP_OLDEST`：删除缓冲区中最旧的元素并将当前值添加到缓冲区中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_ERROR`: this is the default behavior of the previous two overloads, signalling a `BufferOverflowException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014521Z" creationid="pingfangx" creationdate="20190624T014521Z">
        <seg>- `ON_OVERFLOW_ERROR`：这是前两个重载的默认行为，表示 `BufferOverflowException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `OnErrorNotImplementedException`: reintroduced to detect when the user forgot to add error handling to `subscribe()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091126Z" creationid="pingfangx" creationdate="20190618T091126Z">
        <seg>- `OnErrorNotImplementedException`：重新引入以检测用户何时忘记向 `subscribe()` 添加错误处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ProtocolViolationException`: indicates a bug in an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091133Z" creationid="pingfangx" creationdate="20190618T091133Z">
        <seg>- `ProtocolViolationException`：表示运算符中的错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `RefCountSubscription` has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073214Z" creationid="pingfangx" creationdate="20190618T073214Z">
        <seg>- `RefCountSubscription` 已被移除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.computation()`: Run computation intensive work on a fixed number of dedicated threads in the background.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073217Z" creationid="pingfangx" creationdate="20190617T073217Z">
        <seg>- `Schedulers.computation()`: 在后台固定数量的专用线程上，运行计算密集型工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.io()`: Run I/O-like or blocking operations on a dynamically changing set of threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073321Z" creationid="pingfangx" creationdate="20190617T073321Z">
        <seg>- `Schedulers.io()`: 在动态变化的线程集上运行类似 I/O 或阻塞操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.single()`: Run work on a single thread in a sequential and FIFO manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073336Z" creationid="pingfangx" creationdate="20190617T073336Z">
        <seg>- `Schedulers.single()`: 以顺序和 FIFO 方式在单个线程上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.trampoline()`: Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073400Z" creationid="pingfangx" creationdate="20190617T073400Z">
        <seg>- `Schedulers.trampoline()`: 在一个参与线程中以顺序和 FIFO 方式运行，通常用于测试目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `SerialSubscription` and `MultipleAssignmentSubscription` have been merged into `SerialDisposable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073154Z" creationid="pingfangx" creationdate="20190618T073154Z">
        <seg>- `SerialSubscription` 和 `MultipleAssignmentSubscription` 已合并到 `SerialDisposable` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `UndeliverableException`: wraps the original exception that can't be delivered due to lifecycle restrictions on a `Subscriber`/`Observer`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091154Z" creationid="pingfangx" creationdate="20190618T091154Z">
        <seg>- `UndeliverableException`：包装因 `Subscriber`/`Observer` 的生命周期限制而无法传递的原始异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertFailure(Class&lt;? extends Throwable&gt; clazz, T... items)`: asserts if subscribed, received exactly the given items in the given order followed by a `Throwable` error of wich `clazz.isInstance()` returns true.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101401Z" creationid="pingfangx" creationdate="20190618T101401Z">
        <seg>- `assertFailure(Class&lt;? extends Throwable&gt; clazz, T... items)`：断言如果订阅，按给定顺序接收到给定项后，跟一个 `Throwable` 错误，其 `clazz.isInstance()` 返回 true。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertFailureAndMessage(Class&lt;? extends Throwable&gt; clazz, String message, T... items)`: same as `assertFailure` plus validates the `getMessage()` contains the specified message</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101434Z" creationid="pingfangx" creationdate="20190618T101434Z">
        <seg>- `assertFailureAndMessage(Class&lt;? extends Throwable&gt; clazz, String message, T... items)`：与 `assertFailure` 相同，加上验证 `getMessage()` 包含指定的消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertOf(Consumer&lt;TestSubscriber&lt;T&gt;&gt; consumer)` compose some assertions into the fluent chain (used internally for fusion test as operator fusion is not part of the public API right now).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101538Z" creationid="pingfangx" creationdate="20190618T101538Z">
        <seg>- `assertOf(Consumer&lt;TestSubscriber&lt;T&gt;&gt; consumer)` 将一些断言组合到流畅的链中(内部用于融合测试，因为运算符融合现在不是公共 API 的一部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertResult(T... items)`: asserts if subscribed, received exactly the given items in the given order followed by `onComplete` and no errors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100201Z" creationid="pingfangx" creationdate="20190618T100201Z">
        <seg>- `assertResult(T... items)`：断言如果已订阅，则在 `onComplete` 之后按给定顺序接收给定的项，并且没有错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `awaitDone(long time, TimeUnit unit)` awaits a terminal event (blockingly) and cancels the sequence if the timeout elapsed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101454Z" creationid="pingfangx" creationdate="20190618T101454Z">
        <seg>- `awaitDone(long time, TimeUnit unit)` 等待终端事件(阻塞)并在超时结束时取消序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `concatMapEager` which runs all inner flows "at once" but the output flow will be in the order those inner flows were created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083254Z" creationid="pingfangx" creationdate="20190617T083254Z">
        <seg>- `concatMapEager`，它“同时”运行所有内部流，但输出流将按照创建内部流的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `concatMap` that maps and runs one inner flow at a time and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083218Z" creationid="pingfangx" creationdate="20190617T083218Z">
        <seg>- `concatMap` 一次映射并运行一个内部流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- a `BackpressureStrategy` enumeration that mandates the developer to specify the backpressure behavior to be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021957Z" creationid="pingfangx" creationdate="20190624T021957Z">
        <seg>- 一个 `BackpressureStrategy` 枚举，要求开发人员指定要应用的背压行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- a callback that will be called with an instance of the `Emitter&lt;T&gt;` interface for each incoming subscriber,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021941Z" creationid="pingfangx" creationdate="20190624T021941Z">
        <seg>-将为每个传入的订阅者调用的回调，回调时带 `Emitter&lt;T&gt;` 接口实例，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- async or synchronous execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065441Z" creationid="pingfangx" creationdate="20190617T065441Z">
        <seg> - 异步或同步执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- continued support for Java 6+ &amp; [Android](https://github.com/ReactiveX/RxAndroid) 2.3+</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065015Z" creationid="pingfangx" creationdate="20190617T065015Z">
        <seg>- 继续支持 Java 6+ 和 [Android](https://github.com/ReactiveX/RxAndroid) 2.3+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- performance gains through design changes learned through the 1.x cycle and through [Reactive-Streams-Commons](https://github.com/reactor/reactive-streams-commons) research project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065138Z" creationid="pingfangx" creationdate="20190617T065138Z">
        <seg>- 从 1.x 周期和 [Reactive-Streams-Commons](https://github.com/reactor/reactive-streams-commons) 研究项目获得的设计变更带来的性能提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- single dependency: [Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064948Z" creationid="pingfangx" creationdate="20190617T064943Z">
        <seg>- 单一依赖：[Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- virtual time and schedulers for parameterized concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065452Z" creationid="pingfangx" creationdate="20190617T065452Z">
        <seg> - 参数化并发的虚拟时间和调度程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §1.3 relaxation: `onSubscribe` may run concurrently with `onNext` in case the `FlowableSubscriber` calls `request()` from inside `onSubscribe` and it is the resposibility of `FlowableSubscriber` to ensure thread-safety between the remaining instructions in `onSubscribe` and `onNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084037Z" creationid="pingfangx" creationdate="20190618T074115Z">
        <seg>- §1.3 宽松：`onSubscribe` 可以与 `onNext` 同时运行，以防 `FlowableSubscriber` 从 `onSubscribe` 内部调用 `request()`，并且它是 `FlowableSubscriber` 的责任以确保在 `onSubscribe` 和 `onNext` 中的其余指令之间的线程安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §2.12 relaxation: if the same `FlowableSubscriber` instance is subscribed to multiple sources, it must ensure its `onXXX` methods remain thread safe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084111Z" creationid="pingfangx" creationdate="20190618T074147Z">
        <seg>- §2.12 宽松：如果同一个 `FlowableSubscriber` 实例订阅了多个源，它必须确保它的 `onXXX` 方法保持线程安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §2.3 relaxation: calling `Subscription.cancel` and `Subscription.request` from `FlowableSubscriber.onComplete()` or `FlowableSubscriber.onError()` is considered a no-operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084051Z" creationid="pingfangx" creationdate="20190618T074127Z">
        <seg>- §2.3 宽松：从 `FlowableSubscriber.onComplete()` 或 `FlowableSubscriber.onError()` 调用 `Subscription.cancel` 和 `Subscription.request` 被认为是无操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §3.9 relaxation: issuing a non-positive `request()` will not stop the current stream but signal an error via `RxJavaPlugins.onError`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084133Z" creationid="pingfangx" creationdate="20190618T074156Z">
        <seg>- §3.9 宽松：发出一个非肯定的 `request()` 不会停止当前流，但会通过 `RxJavaPlugins.onError` 发出错误信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- "how does the TCP identify duplicate segments from previous incarnations of the connection?"  This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023223Z" creationid="pingfangx" creationdate="20190828T023223Z">
        <seg> - “TCP 如何识别以前连接的复制报文段？”如果快速连续打开和关闭连接，或者连接因内存丢失而中断然后重新建立，则此问题变得明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If Java 8 lambdas are supported</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090817Z" creationid="pingfangx" creationdate="20190618T090817Z">
        <seg>//如果支持 Java 8 lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If no Retrolambda or Jack</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090828Z" creationid="pingfangx" creationdate="20190618T090828Z">
        <seg>//如果没有 Retrolambda 或 Jack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 - old sequence numbers which have been acknowledged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111911Z" creationid="pingfangx" creationdate="20190827T111911Z">
        <seg>1 - 已确认的序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 - sequence numbers allowed for new reception</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111916Z" creationid="pingfangx" creationdate="20190827T111916Z">
        <seg>2 - 允许新接收的序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2-9 argument version dropped, use `startWithArray` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053722Z" creationid="pingfangx" creationdate="20190619T053722Z">
        <seg>2-9 参数版本删除，使用 `startWithArray` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 - future sequence numbers which are not yet allowed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111921Z" creationid="pingfangx" creationdate="20190827T111921Z">
        <seg>3 - 未来允许的序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5-9 source overloads dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054154Z" creationid="pingfangx" creationdate="20190619T054154Z">
        <seg>5-9 源重载删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;t1&gt;Single&lt;/t1&gt;&lt;/a0&gt; — a specialized version of an Observable that emits only a single item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044426Z" creationid="pingfangx" creationdate="20190620T044426Z">
        <seg>&lt;a0&gt;&lt;t1&gt;Single&lt;/t1&gt;&lt;/a0&gt; — 特殊版本的 Observable，仅发射单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Another &lt;c1&gt;Scheduler&lt;/c1&gt; method&lt;/a0&gt; allows you to schedule an action to take place at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092613Z" creationid="pingfangx" creationdate="20190620T092613Z">
        <seg>&lt;a0&gt;另一个 &lt;c1&gt;Scheduler&lt;/c1&gt; 方法&lt;/a0&gt; 允许您调度定期执行的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;The &lt;c1&gt;Subscribe&lt;/c1&gt; method&lt;/a0&gt; is how you connect an observer to an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055947Z" creationid="pingfangx" creationdate="20190620T055947Z">
        <seg>&lt;a0&gt;&lt;c1&gt;Subscribe&lt;/c1&gt; 方法&lt;/a0&gt; 是将观察者连接到 Observable 的方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;The &lt;c1&gt;TestScheduler&lt;/c1&gt;&lt;/a0&gt; allows you to exercise fine-tuned manual control over how the Scheduler’s clock behaves.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091811Z" creationid="pingfangx" creationdate="20190620T091811Z">
        <seg>&lt;a0&gt;The &lt;c1&gt;TestScheduler&lt;/c1&gt;&lt;/a0&gt; 允许您对调度器的时钟行为进行微调手动控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt; is a single abstraction that can be used for any of these use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035601Z" creationid="pingfangx" creationdate="20190620T035601Z">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt; 是一个可用于任何这些用例的抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;PublishSubject&lt;/c0&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084605Z" creationid="pingfangx" creationdate="20190620T084605Z">
        <seg>&lt;c0&gt;PublishSubject&lt;/c0&gt; 仅向观察者发射订阅时间之后由源 Observable 发射的那些项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ReplaySubject&lt;/c0&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084938Z" creationid="pingfangx" creationdate="20190620T084938Z">
        <seg>无论观察者何时订阅，&lt;c0&gt;ReplaySubject&lt;/c0&gt; 都会向任何观察者发射源 Observable 发射的所有项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;ObserveOn&lt;/s1&gt;, on the other hand, affects the thread that the Observable will use &lt;e2&gt;below&lt;/e2&gt; where that operator appears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090449Z" creationid="pingfangx" creationdate="20190620T090449Z">
        <seg>另一方面，&lt;s1&gt;ObserveOn&lt;/s1&gt; 会影响 Observable 将在 &lt;e2&gt;下面&lt;/e2&gt; 出现的操作符使用的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;1&lt;/sup&gt;: When turning a multi-valued source into a single valued source, one should decide which of the many source values should be considered as the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095426Z" creationid="pingfangx" creationdate="20190617T095426Z">
        <seg>&lt;sup&gt;1&lt;/sup&gt;：当将多值源转换为单值源时，应该决定应该将多个源值中的哪一个视为结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;1&lt;/sup&gt;The `org.reactivestreams.Publisher` is part of the external Reactive Streams library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104341Z" creationid="pingfangx" creationdate="20190617T104341Z">
        <seg>&lt;sup&gt;1&lt;/sup&gt; `org.reactivestreams.Publisher` 是外部 Reactive Streams 库的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;2&lt;/sup&gt;: Turning an `Observable` into `Flowable` requires an additional decision: what to do with the potential unconstrained flow</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095444Z" creationid="pingfangx" creationdate="20190617T095444Z">
        <seg>&lt;sup&gt;2&lt;/sup&gt;：将 `Observable` 转换为 `Flowable` 需要另外一个决定：如何处理潜在的无约束流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;2&lt;/sup&gt;The naming convention of the interface was to append `Source` to the semi-traditional class name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104446Z" creationid="pingfangx" creationdate="20190617T104446Z">
        <seg>&lt;sup&gt;2&lt;/sup&gt; 接口的命名约定是将 `Source` 附加到半传统类名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;3&lt;/sup&gt;: When there is only (at most) one source item, there is no problem with backpressure as it can be always stored until the downstream is ready to consume.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100635Z" creationid="pingfangx" creationdate="20190617T100635Z">
        <seg>&lt;sup&gt;3&lt;/sup&gt;：当只有(最多)一个源项时，背压没有问题，因为它可以一直存储，直到下游准备好消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A --&gt; B  ACK your sequence number is Y</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023933Z" creationid="pingfangx" creationdate="20190828T023933Z">
        <seg>A --&gt; B  ACK 你的序列号是 Y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A --&gt; B  SYN my sequence number is X</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023843Z" creationid="pingfangx" creationdate="20190828T023843Z">
        <seg>A --&gt; B  SYN 我的序列号是 X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;-- B  ACK your sequence number is X</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023901Z" creationid="pingfangx" creationdate="20190828T023901Z">
        <seg>A &lt;-- B  ACK 你的序列号是 X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;-- B  SYN my sequence number is Y</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023909Z" creationid="pingfangx" creationdate="20190828T023909Z">
        <seg>A &lt;-- B  SYN 我的序列号是 Y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Decision Tree of Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094409Z" creationid="pingfangx" creationdate="20190620T094409Z">
        <seg>Observable 操作符的决策树</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A SYN-ACK is returned (line 3) and causes TCP A to generate a RST (the ACK in line 3 is not acceptable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060402Z" creationid="pingfangx" creationdate="20190828T060402Z">
        <seg>返回 SYN-ACK(第 3 行)并使 TCP A 生成 RST(第 3 行中的 ACK 不可接受)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073414Z" creationid="pingfangx" creationdate="20190620T073414Z">
        <seg>Single 就像一个 Observable，但它不发射一系列值 - 从零个到无限个 - 它总是发射一个值或一个错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Single will call only one of these methods, and will only call it once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073740Z" creationid="pingfangx" creationdate="20190620T073740Z">
        <seg>Single 将只调用其中一个方法，并且只调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T082956Z" creationid="pingfangx" creationdate="20190620T082956Z">
        <seg>Subject 是一种桥梁或代理，在 ReactiveX 的某些实现中可用，它既充当观察者又充当 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP connection progresses from one state to another in response to events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112939Z" creationid="pingfangx" creationdate="20190827T112939Z">
        <seg>TCP 连接从一个状态进展到另一个状态以响应事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP header follows the internet header, supplying information specific to the TCP protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104706Z" creationid="pingfangx" creationdate="20190827T104706Z">
        <seg>TCP 首部跟随 IP 首部，提供特定于 TCP 协议的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP must implement all options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110949Z" creationid="pingfangx" creationdate="20190827T110949Z">
        <seg>TCP 必须实现所有选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP will reliably deliver all buffers SENT before the connection was CLOSED so a user who expects no data in return need only wait to hear the connection was CLOSED successfully to know that all his data was received at the destination TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063448Z" creationid="pingfangx" creationdate="20190828T063048Z">
        <seg>TCP 将在连接被 CLOSED 之前可靠地 SENT 传递所有缓冲区，因此期望没有数据返回的用户只需等待成功地听到连接已成功 CLOSED，以便知道他的所有数据都在目标 TCP 上接收。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;e0&gt;in turn&lt;/e0&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093948Z" creationid="pingfangx" creationdate="20190620T073225Z">
        <seg>链式 Observable 操作符不能在原始的 Observable 上独立运行，它们是依次 &lt;e0&gt;操作&lt;/e0&gt;，每个操作符操作的 Observable 由链中的前一个操作符生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;e1&gt;in turn&lt;/e1&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093956Z" creationid="pingfangx" creationdate="20190620T093858Z">
        <seg>链式 Observable 操作符不能在原始的 Observable 上独立运行，它们是依次 &lt;e1&gt;操作&lt;/e1&gt;，每个操作符操作的 Observable 由链中的前一个操作符生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A connection is defined by a pair of sockets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023136Z" creationid="pingfangx" creationdate="20190828T023136Z">
        <seg>连接由一对套接字定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A connection progresses through a series of states during its lifetime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112040Z" creationid="pingfangx" creationdate="20190827T112040Z">
        <seg>连接在其生命周期中通过一系列状态进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T020934Z" creationid="pingfangx" creationdate="20190828T020934Z">
        <seg>设计中的一个基本概念是通过 TCP 连接发送的每个八位字节数据都有一个序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more complete &lt;c0&gt;subscribe&lt;/c0&gt; call example looks like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060713Z" creationid="pingfangx" creationdate="20190620T060713Z">
        <seg>更完整的 &lt;c0&gt;subscribe&lt;/c0&gt; 调用示例如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more subtle bug happens if the call to `request(1)` triggers an asynchronous call to `onNext` on some other thread and reading `name` in `onNext` races writing it in `onStart` post `request`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084520Z" creationid="pingfangx" creationdate="20190621T083839Z">
        <seg>还可能发生更微妙的错误，如果对 `request(1)` 的调用在某个其他线程上触发对 `onNext` 的异步调用，该调用在 `onNext` 中读取 `name`，而在 `onStart` 中 `request` 之后才会写入。（译注：不知道对不对，太难了）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022101Z" creationid="pingfangx" creationdate="20190828T022101Z">
        <seg>新的确认(称为“可接受的确认”)是下面的不等式所持有的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reset is valid if its sequence number is in the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061734Z" creationid="pingfangx" creationdate="20190828T061734Z">
        <seg>如果序列号在窗口中，则重置有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reset must not be sent if it is not clear that this is the case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060541Z" creationid="pingfangx" creationdate="20190828T060533Z">
        <seg>如果不清楚情况是否如此，则不得发送重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A segment is judged to occupy a portion of valid receive sequence space if</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022317Z" creationid="pingfangx" creationdate="20190828T022317Z">
        <seg>判断报文段占用有效接收序列空间的一部分，如果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less or equal than the acknowledgment value in the incoming segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022114Z" creationid="pingfangx" creationdate="20190828T022114Z">
        <seg>如果重传队列的序列号和长度之和小于或等于传入报文段中的确认值，则完全确认该报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simultaneous CLOSE by users at both ends of a connection causes FIN segments to be exchanged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063912Z" creationid="pingfangx" creationdate="20190828T063912Z">
        <seg>连接两端的用户同时发生 CLOSE 会导致 FIN 报文段被交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A small regret about introducing backpressure in RxJava 0.x is that instead of having a separate base reactive class, the `Observable` itself was retrofitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053113Z" creationid="pingfangx" creationdate="20190618T053113Z">
        <seg>关于在 RxJava 0.x 中引入背压的一个小遗憾是，不再使用单独的基础响应类，`Observable` 本身就进行了改造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN's.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024227Z" creationid="pingfangx" creationdate="20190828T024227Z">
        <seg>三次握手是必要的，因为序列号不依赖于网络中的全局时钟，并且 TCP 可能具有用于挑选 ISN 的不同机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A toolbox of useful Operators for working with Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101906Z" creationid="pingfangx" creationdate="20190620T101906Z">
        <seg>用于处理 Observable 的有用操作符的工具箱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variety of other cases are possible, all of which are accounted for by the following rules for RST generation and processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060454Z" creationid="pingfangx" creationdate="20190828T060454Z">
        <seg>可能存在各种其他情况，所有这些情况都由以下 RST 生成和处理规则来解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T080523Z" creationid="pingfangx" creationdate="20190620T080523Z">
        <seg>超时操作符的一个版本允许你在超时到期时切换到备份的 Single，而不是发送错误通知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070005Z" creationid="pingfangx" creationdate="20190620T070005Z">
        <seg>另一方面，“冷” Observable 会一直等待，直到有观察者订阅它才开始发射数据项，因此观察者保证能从开头看到整个序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T065453Z" creationid="pingfangx" creationdate="20190620T065453Z">
        <seg>“热” Observable 可能在创建后立即开始发射项目，因此任何后来订阅该 Observable 的观察者可能会在序列中间某处开始观察。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACK:  Acknowledgment field significant</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105408Z" creationid="pingfangx" creationdate="20190827T105408Z">
        <seg>ACK：指明确认字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API designers may instead choose to define `Observable&lt;Object&gt;` with no guarantee on what `Object` will be (which should be irrelevant anyway).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052849Z" creationid="pingfangx" creationdate="20190618T052849Z">
        <seg>API 设计者可能会选择定义 `Observable&lt;Object&gt;` 而不保证 `Object` 将是什么(无论如何都应该是无关的)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the [`@Beta`][beta source link] annotation at the class or method level are subject to change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105234Z" creationid="pingfangx" creationdate="20190617T105234Z">
        <seg>在类或方法级别标有 [`@Beta`][beta source link] 注释的 API 可能会发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the [`@Experimental`][experimental source link] annotation at the class or method level will almost certainly change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105322Z" creationid="pingfangx" creationdate="20190617T105322Z">
        <seg>在类或方法级别用 [`@Experimental`][experimental source link] 注释标记的 API 几乎肯定会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the `@Deprecated` annotation at the class or method level will remain supported until the next major release but it is recommended to stop using them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105356Z" creationid="pingfangx" creationdate="20190617T105356Z">
        <seg>在类或方法级别标记有 `@Deprecated` 注释的 API 将保持支持，直到下一个主要版本，但建议停止使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Active Side Causes Half-Open Connection Discovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060319Z" creationid="pingfangx" creationdate="20190828T060319Z">
        <seg>活动侧导致半开连接发现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, it is a little more complicated than this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022404Z" creationid="pingfangx" creationdate="20190828T022404Z">
        <seg>实际上，它比这复杂一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After TCP A crashes, the user attempts to re-open the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055839Z" creationid="pingfangx" creationdate="20190828T055839Z">
        <seg>TCP A 崩溃后，用户尝试重新打开连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All code inside the `io.reactivex.internal.*` packages is considered private API and should not be relied upon at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105411Z" creationid="pingfangx" creationdate="20190617T105411Z">
        <seg>`io.reactivex.internal.*` 包中的所有代码都被视为私有 API，根本不应该依赖它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All options are included in the checksum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110811Z" creationid="pingfangx" creationdate="20190827T110811Z">
        <seg>所有选项都包含在校验和中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All segments preceding and including FIN will be retransmitted until acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070131Z" creationid="pingfangx" creationdate="20190828T063559Z">
        <seg>FIN 之前（包含 FIN ）的所有报文段都将被重传，直到被确认为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093759Z" creationid="pingfangx" creationdate="20190620T093759Z">
        <seg>此外，每个实现都倾向于将其操作符命名为类似于该语言中其他上下文已熟悉的类似方法的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the `Flowable.parallel()` operator and the `ParallelFlowable` type help achieve the same parallel processing pattern:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083319Z" creationid="pingfangx" creationdate="20190617T083319Z">
        <seg>或者，`Flowable.parallel()` 运算符和 `ParallelFlowable` 类型有助于实现相同的并行处理模式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the `doFinally` operator (introduced in 2.0.1 and standardized in 2.1) calls a developer specified `Action` that gets executed after a source completed, failed with an error or got cancelled/disposed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115415Z" creationid="pingfangx" creationdate="20190618T115415Z">
        <seg>或者，`doFinally` 操作符(在 2.0.1 中引入，在 2.1 中标准化)调用开发人员指定的 `Action`，它在源完成后，带错误失败或被取消/释放时执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can use the `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)` (and similar) methods to provide a callback/lambda that can throw:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095717Z" creationid="pingfangx" creationdate="20190618T095717Z">
        <seg>或者，您可以使用 `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)`(和类似的)方法来提供可以抛出的回调/lambda：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the `Flowable` infrastructure guarantees it will be called at most once on each `Subscriber`, the call to `request(1)` may trigger the emission of an element right away.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083229Z" creationid="pingfangx" creationdate="20190621T083229Z">
        <seg>虽然 `Flowable` 基础设施保证在每个 `Subscriber` 上最多只调用一次，但是对 `request(1)` 的调用可能会立即触发一个元素的发射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093543Z" creationid="pingfangx" creationdate="20190620T093543Z">
        <seg>虽然实现之间存在很多重叠，但也有一些操作符仅在某些实现中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although these examples do not show connection synchronization using data-carrying segments, this is perfectly legitimate, so long as the receiving TCP doesn't deliver the data to the user until it is clear the data is valid (i.e., the data must be buffered at the receiver until the connection reaches the ESTABLISHED state).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031823Z" creationid="pingfangx" creationdate="20190828T031823Z">
        <seg>虽然这些示例没有显示使用数据承载报文段的连接同步，但这是完全合法的，只要接收 TCP 不向用户传递数据，直到数据有效（即数据必须在接收器处被缓冲，直到连接达到 ESTABLISHED 状态）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Among the variables stored in the TCB are the local and remote socket numbers, the security and precedence of the connection, pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111529Z" creationid="pingfangx" creationdate="20190827T111529Z">
        <seg>存储在 TCB 中的变量包括本地和远程套接字号，连接的安全性和优先级，指向用户的发送和接收缓冲区的指针，指向重新传输队列和当前报文段的指针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An "XXX" indicates a segment which is lost or rejected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034539Z" creationid="pingfangx" creationdate="20190828T034539Z">
        <seg>“XXX”表示丢失或拒绝的报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;AsyncSubject&lt;/c0&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083933Z" creationid="pingfangx" creationdate="20190620T083933Z">
        <seg>&lt;c0&gt;AsyncSubject&lt;/c0&gt; 发射源 Observable 发射的最后一个值(且仅发射最后一个值)，并且只在该 Observable 源完成后才会发射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Alphabetical List of Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094441Z" creationid="pingfangx" creationdate="20190620T094441Z">
        <seg>按字母顺序排列的 Observable 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable &lt;d3&gt;emits&lt;/d3&gt; &lt;d4&gt;items&lt;/d4&gt; or sends &lt;d5&gt;notifications&lt;/d5&gt; to its observers by calling the observers’ methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045830Z" creationid="pingfangx" creationdate="20190620T045830Z">
        <seg>Observable(可观察对象) &lt;d3&gt;emits (发射)&lt;/d3&gt; &lt;d4&gt;items (数据项)&lt;/d4&gt; 或通过调用观察者的方法向其观察者发送 &lt;d5&gt;notifications (通知)&lt;/d5&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method after it has called &lt;c0&gt;onNext&lt;/c0&gt; for the final time, if it has not encountered any errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060356Z" creationid="pingfangx" creationdate="20190620T060356Z">
        <seg>如果 Observable 没有遇到任何错误，则在最后一次调用 &lt;c0&gt;onNext&lt;/c0&gt; 之后调用此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060301Z" creationid="pingfangx" creationdate="20190620T060301Z">
        <seg>Observable 调用此方法以指示它无法生成预期数据或遇到其他一些错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method whenever the Observable emits an item.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060243Z" creationid="pingfangx" creationdate="20190620T060243Z">
        <seg>只要 Observable 发射一个项目，Observable 就会调用此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable has all of the flexibility and elegance associated with its mirror-image cousin the Iterable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035619Z" creationid="pingfangx" creationdate="20190620T035619Z">
        <seg>Observable 具有与 Iterable 镜像相关的所有灵活性和优雅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable is the asynchronous/push &lt;a0&gt;“dual”&lt;/a0&gt; to the synchronous/pull Iterable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040115Z" creationid="pingfangx" creationdate="20190620T035959Z">
        <seg>Observable 是异步的双向(&lt;a0&gt;“dual”&lt;/a0&gt;) push，Iterable 是同步的 pull</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one — that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045630Z" creationid="pingfangx" creationdate="20190620T045630Z">
        <seg>这种方法的一个优点是，当您有一堆不依赖于彼此的任务时，你可以同时启动所有任务，而不是等到每个任务完成后再开始下一个 - 这样，你的整个捆绑任务只会耗费与捆绑中最长的任务一样长的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An established connection is said to be  "half-open" if one of the TCPs has closed or aborted the connection at its end without the knowledge of the other, or if the two ends of the connection have become desynchronized owing to a crash that resulted in loss of memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043526Z" creationid="pingfangx" creationdate="20190828T043432Z">
        <seg>如果其中一个 TCP 在其不知道另一个的情况下关闭或中止了连接，或者如果连接的两端由于崩溃而变得不同步导致失去记忆，则建立的连接被称为“半开”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of an enhancement that would classify as this is adding reactive pull backpressure support to an operator that previously did not support it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105030Z" creationid="pingfangx" creationdate="20190617T105030Z">
        <seg>可归类为此增强功能的一个示例是向先前不支持它的运算符添加反应性拉背压支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An important change regarding `Subject`s (and by extension, `FlowableProcessor`) that they no longer support `T -&gt; R` like conversion (that is, input is of type `T` and the output is of type `R`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062234Z" creationid="pingfangx" creationdate="20190618T062234Z">
        <seg>关于 `Subject` (以及扩展名 `FlowableProcessor`)的一个重要变化是它们不再支持类似 `T -&gt; R` 的转换(即输入类型为 `T` 且输出类型为 `R` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interesting alternative case occurs when TCP A crashes and TCP B tries to send data on what it thinks is a synchronized connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060206Z" creationid="pingfangx" creationdate="20190828T060206Z">
        <seg>当 TCP A 崩溃并且 TCP B 尝试发送它认为是同步连接的数据时，会出现一个有趣的替代情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An old duplicate arriving at TCP B (line 2) stirs B into action.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060353Z" creationid="pingfangx" creationdate="20190828T060353Z">
        <seg>到达 TCP B(第 2 行)的旧副本激起 B 采取行动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An option may begin on any octet boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110814Z" creationid="pingfangx" creationdate="20190827T110814Z">
        <seg>选项可以从任何八位字节边界开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040922Z" creationid="pingfangx" creationdate="20190620T040922Z">
        <seg>而且重要的是：使用 ReactiveX，你可以改变你的观念，你可从根本上改变 Observable 的底层实现，而不会破坏 Observable 的使用者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another significant difference between `rx.Subscriber` (and co) and `org.reactivestreams.Subscriber` (and co) is that in 2.x, your `Subscriber`s and `Observer`s are not allowed to throw anything but fatal exceptions (see `Exceptions.throwIfFatal()`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095501Z" creationid="pingfangx" creationdate="20190618T095501Z">
        <seg>`rx.Subscriber`(及 co) 和 `org.reactivestreams.Subscriber`(及 co)之间的另一个显着区别是在 2.x 中，您的 `Subscriber`s 和 `Observer`s 不允许抛出任何异常，除了致命的异常(参见 `Exceptions.throwIfFatal()`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075544Z" creationid="pingfangx" creationdate="20190620T075544Z">
        <seg>另一个版本需要两个或更多 Singles 并将它们合并到一个 Observable 中，该 Observable 发射源 Singles 发射的项目(以任意顺序)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from subscribing to the base types with their respective consumers (`Subscriber`, `Observer`, `SingleObserver`, `MaybeObserver` and `CompletableObserver`) and functional-interface based consumers (such as `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)`), the formerly separate 1.x `BlockingObservable` (and similar classes for the others) has been integrated with the main reactive type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095158Z" creationid="pingfangx" creationdate="20190618T095158Z">
        <seg>除了订阅基本类型用他们各自的消费者（`Subscriber`，`Observer`，`SingleObserver`，`MaybeObserver` 和 `CompletableObserver`）和基于函数接口的消费者（例如 `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action`），以前单独的 1.x `BlockingObservable`（以及其他类似的类）已经与主要的响应类型集成在一起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general rule, reset (RST) must be sent whenever a segment arrives which apparently is not intended for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060524Z" creationid="pingfangx" creationdate="20190828T060524Z">
        <seg>作为一般规则，每当显然不是用于当前连接的报文段到达时必须发送重置(RST)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, A will probably try to OPEN the connection again or try to SEND on the connection it believes open.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055812Z" creationid="pingfangx" creationdate="20190828T055812Z">
        <seg>因此，A 可能会尝试再次打开连接或尝试在它认为打开的连接上发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a shorthand, segments carrying the SYN bit are also called "SYNs".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023717Z" creationid="pingfangx" creationdate="20190828T023717Z">
        <seg>作为简写，携带 SYN 位的报文段也称为“SYNs”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a simple example of recovery from old duplicates, consider figure 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042858Z" creationid="pingfangx" creationdate="20190828T042858Z">
        <seg>作为从旧重复项恢复的简单示例，请考虑图 9。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative, the 2.x `Observable` doesn't do backpressure at all and is available as a choice to switch over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073717Z" creationid="pingfangx" creationdate="20190618T073717Z">
        <seg>作为替代方案，2.x `Observable` 根本不做背压，可作为切换的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one of the primary goals of RxJava 2, the design focuses on performance and in order enable it, RxJava 2.0.7 adds a custom `io.reactivex.FlowableSubscriber` interface (extends `org.reactivestreams.Subscriber`) but adds no new methods to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073904Z" creationid="pingfangx" creationdate="20190618T073904Z">
        <seg>作为 RxJava 2 的主要目标之一，该设计侧重于性能，为了实现它，RxJava 2.0.7 增加了一个自定义的 `io.reactivex.FlowableSubscriber` 接口(扩展了 `org.reactivestreams.Subscriber`)，但没有添加新的它的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in this illustration, the &lt;s0&gt;SubscribeOn&lt;/s0&gt; operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090322Z" creationid="pingfangx" creationdate="20190620T090322Z">
        <seg>如图所示，&lt;s0&gt;SubscribeOn&lt;/s0&gt; 操作符指定 Observable 将开始操作的线程，无论操作符链中的哪个操作符被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the opportunity to reduce component count, 2.x doesn't define `Action3`-`Action9` and `ActionN` (these were unused within RxJava itself anyway).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064522Z" creationid="pingfangx" creationdate="20190618T064522Z">
        <seg>作为减少组件数量的机会，2.x 没有定义 `Action3`-`Action9` 和 `ActionN`(无论如何这些都在 RxJava 本身中未使用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the `Observable`/`Flowable` split, the backpressure-aware, Reactive-Streams compliant implementations are based on the `FlowableProcessor&lt;T&gt;` class (which extends `Flowable` to give a rich set of instance operators).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062103Z" creationid="pingfangx" creationdate="20190618T062103Z">
        <seg>与 `Observable`/`Flowable` 拆分一样，背压感知，Reactive-Streams 兼容实现基于 `FlowableProcessor&lt;T&gt;` 类(扩展 `Flowable` 以提供丰富的实例操作符集)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091954Z" creationid="pingfangx" creationdate="20190620T091954Z">
        <seg>除了将这些调度器传递给 RxJava Observable 操作符之外，您还可以使用它们来安排自己的订阅工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assume that two user processes A and B are communicating with one another when a crash occurs causing loss of memory to A's TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055708Z" creationid="pingfangx" creationdate="20190828T055708Z">
        <seg>假设发生崩溃时两个用户进程 A 和 B 正在彼此通信，从而导致 A 的 TCP 内存丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025441Z" creationid="pingfangx" creationdate="20190828T025441Z">
        <seg>在 100 兆比特/秒时，循环时间为 5.4 分钟，这可能有点短，但仍然在合理范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At 2 megabits/sec.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025341Z" creationid="pingfangx" creationdate="20190828T025341Z">
        <seg>以 2 兆比特/秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At each invocation, it has to call `onNext` at most once optionally followed by either `onError` or `onComplete`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021246Z" creationid="pingfangx" creationdate="20190624T021246Z">
        <seg>在每次调用时，它必须最多调用 `onNext` 一次，可选地后跟 `onError` 或 `onComplete`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At line 3, an old duplicate SYN arrives at TCP B.  TCP B cannot tell that this is an old duplicate, so it responds normally (line 4).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042922Z" creationid="pingfangx" creationdate="20190828T042922Z">
        <seg>在第 3 行，旧的重复的 SYN 到达 TCP B.TCP B 无法判断这是一个旧副本，因此它正常响应(第 4 行)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At line 4, TCP A responds with an empty segment containing an ACK for TCP B's SYN; and in line 5, TCP A sends some data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041742Z" creationid="pingfangx" creationdate="20190828T041742Z">
        <seg>在第 4 行，TCP A 响应一个包含确认 TCP B 的 SYN 的 ACK 空报文段；在第 5 行中，TCP A 发送一些数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the data is not flowing yet and no side-effects are happening.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071727Z" creationid="pingfangx" creationdate="20190617T071727Z">
        <seg>此时，数据尚未流动，并且没有发生任何副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attach the observer to that Observable by &lt;i0&gt;subscribing&lt;/i0&gt; it (this also initiates the actions of the Observable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055804Z" creationid="pingfangx" creationdate="20190620T055804Z">
        <seg>通过 &lt;i0&gt;subscribing (订阅)&lt;/i0&gt; 将观察者附加到该 Observable(这也启动了 Observable 的操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Background</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044531Z" creationid="pingfangx" creationdate="20190620T044531Z">
        <seg>背景</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backpressure Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072112Z" creationid="pingfangx" creationdate="20190620T072112Z">
        <seg>背压操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic 3-Way Handshake for Connection Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T040732Z" creationid="pingfangx" creationdate="20190828T040732Z">
        <seg>连接同步的基本三次握手</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Reactive-Streams base interface, `org.reactivestreams.Publisher` defines the `subscribe()` method as `void`, `Flowable.subscribe(Subscriber)` no longer returns any `Subscription` (or `Disposable`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072916Z" creationid="pingfangx" creationdate="20190618T072916Z">
        <seg>因为 Reactive-Streams 基接口，`org.reactivestreams.Publisher` 将 `subscribe()` 方法定义为 `void`，`Flowable.subscribe(Subscriber)` 不再返回任何 `Subscription`(或 `Disposable`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Reactive-Streams has a different architecture, it mandates changes to some well known RxJava types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051847Z" creationid="pingfangx" creationdate="20190618T051847Z">
        <seg>由于 Reactive-Streams 具有不同的体系结构，因此它要求对一些众所周知的 RxJava 类型进行更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is “cold” — that is, if it waits for a subscription before it begins to emit items).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083553Z" creationid="pingfangx" creationdate="20190620T083553Z">
        <seg>因为 Subject 订阅了 Observable，它会触发 Observable 开始发射项目(如果 Observable 是“冷” - 也就是说，如果它在开始发射项目之前等待订阅)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because both 1.x and 2.x is aimed at Java 6+, we can't use the Java 8 functional interfaces such as `java.util.function.Function`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064046Z" creationid="pingfangx" creationdate="20190618T064046Z">
        <seg>因为 1.x 和 2.x 都是针对 Java 6+，所以我们不能使用 Java 8 的函数接口，例如 `java.util.function.Function`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083529Z" creationid="pingfangx" creationdate="20190620T083529Z">
        <seg>因为它是一个观察者，它可以订阅一个或多个 Observable，并且因为它是一个 Observable，它可以通过重新发送来传递它所观察的项目，并且它也可以发射新项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because steps 2 and 3 can be combined in a single message this is called the three way (or three message) handshake.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024008Z" creationid="pingfangx" creationdate="20190828T024008Z">
        <seg>因为步骤 2 和 3 可以组合在单个消息中，所以这称为三向(或三个消息)握手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there could be at most 1 element emitted, the `Maybe` type has no notion of backpressure (because there is no buffer bloat possible as with unknown length `Flowable`s or `Observable`s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060825Z" creationid="pingfangx" creationdate="20190618T060825Z">
        <seg>因为最多可以发射 1 个元素，所以 `Maybe` 类型没有背压概念(因为没有缓冲膨胀可能，而未知长度的 `Flowable` 或 `Observable` 则有这种可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before 2.0.7, the operator `strict()` had to be applied in order to achieve the same level of compliance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073825Z" creationid="pingfangx" creationdate="20190618T073825Z">
        <seg>在 2.0.7 之前，必须应用运算符 `strict()` 才能达到相同的合规水平。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111246Z" creationid="pingfangx" creationdate="20190827T111246Z">
        <seg>在我们详细讨论 TCP 的操作之前，我们需要介绍一些详细的术语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being unbounded means as long as the JVM doesn't run out of memory, it can handle almost any amount coming from a bursty source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092431Z" creationid="pingfangx" creationdate="20190621T092431Z">
        <seg>无限制意味着只要 JVM 没有内存耗尽，它几乎可以处理来自突发源的任何数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond the `PublishProcessor`above, there are other operators that don't support backpressure, mostly due to functional reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T073835Z" creationid="pingfangx" creationdate="20190621T073258Z">
        <seg>除了 `PublishProcessor` 之外，还有其他一些操作符不支持背压，主要是由于函数原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105518Z" creationid="pingfangx" creationdate="20190617T105518Z">
        <seg>可以在 [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava2) 上找到 Maven，Ivy，Gradle 和其他的二进制文件和依赖信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both `Publisher` and `SingleSource` appear as functional interfaces (types with one abstract method) and may encourage users to try to provide a lambda expression:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102531Z" creationid="pingfangx" creationdate="20190617T102531Z">
        <seg>`Publisher` 和 `SingleSource` 都显示为函数接口(具有一个抽象方法的类型)，并且可能鼓励用户尝试提供 lambda 表达式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both users CLOSE simultaneously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063213Z" creationid="pingfangx" creationdate="20190828T063213Z">
        <seg>两个用户同时关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both will, upon receiving these ACKs, delete the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063927Z" creationid="pingfangx" creationdate="20190828T063927Z">
        <seg>收到这些 ACK 后，两者都将删除该连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Briefly the meanings of the states are:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112508Z" creationid="pingfangx" creationdate="20190827T112508Z">
        <seg>简而言之，各状态的意义是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a0&gt;with nested composition they become unwieldy&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041126Z" creationid="pingfangx" creationdate="20190620T041126Z">
        <seg>但与 Futures 一样，虽然回调很容易使用单层的异步执行，但是 &lt;a0&gt;对于嵌套组合，它们难以处理&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by “observers.” Rather than &lt;e0&gt;calling&lt;/e0&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an “Observable,” and then &lt;e1&gt;subscribe&lt;/e1&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045501Z" creationid="pingfangx" creationdate="20190620T045501Z">
        <seg>但是在 ReactiveX 中，许多指令可以并行执行，并且它们的结果稍后由“观察者”以任意顺序捕获。你不用 &lt;e0&gt;调用&lt;/e0&gt; 方法，而是定义一种获取和转换数据的机制，以“Observable”的形式，然后为它 &lt;e1&gt;subscribe (订阅)&lt;/e1&gt; 一个观察者，一旦 Observable 发射的数据准备好，先前定义的机制就会发射数据，观察者表示的哨兵捕捉并作出响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators &lt;e0&gt;order matters&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072946Z" creationid="pingfangx" creationdate="20190620T072946Z">
        <seg>但是在 Builder 模式中，方法在链中出现的顺序通常并不重要，而 Observable 操作符是 &lt;e0&gt;顺序重要的&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, with an Observable the producer pushes values to the consumer whenever values are available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042145Z" creationid="pingfangx" creationdate="20190620T042145Z">
        <seg>相比之下，对于 Observable，只要值可用，生产者就会将值推送给消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, in this document, calls to &lt;c4&gt;onNext&lt;/c4&gt; are usually called “emissions” of items, whereas calls to &lt;c5&gt;onCompleted&lt;/c5&gt; or &lt;c6&gt;onError&lt;/c6&gt; are called “notifications.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060707Z" creationid="pingfangx" creationdate="20190620T060707Z">
        <seg>按照惯例，在本文档中，对 &lt;c4&gt;onNext&lt;/c4&gt; 的调用通常称为项目的“发射 (emissions)”，而对 &lt;c5&gt;onCompleted&lt;/c5&gt; 或 &lt;c6&gt;onError&lt;/c6&gt; 的调用称为“通知 (notifications)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;c0&gt;Subscribe&lt;/c0&gt; method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090042Z" creationid="pingfangx" creationdate="20190620T085923Z">
        <seg>默认情况下，Observable 和应用于它的操作符链将完成其工作，并通知其观察者，在调用其 &lt;c0&gt;Subscribe&lt;/c0&gt; 方法的同一线程上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By having `Publisher` as input this way, you can compose with other Reactive-Streams compliant libraries without the need to wrap them or convert them into `Flowable` first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061637Z" creationid="pingfangx" creationdate="20190618T061637Z">
        <seg>通过以这种方式输入 `Publisher`，您可以使用其他符合 Reactive-Streams 标准的库进行组合，而无需先将它们包装或转换为 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By the terms of &lt;a0&gt;the Observable contract&lt;/a0&gt;, it may call &lt;c1&gt;onNext&lt;/c1&gt; zero or more times, and then may follow those calls with a call to either &lt;c2&gt;onCompleted&lt;/c2&gt; or &lt;c3&gt;onError&lt;/c3&gt; but not both, which will be its last call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060553Z" creationid="pingfangx" creationdate="20190620T060553Z">
        <seg>根据 &lt;a0&gt;Observable 协议&lt;/a0&gt; 的定义，它可以调用 &lt;c1&gt;onNext&lt;/c1&gt; 零次或多次，然后这些调用可能跟随 &lt;c2&gt;onCompleted&lt;/c2&gt; 或 &lt;c3&gt;onError&lt;/c3&gt; ，但不会同时，这将是它的最后一次调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By themselves they’d be nothing more than a slight extension of the standard observer pattern, better suited to handling a sequence of events rather than a single callback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071412Z" creationid="pingfangx" creationdate="20190620T070347Z">
        <seg>它们本身只不过是标准观察者模式的轻微扩展，使其更适合处理一系列事件而不是单个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSE is an operation meaning "I have no more data to send."  The notion of closing a full-duplex connection is subject to ambiguous interpretation, of course, since it may not be obvious how to treat the receiving side of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062603Z" creationid="pingfangx" creationdate="20190828T062603Z">
        <seg>CLOSE 是一项操作，意思是“我没有更多数据要发送”。当然，关闭全双工连接的概念会受到模糊解释，因为如何处理连接的接收方可能并不明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSE-WAIT - represents waiting for a connection termination request from the local user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112754Z" creationid="pingfangx" creationdate="20190827T112754Z">
        <seg>CLOSE-WAIT - 表示等待本地用户的连接终止请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSED - represents no connection state at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112930Z" creationid="pingfangx" creationdate="20190827T112930Z">
        <seg>CLOSED - 表示根本没有连接状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112458Z" creationid="pingfangx" creationdate="20190827T112458Z">
        <seg>CLOSED 是虚构的，因为它表示没有 TCB 时的状态，因此没有连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112817Z" creationid="pingfangx" creationdate="20190827T112817Z">
        <seg>CLOSING - 表示等待来自远程 TCP 的连接终止请求确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call a method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053007Z" creationid="pingfangx" creationdate="20190620T053007Z">
        <seg>调用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callbacks Have Their Own Problems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040949Z" creationid="pingfangx" creationdate="20190620T040937Z">
        <seg>使用回调会有问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callbacks solve the problem of premature blocking on &lt;c0&gt;Future.get()&lt;/c0&gt; by not allowing anything to block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041019Z" creationid="pingfangx" creationdate="20190620T041019Z">
        <seg>回调通过不允许任何阻塞来解决 &lt;c0&gt;Future.get()&lt;/c0&gt; 上的过早阻塞问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 1:  A single octet of option-kind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110829Z" creationid="pingfangx" creationdate="20190827T110829Z">
        <seg>情况 1：选项类型的单个八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 1:  Local user initiates the close</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063230Z" creationid="pingfangx" creationdate="20190828T063230Z">
        <seg>情况 1：本地用户启动关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 2:  An octet of option-kind, an octet of option-length, and the actual option-data octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110845Z" creationid="pingfangx" creationdate="20190827T110845Z">
        <seg>情况 2：选项类型的八位字节，选项长度的八位字节和实际的选项 - 数据八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 2:  TCP receives a FIN from the network</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063644Z" creationid="pingfangx" creationdate="20190828T063644Z">
        <seg>情况 2：TCP 从网络接收 FIN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 3:  both users close simultaneously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063756Z" creationid="pingfangx" creationdate="20190828T063756Z">
        <seg>案例 3：两个用户同时关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072235Z" creationid="pingfangx" creationdate="20190620T072235Z">
        <seg>链接操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking or Setting Unsubscribed Status</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092143Z" creationid="pingfangx" creationdate="20190620T092143Z">
        <seg>检查或设置取消订阅状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client code treats all of its interactions with Observables as asynchronous, whether your underlying implementation is blocking or non-blocking and however you choose to implement it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040444Z" creationid="pingfangx" creationdate="20190620T040444Z">
        <seg>客户端代码将其与 Observable 的所有交互视为异步，无论您的底层实现是阻塞还是非阻塞，无论您选择什么实现它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing a Connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061836Z" creationid="pingfangx" creationdate="20190828T061836Z">
        <seg>关闭连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071920Z" creationid="pingfangx" creationdate="20190620T071920Z">
        <seg>结合 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments appear in parentheses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034558Z" creationid="pingfangx" creationdate="20190828T034558Z">
        <seg>注释显示在括号中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composition via Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070213Z" creationid="pingfangx" creationdate="20190620T070213Z">
        <seg>通过 Observable 操作符组合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composition via Single Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073849Z" creationid="pingfangx" creationdate="20190620T073849Z">
        <seg>Single 操作符组合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conceptually, it is a union of `Single` and `Completable` providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060448Z" creationid="pingfangx" creationdate="20190618T060448Z">
        <seg>从概念上讲，它是 `Single` 和 `Completable` 的结合，提供捕获发射模式的方法，这些模式可能存在 0 或 1 个项或由某些响应源发出的错误信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional and Boolean Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072009Z" creationid="pingfangx" creationdate="20190620T072009Z">
        <seg>条件和布尔操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connectable Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103640Z" creationid="pingfangx" creationdate="20190620T072045Z">
        <seg>Connectable Observable 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, we must adopt rules for implicitly assigning sequence numbers to control.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T035208Z" creationid="pingfangx" creationdate="20190828T022556Z">
        <seg>因此，我们必须为控制位采用隐式分配序列号的规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control information is not physically carried in the segment data space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022547Z" creationid="pingfangx" creationdate="20190828T022547Z">
        <seg>控制信息不是在报文段数据空间中物理携带的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072026Z" creationid="pingfangx" creationdate="20190620T072026Z">
        <seg>转换 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counts the number of elements in the sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061046Z" creationid="pingfangx" creationdate="20190619T061046Z">
        <seg>计算序列中的元素数量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071826Z" creationid="pingfangx" creationdate="20190620T071826Z">
        <seg>创建 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating backpressured data sources is the relatively easier task when dealing with backpressure in general because the library already offers static methods on `Flowable` that handle backpressure for the developer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015503Z" creationid="pingfangx" creationdate="20190624T015503Z">
        <seg>在处理背压时，创建背压数据源是相对容易的任务，因为库已经在 `Flowable` 上提供了静态方法，可以让开发人员处理背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current Segment Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111956Z" creationid="pingfangx" creationdate="20190827T111956Z">
        <seg>当前报文段变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently defined options include (kind indicated in octal):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111000Z" creationid="pingfangx" creationdate="20190827T111000Z">
        <seg>目前定义的选项包括(以八进制表示的种类)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflows can fail, at which point the error is emitted to the consumer(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103130Z" creationid="pingfangx" creationdate="20190617T103130Z">
        <seg>数据流可能会失败，此时错误会发送给消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Schedulers for RxGroovy Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091353Z" creationid="pingfangx" creationdate="20190620T091353Z">
        <seg>RxGroovy Observable 操作符的默认调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define a method that does something useful with the return value from the asynchronous call; this method is part of the &lt;i0&gt;observer&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055742Z" creationid="pingfangx" creationdate="20190620T055742Z">
        <seg>定义一个方法，该方法对异步调用的返回值执行一些有用的操作；此方法是 &lt;i0&gt;observer&lt;/i0&gt; 的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define the asynchronous call itself as an &lt;i0&gt;Observable&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055748Z" creationid="pingfangx" creationdate="20190620T055748Z">
        <seg>将异步调用本身定义为 &lt;i0&gt;Observable&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delayed and Periodic Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092325Z" creationid="pingfangx" creationdate="20190620T092325Z">
        <seg>延迟和周期调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the operating system supporting A's TCP, it is likely that some error recovery mechanism exists.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055717Z" creationid="pingfangx" creationdate="20190828T055717Z">
        <seg>根据支持 A 的 TCP 的操作系统，可能存在一些错误恢复机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the Reactive-Streams specification, `Publisher.subscribe` returns void and the pattern by itself no longer works in 2.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070624Z" creationid="pingfangx" creationdate="20190618T070624Z">
        <seg>由于 Reactive-Streams 规范，`Publisher.subscribe` 返回 void，该模式本身不再适用于 2.0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the name conflict, replacing the package from `rx` to `org.reactivestreams` is not enough.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065709Z" creationid="pingfangx" creationdate="20190618T065709Z">
        <seg>由于名称冲突，将包从 `rx` 替换为 `org.reactivestreams` 是不够的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to zero windows and zero length segments, we have four cases for the acceptability of an incoming segment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022410Z" creationid="pingfangx" creationdate="20190828T022410Z">
        <seg>由于零窗口和零长度报文段，我们有四种情况可以接受传入的报文段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ESTABLISHED - represents an open connection, data received can be delivered to the user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112708Z" creationid="pingfangx" creationdate="20190827T112708Z">
        <seg>ESTABLISHED - 表示开放连接，接收的数据可以传递给用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041927Z" creationid="pingfangx" creationdate="20190828T041927Z">
        <seg>每个 TCP 从 CLOSED 到 SYN-SENT 循环到 SYN-RECEIVED 到 ESTABLISHED。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each language-specific implementation of ReactiveX has its own naming quirks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064528Z" creationid="pingfangx" creationdate="20190620T064528Z">
        <seg>ReactiveX 的每种语言特定实现都有自己的命名偏好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each language-specific implementation of ReactiveX implements a set of operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093532Z" creationid="pingfangx" creationdate="20190620T093532Z">
        <seg>ReactiveX 的每个特定于语言的实现都实现了一组操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each line is numbered for reference purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033933Z" creationid="pingfangx" creationdate="20190828T033933Z">
        <seg>每行都有编号以供参考。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator in the chain modifies the Observable that results from the operation of the previous operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072434Z" creationid="pingfangx" creationdate="20190620T072434Z">
        <seg>链中的每个操作符都会修改由前一个操作符的运算产生的 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reactive base class features operators that can perform such conversions, including the protocol conversions, to match some other type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T093029Z" creationid="pingfangx" creationdate="20190617T093029Z">
        <seg>每个反应基类都具有可以执行此类转换的运算符，包括协议转换，以匹配其他类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reactive base type `Flowable`, `Observable`, `Single`, `Maybe` and `Completable` feature a safe `create` operator that does the right thing regarding backpressure (for `Flowable`) and cancellation (all):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094823Z" creationid="pingfangx" creationdate="20190618T094823Z">
        <seg>每个响应基类 `Flowable`，`Observable`，`Single`，`Maybe` 和 `Completable` 都有一个安全的 `create` 操作符，可以对背压(对于 `Flowable`)和取消(对于所有)执行正确的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each requested element triggers a state transition and computation of the returned value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020312Z" creationid="pingfangx" creationdate="20190624T020312Z">
        <seg>每个请求的元素触发状态转换并返回值的计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each side must also receive the other side's initial sequence number and send a confirming acknowledgment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023820Z" creationid="pingfangx" creationdate="20190828T023820Z">
        <seg>每一方还必须接收另一方的初始序列号并发送确认确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ellipsis (...) indicates a segment which is still in the network (delayed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034527Z" creationid="pingfangx" creationdate="20190828T034527Z">
        <seg>省略号(...)表示仍在网络中的报文段(延迟)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the element at the given index or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061100Z" creationid="pingfangx" creationdate="20190619T061100Z">
        <seg>在给定索引处发出元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the element at the given index or the default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061250Z" creationid="pingfangx" creationdate="20190619T061126Z">
        <seg>发出给定索引的元素或默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the first element or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061200Z" creationid="pingfangx" creationdate="20190619T061200Z">
        <seg>发出第一​​个元素或如果源为空，则 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the indexth element or a `NoSuchElementException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T062204Z" creationid="pingfangx" creationdate="20190619T062204Z">
        <seg>发出索引指示的元素或 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the lastelement or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061325Z" creationid="pingfangx" creationdate="20190619T061325Z">
        <seg>发出最后一个元素，或如果源为空，则 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the one and only element, IndexOutOfBoundsException if the source is longer than 1 item or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061440Z" creationid="pingfangx" creationdate="20190619T061440Z">
        <seg>发出唯一元素，如果源长度超过 1 个项，则发出 IndexOutOfBoundsException，如果源为空，则发出 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the only element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061356Z" creationid="pingfangx" creationdate="20190619T061356Z">
        <seg>发出唯一的元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the only element or the default item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061353Z" creationid="pingfangx" creationdate="20190619T061353Z">
        <seg>发出唯一元素或默认项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the reduced value (or the initial value)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061343Z" creationid="pingfangx" creationdate="20190619T061343Z">
        <seg>发出减少的值(或初始值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the reduced value or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061334Z" creationid="pingfangx" creationdate="20190619T061334Z">
        <seg>发出减少的价值或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very first element or `NoSuchElementException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061133Z" creationid="pingfangx" creationdate="20190619T061133Z">
        <seg>发出第一个元素或 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very first element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061140Z" creationid="pingfangx" creationdate="20190619T061140Z">
        <seg>发出第一个元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very last element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061301Z" creationid="pingfangx" creationdate="20190619T061301Z">
        <seg>发出最后一个元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very last element or the default item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061221Z" creationid="pingfangx" creationdate="20190619T061221Z">
        <seg>发出最后一个元素或默认项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if all elements match the predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061036Z" creationid="pingfangx" creationdate="20190619T061036Z">
        <seg>如果所有元素都与谓词匹配，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if any elements match the predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061041Z" creationid="pingfangx" creationdate="20190619T061041Z">
        <seg>如果任何元素与谓词匹配，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061212Z" creationid="pingfangx" creationdate="20190619T061212Z">
        <seg>如果源为空，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enhancements and bugfixes will be synchronized between the two in a timely manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104702Z" creationid="pingfangx" creationdate="20190617T104702Z">
        <seg>增强功能和错误修正将在两者之间及时同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error Handling Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071925Z" creationid="pingfangx" creationdate="20190620T071925Z">
        <seg>错误处理操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing Observers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T050058Z" creationid="pingfangx" creationdate="20190620T050058Z">
        <seg>创建观察者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing a connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030228Z" creationid="pingfangx" creationdate="20190828T030228Z">
        <seg>建立连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025621Z" creationid="pingfangx" creationdate="20190828T025621Z">
        <seg>即使能够记住一天中的时间并且用它来选择初始序列号值的主机也不能免于这个问题(即，即使使用时间来为每个新的连接化身选择初始序列号)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though certain operators have no problems from type erasure, their signature may turn up being ambiguous, especially if one uses Java 8 and lambdas.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102233Z" creationid="pingfangx" creationdate="20190617T102233Z">
        <seg>即使某些操作符没有类型擦除的问题，它们的签名也可能变得有歧义，特别是如果使用 Java 8 和 lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042214Z" creationid="pingfangx" creationdate="20190620T042214Z">
        <seg>示例代码显示了如何将类似的高阶函数应用于 Iterable 和 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example for Gradle:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105522Z" creationid="pingfangx" creationdate="20190617T105522Z">
        <seg>Gradle 示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressing backpressure in end-consumers is rarely necessary (because they are synchronous in respect to their immediate upstream and backpressure naturally happens due to call-stack blocking), but it may be easier to understand the workings of it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083119Z" creationid="pingfangx" creationdate="20190621T083119Z">
        <seg>在最终消费者中很少需要表达背压(因为它们与上游是同步的，背压自然是由于调用堆栈阻塞而发生)，但是可能更容易理解它的工作原理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112735Z" creationid="pingfangx" creationdate="20190827T112735Z">
        <seg>FIN-WAIT-1 - 表示等待来自远程 TCP 的连接终止请求，或者对先前发送的连接终止请求的确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112741Z" creationid="pingfangx" creationdate="20190827T112741Z">
        <seg>FIN-WAIT-2 - 表示等待来自远程 TCP 的连接终止请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIN:  No more data from sender</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105435Z" creationid="pingfangx" creationdate="20190827T105435Z">
        <seg>FIN：没有来自发送者的更多数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTIONAL SPECIFICATION</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T100456Z" creationid="pingfangx" creationdate="20190827T100456Z">
        <seg>功能说明书</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filtering Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071907Z" creationid="pingfangx" creationdate="20190620T071907Z">
        <seg>过滤 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094212Z" creationid="pingfangx" creationdate="20190620T094212Z">
        <seg>最后，有一个按字母顺序排列的操作符列表，表示在大多数 ReactiveX 的特定于语言的实现中可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flows in RxJava are sequential in nature split into processing stages that may run **concurrently** with each other:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075403Z" creationid="pingfangx" creationdate="20190617T075403Z">
        <seg>RxJava 中的流本质上是顺序的，分为处理阶段，这些阶段可以彼此 **并发** 运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following the style of extending the Reactive-Streams `Publisher&lt;T&gt;` in `Flowable`, the other base reactive classes now extend similar base interfaces (in package `io.reactivex`):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061442Z" creationid="pingfangx" creationdate="20190618T061442Z">
        <seg>遵循在 `Flowable` 中扩展 Reactive-Streams `Publisher&lt;T&gt;` 的方式，其他基本响应类现在继承了类似的基接口(在包 `io.reactivex` 中)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a connection to be established or initialized, the two TCPs must synchronize on each other's initial sequence numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023509Z" creationid="pingfangx" creationdate="20190828T023509Z">
        <seg>对于要建立或初始化的连接，两个 TCP 必须在彼此的初始序列号上同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For bugs, questions and discussions please use the [Github Issues](https://github.com/ReactiveX/RxJava/issues).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105641Z" creationid="pingfangx" creationdate="20190617T105641Z">
        <seg>有关错误，问题和讨论，请使用 [Github Issues](https://github.com/ReactiveX/RxJava/issues)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For convenience (and avoiding warnings about generic array creation) there are 2 to 10 argument overloads to `just` that internally delegate to `from`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020236Z" creationid="pingfangx" creationdate="20190624T020236Z">
        <seg>为了方便(并避免关于泛型数组创建的警告)，内部委托给 `from` 的 `just` 有 2 到 10 个参数重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each connection there is a send sequence number and a receive sequence number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023425Z" creationid="pingfangx" creationdate="20190828T023425Z">
        <seg>对于每个连接，存在发送序列号和接收序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example there is the &lt;c0&gt;on&lt;i1&gt;Event&lt;/i1&gt;&lt;/c0&gt; naming pattern (e.g. &lt;c2&gt;onNext&lt;/c2&gt;, &lt;c3&gt;onCompleted&lt;/c3&gt;, &lt;c4&gt;onError&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064718Z" creationid="pingfangx" creationdate="20190620T064718Z">
        <seg>例如，有 &lt;c0&gt;on&lt;i1&gt;Event&lt;/i1&gt;&lt;/c0&gt; 命名模式上(例如 &lt;c2&gt;onNext&lt;/c2&gt;，&lt;c3&gt;onCompleted&lt;/c3&gt;，&lt;c4&gt;onError&lt;/c4&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a service that returns a `Flowable`, we'd like to call another service with values emitted by the first service:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083518Z" creationid="pingfangx" creationdate="20190617T083518Z">
        <seg>例如，给定一个返回 `Flowable` 的服务，我们想要使用第一个服务发出的值调用另一个服务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if one needs a signaller-like source, a shared enum can be defined and its solo instance `onNext`'d:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052921Z" creationid="pingfangx" creationdate="20190618T052921Z">
        <seg>例如，如果需要类似信号器的源，则可以定义共享枚举并将其独立实例 `onNext`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if one wants to perform some periodic background task but each iteration may last longer than the period, it is safe to drop the excess interval notification as there will be more later on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014924Z" creationid="pingfangx" creationdate="20190624T014924Z">
        <seg>例如，如果想要执行一些定期后台任务但每次迭代可能持续的时间超过后台任务周期，则可以安全地删除多余的间隔通知，因为稍后会有更多：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the TCP were to start all connections with sequence number 0, then upon crashing and restarting, a TCP might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025536Z" creationid="pingfangx" creationdate="20190828T025536Z">
        <seg>例如，如果 TCP 要启动序列号为 0 的所有连接，则在崩溃并重新启动时，TCP 可能会重新形成先前的连接(可能在半开连接解析之后)并发射序列号相同或重叠的数据包数据包仍在网络中，这些数据包是在同一连接的早期版本中发射的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the user clicks a lot on the screen, we'd still want to react to its latest input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015255Z" creationid="pingfangx" creationdate="20190624T015255Z">
        <seg>例如，如果用户在屏幕上点击了很多地方，我们仍然希望对其最新的输入做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the inventory example above, `getDemandAsync` could return a `Single&lt;DemandRecord&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092742Z" creationid="pingfangx" creationdate="20190617T092742Z">
        <seg>例如，在上面的清单示例中，`getDemandAsync` 可以返回 `Single &lt;DemandRecord&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the operator `interval` emits values periodically, backpressuring it would lead to shifting in the period relative to a wall clock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T074254Z" creationid="pingfangx" creationdate="20190621T074254Z">
        <seg>例如，操作符 `interval` 周期性地发射值，背压它会导致相对于挂钟的周期偏移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there are several overloads of `concatWith` taking the various other reactive base types as arguments (for providing convenience and performance benefits in the underlying implementation):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102323Z" creationid="pingfangx" creationdate="20190617T102323Z">
        <seg>例如，有几个 `concatWith` 重载将各种其他响应基类型作为参数(为了在底层实现中提供方便和性能优势)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For further details, consult the [wiki](https://github.com/ReactiveX/RxJava/wiki).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104625Z" creationid="pingfangx" creationdate="20190617T104625Z">
        <seg>有关详细信息，请参阅 [wiki](https://github.com/ReactiveX/RxJava/wiki)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about ReactiveX, see the [Introduction to ReactiveX](http://reactivex.io/intro.html) page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113458Z" creationid="pingfangx" creationdate="20190617T113458Z">
        <seg>有关 ReactiveX 的详细信息，请参阅 [ReactiveX 简介](http://reactivex.io/intro.html) 页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022748Z" creationid="pingfangx" creationdate="20190828T022748Z">
        <seg>出于序列号的目的，SYN 被认为发生在它发生的报文段的第一个实际数据八位位组之前，而 FIN 被认为发生在它发生的报文段中的最后一个实际数据八位位组之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For technical details on how to write operators for 2.x, please visit the [Writing Operators](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0) wiki page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051956Z" creationid="pingfangx" creationdate="20190618T051932Z">
        <seg>有关如何为 2.x 编写运算符的技术细节，请访问 [编写运算符](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0) wiki 页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the rest, this gives an opportunity to "extend their internal buffer" by having a larger number with `onBackpressureBuffer` than their default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093329Z" creationid="pingfangx" creationdate="20190621T093329Z">
        <seg>对于其余操作符，这提供了一个“扩展其内部缓冲区”的机会，通过使用 `onBackpressureBuffer` 而不是默认值来扩展它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the same reason, `unsubscribeOn` is not called on the regular termination path but only when there is an actual `cancel` (or `dispose`) call on the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115016Z" creationid="pingfangx" creationdate="20190618T115016Z">
        <seg>出于同样的原因，`unsubscribeOn` 不会在常规终止路径上调用，而是仅在链上有一个实际的 `cancel`(或 `dispose`)调用时调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (&lt;t0&gt;onNext&lt;/t0&gt;, &lt;t1&gt;onError&lt;/t1&gt;, and &lt;t2&gt;onCompleted&lt;/t2&gt;), you only use two methods to subscribe:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073552Z" creationid="pingfangx" creationdate="20190620T073552Z">
        <seg>出于这个原因，不用使用三个方法订阅 Single，来响应来自 Observable 的通知(&lt;t0&gt;onNext&lt;/t0&gt;，&lt;t1&gt;onError&lt;/t1&gt; 和 &lt;t2&gt;onCompleted&lt;/t2&gt;)，你只需要使用两个方法进行订阅：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, you may call &lt;s3&gt;ObserveOn&lt;/s3&gt; multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090714Z" creationid="pingfangx" creationdate="20190620T090714Z">
        <seg>因此，您可以在 Observable 操作符链中的不同点多次调用 &lt;s3&gt;ObserveOn&lt;/s3&gt;，以便更改某些操作符运行的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this specification the MSL is taken to be 2 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024416Z" creationid="pingfangx" creationdate="20190828T024416Z">
        <seg>对于此规范，MSL 为 2 分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From a user's perspective, if one was using the the `subscribe` methods other than `Flowable.subscribe(Subscriber&lt;? super T&gt;)`, there is no need to do anything regarding this change and there is no extra penalty for it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085030Z" creationid="pingfangx" creationdate="20190618T085030Z">
        <seg>从用户的角度来看，如果使用 `subscribe` 而不是 `Flowable.subscribe(Subscriber&lt;? super T&gt;)` 方法，则无需对此更改执行任何操作，也不会对其进行额外惩罚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the Observer’s point of view, it doesn’t matter!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040634Z" creationid="pingfangx" creationdate="20190620T040634Z">
        <seg>从观察者的角度来看，这并不重要！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functional Specification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041850Z" creationid="pingfangx" creationdate="20190828T041850Z">
        <seg>Functional Specification</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further details on building can be found on the [Getting Started](https://github.com/ReactiveX/RxJava/wiki/Getting-Started) page of the wiki.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105621Z" creationid="pingfangx" creationdate="20190617T105621Z">
        <seg>有关构建的更多详细信息，请参见 Wiki 的 [Getting Started](https://github.com/ReactiveX/RxJava/wiki/Getting-Started) 页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064628Z" creationid="pingfangx" creationdate="20190620T064628Z">
        <seg>此外，这些名称中的一些在其他情境中具有不同的含义，或者在特定实现语言的习语中看起来很怪异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, `generate` uses 3 callbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021056Z" creationid="pingfangx" creationdate="20190624T021056Z">
        <seg>通常，`generate` 使用 3 个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, many operators gained overloads that now allow specifying the internal buffer size or prefetch amount they should run their upstream (or inner sources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111231Z" creationid="pingfangx" creationdate="20190618T111129Z">
        <seg>通常，许多操作符获得了重载，现在允许指定内部缓冲区大小或它们应该运行其上游(或内部源)的预取量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an asynchronous source, fluent blocking for a terminal event is now possible:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101831Z" creationid="pingfangx" creationdate="20190618T101831Z">
        <seg>给定异步源，现在可以对终端事件进行流畅阻塞：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the overflowing example in the introduction, we can just increase the buffer size of `observeOn` to have enough room for all values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090705Z" creationid="pingfangx" creationdate="20190621T090705Z">
        <seg>鉴于介绍中的溢出示例，我们可以增加 `observeOn` 的缓冲区大小，以便为所有值提供足够的空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go on with your business; whenever the call returns, the observer’s method will begin to operate on its return value or values — the &lt;i0&gt;items&lt;/i0&gt; emitted by the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055859Z" creationid="pingfangx" creationdate="20190620T055859Z">
        <seg>继续你的业务；每当调用返回时，观察者的方法将开始对其返回值或返回值值 -  Observable 发射的 &lt;i0&gt;items (数据项)&lt;/i0&gt; 进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-Open Connection Discovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055922Z" creationid="pingfangx" creationdate="20190828T055922Z">
        <seg>半开连接发现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-Open Connections and Other Anomalies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043351Z" creationid="pingfangx" creationdate="20190828T043351Z">
        <seg>半开连接和其他异常</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header Format</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T100654Z" creationid="pingfangx" creationdate="20190827T100654Z">
        <seg>首部格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISN's.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023742Z" creationid="pingfangx" creationdate="20190828T023742Z">
        <seg>因此，该解决方案需要合适的机制来挑选初始序列号和稍微涉及的握手以交换 ISN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the `computeValue` is executed only when a subscriber subscribes and for each of them, printing the expected 1 and 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015926Z" creationid="pingfangx" creationdate="20190624T015926Z">
        <seg>这里的 `computeValue` 仅在订阅者订阅时执行，并且每个订阅者都打印预期的 1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the `onStart` implementation indicates `range` to produce its first value, which is then received in `onNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082052Z" creationid="pingfangx" creationdate="20190621T082052Z">
        <seg>这里 `onStart` 实现指示 `range` 产生它的第一个值，然后在 `onNext` 中接收它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, `flatMap` works as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083927Z" creationid="pingfangx" creationdate="20190617T083927Z">
        <seg>这里，`flatMap` 也适用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, if we imagine ourselves on `operator2`, looking to the left towards the source, is called the **upstream**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070815Z" creationid="pingfangx" creationdate="20190617T070815Z">
        <seg>在这里，如果我们想象自己在 `operator2`，向左看向源，则称为 **upstream**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the original `value` will be available inside the inner `flatMap`, courtesy of lambda variable capture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083803Z" creationid="pingfangx" creationdate="20190617T083803Z">
        <seg>在这里，原始的 `value` 将在内部 `flatMap` 中可用，由 lambda 变量捕获提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hosts which prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the "quite time".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025847Z" creationid="pingfangx" creationdate="20190828T025847Z">
        <seg>希望避免等待的主机愿意冒险在给定目的地处可能混淆新旧分组可能选择不等待“相当时间”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is this Observable implemented?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040459Z" creationid="pingfangx" creationdate="20190620T040459Z">
        <seg>Observable 是如何实现的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Android is more strict and terminates the application in such uncaught exception cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090336Z" creationid="pingfangx" creationdate="20190618T090336Z">
        <seg>但是，Android 更严格，并在此类未捕获的异常情况下终止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, RxJava's reactive types are immutable; each of the method calls returns a new `Flowable` with added behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072714Z" creationid="pingfangx" creationdate="20190617T072714Z">
        <seg>但是，RxJava 的反应类型是不可变的；每个方法调用都返回一个带有添加行为的新的 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, backpressure is present more subtly in regular cold sequences (which don't and shouldn't yield `MissingBackpressureException`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080321Z" creationid="pingfangx" creationdate="20190621T080321Z">
        <seg>然而，背压在常规冷序列中更微妙地存在(它不会也不应该产生 `MissingBackpressureException`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even when the receive window is zero, a TCP must process the RST and URG fields of all incoming segments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022507Z" creationid="pingfangx" creationdate="20190828T022507Z">
        <seg>但是，即使接收窗口为零，TCP 也必须处理所有传入报文段的 RST 和 URG 字报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, half-open connections are expected to be unusual, and the recovery procedure is mildly involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043551Z" creationid="pingfangx" creationdate="20190828T043551Z">
        <seg>但是，预计半开连接是不寻常的，并且恢复过程涉及到温和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source Observable terminates with an error, the &lt;c0&gt;AsyncSubject&lt;/c0&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084042Z" creationid="pingfangx" creationdate="20190620T084042Z">
        <seg>但是，如果源 Observable 以错误终止，则 &lt;c0&gt;AsyncSubject&lt;/c0&gt; 将不会发射任何项，而只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source Observable terminates with an error, the &lt;c0&gt;BehaviorSubject&lt;/c0&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084214Z" creationid="pingfangx" creationdate="20190620T084214Z">
        <seg>但是，如果源 Observable 以错误终止，则 &lt;c0&gt;BehaviorSubject&lt;/c0&gt; 将不会向后续观察者发射任何项，而只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the following will call since the `take` operator cancels after the set amount of `onNext` events have been delivered:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115236Z" creationid="pingfangx" creationdate="20190618T115236Z">
        <seg>但是，以下内容将调用，因为 `take` 操作符在已经传递了 `onNext` 事件的设定数量后取消：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the lambda `v -&gt; v * v` doesn't run in parallel for this flow; it receives the values 1 to 10 on the same computation thread one after the other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075726Z" creationid="pingfangx" creationdate="20190617T075726Z">
        <seg>但是，lambda `v -&gt; v * v` 不会并行运行；它一个接一个地在同一个计算线程上接收值 1 到 10。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the producing thread with the for loop can't know this and keeps `onNext`ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072156Z" creationid="pingfangx" creationdate="20190621T072156Z">
        <seg>但是，带有 for 循环的生产线程无法知道这一点，并保持调用 `onNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is not true for `onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083151Z" creationid="pingfangx" creationdate="20190621T083151Z">
        <seg>但是，对于 `onStart` 来说，情况并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable that does not start emitting items to subscribers until asked</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110131Z" creationid="pingfangx" creationdate="20190620T110131Z">
        <seg>我想要一个 Observable，直到被问到才开始向订阅者发送项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable that will notify observers of an error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110039Z" creationid="pingfangx" creationdate="20190620T110039Z">
        <seg>我想要一个 Observable 来通知观察者一个错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable to invoke a particular action when certain events occur</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110026Z" creationid="pingfangx" creationdate="20190620T110026Z">
        <seg>我希望 Observable 在发生某些事件时调用特定的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable to recover gracefully</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110050Z" creationid="pingfangx" creationdate="20190620T110050Z">
        <seg>我希望 Observable 能够优雅地恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an operator to operate on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110007Z" creationid="pingfangx" creationdate="20190620T105954Z">
        <seg>我希望操作符在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to collect items from an Observable and reemit them as buffers of items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105208Z" creationid="pingfangx" creationdate="20190620T105208Z">
        <seg>我想从 Observable 收集项目并将它们重新作为项目的缓冲区重新提交</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to convert the entire sequence of items emitted by an Observable into some other data structure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105950Z" creationid="pingfangx" creationdate="20190620T105950Z">
        <seg>我想将 Observable 发射的整个项目序列转换为其他一些数据结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create a new Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104859Z" creationid="pingfangx" creationdate="20190620T104216Z">
        <seg>我想创建一个新 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create a resource that has the same lifespan as the Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110113Z" creationid="pingfangx" creationdate="20190620T110113Z">
        <seg>我想创建一个与 Observable 具有相同生命周期的资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create an Observable by combining other Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104904Z" creationid="pingfangx" creationdate="20190620T104525Z">
        <seg>我想通过组合其他 Observable 来创建一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to emit the items from an Observable after transforming them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104848Z" creationid="pingfangx" creationdate="20190620T104848Z">
        <seg>我希望在转换后从 Observable 中发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to evaluate the entire sequence of items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105736Z" creationid="pingfangx" creationdate="20190620T105736Z">
        <seg>我想计算 Observable 发射的整个项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105119Z" creationid="pingfangx" creationdate="20190620T105119Z">
        <seg>我想忽略 Observable 发射的所有项目，只传递完成/错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to mirror an Observable but prefix items to its sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105157Z" creationid="pingfangx" creationdate="20190620T105157Z">
        <seg>我想镜像 Observable 仅要它的序列前缀项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105726Z" creationid="pingfangx" creationdate="20190620T105726Z">
        <seg>我想重新发射 Observable 中的项目，条件是它是 Observables 的第一个发射项目的条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to reemit only certain items from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105256Z" creationid="pingfangx" creationdate="20190620T105256Z">
        <seg>我想仅重新提交 Observable 中的某些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to retrieve a particular item emitted by an Observable:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105238Z" creationid="pingfangx" creationdate="20190620T105238Z">
        <seg>我想检索一个 Observable 发射的特定项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to shift the items emitted by an Observable forward in time before reemitting them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105033Z" creationid="pingfangx" creationdate="20190620T105033Z">
        <seg>我希望在重新发送之前向前移动 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to split one Observable into multiple Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105222Z" creationid="pingfangx" creationdate="20190620T105222Z">
        <seg>我想将一个 Observable 拆分成多个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to subscribe to an Observable and receive a &lt;c0&gt;Future&lt;/c0&gt; that blocks until the Observable completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110122Z" creationid="pingfangx" creationdate="20190620T110122Z">
        <seg>我想订阅一个 Observable 并接收一个阻塞的 &lt;c0&gt;Future&lt;/c0&gt;，直到 Observable 完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to transform items &lt;e0&gt;and&lt;/e0&gt; notifications from an Observable into items and reemit them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105054Z" creationid="pingfangx" creationdate="20190620T105054Z">
        <seg>我想将来自 Observable 的项目 &lt;e0&gt;和&lt;/e0&gt; 通知转换为项目并重新发送它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IRS     - initial receive sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111817Z" creationid="pingfangx" creationdate="20190827T111817Z">
        <seg>IRS     - 初始接收序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISS     - initial send sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111745Z" creationid="pingfangx" creationdate="20190827T111745Z">
        <seg>ISS     - 初始发送序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifying the source and reason for these exceptions can be tiresome, especially if they originate from a source and get routed to `RxJavaPlugins.onError` somewhere lower the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091000Z" creationid="pingfangx" creationdate="20190618T091000Z">
        <seg>识别这些异常的来源和原因可能很烦人，特别是如果它们来自一个源并且在链的某个地方被路由到 `RxJavaPlugins.onError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105030Z" creationid="pingfangx" creationdate="20190827T105030Z">
        <seg>如果存在 SYN，则序列号是初始序列号(ISN)，第一个数据八位字节是 ISN + 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a custom class implementing `Subscriber` was employed before, subscribing it to a `Flowable` adds an internal wrapper that ensures observing the Flowable is 100% compliant with the specification at the cost of some per-item overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085333Z" creationid="pingfangx" creationdate="20190618T085333Z">
        <seg>如果之前使用了实现 `Subscriber` 的自定义类，则将它订阅到 `Flowable` 会添加一个内部包装器，以确保观察 Flowable 100% 符合规范，代价是每个项目的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105958Z" creationid="pingfangx" creationdate="20190827T105958Z">
        <seg>如果一个报文段包含的求校验和的首部和文本八位字节是奇数，则最后一个八位字节在右边用零填充，形成一个 16 位字用于求校验和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an ACK is not forthcoming, after the user timeout the connection is aborted and the user is told.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063752Z" creationid="pingfangx" creationdate="20190828T063752Z">
        <seg>如果没有即将发出 ACK，则在用户超时后，中止连接并告知用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an incoming segment has a security level, or compartment, or precedence which does not exactly match the level, and compartment, and precedence requested for the connection,a reset is sent and connection goes to the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061654Z" creationid="pingfangx" creationdate="20190828T061654Z">
        <seg>如果传入的报文段具有与连接请求的级别，compartment 和优先级不完全匹配的安全级别，compartment 或优先级，则会发送重置并且连接将进入 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has to offer a reactive base type, however, the user will receive the full reactive class (as giving out an `XSource` is practically useless as it doesn't have operators on it):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061740Z" creationid="pingfangx" creationdate="20190618T061740Z">
        <seg>但是，如果操作符必须提供响应型基类型，则用户将收到完整的响应类(因为它没有运算符，因此发出 `XSource` 实际上是无用的)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an undeliverable exception is an instance/descendant of `NullPointerException`, `IllegalStateException` (`UndeliverableException` and `ProtocolViolationException` extend this), `IllegalArgumentException`, `CompositeException`, `MissingBackpressureException` or `OnErrorNotImplementedException`, the `UndeliverableException` wrapping doesn't happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091305Z" creationid="pingfangx" creationdate="20190618T091305Z">
        <seg>如果一个无法传递的异常是 `NullPointerException` 的实例/后代，`IllegalStateException`(`UndeliverableException` 和 `ProtocolViolationException` 扩展了它)，`IllegalArgumentException`，`CompositeException`，`MissingBackpressureException` 或 `OnErrorNotImplementedException`，那么 `UndeliverableException` 包装不会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an unsolicited FIN arrives from the network, the receiving TCP can ACK it and tell the user that the connection is closing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063719Z" creationid="pingfangx" creationdate="20190828T063719Z">
        <seg>如果未经请求的 FIN 从网络到达，则接收 TCP 可以确认它并告诉用户连接正在关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If at site A the connection no longer exists, then an attempt by the user at site B to send any data on it will result in the site B TCP receiving a reset control message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043711Z" creationid="pingfangx" creationdate="20190828T043711Z">
        <seg>如果在站点 A 处连接不再存在，则站点 B 处的用户尝试在其上发送任何数据将导致站点 B TCP 接收重置控制消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one decides to add a non-empty global error consumer, here is an example that manages the typical undeliverable exceptions based on whether they represent a likely bug or an ignorable application/network state:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092931Z" creationid="pingfangx" creationdate="20190618T092931Z">
        <seg>如果决定添加一个非空的全局错误消费者，这里有一个例子来管理典型的无法传递的异常，具体取决于它们是代表可能的错误还是可忽略的应用程序/网络状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one has initialization logic after the call to `request(1)` which is needed by `onNext`, you may end up with exceptions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083433Z" creationid="pingfangx" creationdate="20190621T083433Z">
        <seg>如果在调用 `request(1)` 之后有 `onNext` 所需的初始化逻辑，则可能会以异常结束：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one has to handle multiple resources, create a `CompositeSubscription`, associate it with the emitter and then add further resources to the `CompositeSubscription` itself:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022827Z" creationid="pingfangx" creationdate="20190624T022827Z">
        <seg>如果必须处理多个资源，创建一个 `CompositeSubscription`，将它与发射器关联，然后将更多资源添加到 `CompositeSubscription` 本身：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one needs those customization, using `NONE` as the backpressure mode and applying the relevant `onBackpressureXXX` on the resulting `Flowable` is the way to go.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022124Z" creationid="pingfangx" creationdate="20190624T022124Z">
        <seg>如果需要那些定制，使用 `NONE` 作为背压模式并在生成的 `Flowable` 上应用相关的 `onBackpressureXXX` 是可行的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one was using `Flowable.subscribe(Subscriber&lt;? super T&gt;)` with the built-in RxJava `Subscriber` implementations such as `DisposableSubscriber`, `TestSubscriber` and `ResourceSubscriber`, there is a small runtime overhead (one `instanceof` check) associated when the code is not recompiled against 2.0.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085238Z" creationid="pingfangx" creationdate="20190618T085238Z">
        <seg>如果使用 `Flowable.subscribe(Subscriber&lt;? super T&gt;)` 和内置的 RxJava `Subscriber` 实现，如 `DisposableSubscriber`，`TestSubscriber` 和 `ResourceSubscriber`，那么在不根据 2.0.7 重新编译代码时，会有一个较小的运行时开销（一个 `instanceof` 检查）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If our SYN has been acknowledged (perhaps in this incoming segment) the precedence level of the incoming segment must match the local precedence level exactly, if it does not a reset must be sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061024Z" creationid="pingfangx" creationdate="20190828T061024Z">
        <seg>如果我们的 SYN 已被确认(可能在此传入报文段中)，则传入报文段的优先级必须与本地优先级完全匹配，如果不是，则必须发送重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If our SYN has not been acknowledged and the precedence level of the incoming segment is higher than the precedence level requested then either raise the local precedence level (if allowed by the user and the system) or send a reset; or if the precedence level of the incoming segment is lower than the precedence level requested then continue as if the precedence matched exactly (if the remote TCP cannot raise the precedence level to match ours this will be detected in the next segment it sends, and the connection will be terminated then).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061003Z" creationid="pingfangx" creationdate="20190828T061003Z">
        <seg>如果我们的 SYN 未被确认且传入报文段的优先级高于请求的优先级，则提高本地优先级(如果用户和系统允许)或发送重置；或者如果传入报文段的优先级低于请求的优先级，则继续，就好像优先级完全匹配一样(如果远程 TCP 不能提高优先级以匹配我们的优先级将在它发送的下一个报文段中检测到，并且连接将被终止)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If some of the values can be safely ignored, one can use the sampling (with time or another `Flowable`) and throttling operators (`throttleFirst`, `throttleLast`, `throttleWithTimeout`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091633Z" creationid="pingfangx" creationdate="20190621T091633Z">
        <seg>如果可以安全地忽略某些值，可以使用采样(使用时间或其他 `Flowable`)和限制操作符(`throttleFirst`，`throttleLast`，`throttleWithTimeout`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105220Z" creationid="pingfangx" creationdate="20190827T105220Z">
        <seg>如果设置了 ACK 控制位，则该字段包含该报文段的发送者期望接收的下一个序列号的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the SYN at line 6 had arrived before the RST, a more complex exchange might have occurred with RST's sent in both directions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043340Z" creationid="pingfangx" creationdate="20190828T043340Z">
        <seg>如果第 6 行的 SYN 在 RST 之前到达，则可能在两个方向上发送 RST 时发生更复杂的交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the TCP is in one of the synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it aborts the connection and informs its user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042627Z" creationid="pingfangx" creationdate="20190828T042627Z">
        <seg>如果 TCP 处于同步状态之一(ESTABLISHED，FIN-WAIT-1，FIN-WAIT-2，CLOSE-WAIT，CLOSING，LAST-ACK，TIME-WAIT)，它将中止连接并通知其用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the `initialRequest` is given, the `TestSubscriber` offers the `requestMore(long)` method to keep requesting in a fluent manner:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101754Z" creationid="pingfangx" creationdate="20190618T101754Z">
        <seg>如果给出 `initialRequest`，那么 `TestSubscriber` 提供 `requestMore(long)` 方法来以流畅的方式继续请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the call is rewritten, it becomes obvious why it works so:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015836Z" creationid="pingfangx" creationdate="20190624T015806Z">
        <seg>如果调用被重写，为什么它会这样的原因就很明显：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code example is left unchanged, this will result in a compile time error (however, often with misleading error message about lack of overload).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092815Z" creationid="pingfangx" creationdate="20190617T092815Z">
        <seg>如果代码示例保持不变，这将导致编译时错误(但是，通常会出现关于缺少重载的误导性错误消息)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection does not exist (CLOSED) then a reset is sent in response to any incoming segment except another reset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060605Z" creationid="pingfangx" creationdate="20190828T060605Z">
        <seg>如果连接不存在(CLOSED)，则发送复位以响应除另一个复位之外的任何传入报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), any unacceptable segment (out of window sequence number or unacceptible acknowledgment number) must elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating the next sequence number expected to be received, and the connection remains in the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061158Z" creationid="pingfangx" creationdate="20190828T061158Z">
        <seg>如果连接处于同步状态（ESTABLISHED，FIN-WAIT-1，FIN-WAIT-2，CLOSE-WAIT，CLOSING，LAST-ACK，TIME-WAIT），则任何不可接受的报文段（序列号不在窗口内或不可接授的确认）必须仅引出包含当前发送序列号的空确认报文段和指示预期接收的下一个序列号的确认，并且连接保持相同状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED), and the incoming segment acknowledges something not yet sent (the segment carries an unacceptable ACK), or if an incoming segment has a security level or compartment which does not exactly match the level and compartment requested for the connection, a reset is sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060851Z" creationid="pingfangx" creationdate="20190828T060851Z">
        <seg>如果连接处于任何非同步状态(LISTEN，SYN-SENT，SYN-RECEIVED)，并且传入报文段确认尚未发送的内容(该报文段带有不可接受的 ACK)，或者传入的报文段具有的安全级别或 compartment 与连接请求的级别和 compartment 不完全匹配，则发送重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the data is already available as an array of objects, a list of objects or any `Iterable` source, the respective `from` overloads will handle the backpressure and emission of such sources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020156Z" creationid="pingfangx" creationdate="20190624T020156Z">
        <seg>如果数据已经作为一个对象数组，一个对象列表或任何 `Iterable` 源提供，则相应的 `from` 重载将处理这些源的背压和发射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file doesn't exist or can't be read properly, the end consumer will print out `IOException` directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064328Z" creationid="pingfangx" creationdate="20190618T064328Z">
        <seg>如果文件不存在或无法正确读取，最终消费者将直接打印出 `IOException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first example is rewritten:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080334Z" creationid="pingfangx" creationdate="20190621T080334Z">
        <seg>如果第一个示例被重写为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment, otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060658Z" creationid="pingfangx" creationdate="20190828T060658Z">
        <seg>如果传入报文段具有 ACK 字段，则复位从报文段的 ACK 字段获取其序列号，否则复位具有序列号零，并且 ACK 字段被设置为传入报文段的序列号和报文段长度的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the library/code already did this, the undeliverable `InterruptedException`s should stop now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092847Z" creationid="pingfangx" creationdate="20190618T092847Z">
        <seg>如果库/代码已经这样做了，那么无法传递的 `InterruptedException` 应该立即停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiver was in SYN-RECEIVED state and had previously been in the LISTEN state, then the receiver returns to the LISTEN state, otherwise the receiver aborts the connection and goes to the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061815Z" creationid="pingfangx" creationdate="20190828T061815Z">
        <seg>如果接收器处于 SYN-RECEIVED 状态并且之前一直处于 LISTEN 状态，则接收器返回 LISTEN 状态，否则接收器中止连接并进入 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiver was in any other state, it aborts the connection and advises the user and goes to the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061833Z" creationid="pingfangx" creationdate="20190828T061833Z">
        <seg>如果接收器处于任何其他状态，它将中止连接并通知用户并进入 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiver was in the LISTEN state, it ignores it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061759Z" creationid="pingfangx" creationdate="20190828T061759Z">
        <seg>如果接收器处于 LISTEN 状态，则忽略它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiving TCP is in a  non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042612Z" creationid="pingfangx" creationdate="20190828T042612Z">
        <seg>如果接收 TCP 处于非同步状态(即，SYN-SENT，SYN-RECEIVED)，则在接收到可接受的重置时它返回到 LISTEN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025757Z" creationid="pingfangx" creationdate="20190828T025757Z">
        <seg>如果恢复足够快地发生，则 S1 附近的净承载序列号中的任何旧重复可以到达并且被连接的新化身的接收器视为新分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the source Observable terminates with an error, the &lt;c0&gt;PublishSubject&lt;/c0&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084906Z" creationid="pingfangx" creationdate="20190620T084906Z">
        <seg>如果源 Observable 以错误终止，则 &lt;c0&gt;PublishSubject&lt;/c0&gt; 将不会向后续观察者发射任何项，但只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this behavior is desirable can be debated, but in any case, if you want to avoid such calls to the uncaught exception handler, the **final application** that uses RxJava 2 (directly or transitively) should set a no-op handler:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090732Z" creationid="pingfangx" creationdate="20190618T090647Z">
        <seg>如果这种行为值得商榷，但无论如何，如果您想避免对未捕获的异常处理程序的这种调用，使用 RxJava 2(直接或传递)的 **最终应用程序** 应该设置一个无操作处理程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this pattern was not employed before, we encourage updating the code/library in question.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092855Z" creationid="pingfangx" creationdate="20190618T092855Z">
        <seg>如果之前没有使用此模式，我们鼓励更新相关代码/库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we'd consume the `iterator` via classic for-loop, that would result in an infinite loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020542Z" creationid="pingfangx" creationdate="20190624T020542Z">
        <seg>如果我们通过经典的 for 循环使用 `iterator`，那将导致无限循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a &lt;c0&gt;Subject&lt;/c0&gt; and you want to pass it along to some other agent without exposing its &lt;c1&gt;Subscriber&lt;/c1&gt; interface, you can mask it by calling its &lt;c2&gt;asObservable&lt;/c2&gt; method, which will return the Subject as a pure &lt;c3&gt;Observable&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085411Z" creationid="pingfangx" creationdate="20190620T085411Z">
        <seg>如果您有一个 &lt;c0&gt;Subject&lt;/c0&gt; 并且想要将其传递给其他代理而不暴露其 &lt;c1&gt;Subscriber&lt;/c1&gt; 接口，则可以通过调用其 &lt;c2&gt;asObservable&lt;/c2&gt; 方法来掩盖它，它将 Subject 作为纯 &lt;c3&gt;Observable&lt;/c3&gt; 返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with &lt;a1&gt;&lt;c2&gt;Create&lt;/c2&gt;&lt;/a1&gt; so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a &lt;c3&gt;ReplaySubject&lt;/c3&gt; instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084854Z" creationid="pingfangx" creationdate="20190620T084854Z">
        <seg>如果您需要保证从 Observable 源传递所有项目，您需要使用 &lt;a1&gt;&lt;c2&gt;Create&lt;/c2&gt;&lt;/a1&gt; 形成 Observable，以便您可以手动重新引入“冷” Observable 行为(在开始发射项目之前检查所有观察者是否已订阅)，或转而使用 &lt;c3&gt;ReplaySubject&lt;/c3&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to perform cleanup on both regular termination or cancellation, consider the operator `using` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115251Z" creationid="pingfangx" creationdate="20190618T115251Z">
        <seg>如果您需要在常规终止或取消时执行清理，请考虑使用操作符 `using`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a &lt;c0&gt;ReplaySubject&lt;/c0&gt; as an observer, take care not to call its &lt;c1&gt;onNext&lt;/c1&gt; method (or its other &lt;c2&gt;on&lt;/c2&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a3&gt;the Observable contract&lt;/a3&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085148Z" creationid="pingfangx" creationdate="20190620T085148Z">
        <seg>如果您使用 &lt;c0&gt;ReplaySubject&lt;/c0&gt; 作为观察者，请注意不要从多个线程调用其 &lt;c1&gt;onNext&lt;/c1&gt; 方法(或其他 &lt;c2&gt;on&lt;/c2&gt; 方法)，这可能导致重合(非顺序)调用，这违反了 &lt;a3&gt;Observable 协议&lt;/a3&gt;，并在结果主题中产生了关于应首先重播哪个项目或通知的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to implement your own operator, see &lt;a1&gt;Implementing Your Own Operators&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094342Z" creationid="pingfangx" creationdate="20190620T094342Z">
        <seg>如果要实现自己的操作符，请参阅 &lt;a1&gt;Implementing Your Own Operators&lt;/a1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular &lt;d0&gt;Schedulers&lt;/d0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085651Z" creationid="pingfangx" creationdate="20190620T085651Z">
        <seg>如果要将多线程引入到 Observable 操作符链中，可以通过指示这些操作符(或特定的 Observable)在特定的 &lt;d0&gt;Schedulers (调度器)&lt;/d0&gt; 操作来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard, shading, etc).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105307Z" creationid="pingfangx" creationdate="20190617T105307Z">
        <seg>如果您的代码本身就是一个库(即它在您自己控制之外的用户的 CLASSPATH 上使用)，则不应使用 beta API，除非您重新打包它们(例如使用 ProGuard，shading 等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform doesn't support Java 8 lambdas (yet), you have to create an inner class of `Consumer` manually:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065916Z" creationid="pingfangx" creationdate="20190617T065916Z">
        <seg>如果您的平台(还)不支持 Java 8 lambdas，您必须手动创建一个内部类`Consumer`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore all but the terminal events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061209Z" creationid="pingfangx" creationdate="20190619T061209Z">
        <seg>忽略除终端事件之外的所有事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations of `request()` in operators ensure proper happens-before relation  (or in other terms, memory release or full fence) when necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084142Z" creationid="pingfangx" creationdate="20190621T084142Z">
        <seg>操作符中 `request()` 的实现确保在必要时有正确的 happens-before 关系(或在其他术语中，内存释放或完全隔离)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementors may provide TCP users with the ability to select on a connection by connection basis whether to wait after a crash, or may informally implement the "quite time" for all connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025856Z" creationid="pingfangx" creationdate="20190828T025856Z">
        <seg>实现者可以为 TCP 用户提供在连接基础上选择是否在崩溃之后等待的能力，或者可以非正式地实现所有连接的“相当时间”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.x, the `doOnUnsubscribe` was always executed on a terminal event because 1.x' `SafeSubscriber` called `unsubscribe` on itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114822Z" creationid="pingfangx" creationdate="20190618T114822Z">
        <seg>在 1.x 中，`doOnUnsubscribe` 总是在终端事件上执行，因为 1.x 的 `SafeSubscriber` 本身调用 `unsubscribe`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.x, you could create an instance with `GroupedObservable.from()` which was used internally by 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063829Z" creationid="pingfangx" creationdate="20190618T063829Z">
        <seg>在 1.x 中，您可以使用 `GroupedObservable.from()` 创建一个实例，该实例由 1.x 内部使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2.0.7, the operator `strict()` returns `this`, is deprecated and will be removed completely in 2.1.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073837Z" creationid="pingfangx" creationdate="20190618T073837Z">
        <seg>在 2.0.7 中，运算符 `strict()` 返回 `this`，不推荐使用，将在 2.1.0 中完全删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2.x, all use cases now extend `GroupedObservable` directly thus the factory methods are no longer available; the whole class is now abstract.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063859Z" creationid="pingfangx" creationdate="20190618T063859Z">
        <seg>在 2.x 中，所有用例现在都直接继承了 `GroupedObservable`，因此工厂方法不再可用；整个类现在都是抽象的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ReactiveX an &lt;d0&gt;observer&lt;/d0&gt; &lt;d1&gt;subscribes&lt;/d1&gt; to an &lt;d2&gt;Observable&lt;/d2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043135Z" creationid="pingfangx" creationdate="20190620T042910Z">
        <seg>在 ReactiveX 中，一个&lt;d0&gt;observer (观察者)&lt;/d0&gt; &lt;d1&gt;subscribes (订阅)&lt;/d1&gt; 一个 &lt;d2&gt;Observable (可观察对象)&lt;/d2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ReactiveX, however, they name the event handlers themselves.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064811Z" creationid="pingfangx" creationdate="20190620T064811Z">
        <seg>但是，在 ReactiveX 中，它们是事件处理程序的名字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava 1.x, the interface `rx.Subscription` was responsible for stream and resource lifecycle management, namely unsubscribing a sequence and releasing general resources such as scheduled tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072636Z" creationid="pingfangx" creationdate="20190618T072636Z">
        <seg>在 RxJava 1.x 中，接口 `rx.Subscription` 负责流和资源生命周期管理，即取消订阅序列并释放一般资源(如计划任务)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava the default `Scheduler`s run on daemon threads, which means once the Java main thread exits, they all get stopped and background computations may never happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073938Z" creationid="pingfangx" creationdate="20190617T073938Z">
        <seg>在 RxJava 中，默认的 `Scheduler` 在守护线程上运行，这意味着一旦 Java 主线程退出，它们都会被停止并且后台计算可能永远不会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava's documentation, **emission**, **emits**, **item**, **event**, **signal**, **data** and **message** are considered synonyms and represent the object traveling along the dataflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071117Z" creationid="pingfangx" creationdate="20190617T071117Z">
        <seg>在 RxJava 的文档中，**emission**, **emits**, **item**, **event**, **signal**, **data** and **message** 被视为同义词并代表沿数据流传播的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava, the dedicated `Flowable` class is designated to support backpressure and `Observable` is dedicated for the non-backpressured operations (short sequences, GUI interactions, etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071432Z" creationid="pingfangx" creationdate="20190617T071432Z">
        <seg>在 RxJava 中，专用的“Flowable”类被指定为支持背压，而“Observable”专用于非背压操作(短序列，GUI 交互等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In `range`'s terms, it will remember that there was a `request(1)` call while it called `onNext()` and once `onNext()` returns, it will make another round and call `onNext()` with the next integer value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T032615Z" creationid="pingfangx" creationdate="20190621T082709Z">
        <seg>在 `range` 的术语中，它会记住在调用 `onNext()` 时有一个 `request(1)` 调用，一旦 `onNext()` 返回，它将进行另一轮，调用指定整数次数的 `onNext()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a later section, more detail is offered with respect to the reaction of the TCP to events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T113237Z" creationid="pingfangx" creationdate="20190827T113237Z">
        <seg>在后面的部分中，提供了有关 TCP 对事件的反应的更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a naive implementation of `range`, such call would recursively call `onNext`, leading to `StackOverflowError` which is of course undesirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082214Z" creationid="pingfangx" creationdate="20190621T082214Z">
        <seg>在 `range` 的简单实现中，这样的调用将递归调用 `onNext`，导致 `StackOverflowError`，这当然是不可取的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition several variables relating to the send and receive sequence numbers are stored in the TCB.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111545Z" creationid="pingfangx" creationdate="20190827T111545Z">
        <seg>另外，与发送和接收序列号有关的几个变量存储在 TCB 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, `org.reactivestreams.Subscriber` has no notion of adding resources to it, cancelling it or requesting from the outside.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065745Z" creationid="pingfangx" creationdate="20190618T065745Z">
        <seg>此外，`org.reactivestreams.Subscriber` 没有向其添加资源，取消或从外部请求的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, if the wrapped API supports cancellation (such as the listener removal in the example), one can use the `setCancellation` (or `setSubscription` for `Subscription`-like resources) to register a cancellation callback that gets invoked when the downstream unsubscribes or the `onError`/`onComplete` is called on the provided `Emitter`instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022718Z" creationid="pingfangx" creationdate="20190624T022718Z">
        <seg>此外，如果包装的 API 支持取消(例如示例中的侦听器删除)，则可以使用 `setCancellation`(或 `setSubscription` 用于类似 Subscription` 的资源)，来注册在下游取消订阅或在提供的 `Emitter` 实例上调用 `onError`/`onComplete` 时调用的取消回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, operators requiring a predicate no longer use `Func1&lt;T, Boolean&gt;` but have a separate, primitive-returning type of `Predicate&lt;T&gt;` (allows better inlining due to no autoboxing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065124Z" creationid="pingfangx" creationdate="20190618T065124Z">
        <seg>另外，需要谓词的运算符不再使用 `Func1&lt;T, Boolean&gt;`，但是有一个单独的，原始返回类型的 `Predicate&lt;T&gt;`(由于没有自动装箱，允许更好的内联)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, some 3rd party libraries/code throw when they get interrupted by a cancel/dispose call which leads to an undeliverable exception most of the time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091422Z" creationid="pingfangx" creationdate="20190618T091345Z">
        <seg>此外，一些第三方库/代码在被取消/dispose 调用中断时抛出，这导致大多数时间无法传递的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, there is option to wrap an existing `Executor` (and its subtypes such as `ExecutorService`) into a `Scheduler` via `Schedulers.from(Executor)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073659Z" creationid="pingfangx" creationdate="20190617T073659Z">
        <seg>此外，还可以选择通过 `Schedulers.from(Executor)` 将现有的 `Executor`(及其子类型，如 `ExecutorService`) 包装到 `Scheduler` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, they won't signal `BufferOverflowException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014658Z" creationid="pingfangx" creationdate="20190624T014658Z">
        <seg>另外，它们不会发出 `BufferOverflowException` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all states except SYN-SENT, all reset (RST) segments are validated by checking their SEQ-fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061721Z" creationid="pingfangx" creationdate="20190828T061721Z">
        <seg>在除 SYN-SENT 之外的所有状态中，通过检查其 SEQ-字段来验证所有复位(RST)报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an attempt to establish the connection, A's TCP will send a segment containing SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055831Z" creationid="pingfangx" creationdate="20190828T055831Z">
        <seg>在尝试建立连接时，A 的 TCP 将发送包含 SYN 的报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an ordinary method call — that is, &lt;e0&gt;not&lt;/e0&gt; the sort of asynchronous, parallel calls typical in ReactiveX — the flow is something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T052930Z" creationid="pingfangx" creationdate="20190620T052930Z">
        <seg>在一个普通的方法调用中 - 也就是说，&lt;e0&gt;非&lt;/e0&gt; ReactiveX 中典型的异步并行调用 - 流程是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the computation itself should be delayed until the downstream actually requests, we can use `just` with `map`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020054Z" creationid="pingfangx" creationdate="20190624T020040Z">
        <seg>如果计算本身应该延迟到下游实际请求时，我们可以使用 `just` 和 `map`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the source data can be processed more efficiently in batch, one can reduce the likelihood of `MissingBackpressureException` by using one of the standard batching operators (by size and/or by time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091349Z" creationid="pingfangx" creationdate="20190621T091349Z">
        <seg>如果可以批量处理源数据，则可以通过使用标准批处理操作符(按大小和/或按时间)之一减少 `MissingBackpressureException` 的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, since version 2.1.10, it doesn't</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102558Z" creationid="pingfangx" creationdate="20190617T102558Z">
        <seg>事实上，从版本 2.1.10 开始，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In figure 12, we find the two TCPs A and B with passive connections waiting for SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060341Z" creationid="pingfangx" creationdate="20190828T060341Z">
        <seg>在图 12 中，我们发现两个 TCP A 和 B 具有等待 SYN 的被动连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In line 2 of figure 7, TCP A begins by sending a SYN segment indicating that it will use sequence numbers starting with sequence number 100.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041309Z" creationid="pingfangx" creationdate="20190828T041309Z">
        <seg>在图 7 的第 2 行中，TCP A 通过发送 SYN 报文段开始，该 SYN 报文段指示它将使用以序列号 100 开始的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In line 3, TCP B sends a SYN and acknowledges the SYN it received from TCP A.  Note that the acknowledgment field indicates TCP B is now expecting to hear sequence 101, acknowledging the SYN which occupied sequence 100.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041635Z" creationid="pingfangx" creationdate="20190828T041635Z">
        <seg>在第 3 行中，TCP B 发送 SYN 并确认它从 TCP A 收到的 SYN。注意，确认字段指示 TCP B 现在期望收到序列 101，并确认了占用序列号 100 的 SYN 报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044643Z" creationid="pingfangx" creationdate="20190620T044643Z">
        <seg>在许多软件编程任务中，您或多或少地期望您编写的指令将按照您编写的顺序逐个执行并逐步完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In modern RxJava, most asynchronous operators now have a bounded internal buffer, like `observeOn` above and any attempt to overflow this buffer will terminate the whole sequence with `MissingBackpressureException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T075250Z" creationid="pingfangx" creationdate="20190621T075250Z">
        <seg>在现代的 RxJava 中，大多数异步操作符现在都有一个有界的内部缓冲区，如上面的 `observeOn`，任何溢出此缓冲区的尝试都将带 `MissingBackpressureException` 终止整个序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to help lift these extra overheads, a new method `Flowable.subscribe(FlowableSubscriber&lt;? super T&gt;)` has been added which exposes the original behavior from before 2.0.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085441Z" creationid="pingfangx" creationdate="20190618T085441Z">
        <seg>为了帮助解除这些额外的开销，添加了一个新的方法 `Flowable.subscribe(FlowableSubscriber&lt;? super T&gt;)`，它暴露了 2.0.7 之前的原始行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other documents and other contexts, what we are calling an “observer” is sometimes called a “subscriber,” “watcher,” or “reactor.” This model in general is often referred to as the &lt;a0&gt;“reactor pattern”&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T050044Z" creationid="pingfangx" creationdate="20190620T050044Z">
        <seg>在其他文件和其他场景下，我们所谓的“观察者 (observer)”有时被称为“订阅者 (subscriber)”，“观察者 (watcher)”或“反应者 (reactor)”。这种模型通常被称为 &lt;a0&gt;“反应者模式 (reactor pattern)”&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other scenarios, the result(s) of the first source/dataflow is irrelevant and one would like to continue with a quasi independent another source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083915Z" creationid="pingfangx" creationdate="20190617T083915Z">
        <seg>在其他场景中，第一个源/数据流的结果是无关紧要的，并且人们希望继续使用准独立的另一个源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, SYNs addressed to a non-existent connection are rejected by this means.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060619Z" creationid="pingfangx" creationdate="20190828T060619Z">
        <seg>特别是，通过这种方式拒绝寻址到不存在的连接的 SYN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In response to sending data the TCP will receive acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021759Z" creationid="pingfangx" creationdate="20190828T021759Z">
        <seg>为响应发送数据，TCP 将收到确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In return, the `observeOn` calls `Subscription.request(n)` with a value to tell the `range` it is allowed to produce (i.e., `onNext` it) that many **additional** elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081412Z" creationid="pingfangx" creationdate="20190621T081412Z">
        <seg>作为回应，`observeOn` 调用 `Subscription.request(n)`，其值为告诉 `range`，它允许生产(即 `onNext`)多少个**额外的**元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some ReactiveX implementations, there is a specialized observer interface, &lt;c0&gt;Subscriber&lt;/c0&gt;, that implements an &lt;c1&gt;unsubscribe&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061644Z" creationid="pingfangx" creationdate="20190620T061644Z">
        <seg>在一些 ReactiveX 实现中，有一个特殊的观察者​器接口 &lt;c0&gt;Subscriber&lt;/c0&gt;，它实现了 &lt;c1&gt;unsubscribe&lt;/c1&gt; 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some contexts such names would indicate methods by means of which event handlers are &lt;e5&gt;registered&lt;/e5&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064833Z" creationid="pingfangx" creationdate="20190620T064740Z">
        <seg>在某些场景中下，此类名称将指示通过哪个事件处理程序 &lt;e5&gt;registered (注册)&lt;/e5&gt; 的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some implementations of ReactiveX, there is also something called a “Connectable” Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070030Z" creationid="pingfangx" creationdate="20190620T070030Z">
        <seg>在 ReactiveX 的一些实现中，还存在称为“Connectable” 的 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such situations, there are usually two options to fix the transformation: 1) convert to the desired type or 2) find and use an overload of the specific operator supporting the different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092841Z" creationid="pingfangx" creationdate="20190617T092841Z">
        <seg>在这种情况下，通常有两个选项来修复转换：1)转换为所需类型或 2)查找并使用支持不同类型的特定运算符的重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Reactive-Streams specification, the `Subject`-like behavior, namely being a consumer and supplier of events at the same time, is done by the `org.reactivestreams.Processor` interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061946Z" creationid="pingfangx" creationdate="20190618T061946Z">
        <seg>在 Reactive-Streams 规范中，类似 `Subject` 的行为，即同时成为事件的消费者和供应者，由 `org.reactivestreams.Processor` 接口完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the SYN-SENT state (a RST received in response to an initial SYN), the RST is acceptable if the ACK field acknowledges the SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061750Z" creationid="pingfangx" creationdate="20190828T061750Z">
        <seg>在 SYN-SENT 状态(响应初始 SYN 而接收的 RST)中，如果 ACK 字段确认 SYN，则 RST 是可接受的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025600Z" creationid="pingfangx" creationdate="20190828T025600Z">
        <seg>在没有关于特定连接上使用的序列号的知识的情况下，TCP 规范建议在连接上发送报文段之前 MSL 秒的源延迟，以允许来自早期连接化身的报文段的时间从系统中消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the asynchronous model the flow goes more like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053052Z" creationid="pingfangx" creationdate="20190620T053052Z">
        <seg>在异步模型中，流程更像是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the classical Rx.NET and early RxJava, these buffers were unbounded, meaning that they would likely hold nearly all 1 million elements from the example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072300Z" creationid="pingfangx" creationdate="20190621T072300Z">
        <seg>在经典的 Rx.NET 和早期的 RxJava 中，这些缓冲区是无界的，这意味着在该示例中，它们可能会持有几乎所有的 100 万个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example we call `onComplete()` if the read byte is negative, indicating and end of file, and call `onError` in case the read throws an `IOException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021304Z" creationid="pingfangx" creationdate="20190624T021304Z">
        <seg>在示例中，如果读取字节为负数，指示和文件结束，则调用 `onComplete()`，并在读取抛出 `IOException` 时调用 `onError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the latter case, it receives the error message "connection not open" from the local (A's) TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055822Z" creationid="pingfangx" creationdate="20190828T055822Z">
        <seg>在后一种情况下，它从本地(A)的 TCP 接收错误消息“connection not open”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the original Rx.NET, the operator that emits a single item and then completes is called `Return(T)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101615Z" creationid="pingfangx" creationdate="20190617T101615Z">
        <seg>在原始的 Rx.NET 中，发出单个项然后完成的运算符称为 `Return(T)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the paragraphs below, an explanation for this specification is given.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024658Z" creationid="pingfangx" creationdate="20190828T024658Z">
        <seg>在下面的段落中，给出了对该说明书的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, a FIN segment can be constructed and placed on the outgoing segment queue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063356Z" creationid="pingfangx" creationdate="20190828T063356Z">
        <seg>在这种情况下，可以构造 FIN 报文段并将其放置在传出报文段队列上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, one can use one of the following operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091117Z" creationid="pingfangx" creationdate="20190621T091117Z">
        <seg>在这种情况下，可以使用以下操作符之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the data arriving at TCP A from TCP B (line 2) is unacceptable because no such connection exists, so TCP A sends a RST.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060249Z" creationid="pingfangx" creationdate="20190828T060249Z">
        <seg>在这种情况下，从 TCP B(第 2 行)到达 TCP A 的数据是不可接受的，因为不存在这样的连接，因此 TCP A 发送 RST。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the delegation works the same way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022948Z" creationid="pingfangx" creationdate="20190624T022948Z">
        <seg>在这种情况下，委托以相同的方式工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the `observeOn` goes with a very low buffer size yet there is no `MissingBackpressureException` as `onBackpressureBuffer` soaks up all the 1 million values and hands over small batches of it to `observeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092532Z" creationid="pingfangx" creationdate="20190621T092532Z">
        <seg>在这个例子中，`observeOn` 的缓冲区大小非常低，但是不会产生 `MissingBackpressureException`，因为 `onBackpressureBuffer` 吸收了所有 100 万个值并将其小批量交给 `observeOn`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the main thread will produce 1 million items to an end consumer which is processing it on a background thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072031Z" creationid="pingfangx" creationdate="20190621T072031Z">
        <seg>在此示例中，主线程将向最终消费者生产 100 万个项目，该消费者在后台线程上处理项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this setup, the `current` starts out with `0` and next time the lambda is invoked, the parameter `current` now holds `1`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021541Z" creationid="pingfangx" creationdate="20190624T021541Z">
        <seg>在这个设置中，`current` 以 `0` 开始，下次调用 lambda 时，参数 `current` 现在保持 `1`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this synchronous case, a `NullPointerException` will be thrown immediately while still executing `onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083450Z" creationid="pingfangx" creationdate="20190621T083450Z">
        <seg>在这种同步的情况下，在执行 `onStart` 时会立即抛出 `NullPointerException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Sequence Number Selection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023120Z" creationid="pingfangx" creationdate="20190828T023120Z">
        <seg>初始序列号选择</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we defined our own functional interfaces in 1.x and 2.x follows this tradition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064103Z" creationid="pingfangx" creationdate="20190618T064103Z">
        <seg>相反，我们在 1.x 和 2.x 中定义了我们自己的函数接口遵循这一传统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal changes in 2.0.6 now consistently cancel or dispose a `Subscription`/`Disposable` before cancelling/disposing a task or worker (which causes the interrupt on the target thread).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092743Z" creationid="pingfangx" creationdate="20190618T092743Z">
        <seg>2.0.6 中的内部更改现在在取消/释放任务或工作程序(导致目标线程上的中断)之前始终取消或释放 `Subscription`/“Disposable”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, asynchronous operators have buffers to hold such elements until they can be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072208Z" creationid="pingfangx" creationdate="20190621T072208Z">
        <seg>在内部，异步操作符具有缓冲区来保存这些元素，直到它们可以被处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can change at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105413Z" creationid="pingfangx" creationdate="20190617T105413Z">
        <seg>它可以随时改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It depends on the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064956Z" creationid="pingfangx" creationdate="20190620T064956Z">
        <seg>这取决于 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends &lt;a0&gt;the observer pattern&lt;/a0&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033455Z" creationid="pingfangx" creationdate="20190620T033244Z">
        <seg>它扩展了 &lt;a0&gt;观察者模式&lt;/a0&gt; 以支持数据和/或事件序列，并添加操作符，允许您以声明方式组合序列，而无需关注底层的线程，同步，线程安全，并发数据结构和非阻塞 I/O 等问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends the [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern) to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064839Z" creationid="pingfangx" creationdate="20190617T064839Z">
        <seg>它扩展了 [观察者模式](http://en.wikipedia.org/wiki/Observer_pattern) 以支持数据/事件序列，并添加运算符，允许您以声明方式组合序列，同时抽象出对低级别线程，同步，线程安全和并发数据结构等的关注。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034456Z" creationid="pingfangx" creationdate="20190620T034456Z">
        <seg>它使您摆脱了纠结的回调网络，从而使您的代码更具可读性，且不易出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the usual modes, similar to `onBackpressureXXX` in addition to signalling a `MissingBackpressureException` or simply ignoring such overflow inside it altogether.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022056Z" creationid="pingfangx" creationdate="20190624T022056Z">
        <seg>它具有通常的模式，类似于 `onBackpressureXXX`，除了发出 `MissingBackpressureException` 信号或完全忽略它内部的溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is &lt;a0&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a0&gt; (or impossible, since latencies of each request vary at runtime).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035228Z" creationid="pingfangx" creationdate="20190620T035228Z">
        <seg>&lt;a0&gt;使用 Futures 难以很好地组合带条件的异步执行流程&lt;/a0&gt;(或者可以说不可能，因为每个请求的延迟在运行时变化)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is automatically applied by `RxJavaPlugins.onError` with intact stacktrace that may help find which exact operator rerouted the original error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091225Z" creationid="pingfangx" creationdate="20190618T091225Z">
        <seg>它由 `RxJavaPlugins.onError` 自动应用，带有完整的堆栈跟踪，可以帮助找到哪个确切的运算符重新路由了原始错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is essential to remember that the actual sequence number space is finite, though very large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021243Z" creationid="pingfangx" creationdate="20190828T021243Z">
        <seg>必须记住，实际的序列号空间是有限的，尽管非常大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is implemented as a single JAR that is focused on just the Observable abstraction and related higher-order functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113521Z" creationid="pingfangx" creationdate="20190617T113521Z">
        <seg>它作为单个 JAR 实现，仅关注 Observable 抽象和相关的高阶函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is likely the `compute(int)` method takes some time but the overhead of the `Flowable` operator chain may also add to the time it takes to process items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072107Z" creationid="pingfangx" creationdate="20190621T072107Z">
        <seg>`compute(int)` 方法可能需要一些时间，但 `Flowable` 操作链的开销也可能增加处理项目所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not advised intermediate libraries change the error handler outside their own testing environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090838Z" creationid="pingfangx" creationdate="20190618T090838Z">
        <seg>不建议中间库在自己的测试环境之外更改错误处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often the case also that later sequences would require values from earlier mappings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083734Z" creationid="pingfangx" creationdate="20190617T083734Z">
        <seg>通常情况也是后来的序列需要来自早期映射的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended that new custom consumer implementations extend `FlowableSubscriber` instead of just `Subscriber`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085457Z" creationid="pingfangx" creationdate="20190618T085457Z">
        <seg>建议新的自定义消费者实现继承 `FlowableSubscriber` 而不仅仅是 `Subscriber`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes called “functional reactive programming” but this is a misnomer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033739Z" creationid="pingfangx" creationdate="20190620T033739Z">
        <seg>它有时被称为“函数响应式编程”，但这是用词不当。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the implementation of a trade-off between memory and messages to provide information for this checking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033644Z" creationid="pingfangx" creationdate="20190828T033644Z">
        <seg>它是在为此检查提供信息的内存和消息之间进行权衡的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the main type to interact with other reactive libraries through a standardized mechanism governed by the [Reactive Streams specification](https://github.com/reactive-streams/reactive-streams-jvm#specification).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104412Z" creationid="pingfangx" creationdate="20190617T104412Z">
        <seg>它是通过由 [Reactive Streams 规范 ](https://github.com/reactive-streams/reactive-streams-jvm#specification) 管理的标准化机制与其他响应库交互的主要类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then the `observeOn`'s responsibility to call the `request` method in the right time and with the right value to keep the data flowing but not overflowing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081443Z" creationid="pingfangx" creationdate="20190621T081443Z">
        <seg>然后，`observeOn` 有责任在正确的时间调用 `request` 方法并使用正确的值来保持数据流动但不会溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may be useful in conjunction with the source operator `interval()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014834Z" creationid="pingfangx" creationdate="20190624T014834Z">
        <seg>它可能与源操作符 `interval()` 结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes two parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021722Z" creationid="pingfangx" creationdate="20190624T021722Z">
        <seg>它需要两个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was already designed along the Reactive-Streams style for 1.x so no user-level changes there.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060028Z" creationid="pingfangx" creationdate="20190618T060028Z">
        <seg>它已经按照 Reactive-Streams 样式设计了 1.x，因此没有用户级别的更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was frequently misused and didn't implement the `Scheduler` specification correctly anyway; it contained blocking sleep for delayed action and didn't support recursive scheduling at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093611Z" creationid="pingfangx" creationdate="20190618T093611Z">
        <seg>它经常被滥用，并且无论如何都没有正确实现 `Scheduler` 规范；它包含阻塞睡眠以延迟操作，并且根本不支持递归调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will also emit this same final value to any subsequent observers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083957Z" creationid="pingfangx" creationdate="20190620T083957Z">
        <seg>它还将向任何后续观察者发射相同的最终值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not make further calls to &lt;c0&gt;onNext&lt;/c0&gt; or &lt;c1&gt;onCompleted&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060309Z" creationid="pingfangx" creationdate="20190620T060309Z">
        <seg>它不会进一步调用 &lt;c0&gt;onNext&lt;/c0&gt; 或 &lt;c1&gt;onCompleted&lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its architecture now derives from the Reactive-Streams design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055625Z" creationid="pingfangx" creationdate="20190618T055625Z">
        <seg>它的架构现在来自 Reactive-Streams 设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its consumer type (`rx.Single.SingleSubscriber&lt;T&gt;`) has been changed from being a class that accepts `rx.Subscription` resources to be an interface `io.reactivex.SingleObserver&lt;T&gt;` that has only 3 methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055825Z" creationid="pingfangx" creationdate="20190618T055825Z">
        <seg>它的消费者类型(`rx.Single.SingleSubscriber&lt;T&gt;`)变化了，从接受 `rx.Subscription` 资源的类，变为只有 3 个方法的接口 `io.reactivex.SingleObserver&lt;T&gt;`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its functionality can be achieved via `TestScheduler`, `PublishProcessor`/`PublishSubject` and `observeOn(testScheduler)`/scheduler parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063603Z" creationid="pingfangx" creationdate="20190618T063603Z">
        <seg>它的功能可以通过 `TestScheduler`，`PublishProcessor`/`PublishSubject` 和 `observeOn(testScheduler)`/scheduler 参数来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its usefulness is rather limited as there is no other information provided about the overflow than the current call stack.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093512Z" creationid="pingfangx" creationdate="20190621T093512Z">
        <seg>它的实用性相当有限，因为除了当前调用堆栈之外，没有其他关于溢出的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java doesn't consider signatures such as `operator(Function&lt;T, Single&lt;R&gt;&gt;)` and `operator(Function&lt;T, Maybe&lt;R&gt;&gt;)` different (unlike C#) and due to erasure, the two `operator`s would end up as duplicate methods with the same signature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100903Z" creationid="pingfangx" creationdate="20190617T100903Z">
        <seg>由于擦除，Java 不认为 `operator(Function &lt;T，Single &lt;R &gt;&gt;)` 和 `operator(Function &lt;T，Maybe &lt;R &gt;&gt;)` 的签名是不同的(与 C# 不同)，这两个 ` operator` 最终会成为具有相同签名的重复方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Knowing When to Keep Quiet</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024330Z" creationid="pingfangx" creationdate="20190828T024330Z">
        <seg>知道什么时候保持安静</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LAST-ACK - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112839Z" creationid="pingfangx" creationdate="20190827T112839Z">
        <seg>LAST-ACK - 表示等待先前发送到远程 TCP 的连接终止请求的确认(其包括对其连接终止请求的确认)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LISTEN - represents waiting for a connection request from any remote TCP and port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112612Z" creationid="pingfangx" creationdate="20190827T112612Z">
        <seg>LISTEN - 表示等待来自任何远程 TCP 和端口的连接请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language-Specific Information:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090906Z" creationid="pingfangx" creationdate="20190620T090906Z">
        <seg>语言特定信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn more about RxJava in general on the &lt;a href="https://github.com/ReactiveX/RxJava/wiki"&gt;Wiki Home&lt;/a&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065616Z" creationid="pingfangx" creationdate="20190617T065616Z">
        <seg>有关 RxJava 的更多信息可参阅 &lt;a href="https://github.com/ReactiveX/RxJava/wiki"&gt;Wiki Home&lt;/a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like Observables, Singles can be manipulated by means of a variety of operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073856Z" creationid="pingfangx" creationdate="20190620T073856Z">
        <seg>像 Observables 一样，Singles 可以通过各种操作符进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking to the right towards the subscriber/consumer, is called the **downstream**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070953Z" creationid="pingfangx" creationdate="20190617T070908Z">
        <seg>向右侧的订阅者/消费者看，称为 **downstream**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many frequently used operator has overloads that can deal with the other types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100658Z" creationid="pingfangx" creationdate="20190617T100658Z">
        <seg>许多经常使用的运算符具有可以处理其他类型的重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators that expect the user to provide some function returning a reactive type can't be overloaded because the type erasure around a `Function&lt;T, X&gt;` turns such method signatures into duplicates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102139Z" creationid="pingfangx" creationdate="20190617T102139Z">
        <seg>许多期望用户提供返回反应类型的函数的运算符不能被重载，因为围绕 `Function&lt;T, X&gt;` 的类型擦除将这样的方法签名变成重复的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many value generation can be expressed in a form of a state-machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020256Z" creationid="pingfangx" creationdate="20190624T020256Z">
        <seg>许多值生成可以以状态机的形式表达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mathematical and Aggregate Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072016Z" creationid="pingfangx" creationdate="20190620T072016Z">
        <seg>数学和集合操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minor 2.x increments (such as 2.1, 2.2, etc) will occur when non-trivial new functionality is added or significant enhancements or bug fixes occur that may have behavioral changes that may affect some edge cases (such as dependence on behavior resulting from a bug).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104949Z" creationid="pingfangx" creationdate="20190617T104949Z">
        <seg>当添加非平凡的新功能或重大增强或发生可能影响某些边缘情况的行为变化（例如，对错误导致的行为的依赖）的错误修复时，将发生次要 2.x 升级（例如 2.1,2.2 等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, it provides a `Scheduler` that schedules on the main thread or any given `Looper`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T030026Z" creationid="pingfangx" creationdate="20190624T030026Z">
        <seg>更具体地说，它提供了一个 `Scheduler`，它在主线程或任何给定的 `Looper` 上进行调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most asynchronous operator use this as their default `Scheduler`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073243Z" creationid="pingfangx" creationdate="20190617T073243Z">
        <seg>大多数异步操作符使用它作为它们的默认 `Scheduler`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most backpressure-sensitive operators in the recent versions of RxJava now allow programmers to specify the size of their internal buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090433Z" creationid="pingfangx" creationdate="20190621T090433Z">
        <seg>最近版本的 RxJava 中的大多数背压敏感操作符现在允许程序员指定其内部缓冲区的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most developers encounter backpressure when their application fails with `MissingBackpressureException` and the exception usually points to the `observeOn` operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T085845Z" creationid="pingfangx" creationdate="20190621T085845Z">
        <seg>大多数开发人员在应用程序因 `MissingBackpressureException` 而失败时都会遇到背压，而该异常通常指向 `observeOn` 操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators are still there in 2.x and practically all of them have the same behavior as they had in 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T110949Z" creationid="pingfangx" creationdate="20190618T110949Z">
        <seg>大多数操作符仍然在 2.x 中，并且几乎所有操作符都具有与 1.x 中相同的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators operate on an Observable and return an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072320Z" creationid="pingfangx" creationdate="20190620T072320Z">
        <seg>大多数操作符都在 Observable 上操作并返回一个 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Must be zero.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105328Z" creationid="pingfangx" creationdate="20190827T105328Z">
        <seg>必须为零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NOTE BENE:  this diagram is only a summary and must not be taken as the total specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T113245Z" creationid="pingfangx" creationdate="20190827T113245Z">
        <seg>注：此图只是一个概要，不能作为总规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming in programming is one of the hardest things as names are expected to be not long, expressive, capturing and easily memorable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101332Z" creationid="pingfangx" creationdate="20190617T101332Z">
        <seg>编程中的命名是最困难的事情之一，因为名称不宜太长，表达清楚，容易捕捉且容易记忆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, `fromCallable` also properly supports backpressure and won't emit the computed value unless requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020008Z" creationid="pingfangx" creationdate="20190624T020008Z">
        <seg>当然，`fromCallable` 也能正确支持背压，除非有要求，否则不会发射计算值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New functionality marked with an [`@Beta`][beta source link] or [`@Experimental`][experimental source link] annotation can also be added in patch releases to allow rapid exploration and iteration of unstable new functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105214Z" creationid="pingfangx" creationdate="20190617T105214Z">
        <seg>标记有 [`@Beta`][beta source link] 或 [`@Experimental`][experimental source link] 注释的新功能也可以添加到补丁版本中，以便快速探索和迭代不稳定的新功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New instances of a connection will be referred to as incarnations of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023152Z" creationid="pingfangx" creationdate="20190828T023152Z">
        <seg>连接的新实例将被称为连接的化身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061022Z" creationid="pingfangx" creationdate="20190619T061022Z">
        <seg>新返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next is a “decision tree” that may help you choose the operator that is most appropriate to your use case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094107Z" creationid="pingfangx" creationdate="20190620T094107Z">
        <seg>接下来是一个“决策树”，可以帮助您选择最适合您的用例的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further SENDs from the user will be accepted by the TCP, and it enters the FIN-WAIT-1 state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063418Z" creationid="pingfangx" creationdate="20190828T063418Z">
        <seg>TCP 不接受用户的进一步 SEND，并进入 FIN-WAIT-1 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further development, support, maintenance, PRs and updates will happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065638Z" creationid="pingfangx" creationdate="20190617T065638Z">
        <seg>不会进一步开发，支持，维护，PR 和更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No longer wraps all consumer types (i.e., `Observer`) with a safety wrapper, (just like the 1.x `unsafeSubscribe` no longer available).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053805Z" creationid="pingfangx" creationdate="20190619T053805Z">
        <seg>不再用安全包装器包装所有消费者类型(即 `Observer`)(就像 1.x 中的 `unsafeSubscribe` 不再可用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal Close Sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063956Z" creationid="pingfangx" creationdate="20190828T063956Z">
        <seg>正常关闭序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a “PublishSubject” here is known simply as a “Subject”):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083851Z" creationid="pingfangx" creationdate="20190620T083851Z">
        <seg>并非所有这些种类都在所有实现中可用，并且一些实现使用其他命名约定(例如，在 RxScala 中，在这里简称为“Subject”的被称为的“PublishSubject”)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that due to Reactive-Streams compatibility, the method `onCompleted` has been renamed to `onComplete` without the trailing `d`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070522Z" creationid="pingfangx" creationdate="20190618T070522Z">
        <seg>另请注意，由于 Reactive-Streams 兼容性，方法 `onCompleted` 已重命名为 `onComplete` 而没有尾随的 `d`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also the `Files.readLines(name)` invoked without try-catch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064342Z" creationid="pingfangx" creationdate="20190618T064342Z">
        <seg>另请注意，在没有 try-catch 的情况下调用 `Files.readLines(name)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note hovewer that these operators only reduce the rate of value reception by the downstream and thus they may still lead to `MissingBackpressureException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091703Z" creationid="pingfangx" creationdate="20190621T091703Z">
        <seg>但请注意，这些操作符仅降低了下游的值接收速率，因此它们仍可能导致 `MissingBackpressureException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that `onBackpressureBuffer` consumes its source in an unbounded manner, that is, without applying any backpressure to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092853Z" creationid="pingfangx" creationdate="20190621T092853Z">
        <seg>但请注意，`onBackpressureBuffer` 以无限制的方式消耗其来源，即不对其施加任何背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that generally, this may be only a temporary fix as the overflow can still happen if the source overproduces the predicted buffer size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091109Z" creationid="pingfangx" creationdate="20190621T091109Z">
        <seg>但请注意，通常情况下，这可能只是一个临时修复，因为如果源过量生产超出预测的缓冲区大小，仍可能发生溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that the computation does happen anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020014Z" creationid="pingfangx" creationdate="20190624T020014Z">
        <seg>但请注意，无论如何计算确实会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a &lt;c0&gt;PublishSubject&lt;/c0&gt; may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084738Z" creationid="pingfangx" creationdate="20190620T084738Z">
        <seg>请注意，&lt;c0&gt;PublishSubject&lt;/c0&gt; 可能会在创建后立即开始发射项目(除非您已采取措施防止此情况)，因此在创建 Subject 和观察者订阅它之间的时间段内，可能会丢失一个或多个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a TCP receiving a FIN will ACK but not send its own FIN until its user has CLOSED the connection also.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063636Z" creationid="pingfangx" creationdate="20190828T063636Z">
        <seg>请注意，接收 FIN 的 TCP 将确认但不发送自己的 FIN，直到其用户也已 CLOSED 连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that due to how request management works, calling `request(n)` from `Subscriber.onSubscribe` or `ResourceSubscriber.onStart` may trigger calls to `onNext` immediately before the `request()` call itself returns to the `onSubscribe`/`onStart` method of yours:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072258Z" creationid="pingfangx" creationdate="20190618T071233Z">
        <seg>请注意，由于请求管理的工作方式，从 `Subscriber.onSubscribe` 或 `ResourceSubscriber.onStart` 调用 `request(n)` 可能会立即触发对 `onNext` 的调用，该调用在 `request()` 调用本身返回 `onSubscribe`/`onStart` 方法之前：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if a TCP is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024451Z" creationid="pingfangx" creationdate="20190828T024451Z">
        <seg>请注意，如果 TCP 在某种意义上重新初始化，但仍然保留其使用的序列号的内存，那么它根本不需要等待；它必须只能确保使用大于最近使用的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it currently doesn't support additional parameters to those backpressure modes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022104Z" creationid="pingfangx" creationdate="20190624T022104Z">
        <seg>请注意，它目前不支持那些背压模式的附加参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that one tick mark represents one bit position.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104850Z" creationid="pingfangx" creationdate="20190827T104850Z">
        <seg>请注意，一个刻度标记表示一位位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the last two strategies cause discontinuity in the stream as they drop out elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014649Z" creationid="pingfangx" creationdate="20190624T014649Z">
        <seg>请注意，最后两个策略会导致流不连续，因为它们会删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the list of options may be shorter than the data offset field might imply.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110921Z" creationid="pingfangx" creationdate="20190827T110921Z">
        <seg>请注意，选项列表可能比数据偏移字段可能暗示的要短。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the sequence number of the segment in line 5 is the same as in line 4 because the ACK does not occupy sequence number space (if it did, we would wind up ACKing ACK's!).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041825Z" creationid="pingfangx" creationdate="20190828T041825Z">
        <seg>请注意，第 5 行中的报文段的序列号与第 4 行中的相同，因为 ACK 不占用序列号空间(如果确实如此，我们将结束 ACK 确认！)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when the receive window is zero no segments should be acceptable except ACK segments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022420Z" creationid="pingfangx" creationdate="20190828T022420Z">
        <seg>请注意，当接收窗口为零时，除了 ACK 报文段之外，不应接受任何报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of the `LATEST` backpressure mode; if we know there will be only a single value, we don't need the `BUFFER` strategy as it allocates a default 128 element long buffer (that grows as necessary) that is never going to be fully utilized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T023107Z" creationid="pingfangx" creationdate="20190624T023107Z">
        <seg>注意使用 `LATEST` 背压模式；如果我们知道只有一个值，我们不需要 `BUFFER` 策略，因为它分配一个永远不会被充分利用的默认 128 元素长缓冲区(必要时增长)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that `flatMap` doesn't guarantee any order and the end result from the inner flows may end up interleaved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083110Z" creationid="pingfangx" creationdate="20190617T083110Z">
        <seg>但请注意，`flatMap` 不保证任何顺序，内部流的最终结果可能会交错出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now suppose, at this instant, the host crashes, recovers, and establishes a new incarnation of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025655Z" creationid="pingfangx" creationdate="20190828T025655Z">
        <seg>现在假设，在这一瞬间，主机崩溃，恢复并建立连接的新化身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can directly block for some results by invoking a `blockingX` operation directly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095232Z" creationid="pingfangx" creationdate="20190618T095232Z">
        <seg>现在，您可以通过直接调用 `blockingX` 操作直接阻塞某些结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbering of octets within a segment is that the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021236Z" creationid="pingfangx" creationdate="20190828T021122Z">
        <seg>报文段内八位字节的编号是紧跟在首部之后的第一个数据八位字节，其编号最小的，并且后面的八位字节是连续编号的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects of the &lt;c0&gt;Worker&lt;/c0&gt; class implement &lt;a1&gt;the &lt;c2&gt;Subscription&lt;/c2&gt; interface&lt;/a1&gt;, with its &lt;a3&gt;&lt;c4&gt;isUnsubscribed&lt;/c4&gt;&lt;/a3&gt; and &lt;a5&gt;&lt;c6&gt;unsubscribe&lt;/c6&gt;&lt;/a5&gt; methods, so you can stop work when a subscription is cancelled, or you can cancel the subscription from within the scheduled task:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092237Z" creationid="pingfangx" creationdate="20190620T092237Z">
        <seg>&lt;c0&gt;Worker&lt;/c0&gt; 类的对象实现 &lt;a1&gt;&lt;c2&gt;Subscription&lt;/c2&gt; 接口&lt;/a1&gt;，使用他的 &lt;a3&gt;&lt;c4&gt;isUnsubscribed&lt;/c4&gt;&lt;/a3&gt; 和 &lt;a5&gt;&lt;c6&gt;unsubscribe&lt;/c6&gt;&lt;/a5&gt; 方法，因此你可以在取消订阅时停止工作，也可以从计划任务中取消订阅：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observable Utility Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101858Z" creationid="pingfangx" creationdate="20190620T101858Z">
        <seg>Observable 辅助操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Composable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034539Z" creationid="pingfangx" creationdate="20190620T034517Z">
        <seg>Observables 是可组合的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Flexible</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034528Z" creationid="pingfangx" creationdate="20190620T034528Z">
        <seg>Observables 是灵活的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Less Opinionated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034607Z" creationid="pingfangx" creationdate="20190620T034607Z">
        <seg>Observables 是无偏见的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables and observers are only the start of ReactiveX.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071352Z" creationid="pingfangx" creationdate="20190620T070226Z">
        <seg>对于 ReactiveX 来说，Observable 和观察者仅仅是个开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables can be implemented using thread-pools, event loops, non-blocking I/O, actors (such as from Akka), or whatever implementation suits your needs, your style, or your expertise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040404Z" creationid="pingfangx" creationdate="20190620T040312Z">
        <seg>可以用任何方式来实现 Observable，使用线程池，事件循环，非阻塞 I/O，actor(例如来自 Akka)或任何适合您的需求，风格或专业知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables fill the gap by being the ideal way to access asynchronous sequences of multiple items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033647Z" creationid="pingfangx" creationdate="20190620T033647Z">
        <seg>Observable 通过理想方式访问多个项的异步序列来填补空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, even where a user selects to "wait," this is not necessary after the host has been "up" for at least MSL seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025902Z" creationid="pingfangx" creationdate="20190828T025902Z">
        <seg>显然，即使用户选择“等待”，在主机已经“启动”至少 MSL 秒之后也不需要这样做。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, suffixes of various kinds may appear together:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103554Z" creationid="pingfangx" creationdate="20190617T103554Z">
        <seg>当然，各种后缀可能会一起出现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, the arrival of an old duplicate "SYN" segment can potentially make it appear, to the recipient, that a simultaneous connection initiation is in progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031550Z" creationid="pingfangx" creationdate="20190828T031550Z">
        <seg>当然，旧的重复“SYN”报文段的到来可能使得向接收者显示同时连接启动正在进行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, we can imitate other typical sources, such as an unbounded range with it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021515Z" creationid="pingfangx" creationdate="20190624T021515Z">
        <seg>当然，我们可以模仿其他典型的来源，例如无限范围：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often though there is a way that is somewhat more expressive (and also lower overhead) by using `Completable` as the mediator and its operator `andThen` to resume with something else:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091925Z" creationid="pingfangx" creationdate="20190617T091925Z">
        <seg>通常有一种方式更具表现力(也更低开销)，使用 `Completable` 作为调解器及其运算符 `andThen` 继续使用其他内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old Duplicate SYN Initiates a Reset on two Passive Sockets</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060417Z" creationid="pingfangx" creationdate="20190828T060417Z">
        <seg>旧的重复 SYN 在两个无源套接字上启动重置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061019Z" creationid="pingfangx" creationdate="20190619T061019Z">
        <seg>旧返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On desktop Java, this latter handler does nothing on an `ExecutorService` backed `Scheduler` and the application can keep running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090323Z" creationid="pingfangx" creationdate="20190618T090323Z">
        <seg>在桌面 Java 上，后一个处理程序对 `ExecutorService` 支持的 `Scheduler` 什么都不做，应用程序可以继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a connection is established this is always sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105237Z" creationid="pingfangx" creationdate="20190827T105237Z">
        <seg>建立连接后，始终会发送此字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the `compute(int)` finishes, the another value is then requested from `range`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082132Z" creationid="pingfangx" creationdate="20190621T082132Z">
        <seg>一旦 `compute(int)` 完成，就会从 `range` 请求另一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data is ready, you can make sure they get processed on the foreground or GUI thread via `observeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072853Z" creationid="pingfangx" creationdate="20190617T072853Z">
        <seg>数据准备好后，您可以确保通过 `observeOn` 在前台或 GUI 线程上处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can think of it as a 0 capacity `onBackpressureBuffer` with strategy `ON_OVERFLOW_DROP_LATEST`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014750Z" creationid="pingfangx" creationdate="20190624T014750Z">
        <seg>可以将其视为具有策略 `ON_OVERFLOW_DROP_LATEST` 的 0 容量 `onBackpressureBuffer`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can think of this as a variant of the `onBackpressureBuffer` with a capacity of 1 and strategy of `ON_OVERFLOW_DROP_OLDEST`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015135Z" creationid="pingfangx" creationdate="20190624T015135Z">
        <seg>可以将其视为 `onBackpressureBuffer` 的变体，其容量为 1，策略为 `ON_OVERFLOW_DROP_OLDEST`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One could, of course, turn that into an `Iterable` but when such sources are associated with resources, we may leak those resources if the downstream unsubscribes the sequence before it would end.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021000Z" creationid="pingfangx" creationdate="20190624T021000Z">
        <seg>当然，可以将其转换为 `Iterable`，但是当这些源与资源相关联时，如果下游在序列结束之前取消订阅序列，我们可能会泄漏这些资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important design requirement for 2.x is that no `Throwable` errors should be swallowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085938Z" creationid="pingfangx" creationdate="20190618T085938Z">
        <seg>2.x 的一个重要设计要求是不应忽略任何 `Throwable` 的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One main point of difference is that functional reactive programming operates on values that change &lt;e0&gt;continuously&lt;/e0&gt; over time, while ReactiveX operates on &lt;e1&gt;discrete&lt;/e1&gt; values that are emitted over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034024Z" creationid="pingfangx" creationdate="20190620T034024Z">
        <seg>一个主要的不同点是函数性响应式编程对随时间变化的 &lt;e0&gt;continuously (连续)&lt;/e0&gt; 值进行操作，而 ReactiveX 对随时间发射的 &lt;e1&gt;discrete (离散)&lt;/e1&gt; 值进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One notable difference is that all our functional interfaces now define `throws Exception`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064131Z" creationid="pingfangx" creationdate="20190618T064131Z">
        <seg>一个值得注意的区别是我们所有的函数接口现在都定义了 `throws Exception`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the benefits is that changing `Flowable` to `Observable` here the test code part doesn't have to change at all due to the implicit type change of the `TestSubscriber` to `TestObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101614Z" creationid="pingfangx" creationdate="20190618T101614Z">
        <seg>其中一个好处是将 `Flowable` 改为 `Observable`，测试代码部分根本不需要改变，因为 `TestSubscriber` 隐式改为 `TestObserver`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the common use cases for RxJava is to run some computation, network request on a background thread and show the results (or error) on the UI thread:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072246Z" creationid="pingfangx" creationdate="20190617T072246Z">
        <seg>RxJava 的一个常见用例是在后台线程上运行一些计算，网络请求并在 UI 线程上显示结果(或错误)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the design flaws of RxJava 1.x was the exposure of the `rx.Observable.create()` method that while powerful, not the typical operator you want to use to enter the reactive world.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094300Z" creationid="pingfangx" creationdate="20190618T094300Z">
        <seg>RxJava 1.x 的一个设计缺陷是 `rx.Observable.create()` 方法的曝光，虽然功能强大，但不是您想要用来进入响应世界的典型操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One version allows you to set this time out by means of a number of specified time units:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075647Z" creationid="pingfangx" creationdate="20190620T075647Z">
        <seg>一个版本允许您通过许多指定的时间单位设置此时间：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One version of merge takes a Single that emits a second Single and converts it into a Single that emits the item emitted by that second Single:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075522Z" creationid="pingfangx" creationdate="20190620T075522Z">
        <seg>一个合并的版本，需要一个 Single 发射第二个 Single 并将其转换为 Single，它发射第二个 Single 发射的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the "quite time" specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025829Z" creationid="pingfangx" creationdate="20190828T025829Z">
        <seg>解决这个问题的一种方法是在从崩溃恢复后故意延迟一个 MSL 的发射报文段 - 这是“quite time”的规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One would be inclined to write such continuations as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092156Z" creationid="pingfangx" creationdate="20190617T092156Z">
        <seg>人们倾向于写下如下的延续：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators By Category</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094354Z" creationid="pingfangx" creationdate="20190620T094354Z">
        <seg>操作符分类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators marked as `@Beta` or `@Experimental` in 1.x are promoted to standard.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111329Z" creationid="pingfangx" creationdate="20190618T111329Z">
        <seg>在 1.x 中标记为 `@Beta` 或 `@Experimental` 的操作符将升级为标准操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators of the new `Flowable` base reactive type now consider downstream request amounts properly, however, this doesn't mean `MissingBackpressureException` is gone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073550Z" creationid="pingfangx" creationdate="20190618T073550Z">
        <seg>新的 `Flowable` 基本响应类型的运算符现在正确考虑下游请求数量，但是，这并不意味着 `MissingBackpressureException` 消失了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that evaluate one or more Observables or items emitted by Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102521Z" creationid="pingfangx" creationdate="20190620T102521Z">
        <seg>计算一个或多个 Observables 或 Observable 发射的项目的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that help to recover from error notifications from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101819Z" creationid="pingfangx" creationdate="20190620T101819Z">
        <seg>有助于从 Observable 发出的错误通知中恢复的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that operate on the entire sequence of items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102846Z" creationid="pingfangx" creationdate="20190620T102846Z">
        <seg>操作 Observable 发射的整个项目序列的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that originate new Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094459Z" creationid="pingfangx" creationdate="20190620T094459Z">
        <seg>创建新 Observables 的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that selectively emit items from a source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100037Z" creationid="pingfangx" creationdate="20190620T100037Z">
        <seg>有选择地从源 Observable 中发射项的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that transform items that are emitted by an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095438Z" creationid="pingfangx" creationdate="20190620T095438Z">
        <seg>转换 Observable 发射的数据项的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that work with multiple source Observables to create a single Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101232Z" creationid="pingfangx" creationdate="20190620T101232Z">
        <seg>使用多个源 Observable 创建单个 Observable 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators to Convert Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103717Z" creationid="pingfangx" creationdate="20190620T103717Z">
        <seg>转换 Observables 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110808Z" creationid="pingfangx" creationdate="20190827T110808Z">
        <seg>选项可能占用 TCP 首部末尾的空间，并且长度为 8 位的倍数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or, something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053036Z" creationid="pingfangx" creationdate="20190620T053036Z">
        <seg>或者，像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other fields such as window, addresses, lengths, and text have been left out in the interest of clarity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034713Z" creationid="pingfangx" creationdate="20190828T034713Z">
        <seg>为了清楚起见，省略了诸如窗口，地址，长度和文本之类的其他字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other pages show how you use &lt;a0&gt;the variety of Observable operators&lt;/a0&gt; to link Observables together and change their behaviors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044205Z" creationid="pingfangx" creationdate="20190620T044205Z">
        <seg>其他页面显示了如何使用 &lt;a0&gt;各种 Observable 运算符&lt;/a0&gt; 将 Observable 链接在一起并更改其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others do not operate on any particular Scheduler, or operate on a particular default Scheduler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091415Z" creationid="pingfangx" creationdate="20190620T091415Z">
        <seg>其他人不在任何特定的调度器上运行，或在特定的默认调度器上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PSH:  Push Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105413Z" creationid="pingfangx" creationdate="20190827T105413Z">
        <seg>PSH：推送功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patch 2.x.y increments (such as 2.0.0 -&gt; 2.0.1, 2.3.1 -&gt; 2.3.2, etc) will occur for bug fixes and trivial functionality (like adding a method overload).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105139Z" creationid="pingfangx" creationdate="20190617T105139Z">
        <seg>补丁 2.x.y 增量(如 2.0.0-&gt;2.0.1、2.3.1-&gt;2.3.2 等)将出现在 bug 修复和琐碎功能(如添加方法重载)上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, parallelism in RxJava means running independent flows and merging their results back into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075816Z" creationid="pingfangx" creationdate="20190617T075816Z">
        <seg>实际上，RxJava 中的并行性意味着运行独立流并将其结果合并回单个流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, the 1.x `fromEmitter` (formerly `fromAsync`) has been renamed to `Flowable.create`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094844Z" creationid="pingfangx" creationdate="20190618T094844Z">
        <seg>实际上，1.x 的 `fromEmitter`(以前称为 fromAsync`)已被重命名为 `Flowable.create`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, this is when the body of the given example above executes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072207Z" creationid="pingfangx" creationdate="20190617T072207Z">
        <seg>实际上，这是在上面给出的示例的主体执行时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing the numbers 1 to 10 in parallel is a bit more involved:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075758Z" creationid="pingfangx" creationdate="20190617T075758Z">
        <seg>并行处理数字 1 到 10 涉及更多：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proper use of "reset" segments can disambiguate these cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031556Z" creationid="pingfangx" creationdate="20190828T031556Z">
        <seg>正确使用“重置”报文段可以消除这些情况的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RC3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061550Z" creationid="pingfangx" creationdate="20190619T061550Z">
        <seg>RC3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.NXT - receive next</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111754Z" creationid="pingfangx" creationdate="20190827T111754Z">
        <seg>RCV.NXT - 接收下一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022217Z" creationid="pingfangx" creationdate="20190828T022217Z">
        <seg>RCV.NXT =传入报文段上预期的下一个序列号，是接收窗口的左下边缘</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022231Z" creationid="pingfangx" creationdate="20190828T022231Z">
        <seg>RCV.NXT+RCV.WND-1 =传入报文段上预期的最后序列号，是接收窗口的右边缘或上边缘</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.UP  - receive urgent pointer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111805Z" creationid="pingfangx" creationdate="20190827T111805Z">
        <seg>RCV.UP  - 接收紧急指针</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.WND - receive window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111800Z" creationid="pingfangx" creationdate="20190827T111800Z">
        <seg>RCV.WND - 接收窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RECEIVEs are allowed in this state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063508Z" creationid="pingfangx" creationdate="20190828T063508Z">
        <seg>在这种状态下允许 RECEIVE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RST:  Reset the connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105420Z" creationid="pingfangx" creationdate="20190827T105420Z">
        <seg>RST：重置连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reactive Programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041620Z" creationid="pingfangx" creationdate="20190620T041620Z">
        <seg>响应式编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Is a Polyglot Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034622Z" creationid="pingfangx" creationdate="20190620T034622Z">
        <seg>ReactiveX 是一种多语言实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Observables support not just the emission of single scalar values (as Futures do), but also of sequences of values or even infinite streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035551Z" creationid="pingfangx" creationdate="20190620T035545Z">
        <seg>ReactiveX Observables 不仅支持单个标量值的发射(如 Futures 那样)，还支持值序列甚至无限流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Observables, on the other hand, are &lt;e0&gt;intended&lt;/e0&gt; for &lt;a1&gt;composing flows and sequences of asynchronous data&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035425Z" creationid="pingfangx" creationdate="20190620T035425Z">
        <seg>另一方面，ReactiveX Observables &lt;e0&gt;旨在&lt;/e0&gt; 用于 &lt;a1&gt;组合异步数据流和序列&lt;/a1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T025919Z" creationid="pingfangx" creationdate="20190620T025919Z">
        <seg>ReactiveX 是一个库，通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is currently implemented in a variety of languages, in ways that respect those languages’ idioms, and more languages are being added at a rapid clip.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041309Z" creationid="pingfangx" creationdate="20190620T041309Z">
        <seg>ReactiveX 在大量的编程语言中都有实现，并尊重实现语言的风格，而且更多的实现正在飞速增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is not biased toward some particular source of concurrency or asynchronicity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040233Z" creationid="pingfangx" creationdate="20190620T040233Z">
        <seg>ReactiveX 不偏向某些特定的并发或异步性源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX may be functional, and it may be reactive, but “functional reactive programming” is a different animal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033853Z" creationid="pingfangx" creationdate="20190620T033853Z">
        <seg>ReactiveX 可能是函数式的，它可能是响应式的，但“函数响应式编程”是一种不同的动物。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX provides &lt;a0&gt;a collection of operators&lt;/a0&gt; with which you can filter, select, transform, combine, and compose Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041826Z" creationid="pingfangx" creationdate="20190620T041826Z">
        <seg>ReactiveX 提供了 &lt;a0&gt;一系列操作符&lt;/a0&gt;，你可以使用它们来过滤(filter)，选择(select)，转换(transform)，结合(combine)和组合(compose) Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receive Sequence Space</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111923Z" creationid="pingfangx" creationdate="20190827T111923Z">
        <seg>接收序列空间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receive Sequence Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111748Z" creationid="pingfangx" creationdate="20190827T111748Z">
        <seg>接收序列变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovery from Old Duplicate SYN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042815Z" creationid="pingfangx" creationdate="20190828T042815Z">
        <seg>从旧的重复 SYN 恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursive Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092103Z" creationid="pingfangx" creationdate="20190620T092103Z">
        <seg>递归调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061028Z" creationid="pingfangx" creationdate="20190619T061028Z">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data in the segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025239Z" creationid="pingfangx" creationdate="20190828T025239Z">
        <seg>请记住，每个报文段都绑定了与报文段中数据的八位字节一样多的连续序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed as the Reactive Streams specification mandates the `onXXX` methods don't crash and therefore the default is to not have a safety net in `subscribe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054131Z" creationid="pingfangx" creationdate="20190619T054131Z">
        <seg>在 Reactive Streams 规范要求删除 `onXXX` 方法不会崩溃，因此默认是在 `subscribe` 中没有安全网。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed in version</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061536Z" creationid="pingfangx" creationdate="20190619T061536Z">
        <seg>在版本移除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reserved for future use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105325Z" creationid="pingfangx" creationdate="20190827T105325Z">
        <seg>保留供将来使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset Generation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060500Z" creationid="pingfangx" creationdate="20190828T060500Z">
        <seg>重置生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061707Z" creationid="pingfangx" creationdate="20190828T061707Z">
        <seg>重置处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Right arrows (--&gt;) indicate departure of a TCP segment from TCP A to TCP B, or arrival of a segment at B from A.  Left arrows (&lt;--), indicate the reverse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034516Z" creationid="pingfangx" creationdate="20190828T034516Z">
        <seg>右箭头(--&gt;)表示 TCP 报文段从 TCP A 到 TCP B 的离开，或者从 A 到达 B 的报文段的到达。左箭头(&lt;--)表示相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava (and its derivatives like RxGroovy &amp; RxScala) has developed an &lt;a0&gt;Observable&lt;/a0&gt; variant called “Single.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073327Z" creationid="pingfangx" creationdate="20190620T073327Z">
        <seg>RxJava(及其衍生品，如 RxGroovy 和 RxScala)开发了一种名为“Single”的 &lt;a0&gt;Observable&lt;/a0&gt; 变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2 features several base classes you can discover operators on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065936Z" creationid="pingfangx" creationdate="20190617T065936Z">
        <seg>RxJava 2 具有几个可以发现运算符的基类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2 features several standard schedulers accessible via `Schedulers` utility class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073108Z" creationid="pingfangx" creationdate="20190617T073108Z">
        <seg>RxJava 2 具有几个可通过 `Schedulers` 实用程序类访问的标准调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2's design was heavily influenced by the [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams) specification, therefore, the library features a class and an interface per each reactive type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103741Z" creationid="pingfangx" creationdate="20190617T103741Z">
        <seg>RxJava 2 的设计深受 [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams) 规范的影响，因此，该库为每种反应类型提供了一个类和一个接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.0 has been completely rewritten from scratch on top of the Reactive-Streams specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T015500Z" creationid="pingfangx" creationdate="20190618T015500Z">
        <seg>RxJava 2.0 已经根据 Reactive-Streams 规范从头开始完全重写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.0.0-RC2 introduced a new base reactive type called `Maybe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060309Z" creationid="pingfangx" creationdate="20190618T060309Z">
        <seg>RxJava 2.0.0-RC2 引入了一个名为 `Maybe` 的新的基本响应类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.x no longer accepts `null` values and the following will yield `NullPointerException` immediately or as a signal to downstream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052728Z" creationid="pingfangx" creationdate="20190618T052728Z">
        <seg>RxJava 2.x 不再接受 `null` 值，以下将立即产生 `NullPointerException` 或作为下游的信号：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava chose to name such operators by appending the type as suffix as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102150Z" creationid="pingfangx" creationdate="20190617T102150Z">
        <seg>RxJava 选择通过将类型附加为后缀来命名此类运算符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is a Java VM implementation of [Reactive Extensions](http://reactivex.io): a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064503Z" creationid="pingfangx" creationdate="20190617T064503Z">
        <seg>RxJava 是 [Reactive Extensions](http://reactivex.io) 的 Java VM 实现：其用于通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is a Java VM implementation of [ReactiveX (Reactive Extensions)](https://reactivex.io): a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113439Z" creationid="pingfangx" creationdate="20190617T113439Z">
        <seg>RxJava 是 [ReactiveX(Reactive Extensions)](https://reactivex.io) 的 Java VM 实现：其通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is meant for a more polyglot environment than just Java/Scala, and it is being designed to respect the idioms of each JVM-based language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113631Z" creationid="pingfangx" creationdate="20190617T113631Z">
        <seg>RxJava 用于比 Java/Scala 更多的多语言环境，它被设计为尊重每种基于 JVM 的语言的习语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava operators don't work with `Thread`s or `ExecutorService`s directly but with so called `Scheduler`s that abstract away sources of concurrency behind a uniform API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073048Z" creationid="pingfangx" creationdate="20190617T073048Z">
        <seg>RxJava 运算符不能直接使用 `Thread` 或 `ExecutorService`，而是使用所谓的 `Scheduler` 来抽象统一 API 背后的并发源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava supports Java 6 or higher and JVM-based languages such as [Groovy](https://github.com/ReactiveX/RxGroovy), [Clojure](https://github.com/ReactiveX/RxClojure), [JRuby](https://github.com/ReactiveX/RxJRuby), [Kotlin](https://github.com/ReactiveX/RxKotlin) and [Scala](https://github.com/ReactiveX/RxScala).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113556Z" creationid="pingfangx" creationdate="20190617T113556Z">
        <seg>RxJava 支持 Java 6 或更高版本以及基于 JVM 的语言，如 [Groovy](https://github.com/ReactiveX/RxGroovy)，[Clojure](https://github.com/ReactiveX/RxClojure)，[JRuby] (https://github.com/ReactiveX/RxJRuby)，[Kotlin](https://github.com/ReactiveX/RxKotlin) 和 [Scala](https://github.com/ReactiveX/RxScala)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava tries to be very lightweight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113503Z" creationid="pingfangx" creationdate="20190617T113503Z">
        <seg>RxJava 试图非常轻量级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S1 = ISN(t) -- last used sequence number on old incarnation of connection!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025715Z" creationid="pingfangx" creationdate="20190828T025715Z">
        <seg>S1 = ISN(t) - 旧的连接化身上最后使用的序列号！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.ACK - segment acknowledgment number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112007Z" creationid="pingfangx" creationdate="20190827T112007Z">
        <seg>SEG.ACK - 报文段确认号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.ACK = acknowledgment from the receiving TCP (next sequence number expected by the receiving TCP)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022012Z" creationid="pingfangx" creationdate="20190828T022012Z">
        <seg>SEG.ACK =来自接收 TCP 的确认号(接收 TCP 预期的下一个序列号)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.LEN - segment length</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112012Z" creationid="pingfangx" creationdate="20190827T112012Z">
        <seg>SEG.LEN - 报文段长度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022025Z" creationid="pingfangx" creationdate="20190828T022025Z">
        <seg>SEG.LEN =报文段中数据占用的八位字节数(计算 SYN 和 FIN)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.PRC - segment precedence value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112028Z" creationid="pingfangx" creationdate="20190827T112028Z">
        <seg>SEG.PRC - 报文段优先值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ - segment sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112002Z" creationid="pingfangx" creationdate="20190827T112002Z">
        <seg>SEG.SEQ - 报文段序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ = first sequence number occupied by the incoming segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022235Z" creationid="pingfangx" creationdate="20190828T022235Z">
        <seg>SEG.SEQ =传入报文段占用的第一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ = first sequence number of a segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022017Z" creationid="pingfangx" creationdate="20190828T022017Z">
        <seg>SEG.SEQ =报文段的第一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022245Z" creationid="pingfangx" creationdate="20190828T022245Z">
        <seg>SEG.SEQ+SEG.LEN-1 =传入报文段占用的最后一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ+SEG.LEN-1 = last sequence number of a segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022047Z" creationid="pingfangx" creationdate="20190828T022047Z">
        <seg>SEG.SEQ+SEG.LEN-1 = 报文段的最后序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.UP  - segment urgent pointer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112023Z" creationid="pingfangx" creationdate="20190827T112023Z">
        <seg>SEG.UP  - 报文段紧急指针</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.WND - segment window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112019Z" creationid="pingfangx" creationdate="20190827T112019Z">
        <seg>SEG.AND - 报文段窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.NXT - send next</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111654Z" creationid="pingfangx" creationdate="20190827T111654Z">
        <seg>SND.NXT - 发送下一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.NXT = next sequence number to be sent</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021952Z" creationid="pingfangx" creationdate="20190828T021952Z">
        <seg>SND.NXT =要发送的下一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.UNA - send unacknowledged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111647Z" creationid="pingfangx" creationdate="20190827T111647Z">
        <seg>SND.UNA  - 发送未确认的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.UNA = oldest unacknowledged sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021949Z" creationid="pingfangx" creationdate="20190828T021949Z">
        <seg>SND.UNA =最早的未确认序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.UP  - send urgent pointer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111710Z" creationid="pingfangx" creationdate="20190827T111710Z">
        <seg>SND.UP  - 发送紧急指针</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.WL1 - segment sequence number used for last window update</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111726Z" creationid="pingfangx" creationdate="20190827T111726Z">
        <seg>SND.WL1 - 用于最后一次窗口更新的报文段序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.WL2 - segment acknowledgment number used for last window update</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111734Z" creationid="pingfangx" creationdate="20190827T111734Z">
        <seg>SND.WL2 - 用于最后一次窗口更新的报文段确认号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.WND - send window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111659Z" creationid="pingfangx" creationdate="20190827T111659Z">
        <seg>SND.WND - 发送窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112646Z" creationid="pingfangx" creationdate="20190827T112646Z">
        <seg>SYN-RECEIVED - 表示在收到并发送连接请求后等待确认连接请求确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYN-SENT - represents waiting for a matching connection request after having sent a connection request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112624Z" creationid="pingfangx" creationdate="20190827T112624Z">
        <seg>SYN-SENT - 表示在发送连接请求后等待匹配的连接请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYN:  Synchronize sequence numbers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105424Z" creationid="pingfangx" creationdate="20190827T105424Z">
        <seg>SYN：同步序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044335Z" creationid="pingfangx" creationdate="20190620T044335Z">
        <seg>相关参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the differences between version 1.x and 2.x in the wiki article [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065542Z" creationid="pingfangx" creationdate="20190617T065542Z">
        <seg>请参阅 wiki 文章中的版本 1.x 和 2.x 之间的差异 [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Segment contents are shown in abbreviated form, with sequence number, control flags, and ACK field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034700Z" creationid="pingfangx" creationdate="20190828T034700Z">
        <seg>报文段内容以缩写形式显示，具有序列号，控制标志和 ACK 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Send Sequence Space</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111904Z" creationid="pingfangx" creationdate="20190827T111904Z">
        <seg>发送序列空间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Send Sequence Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111553Z" creationid="pingfangx" creationdate="20190827T111553Z">
        <seg>发送序列变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>September 1981</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041848Z" creationid="pingfangx" creationdate="20190828T041848Z">
        <seg>September 1981</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequence Numbers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T020911Z" creationid="pingfangx" creationdate="20190828T020911Z">
        <seg>序号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several examples of connection initiation follow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031601Z" creationid="pingfangx" creationdate="20190828T031601Z">
        <seg>下面是几个连接启动的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to how error-handling became a first-class citizen and received operators to deal with it (via `onErrorXXX` operators), backpressure is another property of dataflows that the programmer has to think about and handle (via `onBackpressureXXX` operators).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T073237Z" creationid="pingfangx" creationdate="20190621T073237Z">
        <seg>类似于错误处理成为一等公民并接受操作符处理它(通过 `onErrorXXX` 操作符)，背压是数据流的另一个属性，程序员必须考虑和处理(通过 `onBackpressureXXX` 操作符)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the naming changes, `rx.Completable.CompletableSubscriber` has become `io.reactivex.CompletableObserver` with `onSubscribe(Disposable)`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060056Z" creationid="pingfangx" creationdate="20190618T060056Z">
        <seg>与命名更改类似，`rx.Completable.CompletableSubscriber` 已变为 `io.reactivex.CompletableObserver`，带有 `onSubscribe(Disposable)`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simultaneous Close Sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063958Z" creationid="pingfangx" creationdate="20190828T063958Z">
        <seg>同时关闭序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simultaneous Connection Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042446Z" creationid="pingfangx" creationdate="20190828T042446Z">
        <seg>同时连接同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simultaneous initiation is only slightly more complex, as is shown in figure 8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041917Z" creationid="pingfangx" creationdate="20190828T041917Z">
        <seg>同时启动只是稍微复杂一些，如图 8 所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since 1.x `Observable.subscribe(Subscriber)` returned `Subscription`, users often added the `Subscription` to a `CompositeSubscription` for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070549Z" creationid="pingfangx" creationdate="20190618T070549Z">
        <seg>由于 1.x `Observable.subscribe(Subscriber)` 返回 `Subscription`，用户经常将 `Subscription` 添加到 `CompositeSubscription` 中，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since 2.x is a fresh start, we won't make that mistake again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094650Z" creationid="pingfangx" creationdate="20190618T094650Z">
        <seg>由于 2.x 是一个新的开始，我们不会再犯这个错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since every octet is sequenced, each of them can be acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T020941Z" creationid="pingfangx" creationdate="20190828T020941Z">
        <seg>由于每个八位字节都是有序的，因此每个八位字节都可以被确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since many of the existing code targeting 1.x do such things, the method `safeSubscribe` has been introduced that does handle these non-conforming consumers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095633Z" creationid="pingfangx" creationdate="20190618T095633Z">
        <seg>由于许多针对 1.x 的现有代码都是这样做的，因此引入了 `safeSubscribe` 方法来处理这些不符合要求的消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since not all sources need all these features, the static methods of `Flowable.generate` let's one create instances without them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021428Z" creationid="pingfangx" creationdate="20190624T021428Z">
        <seg>由于并非所有源都需要所有这些功能，因此 `Flowable.generate` 的静态方法可以创建没有它们的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Java convention is to have a lowercase letter start a method name, this would have been `return(T)` which is a keyword in Java and thus not available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101634Z" creationid="pingfangx" creationdate="20190617T101634Z">
        <seg>由于 Java 约定是以小写字母开始一个方法名称，这将是 `return(T)`，它是 Java 中的关键字，因此不可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to l0's of megabits/sec.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025430Z" creationid="pingfangx" creationdate="20190828T025430Z">
        <seg>由于网络中的最大报文段寿命不可能超过几十秒，因此即使数据速率上升到 10 兆字节/秒，也可以认为这对可预见的网络提供了充足的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2**32.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021312Z" creationid="pingfangx" creationdate="20190828T021312Z">
        <seg>由于空间是有限的，所有处理序列号的算术必须以 2 ** 32 为模进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we assume that segments will stay in the network no more than the Maximum Segment Lifetime (MSL) and that the MSL is less than 4.55 hours we can reasonably assume that ISN's will be unique.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023417Z" creationid="pingfangx" creationdate="20190828T023417Z">
        <seg>由于我们假设网报文段将在网络中停留不超过最大网报文段生命周期(MSL)并且 MSL 小于 4.55 小时，我们可以合理地假设 ISN 将是唯一的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we build an `Flowable` out of it, we can express our will to consume only the first 5 of it and then stop requesting anything.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020557Z" creationid="pingfangx" creationdate="20190624T020557Z">
        <seg>由于我们构建了一个 `Flowable`，我们可以表达我们的意愿，只消耗它的前 5 个，然后停止请求任何东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we explicitly don't request in `onStart`, this will not print anything.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015652Z" creationid="pingfangx" creationdate="20190624T015652Z">
        <seg>由于我们明确地不在 `onStart` 中请求，因此不会打印任何内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sleeping for some time in this example situations lets you see the output of the flow on the console with time to spare.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T074030Z" creationid="pingfangx" creationdate="20190617T074030Z">
        <seg>在此示例情况下休眠一段时间，使您可以在留出的时间在控制台上查看流的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Snapshots are available via https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105550Z" creationid="pingfangx" creationdate="20190617T105550Z">
        <seg>可通过 https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/ 获取快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Notes on Naming Conventions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064512Z" creationid="pingfangx" creationdate="20190620T064512Z">
        <seg>关于命名约定的一些注释</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091407Z" creationid="pingfangx" creationdate="20190620T091407Z">
        <seg>RxGroovy 中的一些 Observable 操作符具有替代形式，允许您设置操作符将用于(至少某些部分)其操作的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091921Z" creationid="pingfangx" creationdate="20190620T091921Z">
        <seg>RxJava 中的一些 Observable 操作符具有替代形式，允许您设置操作符将用于(至少某些部分)其操作的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085701Z" creationid="pingfangx" creationdate="20190620T085701Z">
        <seg>一些 ReactiveX Observable 操作符具有将 Scheduler 作为参数的变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some libraries offer some help, such as Google Guava's `AbstractIterable` and IxJava's `Ix.generate()` and `Ix.forloop()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020434Z" creationid="pingfangx" creationdate="20190624T020434Z">
        <seg>一些库提供了一些帮助，例如 Google Guava 的 `AbstractIterable` 和 IxJava 的 `Ix.generate()` 和 `Ix.forloop()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operator overloads have been renamed with a postfix, such as `fromArray`, `fromIterable` etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111237Z" creationid="pingfangx" creationdate="20190618T111140Z">
        <seg>一些操作符重载已使用后缀重命名，例如 `fromArray`，`fromIterable` 等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators also allow for an interface between the Observable world and the Single world so that you can mix the two varieties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073958Z" creationid="pingfangx" creationdate="20190620T073958Z">
        <seg>一些操作符还允许 Obse​​rvable 世界和 Single 世界之间的接口，以便您可以混合两种变体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators that produced exactly one value or an error now return `Single` in 2.x (or `Maybe` if an empty source is allowed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060131Z" creationid="pingfangx" creationdate="20190619T060131Z">
        <seg>一些只生成一个值或错误的操作符现在在 2.x 中返回 `Single`(如果允许空源，则返回 `Maybe`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some sources block or start emitting items right away in this state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072007Z" creationid="pingfangx" creationdate="20190617T072007Z">
        <seg>某些来源在此状态下会立即阻止或开始发射项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes such overflows happen due to bursty sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090237Z" creationid="pingfangx" creationdate="20190621T090237Z">
        <seg>有时这种溢出是由于突发源而发生的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes though, multiple sources may fail at which point there is a choice whether or not wait for all of them to complete or fail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103451Z" creationid="pingfangx" creationdate="20190617T103451Z">
        <seg>但有时候，多个来源可能会失败，此时可以选择是否等待所有来源完成或失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, a source or service returns a different type than the flow that is supposed to work with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092728Z" creationid="pingfangx" creationdate="20190617T092728Z">
        <seg>有时，源或服务返回的类型与应该使用它的流不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, a suffix is added to avoid logical ambiguities that may compile but produce the wrong type in a flow:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103058Z" creationid="pingfangx" creationdate="20190617T103058Z">
        <seg>有时，会添加一个后缀以避免可能编译但在流中产生错误类型的逻辑歧义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, the data source to be converted into the reactive world itself is synchronous (blocking) and pull-like, that is, we have to call some `get` or `read` method to get the next piece of data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020722Z" creationid="pingfangx" creationdate="20190624T020722Z">
        <seg>有时，要转换为响应世界本身的数据源是同步的(阻塞)和拉式的，也就是说，我们必须调用一些 `get` 或 `read` 方法来获取下一个数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, the source to be wrapped into an `Flowable` is already hot (such as mouse moves) or cold but not backpressurable in its API (such as an asynchronous network callback).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021709Z" creationid="pingfangx" creationdate="20190624T021709Z">
        <seg>有时，被包装成 `Flowable` 的源已经是热源(例如鼠标移动)或是冷源但在其 API 中不能背压(例如异步网络回调)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, there is an implicit data dependency between the previous sequence and the new sequence that, for some reason, was not flowing through the "regular channels".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092144Z" creationid="pingfangx" creationdate="20190617T092144Z">
        <seg>有时，前一个序列和新序列之间存在隐含的数据依赖性，由于某种原因，它不会流经“常规通道”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, when an item has become available, one would like to perform some dependent computations on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083533Z" creationid="pingfangx" creationdate="20190617T083533Z">
        <seg>有时，当项目可用时，人们希望对其执行一些依赖计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specialty Observables that have more precisely-controlled subscription dynamics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103546Z" creationid="pingfangx" creationdate="20190620T103546Z">
        <seg>具有更精确控制的订阅动态的特殊 Observables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Store the return value from that method in a variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053011Z" creationid="pingfangx" creationdate="20190620T053011Z">
        <seg>将该方法的返回值存储在变量中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a message indicates to the site B TCP that something is wrong, and it is expected to abort the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055639Z" creationid="pingfangx" creationdate="20190828T055639Z">
        <seg>这样的消息向站点 B TCP 指示出现了问题，并且预计会中止连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such an Observable does not begin emitting items until its &lt;a0&gt;&lt;s1&gt;Connect&lt;/s1&gt;&lt;/a0&gt; method is called, whether or not any observers have subscribed to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070147Z" creationid="pingfangx" creationdate="20190620T070147Z">
        <seg>这样的 Observable 在调用 &lt;a0&gt;&lt;s1&gt;Connect&lt;/s1&gt;&lt;/a0&gt; 方法之前不会开始发射项目，无论是否有任何观察者订阅了它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such connections will automatically become reset if an attempt is made to send data in either direction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043538Z" creationid="pingfangx" creationdate="20190828T043538Z">
        <seg>如果尝试向任一方向发送数据，则此类连接将自动重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such errors are routed to the `RxJavaPlugins.onError` handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090058Z" creationid="pingfangx" creationdate="20190618T090058Z">
        <seg>这些错误被路由到 `RxJavaPlugins.onError` 处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suddenly, the user taps the screen too quickly and `observeOn`'s default 16-element internal buffer on Android overflows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090257Z" creationid="pingfangx" creationdate="20190621T090257Z">
        <seg>突然，用户太快地点击了屏幕，Android 上的 `observeOn` 的默认 16 元素内部缓冲区溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose, for example, that a connection is opened starting with sequence number S.  Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025646Z" creationid="pingfangx" creationdate="20190828T025646Z">
        <seg>例如，假设从序列号 S 开始打开连接。假设此连接使用不多，并且最终初始序列号函数(ISN(t))采用等于序列号的值，例如 S1，此 TCP 在特定连接上发送的最后一个报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Surprising to some, this prints 1 twice instead of printing 1 and 2 respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015800Z" creationid="pingfangx" creationdate="20190624T015800Z">
        <seg>令某些人感到惊讶的是，这打印 1 次，而不是分别打印 1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP A detects that the ACK field is incorrect and returns a RST (reset) with its SEQ field selected to make the segment believable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043058Z" creationid="pingfangx" creationdate="20190828T043058Z">
        <seg>TCP A 检测到 ACK 字报文段不正确并返回 RST(重置)，并选择其 SEQ 字段以使该报文段可信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP A sees that this segment does not acknowledge anything it sent and, being unsynchronized, sends a reset (RST) because it has detected a half-open connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060135Z" creationid="pingfangx" creationdate="20190828T060135Z">
        <seg>TCP A 看到此报文段未确认它发送的任何内容，因此不同步，所以会发送重置(RST)因为它已检测到半开连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP A will continue to try to establish the connection; the problem is now reduced to the basic 3-way handshake of figure 7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060158Z" creationid="pingfangx" creationdate="20190828T060158Z">
        <seg>TCP A 将继续尝试建立连接；问题现在减少到图 7 的基本三次握手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B aborts at line 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060145Z" creationid="pingfangx" creationdate="20190828T060145Z">
        <seg>TCP B 在第 5 行中止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B accepts the reset and returns to its passive LISTEN state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060408Z" creationid="pingfangx" creationdate="20190828T060408Z">
        <seg>TCP B 接受重置并返回其被动 LISTEN 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B, in the meantime, thinks the connection is open.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055851Z" creationid="pingfangx" creationdate="20190828T055844Z">
        <seg>在此期间，TCP B 认为连接是打开的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B, on receiving the RST, returns to the LISTEN state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043257Z" creationid="pingfangx" creationdate="20190828T043257Z">
        <seg>接收到 RST 后，TCP B 返回到 LISTEN 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP Header Format</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104755Z" creationid="pingfangx" creationdate="20190827T104755Z">
        <seg>TCP 首部格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP implementors may violate the "quiet time" restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024916Z" creationid="pingfangx" creationdate="20190828T024916Z">
        <seg>TCP 实现者可能违反“安静时间”限制，但仅有可能导致某些旧数据被接受为新的或新的数据被拒绝，因为互联网系统中的某些接收器复制旧数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP segments are sent as internet datagrams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T100659Z" creationid="pingfangx" creationdate="20190827T100659Z">
        <seg>TCP 报文段作为 Internet 数据报发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP states represent the state AFTER the departure or arrival of the segment (whose contents are shown in the center of each line).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034622Z" creationid="pingfangx" creationdate="20190828T034622Z">
        <seg>TCP 状态表示报文段的离开或到达之后的状态(其内容显示在每条线的中心)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCPs consume sequence number space each time a segment is formed and entered into the network output queue at a source host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025014Z" creationid="pingfangx" creationdate="20190828T025014Z">
        <seg>每次形成一个报文段并将其输入到源主机的网络输出队列中时，TCP 会消耗序列号空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112924Z" creationid="pingfangx" creationdate="20190827T112924Z">
        <seg>TIME-WAIT - 表示等待足够的时间以确保远程 TCP 收到其连接终止请求的确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TRANSMISSION CONTROL PROTOCOL</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025942Z" creationid="pingfangx" creationdate="20190828T024814Z">
        <seg>TRANSMISSION CONTROL PROTOCOL
输输控制协议
没有完全翻译，并且有部分内容不太理解，可能只是单纯的机器翻译，没加修饰。
应该需要多读几遍才行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Techniques like &lt;a0&gt;Java Futures&lt;/a0&gt; are straightforward to use for &lt;a1&gt;a single level of asynchronous execution&lt;/a1&gt; but they start to add &lt;a2&gt;non-trivial complexity&lt;/a2&gt; when they’re nested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034736Z" creationid="pingfangx" creationdate="20190620T034736Z">
        <seg>诸如 &lt;a0&gt;Java Futures&lt;/a0&gt; 之类的技术可以直接用于 &lt;a1&gt;单层的异步操作&lt;/a1&gt;，但是当它们嵌套时，它们开始变得 &lt;a2&gt;异常的复杂&lt;/a2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111055Z" creationid="pingfangx" creationdate="20190827T111055Z">
        <seg>术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test developers are now encouraged to simply `new TestScheduler()` in their code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093750Z" creationid="pingfangx" creationdate="20190618T093750Z">
        <seg>现在鼓励测试开发人员在他们的代码中简单地使用 `new TestScheduler()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing RxJava 2.x works the same way as it does in 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095744Z" creationid="pingfangx" creationdate="20190618T095744Z">
        <seg>测试 RxJava 2.x 的工作方式与 1.x 相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests that want to override the schedulers and the lifecycle of the base reactive types can do it on a case-by-case basis through callback functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085756Z" creationid="pingfangx" creationdate="20190618T085756Z">
        <seg>想要覆盖调度器和基本响应类型生命周期的测试可以通过回调函数逐个进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "three-way handshake" is the procedure used to establish a connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030650Z" creationid="pingfangx" creationdate="20190828T030650Z">
        <seg>“三次握手”是用于建立连接的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 1.x `TestSubject` has been dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063524Z" creationid="pingfangx" creationdate="20190618T063524Z">
        <seg>1.x 的 `TestSubject` 已被删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x API still supports the main default scheduler types: `computation`, `io`, `newThread` and `trampoline`, accessible through `io.reactivex.schedulers.Schedulers` utility class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093502Z" creationid="pingfangx" creationdate="20190618T093502Z">
        <seg>2.x API 仍支持主要的默认调度器类型：`calculate`，`io`，`newThread` 和 `trampoline`，可通过 `io.reactivex.schedulers.Schedulers` 实用程序类访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x `Single` reactive base type, which can emit a single `onSuccess` or `onError` has been redesigned from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055616Z" creationid="pingfangx" creationdate="20190618T055616Z">
        <seg>2.x 重新设计的 `Single` 响应基类型，它可以发出单个 `onSuccess` 或 `onError` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x redesigned the `RxJavaPlugins` class which now supports changing the hooks at runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085718Z" creationid="pingfangx" creationdate="20190618T085718Z">
        <seg>2.x 重新设计了 `RxJavaPlugins` 类，它现在支持在运行时更改钩子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Worker&lt;/c0&gt; is also a &lt;c1&gt;Subscription&lt;/c1&gt; and so you can (and should, eventually) call its &lt;c2&gt;unsubscribe&lt;/c2&gt; method to signal that it can halt work and release resources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092316Z" creationid="pingfangx" creationdate="20190620T092316Z">
        <seg>&lt;c0&gt;Worker&lt;/c0&gt; 也是 &lt;c1&gt;Subscription&lt;/c1&gt;，因此您可以(通常也应该)调用其 &lt;c2&gt;unsubscribe&lt;/c2&gt; 方法来表示它可以停止工作和释放资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;onError&lt;/c2&gt; method takes as its parameter an indication of what caused the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060342Z" creationid="pingfangx" creationdate="20190620T060342Z">
        <seg>&lt;c2&gt;onError&lt;/c2&gt; 方法将导致错误的原因作为其参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;s1&gt;SubscribeOn&lt;/s1&gt; operator changes this behavior by specifying a different Scheduler on which the Observable should operate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085953Z" creationid="pingfangx" creationdate="20190620T085953Z">
        <seg>&lt;s1&gt;SubscribeOn&lt;/s1&gt; 操作符通过指定 Observable 应在其上运行的其他 Scheduler 来更改此行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;s2&gt;ObserveOn&lt;/s2&gt; operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090251Z" creationid="pingfangx" creationdate="20190620T090251Z">
        <seg>&lt;s2&gt;ObserveOn&lt;/s2&gt; 操作符指定 Observable 将用于向其观察者发送通知的另一个 Scheduler。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Internet Protocol header carries several information fields, including the source and destination host addresses [2].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T103155Z" creationid="pingfangx" creationdate="20190827T103155Z">
        <seg>Internet 协议首部包含多个信息字段，包括源地址和目标主机地址 [2]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Observable type adds two missing semantics to &lt;a0&gt;the Gang of Four’s Observer pattern&lt;/a0&gt;, to match those that are available in the Iterable type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042308Z" creationid="pingfangx" creationdate="20190620T042308Z">
        <seg>Observable 类型为 &lt;a0&gt;Gang of Four 的观察者模式&lt;/a0&gt; 添加了两个缺少的语义，以匹配 Iterable 类型中可用的语义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Operators of ReactiveX</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094002Z" creationid="pingfangx" creationdate="20190620T094002Z">
        <seg>ReactiveX 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RST is acceptable so TCP B processes it and aborts the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060254Z" creationid="pingfangx" creationdate="20190828T060254Z">
        <seg>RST 是可接受的，因此 TCP B 处理它并中止连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification has its own Subscriber as an interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065304Z" creationid="pingfangx" creationdate="20190618T065304Z">
        <seg>Reactive-Streams 规范有自己的订阅者作为接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification mandates operators supporting backpressure, specifically via the guarantee that they don't overflow their consumers when those don't request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073359Z" creationid="pingfangx" creationdate="20190618T073359Z">
        <seg>Reactive-Streams 规范要求操作符支持背压，特别是通过保证在没有请求时它们不会溢出消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification took this name for specifying an interaction point between a source and a consumer: `org.reactivestreams.Subscription` allows requesting a positive amount from the upstream and allows cancelling the sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072735Z" creationid="pingfangx" creationdate="20190618T072735Z">
        <seg>Reactive-Streams 规范使用此名称来指定源和消费者之间的交互点：`org.reactivestreams.Subscription` 允许从上游请求正数量并允许取消序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034410Z" creationid="pingfangx" creationdate="20190620T034410Z">
        <seg>ReactiveX Observable 模型允许您使用简单，可组合的操作来处理异步事件流，就像用于数据项集合(如数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022716Z" creationid="pingfangx" creationdate="20190828T022716Z">
        <seg>SYN 和 FIN 是唯一需要此保护的控制位，这些控制位仅用于连接打开和关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP Length is the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity, but is computed), and it does not count the 12 octets of the pseudo header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110544Z" creationid="pingfangx" creationdate="20190827T110544Z">
        <seg>TCP 长度是 TCP 报头长度加上八位字节的数据长度(这不是显式发送的数量，而是计算的)，并且它不计算伪首部的 12 个八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP Quiet Time Concept</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024503Z" creationid="pingfangx" creationdate="20190828T024503Z">
        <seg>TCP 安静的时间概念</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP header (even one including options) is an integral number of 32 bits long.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105322Z" creationid="pingfangx" creationdate="20190827T105322Z">
        <seg>TCP 首部(甚至包括选项)是 32 位长的整数倍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111049Z" creationid="pingfangx" creationdate="20190827T111049Z">
        <seg>TCP 首部填充用于确保 TCP 首部结束和数据开始在 32 位边界上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP then waits until its own FIN is acknowledged whereupon it deletes the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063742Z" creationid="pingfangx" creationdate="20190828T063742Z">
        <seg>然后 TCP 等待，直到它自己的 FIN 被确认，然后删除连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `BackpressureOverflow.Strategy` is an interface actually but the class `BackpressureOverflow` offers 4 static fields with implementations of it representing typical actions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014454Z" creationid="pingfangx" creationdate="20190624T014454Z">
        <seg>`BackpressureOverflow.Strategy` 实际上是一个接口，但是 `BackpressureOverflow` 类提供了 4 个静态字段，其实现代表了典型的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `BehaviorProcessor` and `PublishProcessor` don't coordinate requests (use `Flowable.publish()` for that) of their downstream subscribers and will signal them `MissingBackpressureException` if the downstream can't keep up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063040Z" creationid="pingfangx" creationdate="20190618T063040Z">
        <seg>`BehaviorProcessor` 和 `PublishProcessor` 不协调下游订阅者的请求(如果需要则使用 `Flowable.publish()`)，如果下游无法跟上，则会发出 `MissingBackpressureException` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Completable` type remains largely the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055938Z" creationid="pingfangx" creationdate="20190618T055938Z">
        <seg>`Completable` 类型基本保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Emitter` is relatively straightforward to use; one can call `onNext`, `onError` and `onComplete` on it and the operator handles backpressure and unsubscription management on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022550Z" creationid="pingfangx" creationdate="20190624T022550Z">
        <seg>`Emitter` 的使用相对简单；可以在其上调用 `onNext`，`onError` 和 `onComplete`，操作符可以自己处理背压和取消订阅管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `FuncN` is replaced by the `Function&lt;Object[], R&gt;` type declaration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065013Z" creationid="pingfangx" creationdate="20190618T065013Z">
        <seg>`FuncN` 被 `Function&lt;Object[], R&gt;` 类型声明所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Maybe` class is accompanied by `MaybeSource` as its base interface type, `MaybeObserver&lt;T&gt;` as its signal-receiving interface and follows the protocol `onSubscribe (onSuccess | onError | onComplete)?`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060616Z" creationid="pingfangx" creationdate="20190618T060616Z">
        <seg>`Maybe` 类伴随着 `MaybeSource` 作为其基本接口类型，`MaybeObserver&lt;T&gt;` 作为其信号接收接口，并遵循协议 `onSubscribe (onSuccess | onError | onComplete)?`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Schedulers.test()` has been removed as well to avoid the conceptional difference with the rest of the default schedulers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093658Z" creationid="pingfangx" creationdate="20190618T093658Z">
        <seg>`Schedulers.test()` 也已被移除，以避免与其他默认调度器的概念差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `SerializedSubject` is no longer a public class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063614Z" creationid="pingfangx" creationdate="20190618T063614Z">
        <seg>`SerializedSubject` 不再是公共类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Thread.sleep(2000);` at the end is no accident.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073846Z" creationid="pingfangx" creationdate="20190617T073846Z">
        <seg>最后的 `Thread.sleep(2000);`  不是偶然的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `computeValue` is called as part of the main routine and not in response to the subscribers subscribing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015849Z" creationid="pingfangx" creationdate="20190624T015849Z">
        <seg>`computeValue` 作为主程序的一部分被调用，而不是响应订阅者的订阅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `fromIterable` also gives an interesting opportunity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020241Z" creationid="pingfangx" creationdate="20190624T020241Z">
        <seg>`fromIterable` 也提供了一个有趣的机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `immediate` scheduler is not present in 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093540Z" creationid="pingfangx" creationdate="20190618T093540Z">
        <seg>`immediate` 调度器不存在于 2.x 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.Scheduler` abstract base class now supports scheduling tasks directly without the need to create and then destroy a `Worker` (which is often forgotten):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093812Z" creationid="pingfangx" creationdate="20190618T093812Z">
        <seg>`io.reactivex.Scheduler` 抽象基类现在支持直接调度任务，而不需要创建然后销毁 `Worker`(经常被遗忘)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.processors.AsyncProcessor`, `io.reactivex.processors.BehaviorProcessor`, `io.reactivex.processors.PublishProcessor`, `io.reactivex.processors.ReplayProcessor` and `io.reactivex.processors.UnicastProcessor` are backpressure-aware.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062905Z" creationid="pingfangx" creationdate="20190618T062905Z">
        <seg>`io.reactivex.processors.AsyncProcessor`，`io.reactivex.processors.BehaviorProcessor`，`io.reactivex.processors.PublishProcessor`，`io.reactivex.processors.ReplayProcessor` 和 `io.reactivex.processors.UnicastProcessor` 是背压感知的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.subjects.AsyncSubject`, `io.reactivex.subjects.BehaviorSubject`, `io.reactivex.subjects.PublishSubject`, `io.reactivex.subjects.ReplaySubject` and `io.reactivex.subjects.UnicastSubject` in 2.x don't support backpressure (as part of the 2.x `Observable` family).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062846Z" creationid="pingfangx" creationdate="20190618T062846Z">
        <seg>`io.reactivex.subjects.AsyncSubject`，`io.reactivex.subjects.BehaviorSubject`，`io.reactivex.subjects.PublishSubject`，`io.reactivex.subjects.ReplaySubject` 和 `io.reactivex.subjects.UnicastSubject` 在 2.x 中不支持背压(作为 2.x `Observable` 系列的一部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `rx.observables.ConnectableObservable` is now `io.reactivex.observables.ConnectableObservable&lt;T&gt;` and `io.reactivex.flowables.ConnectableFlowable&lt;T&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063659Z" creationid="pingfangx" creationdate="20190618T063659Z">
        <seg>`rx.observables.ConnectableObservable` 现在是 `io.reactivex.observables.ConnectableObservable&lt;T&gt;` 和 `io.reactivex.flowables.ConnectableFlowable&lt;T&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `rx.observables.GroupedObservable` is now `io.reactivex.observables.GroupedObservable&lt;T&gt;` and `io.reactivex.flowables.GroupedFlowable&lt;T&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063807Z" creationid="pingfangx" creationdate="20190618T063807Z">
        <seg>`rx.observables.GroupedObservable` 现在是 `io.reactivex.observables.GroupedObservable&lt;T&gt;` 和 `io.reactivex.flowables.GroupedFlowable&lt;T&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `set()` method disposes the old value and `replace()` method does not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073205Z" creationid="pingfangx" creationdate="20190618T073205Z">
        <seg>`set()` 方法处理旧值，而 'replace()` 方法则不处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `test()` method on `TestObserver` has a `test(boolean cancel)` overload which cancels/disposes the `TestSubscriber`/`TestObserver` before it even gets subscribed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101725Z" creationid="pingfangx" creationdate="20190618T101725Z">
        <seg>`TestObserver` 上的 `test()` 方法有一个 `test(boolean cancel)` 重载，在它被订阅之前取消/释放 `TestSubscriber`/`TestObserver`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021046Z" creationid="pingfangx" creationdate="20190828T021046Z">
        <seg>所采用的确认机制是累积的，因此序列号 X 的确认表明已经接收到所有八位字节但不包括 X。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual cause is usually the non-backpressured use of `PublishProcessor`, `timer()` or `interval()` or custom operators created via `create()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090210Z" creationid="pingfangx" creationdate="20190621T090210Z">
        <seg>实际原因通常是使用 `PublishProcessor`，`timer()` 或 `interval()` 或通过 `create()` 创建的自定义操作符的非背压使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bad news is that one should be careful when performing 'organize imports' as it may select the non-backpressured `io.reactivex.Observable` unintended.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053501Z" creationid="pingfangx" creationdate="20190618T053501Z">
        <seg>坏消息是，在执行“组织导入”时应该小心，因为它可能会无意中选择非背压的 `io.reactivex.Observable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base classes can be considered heavy due to the sheer number of static and instance methods on them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103625Z" creationid="pingfangx" creationdate="20190617T103625Z">
        <seg>由于基类的静态和实例方法数量庞大，因此可以认为基类很重。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP does not have any memory of the sequence numbers it last used on a given connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025512Z" creationid="pingfangx" creationdate="20190828T025512Z">
        <seg>但是，如果源 TCP 没有最后在给定连接上使用的序列号的任何内存，则可以取消 TCP 中的基本重复检测和排序算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checksum also covers a 96 bit pseudo header conceptually</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110032Z" creationid="pingfangx" creationdate="20190827T110032Z">
        <seg>校验和还在 TCP 首部之前，概念性地涵盖了 96 位伪首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105814Z" creationid="pingfangx" creationdate="20190827T105814Z">
        <seg>校验和字段是首部和文本中所有 16 位字的反码求和的 16 位反码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class-based `RxJavaObservableHook` and friends are now gone and `RxJavaHooks` functionality is incorporated into `RxJavaPlugins`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085830Z" creationid="pingfangx" creationdate="20190618T085830Z">
        <seg>基于类 `RxJavaObservableHook` 和朋友现在已经不在了，`RxJavaHooks` 函数被整合到 `RxJavaPlugins` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classic case of the need for backpressure is when the producer is a hot source:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T071555Z" creationid="pingfangx" creationdate="20190621T071555Z">
        <seg>需要背压的经典案例是当生产者是热源时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection remains in the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060702Z" creationid="pingfangx" creationdate="20190828T060702Z">
        <seg>连接仍处于 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection remains in the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061030Z" creationid="pingfangx" creationdate="20190828T061030Z">
        <seg>连接保持相同状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The content of the header beyond the End-of-Option option must be header padding (i.e., zero).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110945Z" creationid="pingfangx" creationdate="20190827T110945Z">
        <seg>超出选项结束选项的首部的内容必须是首部填充(即，零)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dataflows in RxJava consist of a source, zero or more intermediate steps followed by a data consumer or combinator step (where the step is responsible to consume the dataflow by some means):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070925Z" creationid="pingfangx" creationdate="20190617T070735Z">
        <seg>RxJava 中的数据流由源，零个或多个中间步骤，后跟数据消费者或组合器步骤(其中步骤负责通过某种方式消费数据流)组成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The destination port number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104937Z" creationid="pingfangx" creationdate="20190827T104937Z">
        <seg>目的端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation of each operator has a description about its backpressure behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080246Z" creationid="pingfangx" creationdate="20190621T080246Z">
        <seg>每个操作符的文档都有关于其背压行为的描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2**32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have "drained" from the internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025040Z" creationid="pingfangx" creationdate="20190828T025040Z">
        <seg>TCP 协议中的重复检测和排序算法依赖于报文段数据与序列空间的唯一绑定，以使序列号在绑定到那些序列号的报文段数据之前不会循环通过所有 2 ** 32 值并且接收方承认并且所有报文段的重复副本已从互联网“耗尽”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception is still there but this time, the operator that can't signal more `onNext` will signal this exception instead (allowing better identification of who is not properly backpressured).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073650Z" creationid="pingfangx" creationdate="20190618T073650Z">
        <seg>例外情况仍然存在，但这一次，无法发出更多 `onNext` 信号的操作符将发出异常信号(允许更好地识别谁没有正确背压)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figures should be interpreted in the following way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033919Z" creationid="pingfangx" creationdate="20190828T033900Z">
        <seg>该图应按以下方式解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final callback gets invoked when the downstream unsubscribes (closing the inputstream) or when the previous callback called the terminal methods; it allows freeing up resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021408Z" creationid="pingfangx" creationdate="20190624T021408Z">
        <seg>当下游取消​​订阅(关闭输入流)或前一个回调调用终端方法时，将调用最终的回调；它允许释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final operator keeps only the latest value and practically overwrites older, undelivered values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015125Z" creationid="pingfangx" creationdate="20190624T015125Z">
        <seg>最后一个操作符只保留最新的值，实际上覆盖了旧的、未传递的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first callbacks allows one to create a per-subscriber state, such as the `FileInputStream` in the example; the file will be opened independently to each individual subscriber.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021149Z" creationid="pingfangx" creationdate="20190624T021149Z">
        <seg>第一个回调允许创建一个每个订阅者独立的状态，例如示例中的 `FileInputStream`;该文件将为每个订阅者独立打开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022401Z" creationid="pingfangx" creationdate="20190828T022401Z">
        <seg>该测试的第一部分检查该报文段的开头是否落入窗口，测试的第二部分检查该报文段的末端是否落入窗口；如果报文段通过测试的任何一部分，则它包含窗口中的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first step is to include RxJava 2 into your project, for example, as a Gradle compile dependency:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065845Z" creationid="pingfangx" creationdate="20190617T065845Z">
        <seg>第一步是将 RxJava 2 包含到您的项目中，例如，作为 Gradle 编译依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first typical case for its use when one wants to interact with a push-based source, such as GUI events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022214Z" creationid="pingfangx" creationdate="20190624T022214Z">
        <seg>当人们想要与基于推的源（例如 GUI 事件）交互时使用的第一个典型案例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following comparisons are needed to process the acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021803Z" creationid="pingfangx" creationdate="20190828T021803Z">
        <seg>处理确认需要进行以下比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following diagrams may help to relate some of these variables to the sequence space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111858Z" creationid="pingfangx" creationdate="20190827T111858Z">
        <seg>以下图表可能有助于将这些变量中的一些与序列空间相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example schedules &lt;c2&gt;someAction&lt;/c2&gt; to be performed on &lt;c3&gt;someScheduler&lt;/c3&gt; after 500ms have passed according to that Scheduler’s clock:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092445Z" creationid="pingfangx" creationdate="20190620T092445Z">
        <seg>以下示例根据调度器的时钟调度 500ms 后，在 &lt;c3&gt;someScheduler&lt;/c3&gt; 上调度 &lt;c2&gt;someAction&lt;/c2&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example schedules &lt;c2&gt;someAction&lt;/c2&gt; to be performed on &lt;c3&gt;someScheduler&lt;/c3&gt; after 500ms have passed, and then every 250ms thereafter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092640Z" creationid="pingfangx" creationdate="20190620T092640Z">
        <seg>以下示例调度在经过 500ms 后在 &lt;c3&gt;someScheduler&lt;/c3&gt; 上执行 &lt;c2&gt;someAction&lt;/c2&gt;，然后每隔 250ms 执行一次：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses &lt;a0&gt;the &lt;c1&gt;schedule&lt;/c1&gt; method&lt;/a0&gt; of &lt;a2&gt;the &lt;c3&gt;Scheduler.Worker&lt;/c3&gt; class&lt;/a2&gt; to schedule work on the &lt;c4&gt;newThread&lt;/c4&gt; Scheduler:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092100Z" creationid="pingfangx" creationdate="20190620T092100Z">
        <seg>以下示例使用&lt;a2&gt;&lt;c3&gt;Scheduler.Worker&lt;/c3&gt; 类&lt;/a2&gt; 的 &lt;a0&gt;&lt;c1&gt;schedule&lt;/c1&gt; 方法&lt;/a0&gt; 来安排 &lt;c4&gt;newThread&lt;/c4&gt; 调度器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following external libraries can work with RxJava:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113641Z" creationid="pingfangx" creationdate="20190617T113641Z">
        <seg>以下外部库可以与 RxJava 一起使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following matrix shows the available conversion options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T093040Z" creationid="pingfangx" creationdate="20190617T093040Z">
        <seg>以下矩阵显示了可用的转换选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following sections of this page will give marble diagrams that explain these operators schematically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074923Z" creationid="pingfangx" creationdate="20190620T074923Z">
        <seg>本页的以下部分将给出 marble 图，可以示意性地解释这些操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following subsections list each base reactive type and the difference between 1.x and 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111012Z" creationid="pingfangx" creationdate="20190618T111012Z">
        <seg>以下小节列出了每个基本响应类型以及 1.x 和 2.x 之间的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090950Z" creationid="pingfangx" creationdate="20190620T090950Z">
        <seg>下表显示了在 RxGroovy 中通过这些方法可用的调度器的种类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091905Z" creationid="pingfangx" creationdate="20190620T091905Z">
        <seg>下表显示了在 RxJava 中通过这些方法可用的 Scheduler 的种类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023337Z" creationid="pingfangx" creationdate="20190828T023337Z">
        <seg>生成器绑定到(可能是虚构的)32 位时钟，其低位比特大约每 4 微秒递增一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The good news is that operator names remain (mostly) the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053420Z" creationid="pingfangx" creationdate="20190618T053420Z">
        <seg>好消息是操作符名称(大多数)保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial send sequence number (ISS) is chosen by the data sending TCP, and the initial receive sequence number (IRS) is learned during the connection establishing procedure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023455Z" creationid="pingfangx" creationdate="20190828T023455Z">
        <seg>初始发送序列号(ISS)由数据发送 TCP 选择，并且在连接建立过程期间学习初始接收序列号(IRS)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial sequence number chosen is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025710Z" creationid="pingfangx" creationdate="20190828T025710Z">
        <seg>选择的初始序列号是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main issue with backpressure is that many hot sources, such as UI events, can't be reasonably backpressured and cause unexpected `MissingBackpressureException` (i.e., beginners don't expect them).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053209Z" creationid="pingfangx" creationdate="20190618T053209Z">
        <seg>背压的主要问题是许多热源，例如 UI 事件，不能合理地背压并导致意外的 `MissingBackpressureException`(即，初学者不期望它们)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main purpose is to avoid the tracking overhead of the `Worker`s for typically one-shot tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093953Z" creationid="pingfangx" creationdate="20190618T093953Z">
        <seg>主要目的是避免通常一次性任务的 `Worker` 的跟踪开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maintenance of a TCP connection requires the remembering of several variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111259Z" creationid="pingfangx" creationdate="20190827T111259Z">
        <seg>维护 TCP 连接需要记住几个变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method that returns the scheduler's own notion of current time, `now()` has been changed to accept a `TimeUnit` to indicate the unit of measure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094029Z" creationid="pingfangx" creationdate="20190618T094029Z">
        <seg>返回调度器自己的当前时间概念 `now()` 的方法已被更改为接受 `TimeUnit` 来指示度量单位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods have a default implementation that reuses `createWorker` properly but can be overridden with more efficient implementations if necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094015Z" creationid="pingfangx" creationdate="20190618T094015Z">
        <seg>这些方法有一个默认实现，可以正确地重用 `createWorker`，但如果需要可以用更高效的实现覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most basic backpressure aware source is created via `just`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015628Z" creationid="pingfangx" creationdate="20190624T015628Z">
        <seg>最基本的背压感知源是通过 `just` 创建的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most typical scenario is to given a value, invoke another service, await and continue with its result:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083633Z" creationid="pingfangx" creationdate="20190617T083633Z">
        <seg>最典型的情况是给出一个值，调用另一个服务，等待其结果并继续：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new `safeSubscribe` method was introduced to explicitly add the safety wrapper around a consumer type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054140Z" creationid="pingfangx" creationdate="20190619T054140Z">
        <seg>引入了新的 `safeSubscribe` 方法，以明确地在消费者类型周围添加安全包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new interface is **constrained to RxJava 2** and represents a consumer to `Flowable` that is able to work in a mode that relaxes the Reactive-Streams version 1.0.0 specification in rules §1.3, §2.3, §2.12 and §3.9:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084021Z" creationid="pingfangx" creationdate="20190618T074005Z">
        <seg>新接口被 **约束为 RxJava 2** 并且将消费者表示为 `Flowable`，它能够在 Reactive-Streams 版本 1.0.0 规范的规则 §1.3，§2.3，§2.12 和 §3.9 的宽松模式中工作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The no argument `Action0` is replaced by the `io.reactivex.functions.Action` for the operators and `java.lang.Runnable` for the `Scheduler` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064830Z" creationid="pingfangx" creationdate="20190618T064830Z">
        <seg>无参数 `Action0` 被替换为用于运算符的 `io.reactivex.functions.Action` 和用于 `Scheduler` 方法的 `java.lang.Runnable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The normal state for the data transfer phase of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112713Z" creationid="pingfangx" creationdate="20190827T112713Z">
        <seg>连接的数据传输阶段的正常状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of 32 bit words in the TCP Header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105241Z" creationid="pingfangx" creationdate="20190827T105241Z">
        <seg>TCP 首部中 32 位字的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105729Z" creationid="pingfangx" creationdate="20190827T105729Z">
        <seg>该报文段的发送方愿意接受的数据八位字节数，从确认字段中指示的数据八位字节数开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The official Javadoc pages for 2.x is hosted at http://reactivex.io/RxJava/2.x/javadoc/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052658Z" creationid="pingfangx" creationdate="20190618T052658Z">
        <seg>2.x 的官方 Javadoc 页面托管在 http://reactivex.io/RxJava/2.x/javadoc/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only dependency between the `sourceObservable` and the `someSingleSource` is that the former should complete normally in order for the latter to be consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091956Z" creationid="pingfangx" creationdate="20190617T091956Z">
        <seg>`sourceObservable` 和 `someSingleSource` 之间唯一的依赖关系是前者应该正常完成，以便后者被消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference between them is the direction in which the data flows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042457Z" creationid="pingfangx" creationdate="20190620T042457Z">
        <seg>它们之间的唯一区别是数据流动的方向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator `flatMap` does this by first mapping each number from 1 to 10 into its own individual `Flowable`, runs them and merges the computed squares.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083001Z" creationid="pingfangx" creationdate="20190617T083001Z">
        <seg>运算符 `flatMap` 通过首先将 1 到 10 中的每个数字映射到它自己的 `Flowable` 中，运行它们并合并计算出的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator `range` sends a callback, in the form of an implementation of the `org.reactivestreams.Subscription` interface, to the `observeOn` by calling its (inner `Subscriber`'s) `onSubscribe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081157Z" creationid="pingfangx" creationdate="20190621T081157Z">
        <seg>操作符 `range` 以 `org.reactivestreams.Subscription` 接口的实现形式，通过调用其(内部 `Subscriber` 的) `onSubscribe` 向 `observeOn` 发送一个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The option-length counts the two octets of option-kind and option-length as well as the option-data octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110913Z" creationid="pingfangx" creationdate="20190827T110913Z">
        <seg>option-length 计算 option-kind 和 option-length 的两个八位字节以及 option-data 八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original `Subscription` container types have been renamed and updated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073136Z" creationid="pingfangx" creationdate="20190618T073136Z">
        <seg>原始的 `Subscription` 容器类型已重命名和更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other `XProcessor` types honor backpressure of their downstream subscribers but otherwise, when subscribed to a source (optional), they consume it in an unbounded manner (requesting `Long.MAX_VALUE`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063226Z" creationid="pingfangx" creationdate="20190618T063226Z">
        <seg>其他 `XProcessor` 类型支持其下游订阅者的背压，但是当订阅源(可选)时，它们以无限制的方式消费它(请求 `Long.MAX_VALUE`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other base reactive types also follow this signature with their respective subscriber types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072930Z" creationid="pingfangx" creationdate="20190618T072930Z">
        <seg>其他基本响应类型也遵循此签名及其各自的订阅者类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other base reactive types have similar `create` methods (minus the backpressure strategy).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094904Z" creationid="pingfangx" creationdate="20190618T094904Z">
        <seg>其他基础响应类型具有类似的 `create` 方法(减去背压策略)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other overloads of `subscribe` now return `Disposable` in 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072939Z" creationid="pingfangx" creationdate="20190618T072939Z">
        <seg>`subscribe` 的其他重载现在在 2.x 中返回 `Disposable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other types, `Single`, `Maybe` and `Completable` don't support backpressure nor should they; there is always room to store one item temporarily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071515Z" creationid="pingfangx" creationdate="20190617T071515Z">
        <seg>其他类型，`Single`，`Maybe`和`Completable`不支持背压，也不应该支持背压；它们只是暂时存放单个项目的空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pad is not transmitted as part of the segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110012Z" creationid="pingfangx" creationdate="20190827T110012Z">
        <seg>填充不作为报文段的传输部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The padding is composed of zeros.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111053Z" creationid="pingfangx" creationdate="20190827T111053Z">
        <seg>填充由零组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preparation of dataflows by applying various intermediate operators happens in the so-called **assembly time**:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071711Z" creationid="pingfangx" creationdate="20190617T071711Z">
        <seg>通过应用各种中间运算符来准备数据流发生在所谓的 **assembly time** 中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042455Z" creationid="pingfangx" creationdate="20190828T042455Z">
        <seg>三次握手的主要原因是防止旧的重复连接启动引起混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem comes when one does some initialization in `onSubscribe`/`onStart` after calling `request` there and `onNext` may or may not see the effects of the initialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071801Z" creationid="pingfangx" creationdate="20190618T071801Z">
        <seg>在调用 `request` 之后在 `onSubscribe`/`onStart` 中进行初始化时会出现问题，因为 `onNext` 可能看到或可能看不到初始化的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that the recovering host may not know for how long it crashed nor does it know whether there are still old duplicates in the system from earlier connection incarnations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025808Z" creationid="pingfangx" creationdate="20190828T025808Z">
        <seg>问题是恢复的主机可能不知道它崩溃了多长时间，也不知道系统中是否还存在来自早期连接化身的旧重复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem starts when there are, for example, 1 billion elements or the same 1 million sequence appears 1000 times in a program, leading to `OutOfMemoryError` and generally slowdowns due to excessive GC overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072930Z" creationid="pingfangx" creationdate="20190621T072930Z">
        <seg>例如，当一个程序中有 10 亿个元素或相同的 100 万个序列出现 1000 次时会出现这个问题，导致 `OutOfMemoryError`，并且通常由于过多的 GC 开销而导致变慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem that arises from this is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023158Z" creationid="pingfangx" creationdate="20190828T023158Z">
        <seg>由此产生的问题是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The procedure also works if two TCP simultaneously initiate the procedure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030812Z" creationid="pingfangx" creationdate="20190828T030812Z">
        <seg>如果两个 TCP 同时启动该过程，则该过程也有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol places no restriction on a particular connection being used over and over again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023132Z" creationid="pingfangx" creationdate="20190828T023132Z">
        <seg>该协议对一次又一次使用的特定连接没有限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The real power comes with the “reactive extensions” (hence “ReactiveX”) — operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071557Z" creationid="pingfangx" creationdate="20190620T071557Z">
        <seg>“响应式扩展 (reactive extensions)”(这也是为什么称之为 “ReactiveX”) 真正强大的地方是 - 允许您转换，组合，操作和处理 Observable 发射的项目序列的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is that many source operators can "generate" values on demand and thus the operator `observeOn` can tell the `range` generate at most so many values the `observeOn` buffer can hold at once without overflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080646Z" creationid="pingfangx" creationdate="20190621T080512Z">
        <seg>原因是许多源操作符可以按需“生成”值，因此操作符 `observeOn` 可以告诉 `range`，最多生成 `observeOn` 缓冲区可以立即保存而不会溢出的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is that when the library is compiled with Java 8, the javac often can't disambiguate between functional interface types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111255Z" creationid="pingfangx" creationdate="20190618T111255Z">
        <seg>原因是当使用 Java 8 编译库时，javac 通常无法消除函数接口类型之间的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason these operators have a suffix instead of simply having the same name with different signature is type erasure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100728Z" creationid="pingfangx" creationdate="20190617T100728Z">
        <seg>这些运算符具有后缀而不是简单地具有不同签名的相同名称的原因是类型擦除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receive window is the portion of the sequence space labeled 2 in figure 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111933Z" creationid="pingfangx" creationdate="20190827T111933Z">
        <seg>接收窗口是图 5 中标记为 2 的序列空间的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver of a RST first validates it, then changes state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061754Z" creationid="pingfangx" creationdate="20190828T061754Z">
        <seg>RST 的接收者首先验证它，然后改变状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024312Z" creationid="pingfangx" creationdate="20190828T024312Z">
        <seg>第一个 SYN 的接收者无法知道该报文段是否是旧的延迟报文段，除非它记住连接上使用的最后一个序列号(这并不总是可能)，因此它必须要求发送方验证这个 SYN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevance of this operator is decreasing as more and more operators now allow setting their buffer sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093239Z" creationid="pingfangx" creationdate="20190621T093239Z">
        <seg>随着越来越多的操作符现在允许设置其缓冲区大小，此操作符的相关性正在下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevant parameters are usually called `bufferSize`, `prefetch` or `capacityHint`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090454Z" creationid="pingfangx" creationdate="20190621T090454Z">
        <seg>相关参数通常称为 `bufferSize`，`prefetch` 或 `capacityHint`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining action interfaces were named according to the Java 8 functional types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064541Z" creationid="pingfangx" creationdate="20190618T064541Z">
        <seg>其余的操作接口根据 Java 8 函数类型命名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote TCP initiates by sending a FIN control signal</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063204Z" creationid="pingfangx" creationdate="20190828T063204Z">
        <seg>远程 TCP 通过发送 FIN 控制信号启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reset takes its sequence number from the ACK field of the incoming segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061702Z" creationid="pingfangx" creationdate="20190828T061702Z">
        <seg>重置从传入报文段的 ACK 字段获取其序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T062007Z" creationid="pingfangx" creationdate="20190620T061944Z">
        <seg>取消订阅的结果将通过应用于该观察者所订阅的 Observable 的操作符链级联，这将导致链中的每个链接停止发射项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same applies to `Observer`, `SingleObserver`, `MaybeObserver` and `CompletableObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095612Z" creationid="pingfangx" creationdate="20190618T095612Z">
        <seg>这同样适用于 `Observer`，`SingleObserver`，`MaybeObserver` 和 `CompletableObserver`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same limitation exists for the operator `Switch`, which had to be named `switchOnNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101839Z" creationid="pingfangx" creationdate="20190617T101839Z">
        <seg>运算符 `Switch` 也存在同样的限制，它必须命名为 `switchOnNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second callback takes this state object and provides an output `Observer` whose `onXXX` methods can be called to emit values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021221Z" creationid="pingfangx" creationdate="20190624T021221Z">
        <seg>第二个回调接受这个状态对象，并提供一个输出 `Observer`，可以调用其 `onXXX` 方法来发射值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second convenience is that most `TestSubscriber`/`TestObserver` methods return the instance itself allowing chaining the various `assertX` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095918Z" creationid="pingfangx" creationdate="20190618T095918Z">
        <seg>第二个方便是大多数 `TestSubscriber`/`TestObserver` 方法返回实例本身，允许链式调用各种 `assertX` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second is to write the **Hello World** program:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065858Z" creationid="pingfangx" creationdate="20190617T065858Z">
        <seg>第二个是编写 ** Hello World ** 程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second scenario usually involves some asynchronous, callback-based API that has to be converted into an `Flowable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022924Z" creationid="pingfangx" creationdate="20190624T022924Z">
        <seg>第二种情况通常涉及一些异步的，基于回调的 API，必须将其转换为 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The segment length (SEG.LEN) includes both data and sequence space occupying controls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022829Z" creationid="pingfangx" creationdate="20190828T022829Z">
        <seg>报文段长度(SEG.LEN)包括数据和控制位占用的序列空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence number of the first data octet in this segment (except when SYN is present).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105012Z" creationid="pingfangx" creationdate="20190827T105012Z">
        <seg>此报文段中第一个数据八位字节的序列号(存在 SYN 时除外)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest three-way handshake is shown in figure 7 below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033648Z" creationid="pingfangx" creationdate="20190828T033648Z">
        <seg>最简单的三次握手如下图 7 所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source port number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104852Z" creationid="pingfangx" creationdate="20190827T104852Z">
        <seg>源端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specification itself has evolved out of RxJava 1.x and provides a common baseline for reactive systems and libraries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051835Z" creationid="pingfangx" creationdate="20190618T051835Z">
        <seg>规范本身已经从 RxJava 1.x 发展而来，并为响应式系统和库提供了一个共同的基线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state diagram in figure 6 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T113155Z" creationid="pingfangx" creationdate="20190827T113155Z">
        <seg>图 6 中的状态图仅说明状态变化以及导致事件和结果动作，但既不解决错误条件也不解决与状态变化无关的动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The states are:  LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, and the fictional state CLOSED.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112450Z" creationid="pingfangx" creationdate="20190827T112450Z">
        <seg>状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, 和虚构状态 CLOSED.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The symbol "=&lt;" means "less than or equal" (modulo 2**32).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021556Z" creationid="pingfangx" creationdate="20190828T021556Z">
        <seg>符号 "=&lt;" 表示“小于或等于”(模 2**32)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The synchronization requires each side to send it's own initial sequence number and to receive a confirmation of it in acknowledgment from the other side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023812Z" creationid="pingfangx" creationdate="20190828T023812Z">
        <seg>同步要求每一方发送它自己的初始序列号，并从另一方接收确认信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third convenience is that you can now fluently test your sources without the need to create or introduce `TestSubscriber`/`TestObserver` instance in your code:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100013Z" creationid="pingfangx" creationdate="20190618T100013Z">
        <seg>第三个方便是您现在可以流畅地测试您的源，而无需在代码中创建或引入 `TestSubscriber`/`TestObserver` 实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024325Z" creationid="pingfangx" creationdate="20190828T024325Z">
        <seg>在 [3] 中讨论了三次握手和时钟驱动方案的优点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three-way handshake reduces the possibility of false connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T032510Z" creationid="pingfangx" creationdate="20190828T032510Z">
        <seg>三次握手减少了错误连接的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The typical kinds of sequence number comparisons which the TCP must perform include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021605Z" creationid="pingfangx" creationdate="20190828T021605Z">
        <seg>TCP 必须执行的典型序列号比较包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The urgent pointer points to the sequence number of the octet following the urgent data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110719Z" creationid="pingfangx" creationdate="20190827T110719Z">
        <seg>紧急指针指向紧急数据之后的八位字节的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of `onBackpressureDrop` in this case would lead to a situation where the very last click gets dropped and leaves the user wondering why the business logic wasn't executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015341Z" creationid="pingfangx" creationdate="20190624T015341Z">
        <seg>在这种情况下使用 `onBackpressureDrop` 会导致最后一次点击被删除，并会使用户疑惑为什么没有执行业务逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user in such situations probably wanted to defer some computation until the `someSource` has completed, thus the correct</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102855Z" creationid="pingfangx" creationdate="20190617T102855Z">
        <seg>在这种情况下的用户可能想要推迟一些计算，直到 `someSource` 完成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user initiates by telling the TCP to CLOSE the connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063155Z" creationid="pingfangx" creationdate="20190828T063155Z">
        <seg>用户通过告知 TCP 关闭连接来启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user who CLOSEs may continue to RECEIVE until he is told that the other side has CLOSED also.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T065845Z" creationid="pingfangx" creationdate="20190828T062634Z">
        <seg>CLOSE 的用户会继续 RECEIVE，直到他被告知另一方也已 CLOSED。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user will respond with a CLOSE, upon which the TCP can send a FIN to the other TCP after sending any remaining data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063732Z" creationid="pingfangx" creationdate="20190828T063732Z">
        <seg>用户将以 CLOSE 响应，TCP 可以在发送任何剩余数据后将 FIN 发送到另一个 TCP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then that observer reacts to whatever item or sequence of items the Observable &lt;d3&gt;emits&lt;/d3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043345Z" creationid="pingfangx" creationdate="20190620T043345Z">
        <seg>然后该观察者对 Observable &lt;d3&gt;emits (发射)&lt;/d3&gt;的数据或数据序列作出响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are 4 additional overloads of `onBackpressureBuffer`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093033Z" creationid="pingfangx" creationdate="20190621T093033Z">
        <seg>`onBackpressureBuffer` 还有 4 个额外的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also some variables used frequently in the discussion that take their values from the fields of the current segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111945Z" creationid="pingfangx" creationdate="20190827T111945Z">
        <seg>在讨论中还经常使用一些变量，这些变量从当前报文段的字报文段中获取它们的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also versions of &lt;c0&gt;ReplaySubject&lt;/c0&gt; that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085024Z" creationid="pingfangx" creationdate="20190620T085024Z">
        <seg>还有一些 &lt;c0&gt;ReplaySubject&lt;/c0&gt; 的版本，一旦重放缓冲区超过一定大小，或者自项目最初发射以来已经过了指定的时间跨度，它们将丢弃旧项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are alternative operators:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083144Z" creationid="pingfangx" creationdate="20190617T083144Z">
        <seg>还有其他可选运算符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are essentially three cases:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063148Z" creationid="pingfangx" creationdate="20190828T063148Z">
        <seg>基本上有三种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four varieties of &lt;c0&gt;Subject&lt;/c0&gt; that are designed for particular use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083734Z" creationid="pingfangx" creationdate="20190620T083734Z">
        <seg>有四种 &lt;c0&gt;Subject&lt;/c0&gt; 专为特定用例而设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many terms used to describe this model of asynchronous programming and design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045654Z" creationid="pingfangx" creationdate="20190620T045654Z">
        <seg>有许多术语用于描述这种异步编程和设计模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072833Z" creationid="pingfangx" creationdate="20190620T072833Z">
        <seg>还有其他模式，如 Builder 模式，其中特定类的各种方法对同一类的项进行操作，通过方法的操作修改该项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several strategies available (such as buffering, dropping, keeping the latest) via the `BackpressureStrategy` parameter or via standard `Flowable` operators such as `onBackpressureBuffer`, `onBackpressureDrop`, `onBackpressureLatest` which also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100520Z" creationid="pingfangx" creationdate="20190617T100520Z">
        <seg>有几种策略可用(例如缓冲，丢弃，保持最新)通过 `BackpressureStrategy` 参数或通过标准的 `Flowable` 操作符，如 `onBackpressureBuffer`，`onBackpressureDrop`，`onBackpressureLatest` 它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several ways of dealing with such situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090224Z" creationid="pingfangx" creationdate="20190621T090224Z">
        <seg>有几种方法可以处理这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021509Z" creationid="pingfangx" creationdate="20190828T021509Z">
        <seg>计算机模运算有一些细微之处，因此在对这些值的比较进行编程时应该非常小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three groups of states:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060544Z" creationid="pingfangx" creationdate="20190828T060544Z">
        <seg>有三组状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two cases for the format of an option:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110817Z" creationid="pingfangx" creationdate="20190827T110817Z">
        <seg>选项格式有两种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There exist one overload of this operator: `onBackpressureDrop(Consumer&lt;? super T&gt; onDrop)`  where the (shared) action is called with the value being dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015000Z" creationid="pingfangx" creationdate="20190624T015000Z">
        <seg>这个操作符有一个重载：`onBackpressureDrop(Consumer&lt;? super T&gt; onDrop)`，其中调用(共享)动作并删除该值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a variety that takes a &lt;a0&gt;Scheduler&lt;/a0&gt; as an argument:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075402Z" creationid="pingfangx" creationdate="20190620T075402Z">
        <seg>还有一个变种采用 &lt;a0&gt;Scheduler&lt;/a0&gt; 作为参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a version of this operator that allows you to perform the delay on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075341Z" creationid="pingfangx" creationdate="20190620T075341Z">
        <seg>还有一个此操作符的版本，允许您对特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 执行延迟：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also an instance version of this operator:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075313Z" creationid="pingfangx" creationdate="20190620T075313Z">
        <seg>还有这个操作符的实例版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no `FlowableSource` since `Publisher` is provided by the Reactive Streams library (and subtyping it wouldn't have helped with interoperation either).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104518Z" creationid="pingfangx" creationdate="20190617T104518Z">
        <seg>没有 `FlowableSource`，因为 `Publisher` 是由 Reactive Streams 库提供的(子类型化也不会有助于互操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no canonical naming standard, though there are many commonalities between implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064538Z" creationid="pingfangx" creationdate="20190620T064538Z">
        <seg>虽然实现之间存在许多共性，但没有规范的命名标准。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no error and everything runs smoothly with small memory usage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080515Z" creationid="pingfangx" creationdate="20190621T080432Z">
        <seg>这将没有错误，一切运行顺畅，内存使用量很少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, 2.0.6 introduces specific exception wrappers to help distinguish and track down what was happening the time of the error:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091015Z" creationid="pingfangx" creationdate="20190618T091015Z">
        <seg>因此，2.0.6 引入了特定的异常包装器，以帮助区分和跟踪错误发生时的情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, RxJava chose to name this operator `just(T)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101822Z" creationid="pingfangx" creationdate="20190617T101822Z">
        <seg>因此，RxJava 选择将此运算符命名为 `just(T)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if the two are swapped, the example still works the same:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082820Z" creationid="pingfangx" creationdate="20190621T082820Z">
        <seg>因此，如果两者交换，示例仍然正常工作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, many operators that required some reactive base type from the user now accept `Publisher` and `XSource`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061451Z" creationid="pingfangx" creationdate="20190618T061451Z">
        <seg>因此，许多需要用户使用某种响应基类型的运算符现在接受 `Publisher` 和 `XSource`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, one should do all field initialization in `onStart` or even before that and call `request()` last.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083947Z" creationid="pingfangx" creationdate="20190621T083947Z">
        <seg>因此，应该在 `onStart` 中甚至在此之前进行所有字段初始化，并最后调用 `request()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the following sequence won't call `doOnCancel`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115027Z" creationid="pingfangx" creationdate="20190618T115027Z">
        <seg>因此，以下序列不会调用 `doOnCancel`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071736Z" creationid="pingfangx" creationdate="20190620T071736Z">
        <seg>这些 Rx 操作符允许您以声明方式组合异步序列，它具有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are available on all JVM platforms but some specific platforms, such as Android, have their own typical `Scheduler`s defined: `AndroidSchedulers.mainThread()`, `SwingScheduler.instance()` or `JavaFXSchedulers.gui()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073609Z" creationid="pingfangx" creationdate="20190617T073609Z">
        <seg>这些在所有 JVM 平台上都可用，但某些特定平台（如 Android）有自己典型的 `Scheduler`：`AndroidSchedulers.mainThread()`，`SwingScheduler.instance()` 或 `JavaFXSchedulers.gui()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are by themselves worthy of a full series so let's see some very basic `Iterable` source that repeats some constant value indefinitely:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020455Z" creationid="pingfangx" creationdate="20190624T020455Z">
        <seg>这些本身就值得一个完整的系列，所以让我们看一些非常基本的 `Iterable` 源，它无限地重复一些常量值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are usually named with the suffix of the target type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100713Z" creationid="pingfangx" creationdate="20190617T100713Z">
        <seg>这些通常以目标类型的后缀命名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These instruct the operator to do some or all of its work on a particular Scheduler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085827Z" creationid="pingfangx" creationdate="20190620T085827Z">
        <seg>这会指示操作符在特定的调度器上完成部分或全部工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These interfaces are, however, not standard in the sense of the Reactive Streams specification and are currently RxJava specific only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104540Z" creationid="pingfangx" creationdate="20190617T104540Z">
        <seg>但是，这些接口在 Reactive Streams 规范的意义上并不是标准的，并且目前仅针对 RxJava。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET “SelectMany” operator links to the documentation of the &lt;s0&gt;FlatMap&lt;/s0&gt; ReactiveX operator, of which “SelectMany” is the Rx.NET implementation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094320Z" creationid="pingfangx" creationdate="20190620T094320Z">
        <seg>这些链接到记录核心操作符的页面，该核心操作符最类似于特定于语言的操作符（例如，Rx.NET “SelectMany” 操作符链接到 &lt;s0&gt;FlatMap&lt;/s0&gt; ReactiveX 操作符的文档，其中“SelectMany”是 Rx.NET 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods allow only a single resource to be associated with the emitter at a time and setting a new one unsubscribes the old one automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022745Z" creationid="pingfangx" creationdate="20190624T022745Z">
        <seg>这些方法一次只允许一个源与 emitter 相关联，并且设置一个新资源会自动取消订阅旧资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072226Z" creationid="pingfangx" creationdate="20190620T072226Z">
        <seg>这些页面包含的一些操作符的信息，这些操作符不属于 ReactiveX 的核心，而是在一个或多个特定于语言的实现和/或可选模块中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These patterns also allow you to chain the methods in a similar way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072842Z" creationid="pingfangx" creationdate="20190620T072842Z">
        <seg>这些模式也允许您以类似的方式链接方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are naturally efficient because they execute when the response is ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041028Z" creationid="pingfangx" creationdate="20190620T041028Z">
        <seg>它们自然有效，因为它们在响应准备就绪时执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are purely to allow broad testing and feedback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105331Z" creationid="pingfangx" creationdate="20190617T105331Z">
        <seg>它们纯粹是为了进行广泛的测试和反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be modified in any way, or even removed, at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105240Z" creationid="pingfangx" creationdate="20190617T105240Z">
        <seg>它们可以随时以任何方式进行修改，甚至可以删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They will have different group ids (`io.reactivex.rxjava2` vs `io.reactivex`) and namespaces (`io.reactivex` vs `rx`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065528Z" creationid="pingfangx" creationdate="20190617T065528Z">
        <seg>他们将拥有不同的组 ID (`io.reactivex.rxjava2` vs `io.reactivex`) 和名称空间 (`io.reactivex` vs `rx`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;a1&gt;can be done&lt;/a1&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;c2&gt;Future.get()&lt;/c2&gt;, which eliminates the benefit of asynchronous execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035327Z" creationid="pingfangx" creationdate="20190620T035327Z">
        <seg>当然，这 &lt;a1&gt;可以实现&lt;/a1&gt;，但它很快变得复杂(因而容易出错)或者过早地阻塞了 &lt;c2&gt;Future.get()&lt;/c2&gt;，这消除了异步执行的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This Scheduler has three additional methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091825Z" creationid="pingfangx" creationdate="20190620T091825Z">
        <seg>此调度器还有三种方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows constraining the memory usage of the dataflows in situations where there is generally no way for a step to know how many items the upstream will send to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071409Z" creationid="pingfangx" creationdate="20190617T071409Z">
        <seg>这允许在通常无法知道上游将向其发送多少项的步骤的情况下约束数据流的存储器使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows creating stream consumers with less internal state than the quite heavy `rx.Subscriber` of 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065453Z" creationid="pingfangx" creationdate="20190618T065453Z">
        <seg>这允许创建具有比 1.x 的非常重​​的 `rx.Subscriber` 更少的内部状态的流消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows for efficient execution and composition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041859Z" creationid="pingfangx" creationdate="20190620T041859Z">
        <seg>这些操作符让执行和复合变得非常高效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to apply these operators one after the other, in a chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072332Z" creationid="pingfangx" creationdate="20190620T072332Z">
        <seg>这允许您在链中一个接一个地应用这些操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025324Z" creationid="pingfangx" creationdate="20190828T025324Z">
        <seg>仅这一点并不能保证从网络中排出旧的重复数据，因此序列空间已经非常大，以减少流浪复制品在到达时会造成麻烦的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is more flexible, because values can arrive synchronously or asynchronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042157Z" creationid="pingfangx" creationdate="20190620T042157Z">
        <seg>这种方法更灵活，因为值可以同步或异步到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior differs from 1.x where a `request` call went through a deferred logic that accumulated requests until an upstream `Producer` arrived at some time (This nature adds overhead to all operators and consumers in 1.x.) In 2.x, there is always a `Subscription` coming down first and 90% of the time there is no need to defer requesting.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072117Z" creationid="pingfangx" creationdate="20190618T072117Z">
        <seg>这种行为不同于 1.x，其中 `request` 调用通过延迟逻辑累积请求，直到上游 `Producer` 在某个时间到达(这种性质增加了 1.x 中所有运算符和消费者的开销)。在 2.x 中，总是有一个 `Subscription` 首先出现，90% 的时间不需要延迟请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This callback is executed as many times as the downstream requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021228Z" creationid="pingfangx" creationdate="20190624T021228Z">
        <seg>此回调的执行次数与下游请求的次数相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be achieved by moving the outer `flatMap` into the inner parts of the previous `flatMap` for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083752Z" creationid="pingfangx" creationdate="20190617T083752Z">
        <seg>这可以通过将外部 `flatMap` 移动到前一个 `flatMap` 的内部部分来实现，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be used, for example, to have a larger but still fixed pool of threads (unlike `computation()` and `io()` respectively).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073827Z" creationid="pingfangx" creationdate="20190617T073827Z">
        <seg>例如，这可用于拥有更大但仍然固定的线程池(分别与 `calculation()` 和 `io()` 不同)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful for testing interactions that depend on precise arrangements of actions in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091822Z" creationid="pingfangx" creationdate="20190620T091822Z">
        <seg>这对于测试依赖于及时精确的动作安排的交互是有用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful in some telemetry-like situations where the data may come in some bursty pattern but only the very latest is interesting for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015225Z" creationid="pingfangx" creationdate="20190624T015225Z">
        <seg>这在类似遥测的情况下非常有用，在这种情况下，数据可能会以某种突发模式出现，但只有最新的数据才会对处理感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can get also ambiguous when functional interface types get involved as the type argument `T`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103113Z" creationid="pingfangx" creationdate="20190617T103113Z">
        <seg>当函数接口类型作为类型参数 `T` 参与时，这也会变得有歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can have the effect of making the resulting Subject a “hot” Observable variant of the original “cold” Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083654Z" creationid="pingfangx" creationdate="20190620T083654Z">
        <seg>这可以使得到的 Subject 成为原始“冷” Observable 的“热” Observable 变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This diagram explains how Singles are represented in marble diagrams:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075156Z" creationid="pingfangx" creationdate="20190620T075156Z">
        <seg>此图解释了 Single 如何在 marble 图中表示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This division allows for the existence of host level protocols other than TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104752Z" creationid="pingfangx" creationdate="20190827T104752Z">
        <seg>这种划分允许存在除 TCP 之外的主机级协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document will use the following terms: An &lt;d0&gt;observer&lt;/d0&gt; &lt;d1&gt;subscribes&lt;/d1&gt; to an &lt;d2&gt;Observable&lt;/d2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045732Z" creationid="pingfangx" creationdate="20190620T045732Z">
        <seg>本文档将使用以下术语：&lt;d0&gt;observer (观察者)&lt;/d0&gt; &lt;d1&gt;subscribes (订阅)&lt;/d1&gt; 到 &lt;d2&gt;Observable (可观察对象)&lt;/d2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation accompanies its explanations with “marble diagrams.” Here is how marble diagrams represent Observables and transformations of Observables:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044318Z" creationid="pingfangx" creationdate="20190620T044318Z">
        <seg>本文档的说明会带有“marble 图”。以下是 marble 图如何表示 Observables 的 Observables 的转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation groups information about &lt;a0&gt;the various operators&lt;/a0&gt; and examples of their usage into the following pages:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071815Z" creationid="pingfangx" creationdate="20190620T071815Z">
        <seg>本文档将有关 &lt;a0&gt;各种操作符&lt;/a0&gt; 的信息及其用法示例分组到以下页面中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example flow squares the numbers from 1 to 10 on the **computation** `Scheduler` and consumes the results on the "main" thread (more precisely, the caller thread of `blockingSubscribe`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075535Z" creationid="pingfangx" creationdate="20190617T075535Z">
        <seg>这个示例流在 **computation** `Scheduler` 上将数字 1 到 10 计算平方，并在 "main" 线程上消费结果(更确切地说，是 `blockingSubscribe` 的调用者线程)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110702Z" creationid="pingfangx" creationdate="20190827T110702Z">
        <seg>该字段将紧急指针的当前值传递为该报文段中序列号的正偏移量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This field is only be interpreted in segments with the URG control bit set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110733Z" creationid="pingfangx" creationdate="20190827T110733Z">
        <seg>该字段仅在设置了 URG 控制位的报文段中进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the TCP protection against misrouted segments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110215Z" creationid="pingfangx" creationdate="20190827T110215Z">
        <seg>这为 TCP 提供了针对错误路由的报文段的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This handler can be overridden with the method `RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090229Z" creationid="pingfangx" creationdate="20190618T090229Z">
        <seg>可以使用方法 `RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)` 覆盖此处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the consequence that even a backpressure-supporting source such as `range` will be completely realized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093127Z" creationid="pingfangx" creationdate="20190621T093030Z">
        <seg>这样的结果是，即使是一个支持背压的源，如 `range` ，也将完全 realized。（译注：不知道怎么译）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This indicates where the data begins.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105250Z" creationid="pingfangx" creationdate="20190827T105250Z">
        <seg>这表示数据的起始位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110405Z" creationid="pingfangx" creationdate="20190827T110405Z">
        <seg>此信息在 IP 协议中承载，并通过 TCP / 网络接口在 IP 上的 TCP 调用的参数或结果中传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface is lightweight and combines request management with cancellation into a single interface `org.reactivestreams.Subscription` instead of having `rx.Producer` and `rx.Subscription` separately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065405Z" creationid="pingfangx" creationdate="20190618T065405Z">
        <seg>这个接口是轻量级的，它将请求管理和取消组合到单个接口 `org.reactivestreams.Subscription` 中，而不是单独使用 `rx.Producer` 和 `rx.Subscription`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a bounded version that signals `BufferOverflowError`in case its buffer reaches the given capacity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093138Z" creationid="pingfangx" creationdate="20190621T093138Z">
        <seg>这是一个有界版本，在其缓冲区达到给定容量的情况下发出 `BufferOverflowError` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a large convenience for consumers and mappers that otherwise throw and would need `try-catch` to transform or suppress a checked exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064255Z" creationid="pingfangx" creationdate="20190618T064255Z">
        <seg>这对于消费者和映射器来说是一个很大的便利，否则会抛出并且需要 `try-catch` 来转换或抑制检查型异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a temporary state when `subscribe()` is called on a flow that establishes the chain of processing steps internally:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072138Z" creationid="pingfangx" creationdate="20190617T071850Z">
        <seg>当在内部建立处理步骤链的流上调用 `subscribe()` 时，这是一个临时状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T035131Z" creationid="pingfangx" creationdate="20190828T022537Z">
        <seg>这是通过在序列空间中隐含地包括一些控制标志来实现的，这样它们可以被重传和确认而不会混淆(即，控制位的一个且仅一个副本将被作用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an engineering choice, and may be changed if experience indicates it is desirable to do so.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024425Z" creationid="pingfangx" creationdate="20190828T024425Z">
        <seg>这是一种工程选择，如果经验表明需要这样做，可能会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done in an exchange of connection establishing segments carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023657Z" creationid="pingfangx" creationdate="20190828T023657Z">
        <seg>这是在交换连接建立报文段间完成的，该报文段带有称为“SYN”(表示 synchronize)的控制位和初始序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is illustrated in figure 11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060215Z" creationid="pingfangx" creationdate="20190828T060215Z">
        <seg>这在图 11 中说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064500Z" creationid="pingfangx" creationdate="20190620T064500Z">
        <seg>但是，这并不能保证立即发生，即使在没有观察者观察这些发射之后，Observable 也有可能在一段时间内产生并尝试发射数据项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often more apparent when each element is written on a separate line:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071017Z" creationid="pingfangx" creationdate="20190617T071017Z">
        <seg>当每个元素写在一个单独的行上时，这通常更明显：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is sometimes called **continuations** and, depending on what should happen and what types are involved, may involve various operators to accomplish.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083603Z" creationid="pingfangx" creationdate="20190617T083603Z">
        <seg>这有时被称为 **continuations** ，并且取决于应该发生什么以及涉及什么类型，可能涉及各种操作符来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the state when the flows are actively emitting items, errors or completion signals:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072024Z" creationid="pingfangx" creationdate="20190617T072024Z">
        <seg>这是流主动发出项目，错误或完成信号时的状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the true power of lazily evaluating and computing inside `Flowable`s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020651Z" creationid="pingfangx" creationdate="20190624T020651Z">
        <seg>这是 `Flowable` 内部的懒评估和计算的真正力量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very important because now any operation you can perform on an Iterable, you can also perform on an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042520Z" creationid="pingfangx" creationdate="20190620T042520Z">
        <seg>这非常重要，因为现在您可以在 Iterable 上执行的任何操作，都可以在 Observable 上执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is when the **subscription side-effects** are triggered (see `doOnSubscribe`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072144Z" creationid="pingfangx" creationdate="20190617T071932Z">
        <seg>这是 **subscription side-effects (订阅副作用)** 的触发时机(参见 `doOnSubscribe`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means errors that can't be emitted because the downstream's lifecycle already reached its terminal state or the downstream cancelled a sequence which was about to emit an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090043Z" creationid="pingfangx" creationdate="20190618T090043Z">
        <seg>这意味着无法发出的错误，因为下游的生命周期已达到其终端状态，或者下游取消了将要发出错误的序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that `Observable&lt;Void&gt;` can no longer emit any values but only terminate normally or with an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052823Z" creationid="pingfangx" creationdate="20190618T052823Z">
        <seg>这意味着 `Observable&lt;Void&gt;` 不能再发出任何值，只能正常终止或带异常终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that an invocation of `onSubscribe(Disposable)` is potentially followed by one of the other `onXXX` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060840Z" creationid="pingfangx" creationdate="20190618T060840Z">
        <seg>这意味着 `onSubscribe(Disposable)` 的调用可能跟随其他 `onXXX` 方法之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism allows for straight-forward duplicate detection in the presence of retransmission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021057Z" creationid="pingfangx" creationdate="20190828T021057Z">
        <seg>该机制允许在存在重传的情况下进行直接重复检测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method takes as a parameter the item emitted by the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060250Z" creationid="pingfangx" creationdate="20190620T060250Z">
        <seg>此方法将 Observable 发射的项作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This module adds the minimum classes to RxJava that make writing reactive components in Android applications easy and hassle-free.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T030011Z" creationid="pingfangx" creationdate="20190624T030011Z">
        <seg>该模块为 RxJava 添加了最小类，使得在 Android 应用程序中编写响应组件变得轻松无忧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This negotiation is based on the computer science concept of co-routines (I call you, you call me).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081011Z" creationid="pingfangx" creationdate="20190621T081011Z">
        <seg>这个谈判是基于计算机科学的 co-routines (译注：协程？)概念(我调用你，你调用我)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator in its parameterless form reintroduces an unbounded buffer between the upstream source and the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092414Z" creationid="pingfangx" creationdate="20190621T092414Z">
        <seg>此操作符以无参数形式在上游源和下游操作符之间重新引入无边界缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator is useful when one can safely ignore values from a source (such as mouse moves or current GPS location signals) as there will be more up-to-date values later on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014819Z" creationid="pingfangx" creationdate="20190624T014819Z">
        <seg>当可以安全地忽略来自源的值(例如鼠标移动或当前 GPS 位置信号)时，此操作符非常有用，因为稍后会有更多的最新值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This overload calls a (shared) action in case an overflow happens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093437Z" creationid="pingfangx" creationdate="20190621T093437Z">
        <seg>如果发生溢出，此重载会调用(共享)操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This overload is actually more useful as it let's one define what to do in case the capacity has been reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093534Z" creationid="pingfangx" creationdate="20190621T093534Z">
        <seg>这种重载实际上更有用，因为我们可以定义在达到容量时要做什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043840Z" creationid="pingfangx" creationdate="20190620T043840Z">
        <seg>这个页面解释了什么是响应模式(reactive pattern)？以及什么是可观察对象(Observables)和观察者(observers)？(以及观察者如何订阅 Observables)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page first lists what could be considered the “core” operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094045Z" creationid="pingfangx" creationdate="20190620T094045Z">
        <seg>该页面首先列出了可以被视为 ReactiveX 中的“核心”操作符的内容，以及指向这些页面的链接，这些页面具有关于这些操作符如何工作以及特定语言特定的 ReactiveX 版本如何实现这些操作符的更深入信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T052909Z" creationid="pingfangx" creationdate="20190620T052909Z">
        <seg>此页面使用类似 Groovy 的伪代码作为示例，但在许多语言中都有 ReactiveX 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043646Z" creationid="pingfangx" creationdate="20190620T043534Z">
        <seg>这种模式有利于并发操作，因为它不需要在等待 Observable 发射对象时阻塞，而是以观察者的形式创建一个哨兵，随时准备在 Observable 发射对象做出适当的反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This procedure normally is initiated by one TCP and responded to by another TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030758Z" creationid="pingfangx" creationdate="20190828T030758Z">
        <seg>此过程通常由一个 TCP 启动，并由另一个 TCP 响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110137Z" creationid="pingfangx" creationdate="20190827T110137Z">
        <seg>此伪首部包含源地址，目标地址，协议和 TCP 长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scenario leads to the example shown in figure 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055834Z" creationid="pingfangx" creationdate="20190828T055834Z">
        <seg>该场景导致图 10 中所示的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be backwards compatible but does behave differently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105035Z" creationid="pingfangx" creationdate="20190617T105035Z">
        <seg>这应该是向后兼容的，但表现不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This space ranges from 0 to 2**32 - 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021253Z" creationid="pingfangx" creationdate="20190828T021253Z">
        <seg>此空间范围为 0 到 2**32 - 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification provides that hosts which "crash" without retaining any knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed Maximum Segment Lifetime (MSL) in the internet system of which the host is a part.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024647Z" creationid="pingfangx" creationdate="20190828T024642Z">
        <seg>该规范规定，在不保留每个活动(即非关闭)连接上发送的最后序列号的任何知识的情况下“崩溃”的主机应至少延迟发送任何 TCP 报文段，以便至少在主机是其中的一部分的互联网系统中达成协议的最大报文段寿命(MSL)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This style of chaining methods is called a **fluent API** which resembles the **builder pattern**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072620Z" creationid="pingfangx" creationdate="20190617T072620Z">
        <seg>这种链式方法称为 **fluent API (流式 API)**，类似于 **builder pattern (建造者模式)**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tree can help you find the ReactiveX Observable operator you’re looking for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103812Z" creationid="pingfangx" creationdate="20190620T103812Z">
        <seg>此树可以帮助你找到你正在寻找的 ReactiveX Observable 操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2**32 - 1 to 0 again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021450Z" creationid="pingfangx" creationdate="20190828T021450Z">
        <seg>这个无符号算术保留了序列号的关系，因为它们再次从 2**32 - 1 循环到 0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variant allows cleaning up the values themselves (e.g., releasing associated resources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015008Z" creationid="pingfangx" creationdate="20190624T015008Z">
        <seg>该变体允许清除值本身(例如，释放相关资源)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was practically unnecessary and the Reactive-Streams specification states that when a terminal event arrives at a `Subscriber`, the upstream `Subscription` should be considered cancelled and thus calling `cancel()` is a no-op.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114952Z" creationid="pingfangx" creationdate="20190618T114952Z">
        <seg>这实际上是不必要的，Reactive-Streams 规范声明当终端事件到达 `Subscriber` 时，上游的 `Subscription` 应被视为取消，因此调用 `cancel()` 是无操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wiki page attempts to summarize what has changed and describes how to rewrite 1.x code into 2.x code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051858Z" creationid="pingfangx" creationdate="20190618T051858Z">
        <seg>此 Wiki 页面试图总结已更改的内容，并描述如何将 1.x 代码重写为 2.x 代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will print:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071625Z" creationid="pingfangx" creationdate="20190618T071625Z">
        <seg>这将打印：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This, too, has a &lt;a0&gt;Scheduler&lt;/a0&gt;-specific version:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T080543Z" creationid="pingfangx" creationdate="20190620T080543Z">
        <seg>这也有一个 &lt;a0&gt;Scheduler&lt;/a0&gt; 特定版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those APIs feature some form of `addListener`/`removeListener` calls that one can utilize:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022400Z" creationid="pingfangx" creationdate="20190624T022400Z">
        <seg>这些 API 具有某种形式的 `addListener`/`removeListener` 调用，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061715Z" creationid="pingfangx" creationdate="20190620T061715Z">
        <seg>那些 Observable 可以(如果他们没有其他感兴趣的观察者)选择停止生成要发射的新项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those return a "global" scheduler instance whereas `test()` returned always a new instance of the `TestScheduler`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093740Z" creationid="pingfangx" creationdate="20190618T093740Z">
        <seg>那些返回“全局”调度器实例，而 `test()` 总是返回 `TestScheduler` 的新实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that have a particular default Scheduler include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091455Z" creationid="pingfangx" creationdate="20190620T091455Z">
        <seg>具有特定默认调度器的包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those who are using Mockito and mocked `Observer` in 1.x has to mock the `Subscriber.onSubscribe` method to issue an initial request, otherwise, the sequence will hang or fail with hot sources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101902Z" creationid="pingfangx" creationdate="20190618T101902Z">
        <seg>那些在 1.x 中使用 Mockito 并模拟 `Observer` 的人必须模拟 `Subscriber.onSubscribe` 方法来发出初始请求，否则，序列将因热源而挂起或失败：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a program could initiate several SENDs followed by a CLOSE, and then continue to RECEIVE until signaled that a RECEIVE failed because the other side has CLOSED.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062737Z" creationid="pingfangx" creationdate="20190828T062737Z">
        <seg>因此，一个程序可以启动几个 SEND，然后是 CLOSE，然后继续 RECEIVE，直到发出 RECEIVE 失败，因为另一方已经 CLOSED。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, it is be possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022457Z" creationid="pingfangx" creationdate="20190828T022457Z">
        <seg>因此，TCP 可以在发送数据和接收 ACK 时保持零接收窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the ISN cycles approximately every 4.55 hours.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023344Z" creationid="pingfangx" creationdate="20190828T023344Z">
        <seg>因此，ISN 大约每 4.55 小时循环一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075639Z" creationid="pingfangx" creationdate="20190620T075639Z">
        <seg>如果订阅后某个项目在指定的时间段内未发射该项目，则超时将导致 Single 中止并发射错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow having RxJava 1.x and RxJava 2.x side-by-side, RxJava 2.x is under the maven coordinates `io.reactivex.rxjava2:rxjava:2.x.y` and classes are accessible below `io.reactivex`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052632Z" creationid="pingfangx" creationdate="20190618T052632Z">
        <seg>为了允许 RxJava 1.x 和 RxJava 2.x 共存，RxJava 2.x 位于 maven 坐标 `io.reactivex.rxjava2:rxjava:2.x.y` 下，类可以在 `io.reactivex 下面访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid confusion we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023244Z" creationid="pingfangx" creationdate="20190828T023244Z">
        <seg>为了避免混淆，我们必须防止使用来自连接的一个化身的报文段，而相同的序列号可能仍然存在于早期化身的网络中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid overwhelming such steps, which usually would manifest itself as increased memory usage due to temporary buffering or the need for skipping/dropping data, a so-called backpressure is applied, which is a form of flow control where the steps can express how many items are they ready to process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071348Z" creationid="pingfangx" creationdate="20190617T071348Z">
        <seg>为了避免 overwhelming 这些步骤，通常表现为由于临时缓冲或需要跳过/丢弃数据而增加内存，所以应用所谓的背压，这是流量控制的一种形式，其中步骤可以表达多少项目准备好了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the name clash, the 1.x `rx.Subscription` has been renamed into `io.reactivex.Disposable` (somewhat resembling .NET's own IDisposable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072820Z" creationid="pingfangx" creationdate="20190618T072820Z">
        <seg>为避免名称冲突，1.x 的 `rx .Subscription` 已重命名为 `io .reactivex .Disposable`(有点类似于 .NET 自己的 IDisposable)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this situation, make sure you call `request` **after** all initialization have been done in `onSubscribe`/`onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071838Z" creationid="pingfangx" creationdate="20190618T071838Z">
        <seg>为了避免这种情况，请确保在 `onSubscribe`/`onStart` 中完成所有初始化 **之后** 调用 `request`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024412Z" creationid="pingfangx" creationdate="20190828T024412Z">
        <seg>为了确保 TCP 不会创建一个带有序列号的报文段，该报文段可能被网络中剩余的旧报文段复制，TCP 必须在启动时分配任何序列号之前保持安静，以获得最大报文段寿命(MSL)。或从崩溃中恢复，其中使用的序列号的内存丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To bridge the gap we defined abstract classes `DefaultSubscriber`, `ResourceSubscriber` and `DisposableSubscriber` (plus their `XObserver` variants) for `Flowable` (and `Observable`) respectively that offers resource tracking support (of `Disposable`s) just like `rx.Subscriber` and can be cancelled/disposed externally via `dispose()`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070302Z" creationid="pingfangx" creationdate="20190618T070302Z">
        <seg>为弥合这一差距，我们分别为 `Flowable`(和 `Observable`)定义了抽象类 `DefaultSubscriber`，`ResourceSubscriber` 和 `DisposableSubscriber`(加上它们的 `XObserver` 变体)，提供了资源跟踪支持(`Disposable`)就像 `rx.Subscriber` 一样，并可以通过 `dispose()` 从外部取消/处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105603Z" creationid="pingfangx" creationdate="20190617T105603Z">
        <seg>要构建：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To deal with this, a special control message, reset, has been devised.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042505Z" creationid="pingfangx" creationdate="20190828T042505Z">
        <seg>为了解决这个问题，我们设计了一个特殊的控制消息 reset。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle such cases, RxJava has the `generate` factory method family.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021012Z" creationid="pingfangx" creationdate="20190624T021012Z">
        <seg>为了处理这种情况，RxJava 有 `generate` 工厂方法系列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle such cases, a recent version of RxJava introduced the `create(emitter)` factory method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021719Z" creationid="pingfangx" creationdate="20190624T021719Z">
        <seg>为了处理这种情况，最新版本的 RxJava 引入了 `create(emitter)` 工厂方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate, the example can be rewritten as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072726Z" creationid="pingfangx" creationdate="20190617T072726Z">
        <seg>为了说明，该示例可以重写如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate this opportunity, many operator names are suffixed with the `DelayError` words (while others feature a `delayError` or `delayErrors` boolean flag in one of their overloads):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103545Z" creationid="pingfangx" creationdate="20190617T103545Z">
        <seg>为了表明这个机会，许多运算符名称后缀为 `DelayError` (而其他运算符名称在其中一个重载中具有 `delayError` 或 `delayErrors` 布尔标志)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make sure the final API of 2.0 is clean as possible, we remove methods and other components between release candidates without deprecating them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061528Z" creationid="pingfangx" creationdate="20190619T061528Z">
        <seg>为了确保 2.0 的最终 API 尽可能干净，我们在发布候选版本之间删除方法和其他组件而不弃用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent this, operators use so-called trampolining logic that prevents such reentrant calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082411Z" creationid="pingfangx" creationdate="20190621T082411Z">
        <seg>为了防止这种情况，操作符使用所谓的 trampolining 逻辑来阻止这种可重入的调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remedy this, the method `E subscribeWith(E subscriber)` has been added to each base reactive class which returns its input subscriber/observer as is.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070729Z" creationid="pingfangx" creationdate="20190618T070729Z">
        <seg>为了解决这个问题，方法 `E subscribeWith(E subscriber)` 被添加到每个基本响应类中，该方法按原样返回其输入的订阅者/观察者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To schedule recursive calls, you can use &lt;c0&gt;schedule&lt;/c0&gt; and then &lt;c1&gt;schedule(this)&lt;/c1&gt; on the Worker object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092138Z" creationid="pingfangx" creationdate="20190620T092138Z">
        <seg>要调度递归调用，可以在 Worker 对象上使用 &lt;c0&gt;schedule&lt;/c0&gt; 然后 &lt;c1&gt;schedule(this)&lt;/c1&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are "busy" or "in use" until MSL seconds have passed, upon crashing a block of space-time is occupied by the octets of the last emitted segment, if a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of the last segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030223Z" creationid="pingfangx" creationdate="20190828T030223Z">
        <seg>总结一下：发射的每个报文段都占用了序列空间中的一个或多个序列号，报文段中占用的数字是“忙”或“正在使用”，直到 MSL 秒已经过去，一旦最后一个发射报文段的八位字节位所占用空间的块崩溃了，如果新连接过早启动并使用前一个连接化身的最后一个报文段的空时足迹中的任何序列号，则存在潜在的序列号重叠区域，这可能导致在接收器端的混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support our internal testing, all base reactive types now feature `test()` methods (which is a huge convenience for us) returning `TestSubscriber` or `TestObserver`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095836Z" creationid="pingfangx" creationdate="20190618T095836Z">
        <seg>为了支持我们的内部测试，所有基本响应类型现在都有 `test()` 方法(这对我们来说非常方便)返回 `TestSubscriber` 或 `TestObserver`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transforming Observable Items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071854Z" creationid="pingfangx" creationdate="20190620T071854Z">
        <seg>转换 Observable 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transforming Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095411Z" creationid="pingfangx" creationdate="20190620T095411Z">
        <seg>转换 Observables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transmission Control Protocol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041849Z" creationid="pingfangx" creationdate="20190828T041849Z">
        <seg>Transmission Control Protocol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you can move computations or blocking IO to some other thread via `subscribeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072819Z" creationid="pingfangx" creationdate="20190617T072819Z">
        <seg>通常，您可以通过 `subscribeOn` 将计算或阻塞 IO 移动到其他线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URG:  Urgent Pointer field significant</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105358Z" creationid="pingfangx" creationdate="20190827T105358Z">
        <seg>URG：指明紧急指针字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under normal conditions, TCPs keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly using a sequence number over before its first use has been acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025301Z" creationid="pingfangx" creationdate="20190828T025301Z">
        <seg>在正常情况下，TCP 会跟踪要发射的下一个序列号和最旧的等待确认，以避免在第一次使用确认之前错误地使用序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, RxJava can't tell which of these out-of-lifecycle, undeliverable exceptions should or shouldn't crash your app.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090909Z" creationid="pingfangx" creationdate="20190618T090909Z">
        <seg>不幸的是，RxJava 无法分辨这些生命周期中的哪些，无法传递的异常应该或不应该使您的应用程序崩溃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, `just` is often mistaken for a way to compute something dynamically to be consumed by `Subscriber`s:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015754Z" creationid="pingfangx" creationdate="20190624T015722Z">
        <seg>不幸的是，`just` 经常被误认为是一种供订阅者使用的动态计算东西的方式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, many method calls across the JVM and other libraries throw checked exceptions and need to be wrapped into `try-catch`es as the functional interfaces used by this class don't allow throwing checked exceptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021458Z" creationid="pingfangx" creationdate="20190624T021458Z">
        <seg>不幸的是，JVM 和其他库中的许多方法调用抛出了检查型异常，需要将其包装到 `try-catch` 中，因为此类使用的函数接口不允许抛出检查型异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, so many depend on it that we couldn't remove or rename it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094311Z" creationid="pingfangx" creationdate="20190618T094311Z">
        <seg>不幸的是，很多人依赖它，我们无法移除或重命名它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, the target language (and pre-existing conventions) may not give too much help in this regard (unusable keywords, type erasure, type ambiguities, etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101401Z" creationid="pingfangx" creationdate="20190617T101401Z">
        <seg>不幸的是，目标语言(以及预先存在的约定)在这方面可能不会提供太多帮助(不可用的关键字，类型擦除，类型歧义等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this approach doesn't work and the example does not print `2` at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102539Z" creationid="pingfangx" creationdate="20190617T102539Z">
        <seg>不幸的是，这种方法不起作用，该示例根本不打印 `2`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this prints `0` because `Single.just(count.get())` is evaluated at **assembly time** when the dataflow hasn't even run yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092426Z" creationid="pingfangx" creationdate="20190617T092324Z">
        <seg>不幸的是，这会输出 `0`，`Single.just(count.get())` 计算于 **assembly time**，数据流尚未运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, usually, these classical callback-style APIs don't support cancellation, but if they do, one can setup their cancellation just like in the previoius examples (with perhaps a more involved way though).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T023047Z" creationid="pingfangx" creationdate="20190624T023047Z">
        <seg>不幸的是，通常，这些经典的回调式 API 不支持取消，但是如果它们这样支持，就可以像在上一示例中那样设置取消(尽管可能采用更复杂的方式)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike `Flowable`, if there is only a single value to be signalled, only `onSuccess` is called and `onComplete` is not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060927Z" creationid="pingfangx" creationdate="20190618T060927Z">
        <seg>与 `Flowable` 不同，如果只有一个值要发出信号，则只调用 `onSuccess` 而不调用 `onComplete`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike `onBackpressureDrop` there is always a value available for consumption if the downstream happened to be lagging behind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015151Z" creationid="pingfangx" creationdate="20190624T015151Z">
        <seg>与 `onBackpressureDrop` 不同，如果下游恰好落后，总有一个值可供消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsubscribing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061437Z" creationid="pingfangx" creationdate="20190620T061437Z">
        <seg>取消订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon calling either method, the Single terminates and the subscription to it ends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073823Z" creationid="pingfangx" creationdate="20190620T073823Z">
        <seg>在调用任一方法时，Single 终止并且对它的订阅结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use `Schedulers.trampoline()` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093614Z" creationid="pingfangx" creationdate="20190618T093614Z">
        <seg>请改用 `Schedulers.trampoline()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use `safeSubscribe` to get an explicit safety wrapper around a consumer type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053814Z" creationid="pingfangx" creationdate="20190619T053814Z">
        <seg>使用 `safeSubscribe` 获取消费者类型的显式安全包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use that variable and its new value to do something useful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053026Z" creationid="pingfangx" creationdate="20190620T053026Z">
        <seg>使用该变量及其新值来做一些有用的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users must keep reading connections they close for sending until the TCP says no more data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063142Z" creationid="pingfangx" creationdate="20190828T063142Z">
        <seg>用户必须继续读取他们关闭发送的连接，直到 TCP 说不再有数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users switching from 1.x to 2.x have to re-organize their imports, but carefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052645Z" creationid="pingfangx" creationdate="20190618T052645Z">
        <seg>从 1.x 切换到 2.x 的用户必须重新组织他们的导入，但要小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091922Z" creationid="pingfangx" creationdate="20190620T091922Z">
        <seg>使用调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using `Observable` has lower overhead in general than `Flowable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054816Z" creationid="pingfangx" creationdate="20190618T054816Z">
        <seg>使用 `Observable` 通常比 `Flowable' 具有更低的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utility Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072003Z" creationid="pingfangx" creationdate="20190620T072003Z">
        <seg>辅助操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Varieties of Scheduler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090908Z" creationid="pingfangx" creationdate="20190620T090908Z">
        <seg>调度器的种类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Varieties of Subject</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083727Z" creationid="pingfangx" creationdate="20190620T083727Z">
        <seg>Subject 的种类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 1.x will be supported for several years along with 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104654Z" creationid="pingfangx" creationdate="20190617T104654Z">
        <seg>版本 1.x 将与 2.x 一起支持多年。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 2.x and 1.x will live side-by-side for several years.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065457Z" creationid="pingfangx" creationdate="20190617T065457Z">
        <seg>版本 2.x 和 1.x 将并存数年。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 2.x is now considered stable and final.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104650Z" creationid="pingfangx" creationdate="20190617T104650Z">
        <seg>版本 2.x 现在被认为是稳定且最终的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume that the TCP will signal a user, even if no RECEIVEs are outstanding, that the other side has closed, so the user can terminate his side gracefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062904Z" creationid="pingfangx" creationdate="20190828T062904Z">
        <seg>我们假设 TCP 将向用户发出信号，即使没有 RECEIVE 是未完成的，另一方已关闭，因此用户可以优雅地终止他的一方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can distinguish two kinds of factory methods: cold "generators" that either return and generate elements based on downstream demand and hot "pushers" that usually bridge non-reactive and/or non-backpressurable data sources and layer some backpressure handling on top of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015614Z" creationid="pingfangx" creationdate="20190624T015614Z">
        <seg>我们可以区分两种工厂方法：基于下游需求返回和生成元素的冷“generators”和通常桥接非响应和/或非背压数据源并在他们上面层叠一些背压处理的热“pushers”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111441Z" creationid="pingfangx" creationdate="20190827T111441Z">
        <seg>我们设想这些变量存储在称为传输控制块或 TCB 的连接记录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this latter case under "half-open" connections below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042639Z" creationid="pingfangx" creationdate="20190828T042639Z">
        <seg>我们在下面的“半开”连接下讨论后一种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We followed the naming convention of Java 8 by defining `io.reactivex.functions.Function` and `io.reactivex.functions.BiFunction`, plus renaming `Func3` - `Func9` into `Function3` - `Function9` respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065000Z" creationid="pingfangx" creationdate="20190618T065000Z">
        <seg>我们遵循 Java 8 的命名约定，定义了 `io.reactivex.functions.Function` 和 `io.reactivex.functions.BiFunction`，并分别将 `Func3`  - `Func9` 重命名为 `Function3`  - `Function9`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have chosen to treat CLOSE in a simplex fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062609Z" creationid="pingfangx" creationdate="20190828T062609Z">
        <seg>我们选择以单一的方式对待 CLOSE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have taken advantage of the numbering scheme to protect certain control information as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022517Z" creationid="pingfangx" creationdate="20190828T022517Z">
        <seg>我们也利用编号方案来保护某些控制信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need something that defers the evaluation of this `Single` source until **runtime** when the main source completes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092517Z" creationid="pingfangx" creationdate="20190617T092517Z">
        <seg>我们需要一些推迟计算这个 `Single` 源的东西直到 **runtime**，当主源完成时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We try to remedy this situation in 2.x by having `io.reactivex.Observable` non-backpressured and the new `io.reactivex.Flowable` be the backpressure-enabled base reactive class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053358Z" creationid="pingfangx" creationdate="20190618T053358Z">
        <seg>我们尝试在 2.x 中纠正这种情况，通过使基本响应类 `io.reactivex.Observable` 非背压并且新的 `io.reactivex.Flowable` 支持背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We want to assure this, even if a TCP crashes and loses all knowledge of the sequence numbers it has been using.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023256Z" creationid="pingfangx" creationdate="20190828T023256Z">
        <seg>我们想要确保这一点，即使 TCP 崩溃并且失去了它一直使用的序列号的所有知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What people actually need is the method `fromCallable`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015858Z" creationid="pingfangx" creationdate="20190624T015858Z">
        <seg>人们真正需要的是 `fromCallable` 方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a SYN is present then SEG.SEQ is the sequence number of the SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022848Z" creationid="pingfangx" creationdate="20190828T022848Z">
        <seg>当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When all segments preceding the FINs have been processed and acknowledged, each TCP can ACK the FIN it has received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063921Z" creationid="pingfangx" creationdate="20190828T063921Z">
        <seg>当 FIN 之前的所有报文段都已被处理和确认时，每个 TCP 都可以确认它收到的 FIN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an observer subscribes to a &lt;c0&gt;BehaviorSubject&lt;/c0&gt;, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084158Z" creationid="pingfangx" creationdate="20190620T084158Z">
        <seg>当观察者订阅 &lt;c0&gt;BehaviorSubject&lt;/c0&gt; 时，它首先发射源 Observable 最近发射的项（或者如果尚未发射则会发射种子/默认值），然后继续发射任何稍后由源 Observable 发射的其他项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When architecting dataflows (as an end-consumer of RxJava) or deciding upon what type your 2.x compatible library should take and return, you can consider a few factors that should help you avoid problems down the line such as `MissingBackpressureException` or `OutOfMemoryError`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053633Z" creationid="pingfangx" creationdate="20190618T053633Z">
        <seg>在构建数据流(作为 RxJava 的最终使用者)或决定 2.x 兼容库应该采用和返回的类型时，您可以考虑一些可以帮助您避免问题的因素，相关问题例如 `MissingBackpressureException` 或 ` OutOfMemoryError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When data is received the following comparisons are needed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022122Z" creationid="pingfangx" creationdate="20190828T022122Z">
        <seg>收到数据时，需要进行以下比较：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When does an Observable begin emitting its sequence of items?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064950Z" creationid="pingfangx" creationdate="20190620T064950Z">
        <seg>Observable 何时开始发射其数据项序列？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023313Z" creationid="pingfangx" creationdate="20190828T023313Z">
        <seg>当创建新连接时，使用初始序列号(ISN)生成器，其选择新的 32 位 ISN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When simultaneous attempt occurs, each TCP receives a "SYN" segment which carries no acknowledgment after it has sent a "SYN".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031523Z" creationid="pingfangx" creationdate="20190828T031523Z">
        <seg>当同时尝试发生时，每个 TCP 都会收到一个“SYN”报文段，在发送“SYN”后，该报文段不包含确认信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the SYN arrives at line 3, TCP B, being in a synchronized state, and the incoming segment outside the window, responds with an acknowledgment indicating what sequence it next expects to hear (ACK 100).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060037Z" creationid="pingfangx" creationdate="20190828T060037Z">
        <seg>当 SYN 到达第 3 行时，处于同步状态的 TCP B 和窗口外的传入报文段响应确认，指示接下来希望听到的序列(ACK 100)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the TCP is up again, A is likely to start again from the beginning or from a recovery point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055743Z" creationid="pingfangx" creationdate="20190828T055743Z">
        <seg>当 TCP 再次启动时，A 很可能从开始或从恢复点再次启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the dataflow runs through asynchronous steps, each step may perform different things with different speed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071154Z" creationid="pingfangx" creationdate="20190617T071154Z">
        <seg>当数据流通过异步步骤时，每个步骤可以以不同的速度执行不同的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the original SYN (pun intended) finally arrives at line 6, the synchronization proceeds normally.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043327Z" creationid="pingfangx" creationdate="20190828T043327Z">
        <seg>当原始 SYN(双关语)最终到达第 6 行时，同步正常进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the other TCP has both acknowledged the FIN and sent a FIN of its own, the first TCP can ACK this FIN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063614Z" creationid="pingfangx" creationdate="20190828T063614Z">
        <seg>当另一个 TCP 同时确认了 FIN 并发送了自己的 FIN 时，第一个 TCP 可以确认此 FIN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever the downstream is not ready to receive values, this operator will drop that elemenet from the sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014731Z" creationid="pingfangx" creationdate="20190624T014731Z">
        <seg>每当下游未准备好接收值时，此操作符将从序列中删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which looks something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055915Z" creationid="pingfangx" creationdate="20190620T055915Z">
        <seg>看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While computing the checksum, the checksum field itself is replaced with zeros.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110021Z" creationid="pingfangx" creationdate="20190827T110021Z">
        <seg>在计算校验和时，校验和字段本身将替换为零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why Use Observables?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034112Z" creationid="pingfangx" creationdate="20190620T034112Z">
        <seg>为什么要使用 Observables？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the two examples before, the 2.x code can now look like this since `ResourceSubscriber` implements `Disposable` directly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070804Z" creationid="pingfangx" creationdate="20190618T070804Z">
        <seg>使用前面的两个例子，2.x 代码现在看起来像这样，因为 `ResourceSubscriber` 直接实现 `Disposable`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With these additions, ReactiveX harmonizes the Iterable and Observable types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042451Z" creationid="pingfangx" creationdate="20190620T042451Z">
        <seg>通过这些添加，ReactiveX 使得 Iterable 和 Observable 类型保持一致了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a specific handler, RxJava defaults to printing the `Throwable`'s stacktrace to the console and calls the current thread's uncaught exception handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090305Z" creationid="pingfangx" creationdate="20190618T090305Z">
        <seg>如果没有特定的处理程序，RxJava 默认将 `Throwable` 的堆栈跟踪打印到控制台并调用当前线程的未捕获异常处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025219Z" creationid="pingfangx" creationdate="20190828T025219Z">
        <seg>如果没有这样的假设，可以想象两个不同的 TCP 报文段被分配相同或重叠的序列号，从而导致接收器对哪些数据是新的以及哪些是旧的混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with this new base reactive type is practically the same as the others as it offers a modest subset of the `Flowable` operators that make sense with a 0 or 1 item sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061038Z" creationid="pingfangx" creationdate="20190618T061038Z">
        <seg>使用这种新的基本响应类型实际上与其他类型相同，因为它提供了一个适用于 0 或 1 项序列的 `Flowable` 运算符的适度子集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing such state machines as `Iterable`s is somewhat complicated (but still easier than writing an `Flowable` for consuming it) and unlike C#, Java doesn't have any support from the compiler to build such state machines by simply writing classically looking code (with `yield return` and `yield break`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020416Z" creationid="pingfangx" creationdate="20190624T020416Z">
        <seg>编写像 `Iterable` 这样的状态机有点复杂(但是比编写一个 `Flowable` 更容易使用它)并且与 C＃不同，Java 没有任何编译器支持通过简单编写经典外观来构建这样的状态机代码(带有 `yield return` 和 `yield break`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yet another example is `Catch` which was named `onErrorResumeNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101913Z" creationid="pingfangx" creationdate="20190617T101913Z">
        <seg>另一个例子是 `Catch`，它命名为 `onErrorResumeNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify a particular &lt;a0&gt;Scheduler&lt;/a0&gt; for the timer to operate on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075655Z" creationid="pingfangx" creationdate="20190620T075655Z">
        <seg>您还可以为要运行的计时器指定特定的 &lt;a0&gt;Scheduler&lt;/a0&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use &lt;a0&gt;a version of &lt;c1&gt;schedule&lt;/c1&gt;&lt;/a0&gt; that delays your action on the given Scheduler until a certain timespan has passed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092431Z" creationid="pingfangx" creationdate="20190620T092431Z">
        <seg>您还可以使用 &lt;a0&gt;&lt;c1&gt;schedule&lt;/c1&gt; 的版本&lt;/a0&gt;，该版本会在给定调度器上延时你的操作，直到超过某个时间跨度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061700Z" creationid="pingfangx" creationdate="20190620T061700Z">
        <seg>您可以调用此方法来指示订阅服务器不再对其当前订阅的任何 Observable 感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the class and add your own custom `subscribeActual` behavior to achieve something similar to the 1.x features:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063923Z" creationid="pingfangx" creationdate="20190618T063923Z">
        <seg>您可以继承类并添加自己的自定义 `subscribeActual` 行为，以实现类似于 1.x 功能的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of the Observable class as a “push” equivalent to &lt;a0&gt;Iterable&lt;/a0&gt;, which is a “pull.” With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042125Z" creationid="pingfangx" creationdate="20190620T042125Z">
        <seg>您可以将 Observable 类的“推”，视为等同于 &lt;a0&gt;Iterable&lt;/a0&gt; 的“拉”。对于 Iterable，消费者从生产者拉取值，并且线程阻塞直到这些值到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use `Subject.toSerialized()` and `FlowableProcessor.toSerialized()` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063632Z" creationid="pingfangx" creationdate="20190618T063632Z">
        <seg>您必须使用 `Subject.toSerialized()` 和 `FlowableProcessor.toSerialized()` 代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to handle an element frequency of 1000 Hz or less with Observable but consider using sampling/debouncing anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054651Z" creationid="pingfangx" creationdate="20190618T054651Z">
        <seg>您可以使用 Observable 处理 1000 Hz 或更低的元素频率，但无论如何都要考虑使用 sampling/debouncing。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You obtain a Scheduler from the factory methods described in &lt;a0&gt;the &lt;c1&gt;Schedulers&lt;/c1&gt; class&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090922Z" creationid="pingfangx" creationdate="20190620T090922Z">
        <seg>您可以从 &lt;a0&gt;&lt;c1&gt;Schedulers&lt;/c1&gt; 类&lt;/a0&gt; 中描述的工厂方法获取 Scheduler。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use or rely on them in any production code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105326Z" creationid="pingfangx" creationdate="20190617T105326Z">
        <seg>您不应该在任何生产代码中使用或依赖它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your observer implements some subset of the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060237Z" creationid="pingfangx" creationdate="20190620T060237Z">
        <seg>你的观察者实现以下方法的某些子集：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Action1` has been renamed to `Consumer` and `Action2` is called `BiConsumer`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064844Z" creationid="pingfangx" creationdate="20190618T064844Z">
        <seg>`Action1` 已重命名为 `Consumer`，`Action2` 被称为 `BiConsumer`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ActionN` is replaced by the `Consumer&lt;Object[]&gt;` type declaration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064910Z" creationid="pingfangx" creationdate="20190618T064910Z">
        <seg>`ActionN` 被 `Consumer&lt;Object[]&gt;` 类型声明所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Flowable` can be tested with `io.reactivex.subscribers.TestSubscriber` whereas the non-backpressured `Observable`, `Single`, `Maybe` and `Completable` can be tested with `io.reactivex.observers.TestObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095806Z" creationid="pingfangx" creationdate="20190618T095806Z">
        <seg>`Flowable` 可以使用 `io.reactivex.subscribers.TestSubscriber` 进行测试，而非背压的 `Observable`，`Single`，`Maybe` 和 `Completable` 可以使用 `io.reactivex.observers.TestObserver` 进行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061253Z" creationid="pingfangx" creationdate="20190619T061253Z">
        <seg>`Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Observable&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061251Z" creationid="pingfangx" creationdate="20190619T061251Z">
        <seg>`Observable&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061302Z" creationid="pingfangx" creationdate="20190619T061302Z">
        <seg>`Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`TestSubscriber` has the `test(long initialRequest)` and `test(long initialRequest, boolean cancel)` overloads to specify the initial request amount and whether the `TestSubscriber` should be also immediately cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101738Z" creationid="pingfangx" creationdate="20190618T101738Z">
        <seg>`TestSubscriber` 有 `test(long initialRequest)` 和 `test(long initialRequest，boolean cancel)` 重载来指定初始请求数量以及是否应立即取消 `TestSubscriber`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`flatMap` is a powerful operator and helps in a lot of situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083339Z" creationid="pingfangx" creationdate="20190617T083339Z">
        <seg>`flatMap` 是一个功能强大的运算符，可以在很多情况下提供帮助。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`just` is great when there is a constant value we'd like to jump-start a sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015708Z" creationid="pingfangx" creationdate="20190624T015708Z">
        <seg>当有一个恒定的值我们想要跳过一个序列时，`just` 很棒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`just` won't emit its constant value until requested when it is mapped to the result of the `computeValue`, still called for each subscriber individually.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020123Z" creationid="pingfangx" creationdate="20190624T020123Z">
        <seg>`just` 在被映射到 `computeValue` 的结果之前被请求时不会发射它的常量值，仍然单独为每个用户调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a Single passes this method the Throwable that caused the Single to be unable to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073728Z" creationid="pingfangx" creationdate="20190620T073728Z">
        <seg>Single 将导致 Single 无法发射项目的 Throwable 传递给此方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a Single passes this method the sole item that the Single emits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073630Z" creationid="pingfangx" creationdate="20190620T073630Z">
        <seg>Single 将发射的唯一项目传递给此方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a variety of operators that enforce particular flow-control policies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072125Z" creationid="pingfangx" creationdate="20190620T072125Z">
        <seg>各种执行特定流量控制策略的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `amb(ObservableSource...)` overload, 2-9 argument versions dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112016Z" creationid="pingfangx" creationdate="20190618T112016Z">
        <seg>添加了 `amb(ObservableSource...)` 重载，2-9 个参数的版本被删除了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `concatArrayEager` and `concatArrayEagerDelayError`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112940Z" creationid="pingfangx" creationdate="20190618T112940Z">
        <seg>添加 `concatArrayEager` 和 `concatArrayEagerDelayError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `concatArray` and `concatArrayDelayError`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112930Z" creationid="pingfangx" creationdate="20190618T112930Z">
        <seg>添加 `concatArray` 和 `concatArrayDelayError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `doOnLifecylce` to handle `onSubscribe`, `request` and `cancel` peeking</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052545Z" creationid="pingfangx" creationdate="20190619T052545Z">
        <seg>添加 `doOnLifecylce` 来处理 `onSubscribe`，`request` 和 `cancel` peeking</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `forEachWhile(Predicate&lt;T&gt;, [Consumer&lt;Throwable&gt;, [Action]])` for conditionally stopping consumption</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053032Z" creationid="pingfangx" creationdate="20190619T053032Z">
        <seg>添加 `forEachWhile(Predicate&lt;T&gt;, [Consumer&lt;Throwable&gt;, [Action]])` 以有条件地停止消费</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `fromPublisher`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114304Z" creationid="pingfangx" creationdate="20190618T114304Z">
        <seg>添加 `fromPublisher`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `intervalRange()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114315Z" creationid="pingfangx" creationdate="20190618T114315Z">
        <seg>添加 `intervalRange()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `reduceWith(Callable, BiFunction)` to reduce in a Subscriber-individual manner, returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053555Z" creationid="pingfangx" creationdate="20190619T053415Z">
        <seg>添加 `reduceWith(Callable, BiFunction)` 以订阅者个人的方式减少，返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `repeatUntil(BooleanSupplier)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053425Z" creationid="pingfangx" creationdate="20190619T053425Z">
        <seg>添加 `repeatUntil(BooleanSupplier)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `retry(Predicate)`, `retry(int, Predicate)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053442Z" creationid="pingfangx" creationdate="20190619T053442Z">
        <seg>添加了 `retry(Predicate)`，`retry(int，Predicate)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `retryUntil(BooleanSupplier)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053445Z" creationid="pingfangx" creationdate="20190619T053445Z">
        <seg>添加了 `retryUntil(BooleanSupplier)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `scanWith(Callable, BiFunction)` to scan in a Subscriber-individual manner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053540Z" creationid="pingfangx" creationdate="20190619T053540Z">
        <seg>添加了 `scanWith(Callable, BiFunction)` 来以订阅者个人的方式进行扫描</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `startWithArray` to disambiguate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053729Z" creationid="pingfangx" creationdate="20190619T053729Z">
        <seg>添加了 `startWithArray` 来消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `subscribeWith` that returns its input after subscription</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053822Z" creationid="pingfangx" creationdate="20190619T053822Z">
        <seg>添加了 `subscribeWith`，在订阅后返回其输入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `test()` (returns TestSubscriber subscribed to this) with overloads to fluently test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053900Z" creationid="pingfangx" creationdate="20190619T053900Z">
        <seg>添加了 `test()` (返回 TestSubscriber 订阅了这个)，带有重载以流畅地测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `toFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054030Z" creationid="pingfangx" creationdate="20190619T054030Z">
        <seg>添加了 `toFuture`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `toObservable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054032Z" creationid="pingfangx" creationdate="20190619T054032Z">
        <seg>添加了 `toObservable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `bufferSize`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061908Z" creationid="pingfangx" creationdate="20190618T114358Z">
        <seg>添加带 `bufferSize` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `bufferSize` and `delayError` option, *the custom internal map version didn't make it into RC1*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053105Z" creationid="pingfangx" creationdate="20190619T053105Z">
        <seg>添加带有 `bufferSize` 和 'delayerror' 选项的重载，*自定义内部映射版本没有将其转换为 RC1*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053316Z" creationid="pingfangx" creationdate="20190618T114415Z">
        <seg>添加带 `prefetch` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch` argument</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053832Z" creationid="pingfangx" creationdate="20190619T053832Z">
        <seg>添加了带有 `prefetch` 参数的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch` argument, 5-9 source overloads dropped, use `concatArray` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112702Z" creationid="pingfangx" creationdate="20190618T112702Z">
        <seg>添加带 `prefetch` 参数的重载，删除了 5-9 个源的重载，使用 `concatArray` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `bufferSize` and `delayError` options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053708Z" creationid="pingfangx" creationdate="20190619T053708Z">
        <seg>添加了带有 `bufferSize` 和 `delayError` 选项的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `bufferSize` and `delayErrors` capabilities, disambiguated to `zipArray` and `zipIterable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114528Z" creationid="pingfangx" creationdate="20190618T114528Z">
        <seg>添加带 `bufferSize` 和 `delayErrors` 功能的重载，使用 `zipArray` 和 `zipIterable` 消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061853Z" creationid="pingfangx" creationdate="20190618T114338Z">
        <seg>添加带 `prefetch` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch` and `delayErrors` options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T055924Z" creationid="pingfangx" creationdate="20190619T054541Z">
        <seg>添加了带有 `prefetch` 和 `delayErrors` 选项的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch`, option to delay till the current ends or till the very end</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T051728Z" creationid="pingfangx" creationdate="20190619T051728Z">
        <seg>添加带 `prefetch` 的重载，可选择延迟到当前结束或直到最后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with option to delay till the current ends or till the very end</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113044Z" creationid="pingfangx" creationdate="20190618T113044Z">
        <seg>添加了重载，可选择延迟到当前结束或直到最后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added varargs overload, added overloads with `bufferSize` argument, `combineLatest(List)` dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112450Z" creationid="pingfangx" creationdate="20190618T112450Z">
        <seg>添加了可变参数重载，添加了 `bufferSize` 参数的重载，删除了 `combineLatest(List)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>advances the Scheduler’s clock forward by a particular amount of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091835Z" creationid="pingfangx" creationdate="20190620T091835Z">
        <seg>将调度器的时钟向前推进一段特定的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>advances the Scheduler’s clock to a particular point in time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091831Z" creationid="pingfangx" creationdate="20190620T091831Z">
        <seg>将调度器的时钟提前到特定时间点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after a specified delay</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104344Z" creationid="pingfangx" creationdate="20190620T104344Z">
        <seg>在指定的延迟后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow further customization of the backpressure behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100500Z" creationid="pingfangx" creationdate="20190617T100500Z">
        <seg>允许进一步定制背压行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allows you create a custom operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074015Z" creationid="pingfangx" creationdate="20190620T074015Z">
        <seg>允许创建自定义操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a number indicating how many items were in the sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105901Z" creationid="pingfangx" creationdate="20190620T105901Z">
        <seg>并发射一个数字，表示序列中有多少项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if &lt;e0&gt;all&lt;/e0&gt; of the items pass some test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105808Z" creationid="pingfangx" creationdate="20190620T105808Z">
        <seg>并发射一个布尔值，表明项目的 &lt;e0&gt;全部&lt;/e0&gt; 是否通过了一些测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the Observable emitted &lt;e0&gt;any&lt;/e0&gt; item (that passes some test)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105820Z" creationid="pingfangx" creationdate="20190620T105820Z">
        <seg>并发射一个布尔值，指示 Observable 是否发射了 &lt;e0&gt;任何&lt;/e0&gt; 项(通过了一些测试)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the Observable emitted &lt;e0&gt;no&lt;/e0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105843Z" creationid="pingfangx" creationdate="20190620T105843Z">
        <seg>并发射一个布尔值，指示 Observable 是否 &lt;e0&gt;没有&lt;/e0&gt; 发射项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105848Z" creationid="pingfangx" creationdate="20190620T105848Z">
        <seg>并发射一个布尔值，指示序列是否与第二个 Observable 发射的序列相同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the average of all of their values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105854Z" creationid="pingfangx" creationdate="20190620T105854Z">
        <seg>并发射所有值的平均值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the item with the maximum value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105904Z" creationid="pingfangx" creationdate="20190620T105904Z">
        <seg>并发射具有最大值的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the item with the minimum value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105935Z" creationid="pingfangx" creationdate="20190620T105914Z">
        <seg>并发射具有最小值的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the sum of all of their values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105856Z" creationid="pingfangx" creationdate="20190620T105856Z">
        <seg>并发射所有值的总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting all of the items from all of the Observables in whatever order they are received</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104544Z" creationid="pingfangx" creationdate="20190620T104544Z">
        <seg>按照收到的顺序从所有 Observable 中发射所有项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting all of the items from all of the Observables, one Observable at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104553Z" creationid="pingfangx" creationdate="20190620T104553Z">
        <seg>从所有的 Observable 中发射所有物品，一次一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting the items from only the most-recently emitted of those Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104757Z" creationid="pingfangx" creationdate="20190620T104757Z">
        <seg>仅从最近发射的那些 Observables 中发射项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and follows the protocol `onSubscribe (onSuccess | onError)?`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055918Z" creationid="pingfangx" creationdate="20190618T055918Z">
        <seg>并遵循协议 `onSubscribe (onSuccess | onError)?`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for Ivy:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105531Z" creationid="pingfangx" creationdate="20190617T105531Z">
        <seg>对于 Ivy：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for Maven:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105526Z" creationid="pingfangx" creationdate="20190617T105526Z">
        <seg>对于 Maven：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and still follows the protocol `onSubscribe (onComplete | onError)?`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060131Z" creationid="pingfangx" creationdate="20190618T060131Z">
        <seg>并且仍遵循协议 `onSubscribe (onComplete | onError)?`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then I want to ask it to start</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110202Z" creationid="pingfangx" creationdate="20190620T110202Z">
        <seg>然后我想要它开始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then emits the complete sequence, even to those who subscribe after the sequence has begun</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110150Z" creationid="pingfangx" creationdate="20190620T110150Z">
        <seg>然后发射完整的序列，甚至是那些在序列开始后订阅的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then only emits the last item in its sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110138Z" creationid="pingfangx" creationdate="20190620T110138Z">
        <seg>然后只发射序列中的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100732Z" creationid="pingfangx" creationdate="20190620T095948Z">
        <seg>将函数应用于 Observable 发射的每个项目，按顺序，并发射每个连续的值（译注：与 Map 区别于函数会使用上一次函数值）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a function to each item emitted by an Observable, sequentially, and emit the final value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103018Z" creationid="pingfangx" creationdate="20190620T103018Z">
        <seg>将函数按顺序应用于 Observable 发射的每个项目，并发射最终值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>asynchronous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033704Z" creationid="pingfangx" creationdate="20190620T033704Z">
        <seg>异步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>at particular intervals of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104502Z" creationid="pingfangx" creationdate="20190620T104502Z">
        <seg>在特定的时间间隔</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>attach a timestamp to each item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102352Z" creationid="pingfangx" creationdate="20190620T102352Z">
        <seg>将时间戳附加到 Observable 发射的每个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>based on all of the items that preceded them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104957Z" creationid="pingfangx" creationdate="20190620T104957Z">
        <seg>基于它们之前的所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but I want it to go away once all of its subscribers unsubscribe</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110157Z" creationid="pingfangx" creationdate="20190620T110157Z">
        <seg>但是，一旦所有订阅者取消订阅，我希望它能够消失</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by applying an aggregation function to each item in turn and emitting the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105942Z" creationid="pingfangx" creationdate="20190620T105942Z">
        <seg>通过依次对每个项目应用聚合函数并发射结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by attaching a timestamp to them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105002Z" creationid="pingfangx" creationdate="20190620T105002Z">
        <seg>通过附加时间戳给他们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by attempting to resubscribe to the upstream Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110106Z" creationid="pingfangx" creationdate="20190620T110106Z">
        <seg>试图重新订阅上游的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by combining the items from two or more Observables sequentially to come up with new items to emit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104612Z" creationid="pingfangx" creationdate="20190620T104612Z">
        <seg>通过顺序组合来自两个或多个 Observable 的项目来提出要发射的新项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by delaying my subscription to it for some time after it begins emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105714Z" creationid="pingfangx" creationdate="20190620T105714Z">
        <seg>在开始发布项目后的一段时间内延迟我的订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by emitting all of the items emitted by corresponding Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104946Z" creationid="pingfangx" creationdate="20190620T104946Z">
        <seg>通过发射相应的 Observables 发射的所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by filtering out those that do not match some predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105304Z" creationid="pingfangx" creationdate="20190620T105304Z">
        <seg>通过过滤掉那些与某些谓词不匹配的东西</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by means of &lt;c0&gt;Pattern&lt;/c0&gt; and &lt;c1&gt;Plan&lt;/c1&gt; intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104716Z" creationid="pingfangx" creationdate="20190620T104716Z">
        <seg>通过 &lt;c0&gt;Pattern&lt;/c0&gt; 和 &lt;c1&gt;Plan&lt;/c1&gt; 中介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by only emitting items that are not followed by other items within some duration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105649Z" creationid="pingfangx" creationdate="20190620T105649Z">
        <seg>通过仅在一段时间内发射未跟随其他项目的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by retrieving it from a Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104407Z" creationid="pingfangx" creationdate="20190620T104407Z">
        <seg>通过从 Future 中获取</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by sampling the Observable periodically</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105632Z" creationid="pingfangx" creationdate="20190620T105632Z">
        <seg>通过定期对 Observable 进行抽样</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by suppressing items that are duplicates of already-emitted items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105655Z" creationid="pingfangx" creationdate="20190620T105655Z">
        <seg>通过抑制与已发射项目重复的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by wrapping them in &lt;c0&gt;Notification&lt;/c0&gt; objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105059Z" creationid="pingfangx" creationdate="20190620T105059Z">
        <seg>将它们包装在 &lt;c0&gt;Notification&lt;/c0&gt; 对象中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculate the sum of numbers emitted by an Observable and emit this sum</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103028Z" creationid="pingfangx" creationdate="20190620T103028Z">
        <seg>计算 Observable 发射的数字之和并发射此总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculates the average of numbers emitted by an Observable and emits this average</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102858Z" creationid="pingfangx" creationdate="20190620T102858Z">
        <seg>计算 Observable 发射的数字的平均值并发射此平均值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `List`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061444Z" creationid="pingfangx" creationdate="20190619T061444Z">
        <seg>将所有元素收集到 `List` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `List` and sorts it</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061457Z" creationid="pingfangx" creationdate="20190619T061457Z">
        <seg>将所有元素收集到 `List` 中并对其进行排序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `Map`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061448Z" creationid="pingfangx" creationdate="20190619T061448Z">
        <seg>将所有元素收集到 `Map` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `Map` with collection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061453Z" creationid="pingfangx" creationdate="20190619T061453Z">
        <seg>将所有元素收集到带有集合的 `Map` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101457Z" creationid="pingfangx" creationdate="20190620T101457Z">
        <seg>在根据另一个 Observable 发射的项目定义的时间窗口期间发射一个 Observable 中的项目时，组合两个 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine multiple Observables into one by merging their emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101553Z" creationid="pingfangx" creationdate="20190620T101553Z">
        <seg>通过合并它们的发射，将多个 Observable 组合成一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine sets of items emitted by two or more Observables by means of `Pattern` and `Plan` intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101248Z" creationid="pingfangx" creationdate="20190620T101248Z">
        <seg>通过 `Pattern` 和 `Plan` 中介组合两个或多个 Observable 发射的项目集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101737Z" creationid="pingfangx" creationdate="20190620T101737Z">
        <seg>通过指定的函数将多个 Observable 的发射组合在一起，并根据此函数的结果为每个组合发射单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>concatenates the items emitted by multiple Singles as Observable emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074050Z" creationid="pingfangx" creationdate="20190620T074050Z">
        <seg>将多个 Singles 发射的项目连接为 Observable 的发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containing only the last items emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105215Z" creationid="pingfangx" creationdate="20190620T105215Z">
        <seg>仅包含最后发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable into another object or data structure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103726Z" creationid="pingfangx" creationdate="20190620T103726Z">
        <seg>将 Observable 转换为另一个对象或数据结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101651Z" creationid="pingfangx" creationdate="20190620T101651Z">
        <seg>将发射 Observables 的 Observable 转换为单个 Observable，该 Observable 发射最近发射的 Observables 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102326Z" creationid="pingfangx" creationdate="20190620T102326Z">
        <seg>将发射数据项的 Observable 转换为发射这些发射项之间经过的时间量的指示的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an object or a set of objects into an Observable that emits that or those objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095323Z" creationid="pingfangx" creationdate="20190620T095323Z">
        <seg>将对象或一组对象转换为发射该对象或那些对象的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an ordinary Observable into a connectable Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103616Z" creationid="pingfangx" creationdate="20190620T103616Z">
        <seg>将普通的 Observable 转换为可连接的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert some other object or data structure into an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095214Z" creationid="pingfangx" creationdate="20190620T095214Z">
        <seg>将一些其他对象或数据结构转换为 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Future into a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074449Z" creationid="pingfangx" creationdate="20190620T074449Z">
        <seg>将 Future 转化为 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single into an Observable that emits the item emitted by the Single and then completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074839Z" creationid="pingfangx" creationdate="20190620T074839Z">
        <seg>将 Single 转换为 Observable，它发射 Single 发射的项，然后完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single that emits a second Single into a Single that emits the item emitted by the second Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074616Z" creationid="pingfangx" creationdate="20190620T074616Z">
        <seg>将发射第二个 Single 的 Single 转换为发射第二个 Single 发射的项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single that makes an error notification into a Single that emits a specified item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074728Z" creationid="pingfangx" creationdate="20190620T074728Z">
        <seg>将发射错误通知的 Single 转换为发射指定项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts an Observable that emits a single item into a Single that emits that item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074827Z" creationid="pingfangx" creationdate="20190620T074827Z">
        <seg>将发射单个项目的 Observable 转换为发射该项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>count the number of items emitted by the source Observable and emit only this value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102934Z" creationid="pingfangx" creationdate="20190620T102934Z">
        <seg>计算源 Observable 发射的项目数，并仅发射此值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create Observables that have very precise and limited behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095200Z" creationid="pingfangx" creationdate="20190620T095200Z">
        <seg>创建具有非常精确和有限行为的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create a Single from scratch by calling subscriber methods explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074105Z" creationid="pingfangx" creationdate="20190620T074105Z">
        <seg>通过显式调用订阅者方法从头创建 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create a disposable resource that has the same lifespan as the Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102425Z" creationid="pingfangx" creationdate="20190620T102425Z">
        <seg>创建一个与 Observable 具有相同生命周期的可释放资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable from scratch by calling observer methods programmatically</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095124Z" creationid="pingfangx" creationdate="20190620T095124Z">
        <seg>通过以编程方式调用 observer 方法从头创建一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a particular item or sequence of items repeatedly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095341Z" creationid="pingfangx" creationdate="20190620T095341Z">
        <seg>创建一个 Observable，重复发射特定项目或项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a range of sequential integers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095332Z" creationid="pingfangx" creationdate="20190620T095332Z">
        <seg>创建一个发射一系列连续整数的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a sequence of integers spaced by a particular time interval</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095309Z" creationid="pingfangx" creationdate="20190620T095309Z">
        <seg>创建一个 Observable，它以特定时间间隔发射一系列整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a single item after a given delay</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095356Z" creationid="pingfangx" creationdate="20190620T095356Z">
        <seg>创建一个在给定延迟后发射单个项目的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits the return value of a function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095348Z" creationid="pingfangx" creationdate="20190620T095348Z">
        <seg>创建一个发射函数返回值的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>creates a new thread for each unit of work</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091301Z" creationid="pingfangx" creationdate="20190620T091301Z">
        <seg>为每个工作单元创建一个新线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deprecated and dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115754Z" creationid="pingfangx" creationdate="20190618T115754Z">
        <seg>弃用并删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deprecated overloads dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114441Z" creationid="pingfangx" creationdate="20190618T114441Z">
        <seg>已删除弃用的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether all items emitted by an Observable meet some criteria</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102529Z" creationid="pingfangx" creationdate="20190620T102529Z">
        <seg>确定 Observable 发射的所有项目是否符合某些标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether an Observable emits a particular item or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102737Z" creationid="pingfangx" creationdate="20190620T102737Z">
        <seg>确定 Observable 是否发射特定项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether two Observables emit the same sequence of items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102753Z" creationid="pingfangx" creationdate="20190620T102753Z">
        <seg>确定两个 Observable 是否发射相同的项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine, and emit, the maximum-valued item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102942Z" creationid="pingfangx" creationdate="20190620T102942Z">
        <seg>确定并发射 Observable 发射的最大值项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine, and emit, the minimum-valued item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102948Z" creationid="pingfangx" creationdate="20190620T102948Z">
        <seg>确定并发射 Observable 发射的最小值项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disambiguated into `fromArray`, `fromIterable`, `fromFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114255Z" creationid="pingfangx" creationdate="20190618T114255Z">
        <seg>通过 `fromArray`，`fromIterable`，`fromFuture` 消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disambiguated to `collectInto` and **RC3** returns `Single&lt;U&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115854Z" creationid="pingfangx" creationdate="20190618T115854Z">
        <seg>修改为 `collectInto` 以消除歧义且 **RC3** 返回 `Single&lt;U&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable after a second Observable emits an item or terminates</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102825Z" creationid="pingfangx" creationdate="20190620T102825Z">
        <seg>在第二个 Observable 发射项目或终止后，丢弃 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable after a specified condition becomes false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102833Z" creationid="pingfangx" creationdate="20190620T102833Z">
        <seg>在指定条件变为 false 后，丢弃 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable until a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102802Z" creationid="pingfangx" creationdate="20190620T102802Z">
        <seg>丢弃 Observable 发射的项目，直到第二个 Observable 发射项目为止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable until a specified condition becomes false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102811Z" creationid="pingfangx" creationdate="20190620T102811Z">
        <seg>丢弃 Observable 发射的项目，直到指定的条件变为 false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095819Z" creationid="pingfangx" creationdate="20190620T095819Z">
        <seg>将一个 Observable 划分为一组 Observable，每个 Observable 从原始 Observable 中发射一组不同的项目，按 key 组织</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095149Z" creationid="pingfangx" creationdate="20190620T095149Z">
        <seg>在观察者订阅之前不要创建 Observable，并为每个观察者创建一个新的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not emit any items from an Observable but mirror its termination notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100958Z" creationid="pingfangx" creationdate="20190620T100958Z">
        <seg>不从 Observable 中发射任何项目，但镜像其终止通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it divide its work over multiple threads that may return data to the caller in any order?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040703Z" creationid="pingfangx" creationdate="20190620T040703Z">
        <seg>它是否将其工作划分为多个线程，这些线程可能以任何顺序将数据返回给调用者？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use NIO with an event-loop to do asynchronous network access?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040718Z" creationid="pingfangx" creationdate="20190620T040718Z">
        <seg>它是否使用 NIO 和事件循环来进行异步网络访问？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use an Actor (or multiple Actors) instead of a thread pool?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040709Z" creationid="pingfangx" creationdate="20190620T040709Z">
        <seg>它使用 Actor(或多个 Actors)而不是线程池？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use an event-loop to separate the work thread from the callback thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040725Z" creationid="pingfangx" creationdate="20190620T040725Z">
        <seg>它是否使用事件循环将工作线程与回调线程分开？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it work asynchronously on a distinct thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040653Z" creationid="pingfangx" creationdate="20190620T040653Z">
        <seg>它是否在一个不同的线程上异步工作？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it work synchronously on the same thread as the caller?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040649Z" creationid="pingfangx" creationdate="20190620T040649Z">
        <seg>它是否与调用者在同一个线程上同步工作？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>doesn't emit the very last item if the upstream completes within the period, added overloads with `emitLast` parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053506Z" creationid="pingfangx" creationdate="20190619T053506Z">
        <seg>如果上游在句点内完成，则不会发出最后一项，使用 `emitLast` 参数添加重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>doesn't emit the very last item if the upstream completes within the period, use `sample` with the `emitLast` parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053913Z" creationid="pingfangx" creationdate="20190619T053913Z">
        <seg>如果上游在句点内完成，则不会发出最后一项，请使用带有 `emitLast` 参数的 `sample`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053845Z" creationid="pingfangx" creationdate="20190619T053845Z">
        <seg>删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped the overload, use `subscribeOn(Scheduler).repeatWhen(Function)` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053435Z" creationid="pingfangx" creationdate="20190619T053435Z">
        <seg>删除了重载，使用 `subscribeOn(Scheduler).repeatWhen(Function)` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped the overload, use `subscribeOn(Scheduler).retryWhen(Function)` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053451Z" creationid="pingfangx" creationdate="20190619T053451Z">
        <seg>删除了重载，使用 `subscribeOn(Scheduler).retryWhen(Function)` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `count`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052322Z" creationid="pingfangx" creationdate="20190619T052322Z">
        <seg>删除，使用 `count`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).elementAt(int)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052636Z" creationid="pingfangx" creationdate="20190619T052636Z">
        <seg>删除，使用 `filter(predicate).elementAt(int)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).elementAt(int, T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052928Z" creationid="pingfangx" creationdate="20190619T052928Z">
        <seg>删除，使用 `filter(predicate).elementAt(int, T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).first()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052943Z" creationid="pingfangx" creationdate="20190619T052943Z">
        <seg>删除，使用 `filter(predicate).first()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).first(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053014Z" creationid="pingfangx" creationdate="20190619T053014Z">
        <seg>删除，使用 `filter(predicate).first(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).last()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053145Z" creationid="pingfangx" creationdate="20190619T053145Z">
        <seg>删除，使用 `filter(predicate).last()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).last(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053237Z" creationid="pingfangx" creationdate="20190619T053237Z">
        <seg>删除，使用 `filter(predicate).last(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).single()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053613Z" creationid="pingfangx" creationdate="20190619T053613Z">
        <seg>删除，使用 `filter(predicate).single()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053654Z" creationid="pingfangx" creationdate="20190619T053654Z">
        <seg>删除，使用 `filter(predicate).single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `take`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114325Z" creationid="pingfangx" creationdate="20190618T114325Z">
        <seg>删除，使用 ` take`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use manual `just`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053307Z" creationid="pingfangx" creationdate="20190619T053307Z">
        <seg>删除，使用 manual `just`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit a specified sequence of items before beginning to emit the items from the source Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101632Z" creationid="pingfangx" creationdate="20190620T101632Z">
        <seg>在开始从源 Observable 中发射项之前，发射指定的项序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit items from the source Observable, or a default item if the source Observable emits nothing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102747Z" creationid="pingfangx" creationdate="20190620T102747Z">
        <seg>从源 Observable 发射项，如果源 Observable 没有发射任何内容，则发射默认项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only item &lt;i0&gt;n&lt;/i0&gt; emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100914Z" creationid="pingfangx" creationdate="20190620T100914Z">
        <seg>仅发射 Observable 发射的 &lt;i0&gt;n&lt;/i0&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the first &lt;i3&gt;n&lt;/i3&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101059Z" creationid="pingfangx" creationdate="20190620T101059Z">
        <seg>仅发射 Observable 发射的前 &lt;i3&gt;n&lt;/i3&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the first item, or the first item that meets a condition, from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100934Z" creationid="pingfangx" creationdate="20190620T100934Z">
        <seg>从 Observable 中仅发射第一个项目或满足条件的第一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the last &lt;i4&gt;n&lt;/i4&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101117Z" creationid="pingfangx" creationdate="20190620T101117Z">
        <seg>仅发射 Observable 发射的最后 &lt;i4&gt;n&lt;/i4&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the last item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101003Z" creationid="pingfangx" creationdate="20190620T101003Z">
        <seg>仅发射 Observable 发射的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only those items from an Observable that pass a predicate test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100927Z" creationid="pingfangx" creationdate="20190620T100927Z">
        <seg>仅发射通过谓词测试的 Observable 中的那些项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit the emissions from two or more Observables without interleaving them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102926Z" creationid="pingfangx" creationdate="20190620T102926Z">
        <seg>发射两个或多个 Observable 的发射项而不交错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit the most recent item emitted by an Observable within periodic time intervals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101013Z" creationid="pingfangx" creationdate="20190620T101013Z">
        <seg>在周期性时间间隔内发射 Observable 发射的最新项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103713Z" creationid="pingfangx" creationdate="20190620T103713Z">
        <seg>确保所有观察者都看到相同的发射项序列，即使他们在 Observable 开始发射物品后才订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>even compile because at least 4 `concatWith` overloads exist and the compiler finds the code above ambiguous.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102620Z" creationid="pingfangx" creationdate="20190617T102620Z">
        <seg>它甚至不编译因为至少存在 4 个 `concatWith` 重载并且编译器发现上面的代码有歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for each observer that subscribes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104455Z" creationid="pingfangx" creationdate="20190620T104455Z">
        <seg>对于每个订阅的观察者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>force an Observable to make serialized calls and to be well-behaved</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102052Z" creationid="pingfangx" creationdate="20190620T102052Z">
        <seg>强制 Observable 进行序列化调用并保持良好状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from a timeout by switching to a backup Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110056Z" creationid="pingfangx" creationdate="20190620T110056Z">
        <seg>从超时切换到备份 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from an upstream error notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110101Z" creationid="pingfangx" creationdate="20190620T110101Z">
        <seg>来自上游错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from scratch, with custom logic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104443Z" creationid="pingfangx" creationdate="20190620T104443Z">
        <seg>从头开始，使用自定义逻辑</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from the perspective of `flatMapSingle`, `sourceObservable` is a multi-valued source and thus the mapping may result in multiple values as well).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091158Z" creationid="pingfangx" creationdate="20190617T091158Z">
        <seg>从 `flatMapSingle` 的角度来看，`sourceObservable` 是一个多值源，因此映射也可能导致多个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102731Z" creationid="pingfangx" creationdate="20190620T102731Z">
        <seg>给定两个或多个源 Observable，仅从第一个发射一个项目 Observable 中发射所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>however, the continuation in this case stays `Observable` instead of the likely more appropriate `Single`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T084004Z" creationid="pingfangx" creationdate="20190617T084004Z">
        <seg>然而，在这种情况下的延续仍然是 `Observable` 而不是可能更合适的 `Single`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a source Observable sends an `onError` notification, resubscribe to it in the hopes that it will complete without error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101846Z" creationid="pingfangx" creationdate="20190620T101846Z">
        <seg>如果一个源 Observable 发送一个 `onError` 通知，重新订阅它，希望它能完成而不会出错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a specified period of time elapses without it emitting an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110045Z" creationid="pingfangx" creationdate="20190620T110045Z">
        <seg>如果指定的时间段过去而没有发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if they immediately follow the item they are duplicates of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105703Z" creationid="pingfangx" creationdate="20190620T105703Z">
        <seg>如果他们立即跟随该项目他们是重复的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inlined as `blockingY()` operators, except `toFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053947Z" creationid="pingfangx" creationdate="20190619T053947Z">
        <seg>内联为 `blockingY()` 操作符，除了 `toFuture`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instruct a connectable Observable to begin emitting items to its subscribers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103606Z" creationid="pingfangx" creationdate="20190620T103606Z">
        <seg>指示可连接的 Observable 开始向其订阅者发送项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instructs the Single to call the subscriber methods on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074718Z" creationid="pingfangx" creationdate="20190620T074718Z">
        <seg>指示 Single 在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上调用订阅者方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instructs the Single to operate on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074754Z" creationid="pingfangx" creationdate="20190620T074754Z">
        <seg>指示 Single 在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>into an indicator of the amount of time that lapsed before the emission of the item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105012Z" creationid="pingfangx" creationdate="20190620T105012Z">
        <seg>成为项目发射前经过的时间的指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it takes 4.5 hours to use up 2**32 octets of sequence space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025410Z" creationid="pingfangx" creationdate="20190828T025410Z">
        <seg>用光 2 ** 32 个八位字节的序列空间需要 4.5 小时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make a Connectable Observable behave like an ordinary Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103654Z" creationid="pingfangx" creationdate="20190620T103654Z">
        <seg>使 Connectable Observable 的行为类似于普通的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to &lt;c0&gt;Schedulers.computation( )&lt;/c0&gt;; &lt;c1&gt;Schedulers.io( )&lt;/c1&gt; by default is a &lt;c2&gt;CachedThreadScheduler&lt;/c2&gt;, which is something like a new thread scheduler with thread caching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091257Z" creationid="pingfangx" creationdate="20190620T091257Z">
        <seg>对于 I/O 密集型工作，例如阻塞 I/O 的异步性能，此调度器由一个将根据需要增长的线程池支持；对于普通的计算工作，请切换到 &lt;c0&gt;Schedulers.computation( )&lt;/c0&gt;; &lt;c1&gt;Schedulers.io( )&lt;/c1&gt; 默认情况下是 &lt;c2&gt;CachedThreadScheduler&lt;/c2&gt;，类似于带有线程缓存的新线程调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use &lt;c0&gt;Schedulers.io( )&lt;/c0&gt; instead); the number of threads, by default, is equal to the number of processors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091037Z" creationid="pingfangx" creationdate="20190620T091037Z">
        <seg>用于计算工作，如事件循环和回调处理；不要将此调度器用于 I/O(请改用 &lt;c0&gt;Schedulers.io( )&lt;/c0&gt;);默认情况下，线程数等于处理器数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>merges the items emitted by multiple Singles as Observable emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074647Z" creationid="pingfangx" creationdate="20190620T074647Z">
        <seg>将多个 Singles 发射的数据项合并为 Observable 的发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102347Z" creationid="pingfangx" creationdate="20190620T102347Z">
        <seg>镜像源 Observable，但是如果在没有任何发射项目的情况下经过了特定的时间段，则发射错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>move the emission of an item from a Single forward in time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074211Z" creationid="pingfangx" creationdate="20190620T074211Z">
        <seg>延时 Single 发射项目的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>multiple items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033657Z" creationid="pingfangx" creationdate="20190620T033657Z">
        <seg>多个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not present</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113227Z" creationid="pingfangx" creationdate="20190618T113227Z">
        <seg>不存在</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of the source `Observable`?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095510Z" creationid="pingfangx" creationdate="20190617T095510Z">
        <seg>来自源 `Observable`？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onNext, onCompleted, and onError</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055924Z" creationid="pingfangx" creationdate="20190620T055924Z">
        <seg>onNext，onCompleted 和 onError</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one Observable at a time, in the order they are emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104950Z" creationid="pingfangx" creationdate="20190620T104950Z">
        <seg>一个 Observable，按照它们发射的顺序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one at a time with a function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104938Z" creationid="pingfangx" creationdate="20190620T104938Z">
        <seg>一次一个使用函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>only emit an item from an Observable if a particular timespan has passed without it emitting another item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100816Z" creationid="pingfangx" creationdate="20190620T100302Z">
        <seg>从 Observable 中发射一个项目后，如果过了特定的时间而没有发射别的项目，才发送该项目（译注：防抖动）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>only if its sequence is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105201Z" creationid="pingfangx" creationdate="20190620T105201Z">
        <seg>只有当它的序列为空时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>operate upon the emissions and notifications from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102156Z" creationid="pingfangx" creationdate="20190620T102156Z">
        <seg>对观察者的发射和通知进行操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092652Z" creationid="pingfangx" creationdate="20190617T092652Z">
        <seg>或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or alternatively the `TestSubscriber` instance has to be captured to gain access to its `request()` method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101806Z" creationid="pingfangx" creationdate="20190618T101806Z">
        <seg>或者必须捕获 `TestSubscriber` 实例以获取对其 `request()` 方法的访问：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overload with custom `Collection` supplier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052335Z" creationid="pingfangx" creationdate="20190619T052335Z">
        <seg>使用自定义 `Collection` 提供者重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overloads with custom `Collection` supplier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115739Z" creationid="pingfangx" creationdate="20190618T115739Z">
        <seg>使用自定义 `Collection` 提供者重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100347Z" creationid="pingfangx" creationdate="20190620T095455Z">
        <seg>定期将 Observable 中的项目收集到包中并发射这些包，而不是一次发送一个项目（译注：缓存）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100030Z" creationid="pingfangx" creationdate="20190620T100030Z">
        <seg>定期将 Observable 中的项目细分为 Observable 窗口并发射这些窗口，而不是一次发射一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prefixed to the TCP header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110052Z" creationid="pingfangx" creationdate="20190827T110052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>queues work to begin on the current thread after any already-queued work</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091335Z" creationid="pingfangx" creationdate="20190620T091335Z">
        <seg>当其它排队的任务完成后，在当前线程排队开始执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>recover from an `onError` notification by continuing the sequence without error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101833Z" creationid="pingfangx" creationdate="20190620T101833Z">
        <seg>通过继续序列而不出错来从 `onError` 通知中恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>register an action to take upon a variety of Observable lifecycle events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102021Z" creationid="pingfangx" creationdate="20190620T102021Z">
        <seg>注册一个动作来承担各种 Observable 生命周期事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `Flowable.doOnCancel` and `doOnDispose` for the others, [additional info](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052519Z" creationid="pingfangx" creationdate="20190619T052519Z">
        <seg>重命名为 `Flowable.doOnCancel` 和 `doOnDispose` 对于其他，[additional info](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `create()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114309Z" creationid="pingfangx" creationdate="20190618T114309Z">
        <seg>重命名为 `create()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `doOnComplete`, note the missing `d`!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052410Z" creationid="pingfangx" creationdate="20190619T052410Z">
        <seg>重命名为 `doOnComplete`，注意缺少的 `d`！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `elementAt(int, T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052906Z" creationid="pingfangx" creationdate="20190619T052739Z">
        <seg>重命名为 `elementAt(int, T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `first(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053000Z" creationid="pingfangx" creationdate="20190619T053000Z">
        <seg>重命名为 `first(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `hide()`, hides all identities now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115716Z" creationid="pingfangx" creationdate="20190618T115716Z">
        <seg>重命名为 `hide()`，现在隐藏所有身份</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `last(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053203Z" creationid="pingfangx" creationdate="20190619T053203Z">
        <seg>重命名为 `last(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `single(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053630Z" creationid="pingfangx" creationdate="20190619T053630Z">
        <seg>重命名为 `single(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replaced with `generate` + overloads (distinct interfaces, you can implement them all at once)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113215Z" creationid="pingfangx" creationdate="20190618T113215Z">
        <seg>替换为 `generate` + 重载(不同的接口，您可以一次实现它们)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>represent both the items emitted and the notifications sent as emitted items, or reverse this process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102033Z" creationid="pingfangx" creationdate="20190620T102033Z">
        <seg>表示发射的项目和作为发射项目发送的通知，或者反转此过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repurposed with safe `create(FlowableOnSubscribe, BackpressureStrategy)`, raw support via `unsafeCreate()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113314Z" creationid="pingfangx" creationdate="20190618T113314Z">
        <seg>使用安全的 `create(FlowableOnSubscribe, BackpressureStrategy)` 重新定位，通过 `unsafeCreate()` 提供原始支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that also calls a method you specify when it calls onError</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074251Z" creationid="pingfangx" creationdate="20190620T074251Z">
        <seg>返回在调用 OnError 时也调用指定方法的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that also calls a method you specify when it calls onSuccess</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074309Z" creationid="pingfangx" creationdate="20190620T074309Z">
        <seg>返回在调用 OnSuccess 时也调用指定方法的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits a specified item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074455Z" creationid="pingfangx" creationdate="20190620T074455Z">
        <seg>返回发射指定项的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074908Z" creationid="pingfangx" creationdate="20190620T074908Z">
        <seg>返回一个 Single，它发射一个项目，该项目是应用于两个或多个其他 Single 发射的项目的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits the result of a function applied to the item emitted by the source Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074523Z" creationid="pingfangx" creationdate="20190620T074523Z">
        <seg>返回一个 Single，它发射应用于源 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that immediately notifies subscribers of an error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074345Z" creationid="pingfangx" creationdate="20190620T074345Z">
        <seg>返回一个可立即通知订阅者错误的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that is the result of a function applied to an item emitted by a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074410Z" creationid="pingfangx" creationdate="20190620T074410Z">
        <seg>返回一个 Single，它是应用于 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that makes an error notification if the source Single does not emit a value in a specified time period</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074814Z" creationid="pingfangx" creationdate="20190620T074814Z">
        <seg>如果源 Single 在指定时间段内未发射值，则返回一个发射错误通知的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns an Observable that is the result of a function applied to an item emitted by a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074435Z" creationid="pingfangx" creationdate="20190620T074435Z">
        <seg>返回一个 Observable，它是应用于 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>schedules work to begin immediately in the current thread</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091109Z" creationid="pingfangx" creationdate="20190620T091109Z">
        <seg>立即在当前线程中开始工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift the emissions from an Observable forward in time by a particular amount</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102013Z" creationid="pingfangx" creationdate="20190620T102013Z">
        <seg>将 Observable 的发射向前转移一定量的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>signature changed to `timeout(Publisher, ...)` and dropped the function, use `defer(Callable&lt;Publisher&gt;&gt;)` if necessary</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053938Z" creationid="pingfangx" creationdate="20190619T053938Z">
        <seg>签名改为 `timeout(Publisher, ...)` 并删除了该函数，必要时使用 `defer(Callable&lt;Publisher&gt;&gt;)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>single items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033654Z" creationid="pingfangx" creationdate="20190620T033654Z">
        <seg>单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>so that similar items end up on the same Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105233Z" creationid="pingfangx" creationdate="20190620T105233Z">
        <seg>这样类似的项目最终会出现在同一个 Observable 上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify the scheduler an Observable should use when it is subscribed to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102210Z" creationid="pingfangx" creationdate="20190620T102210Z">
        <seg>指定 Observable 在订阅时应使用的调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify the scheduler on which an observer will observe this Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102045Z" creationid="pingfangx" creationdate="20190620T102045Z">
        <seg>指定观察者将观察此 Observable 的调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler’s clock</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091852Z" creationid="pingfangx" creationdate="20190620T091852Z">
        <seg>根据调度器的时钟启动任何已安排的时间等于或早于当前时间的未启动操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>strategies for coping with Observables that produce items more rapidly than their observers consume them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103456Z" creationid="pingfangx" creationdate="20190620T103456Z">
        <seg>当 Observables 生产数据项比观察者消耗数据项更快时的处理策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress duplicate items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100900Z" creationid="pingfangx" creationdate="20190620T100900Z">
        <seg>抑制 Observable 发射的重复项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress the first &lt;i1&gt;n&lt;/i1&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101039Z" creationid="pingfangx" creationdate="20190620T101019Z">
        <seg>抑制 Observable 发射的前 &lt;i1&gt;n&lt;/i1&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress the last &lt;i2&gt;n&lt;/i2&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101048Z" creationid="pingfangx" creationdate="20190620T101048Z">
        <seg>抑制 Observable 发射的最后 &lt;i2&gt;n&lt;/i2&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>synchronous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033700Z" creationid="pingfangx" creationdate="20190620T033700Z">
        <seg>同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that completes without emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104511Z" creationid="pingfangx" creationdate="20190620T104511Z">
        <seg>完成而不发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that does nothing at all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104514Z" creationid="pingfangx" creationdate="20190620T104514Z">
        <seg>什么都不做</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a particular item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104220Z" creationid="pingfangx" creationdate="20190620T104220Z">
        <seg>发射特定项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a sequence of integers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104459Z" creationid="pingfangx" creationdate="20190620T104459Z">
        <seg>发射一系列整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a sequence of items repeatedly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104425Z" creationid="pingfangx" creationdate="20190620T104425Z">
        <seg>重复发射一系列项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105546Z" creationid="pingfangx" creationdate="20190620T105546Z">
        <seg>在第二个 Observable 发射一个项目之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after an initial period of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105534Z" creationid="pingfangx" creationdate="20190620T105534Z">
        <seg>在最初的一段时间之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after the first &lt;i0&gt;n&lt;/i0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105518Z" creationid="pingfangx" creationdate="20190620T105518Z">
        <seg>前 &lt;i0&gt;n&lt;/i0&gt; 项之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except items emitted after a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105628Z" creationid="pingfangx" creationdate="20190620T105628Z">
        <seg>除了第二个 Observable 发射项目后发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except items emitted during a period of time before the source completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105617Z" creationid="pingfangx" creationdate="20190620T105617Z">
        <seg>除了在源完成之前的一段时间内发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except the last &lt;i0&gt;n&lt;/i0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105604Z" creationid="pingfangx" creationdate="20190620T105604Z">
        <seg>除了最后的 &lt;i0&gt;n&lt;/i0&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only item &lt;i0&gt;n&lt;/i0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105434Z" creationid="pingfangx" creationdate="20190620T105346Z">
        <seg>仅有项目 &lt;i0&gt;n&lt;/i0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the first item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105416Z" creationid="pingfangx" creationdate="20190620T105310Z">
        <seg>仅第一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the first item&lt;e0&gt;s&lt;/e0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105420Z" creationid="pingfangx" creationdate="20190620T105335Z">
        <seg>仅前几项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the last item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105430Z" creationid="pingfangx" creationdate="20190620T105341Z">
        <seg>仅最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only those items after the first items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105456Z" creationid="pingfangx" creationdate="20190620T105456Z">
        <seg>仅第一项之后的那些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, those items except the last items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105558Z" creationid="pingfangx" creationdate="20190620T105558Z">
        <seg>除了最后项之外的那些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, until one of those items matches a predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105527Z" creationid="pingfangx" creationdate="20190620T105527Z">
        <seg>直到其中一个项与谓词匹配</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that obtains its sequence from a Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104413Z" creationid="pingfangx" creationdate="20190620T104413Z">
        <seg>从 Future 获得序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that pulls its emissions from a particular &lt;c0&gt;Array&lt;/c0&gt;, &lt;c1&gt;Iterable&lt;/c1&gt;, or something like that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104401Z" creationid="pingfangx" creationdate="20190620T104401Z">
        <seg>从特定的 &lt;c0&gt;Array&lt;/c0&gt;，&lt;c1&gt;Iterable&lt;/c1&gt; 或类似的东西中拉取其发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that was returned from a function called at subscribe-time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104319Z" creationid="pingfangx" creationdate="20190620T104319Z">
        <seg>从订阅时调用的函数返回的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that was returned from an &lt;c0&gt;Action&lt;/c0&gt;, &lt;c1&gt;Callable&lt;/c1&gt;, &lt;c2&gt;Runnable&lt;/c2&gt;, or something of that sort, called at subscribe-time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104334Z" creationid="pingfangx" creationdate="20190620T104334Z">
        <seg>从 &lt;c0&gt;Action&lt;/c0&gt;，&lt;c1&gt;Callable&lt;/c1&gt;，&lt;c2&gt;Runnable&lt;/c2&gt; 或类似的东西返回，在订阅时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the ability for the producer to signal to the consumer that an error has occurred (an Iterable throws an exception if an error takes place during iteration; an Observable calls its observer’s &lt;c0&gt;onError&lt;/c0&gt; method)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042423Z" creationid="pingfangx" creationdate="20190620T042423Z">
        <seg>生产者向消费者发出错误信号的能力(如果在迭代期间发生错误，则 Iterable 抛出异常；Observable 调用其观察者的 &lt;c0&gt;onError&lt;/c0&gt; 方法)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the ability for the producer to signal to the consumer that there is no more data available (a foreach loop on an Iterable completes and returns normally in such a case; an Observable calls its observer’s &lt;c0&gt;onCompleted&lt;/c0&gt; method)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042400Z" creationid="pingfangx" creationdate="20190620T042400Z">
        <seg>生产者向消费者发出信号表明没有更多可用数据的能力(Iterable 上的 foreach 循环完成并在这种情况下正常返回；Observable 调用其观察者的 &lt;c0&gt;onCompleted&lt;/c0&gt; 方法)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the first item it emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105249Z" creationid="pingfangx" creationdate="20190620T105249Z">
        <seg>它发射的第一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the last item emitted before it completed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105243Z" creationid="pingfangx" creationdate="20190620T105243Z">
        <seg>完成之前发射的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sole item it emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105246Z" creationid="pingfangx" creationdate="20190620T105246Z">
        <seg>它发射的唯一项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transform the items emitted by an Observable by applying a function to each item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095829Z" creationid="pingfangx" creationdate="20190620T095829Z">
        <seg>通过将函数应用于每个项目来转换 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100559Z" creationid="pingfangx" creationdate="20190620T095740Z">
        <seg>将 Observable 发射的项目转换为 Observables，然后将这些项目的发射变为单个 Observable（译注：扁平，一个项变为多个项，然后发出多个项(可能交错)）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unambiguous operator should have been `defer`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102915Z" creationid="pingfangx" creationdate="20190617T102915Z">
        <seg>因此是正确的明确的运算符应该是 `defer`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.ignoreElements()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061549Z" creationid="pingfangx" creationdate="20190619T061549Z">
        <seg>使用 `Flowable.ignoreElements()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061553Z" creationid="pingfangx" creationdate="20190619T061553Z">
        <seg>使用 `Flowable.single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.singleElement()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061555Z" creationid="pingfangx" creationdate="20190619T061555Z">
        <seg>使用 `Flowable.singleElement()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.ignoreElements()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061557Z" creationid="pingfangx" creationdate="20190619T061557Z">
        <seg>使用 `Observable.ignoreElements()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061659Z" creationid="pingfangx" creationdate="20190619T061659Z">
        <seg>使用 `Observable.single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.singleElement()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061702Z" creationid="pingfangx" creationdate="20190619T061702Z">
        <seg>使用 `Observable.singleElement()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uses the specified &lt;c0&gt;Executor&lt;/c0&gt; as a Scheduler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091042Z" creationid="pingfangx" creationdate="20190620T091042Z">
        <seg>使用指定的 &lt;c0&gt;Executor&lt;/c0&gt; 作为调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101309Z" creationid="pingfangx" creationdate="20190620T101309Z">
        <seg>当一个项目由两个 Observable 中的任何一个发射时，通过指定的函数组合每个 Observable 发射的最新项目，并根据此函数的结果发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when it notifies observers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110012Z" creationid="pingfangx" creationdate="20190620T110012Z">
        <seg>当它通知观察者时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever &lt;e0&gt;any&lt;/e0&gt; of the Observables has emitted a new item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104704Z" creationid="pingfangx" creationdate="20190620T104704Z">
        <seg>每当 Observables 的 &lt;e0&gt;任何&lt;/e0&gt; 发射新项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever &lt;e0&gt;each&lt;/e0&gt; of the Observables has emitted a new item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104646Z" creationid="pingfangx" creationdate="20190620T104646Z">
        <seg>每当 Observables 的 &lt;e0&gt;每个&lt;/e0&gt; 发射一个新项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever an item is emitted by one Observable in a window defined by an item emitted by another</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104712Z" creationid="pingfangx" creationdate="20190620T104712Z">
        <seg>每当一个 Observable 在由另一个项目发射的项目定义的窗口中发射一个项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which I can then unwrap again with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105110Z" creationid="pingfangx" creationdate="20190620T105110Z">
        <seg>我可以再解除包装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111935Z" creationid="pingfangx" creationdate="20190618T111935Z">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>—</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095125Z" creationid="pingfangx" creationdate="20190620T095125Z">
        <seg>—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Hot” and “Cold” Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064846Z" creationid="pingfangx" creationdate="20190620T064846Z">
        <seg>“Hot” 和 “Cold” Observables</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
