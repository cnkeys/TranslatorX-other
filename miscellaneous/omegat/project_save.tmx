<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.0.0_0_dev" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>"Authentication" [RFC7235]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094109Z" creationid="pingfangx" creationdate="20190830T094109Z">
        <seg>“认证”[RFC7235]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Caching" [RFC7234]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T093357Z" creationid="pingfangx" creationdate="20190830T093357Z">
        <seg>“缓存”[RFC7234]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Conditional Requests" [RFC7232]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T093351Z" creationid="pingfangx" creationdate="20190830T093351Z">
        <seg>“有条件请求”[RFC7232]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Message Syntax and Routing" (this document)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T093343Z" creationid="pingfangx" creationdate="20190830T093343Z">
        <seg>“消息语法和路由”(本文档)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Quality values" is a misnomer, since these values merely represent relative degradation in desired quality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154350Z" creationid="pingfangx" creationdate="20190828T154350Z">
        <seg>“质量值”是一个用词不当的词，因为这些值仅代表所需质量的相对下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Range Requests" [RFC7233]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T093354Z" creationid="pingfangx" creationdate="20190830T093354Z">
        <seg>“范围请求”[RFC7233]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Semantics and Content" [RFC7231]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T093348Z" creationid="pingfangx" creationdate="20190830T093348Z">
        <seg>“语义和内容”[RFC7231]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"multipart/byteranges" is no longer a way of determining message body length detection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092022Z" creationid="pingfangx" creationdate="20190830T092022Z">
        <seg>“multipart/byteranges”不再是确定消息体长度检测的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Base reactive interfaces</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061145Z" creationid="pingfangx" creationdate="20190618T061145Z">
        <seg># 基本响应接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052054Z" creationid="pingfangx" creationdate="20190618T052054Z">
        <seg># 内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Creating backpressured datasources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015345Z" creationid="pingfangx" creationdate="20190624T015345Z">
        <seg># 创建背压数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Entering the reactive world</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094146Z" creationid="pingfangx" creationdate="20190618T094146Z">
        <seg># 进入响应世界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Introduction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T062104Z" creationid="pingfangx" creationdate="20190621T062104Z">
        <seg># 介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Leaving the reactive world</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094913Z" creationid="pingfangx" creationdate="20190618T094913Z">
        <seg># 离开响应世界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Maven address and base package</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052542Z" creationid="pingfangx" creationdate="20190618T052542Z">
        <seg># Maven 地址和基础包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Miscellaneous changes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114733Z" creationid="pingfangx" creationdate="20190618T114733Z">
        <seg># 杂项更改</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Observable and Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053023Z" creationid="pingfangx" creationdate="20190618T053023Z">
        <seg># Observable 和 Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Operator differences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T103142Z" creationid="pingfangx" creationdate="20190618T103142Z">
        <seg># 操作符差异</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Other classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063638Z" creationid="pingfangx" creationdate="20190618T063638Z">
        <seg># 其他类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># RxJava: Reactive Extensions for the JVM</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103322Z" creationid="pingfangx" creationdate="20190617T103322Z">
        <seg># RxJava: Reactive Extensions for the JVM
原文 [ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The onBackpressureXXX operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084603Z" creationid="pingfangx" creationdate="20190621T084603Z">
        <seg># onBackpressureXXX 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## 1.x Observable to 2.x Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111342Z" creationid="pingfangx" creationdate="20190618T111342Z">
        <seg>## 1.x Observable 到 2.x Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Batching/skipping values with standard operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091136Z" creationid="pingfangx" creationdate="20190621T091136Z">
        <seg>## 使用标准操作符批处理/跳过值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Binaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105435Z" creationid="pingfangx" creationdate="20190617T105435Z">
        <seg>## 二进制文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Bugs and Feedback</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105627Z" creationid="pingfangx" creationdate="20190617T105627Z">
        <seg>## 错误和反馈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Build</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105554Z" creationid="pingfangx" creationdate="20190617T105554Z">
        <seg>## 构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Communication</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104636Z" creationid="pingfangx" creationdate="20190617T104636Z">
        <seg>## 沟通</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Full Documentation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105421Z" creationid="pingfangx" creationdate="20190617T105421Z">
        <seg>## 完整文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Getting started</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065829Z" creationid="pingfangx" creationdate="20190617T065829Z">
        <seg>## 入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Increasing the buffer sizes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090231Z" creationid="pingfangx" creationdate="20190621T090231Z">
        <seg>## 增加缓冲区大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Testing an async source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101814Z" creationid="pingfangx" creationdate="20190618T101814Z">
        <seg>## 测试异步源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Versioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104645Z" creationid="pingfangx" creationdate="20190617T104645Z">
        <seg>## 版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Which type to use?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053516Z" creationid="pingfangx" creationdate="20190618T053516Z">
        <seg>## 使用哪种类型？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## cancel and request upfront</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101647Z" creationid="pingfangx" creationdate="20190618T101647Z">
        <seg>## 取消并提前请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Base classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070028Z" creationid="pingfangx" creationdate="20190617T065921Z">
        <seg>### 基类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Calling request from onSubscribe/onStart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070914Z" creationid="pingfangx" creationdate="20190618T070914Z">
        <seg>### 从 onSubscribe/onStart 调用请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Concurrency within a flow</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075248Z" creationid="pingfangx" creationdate="20190617T075248Z">
        <seg>### Concurrency within a flow (流中的并发)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Different return types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060112Z" creationid="pingfangx" creationdate="20190619T060112Z">
        <seg>### 不同的返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Factory methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111351Z" creationid="pingfangx" creationdate="20190618T111351Z">
        <seg>### 工厂方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Further reading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104614Z" creationid="pingfangx" creationdate="20190617T104614Z">
        <seg>### 扩展阅读</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Instance methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114532Z" creationid="pingfangx" creationdate="20190618T114532Z">
        <seg>### 实例方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Notable new assert methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100029Z" creationid="pingfangx" creationdate="20190618T100029Z">
        <seg>### 值得注意的新断言方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Operator naming conventions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100918Z" creationid="pingfangx" creationdate="20190617T100918Z">
        <seg>### 运算符命名约定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Parallel processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075735Z" creationid="pingfangx" creationdate="20190617T075735Z">
        <seg>### Parallel processing (并行处理)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Removals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061504Z" creationid="pingfangx" creationdate="20190619T061504Z">
        <seg>### 移除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava Libraries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113636Z" creationid="pingfangx" creationdate="20190617T113636Z">
        <seg>### RxJava 库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava is Lightweight</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113501Z" creationid="pingfangx" creationdate="20190617T113501Z">
        <seg>### RxJava 是轻量级的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava is a Polyglot Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113532Z" creationid="pingfangx" creationdate="20190617T113532Z">
        <seg>### RxJava 是一个多语言实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072905Z" creationid="pingfangx" creationdate="20190617T072905Z">
        <seg>### Schedulers (调度器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Setting up the dependency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065800Z" creationid="pingfangx" creationdate="20190617T065800Z">
        <seg>### 设置依赖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Simple background computation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072223Z" creationid="pingfangx" creationdate="20190617T072223Z">
        <seg>### 简单的后台计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Some terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070420Z" creationid="pingfangx" creationdate="20190617T070420Z">
        <seg>### 一些术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Type conversions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092701Z" creationid="pingfangx" creationdate="20190617T092701Z">
        <seg>### Type conversions (类型转换)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### When to use Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054920Z" creationid="pingfangx" creationdate="20190618T054920Z">
        <seg>### 何时使用 Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### When to use Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053650Z" creationid="pingfangx" creationdate="20190618T053650Z">
        <seg>### 何时使用 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Assembly time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092336Z" creationid="pingfangx" creationdate="20190617T072124Z">
        <seg>#### Assembly time (编译时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Backpressure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071620Z" creationid="pingfangx" creationdate="20190617T071124Z">
        <seg>#### Backpressure (背压)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Converting to the desired type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092851Z" creationid="pingfangx" creationdate="20190617T092851Z">
        <seg>#### 转换为所需类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Error handling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103119Z" creationid="pingfangx" creationdate="20190617T103119Z">
        <seg>#### 错误处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Objects in motion</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071614Z" creationid="pingfangx" creationdate="20190617T071032Z">
        <seg>#### Objects in motion (运动中的对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Runtime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072154Z" creationid="pingfangx" creationdate="20190617T072154Z">
        <seg>#### Runtime (运行时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Subscription time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092347Z" creationid="pingfangx" creationdate="20190617T072132Z">
        <seg>#### Subscription time (订阅时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Type ambiguities</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102207Z" creationid="pingfangx" creationdate="20190617T102207Z">
        <seg>#### 类型歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Type erasure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101921Z" creationid="pingfangx" creationdate="20190617T101921Z">
        <seg>#### 类型擦除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Unusable keywords</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101509Z" creationid="pingfangx" creationdate="20190617T101509Z">
        <seg>#### 不可用的关键字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Upstream, downstream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071556Z" creationid="pingfangx" creationdate="20190617T070428Z">
        <seg>#### Upstream, downstream (上游，下游)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Using an overload with the desired type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100644Z" creationid="pingfangx" creationdate="20190617T100644Z">
        <seg>#### 使用所需类型的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A sequence is idempotent if a single execution of the entire sequence always yields a result that is not changed by a reexecution of all, or part, of that sequence.) For example, a sequence is non-idempotent if its result depends on a value that is later modified in the same sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T040739Z" creationid="pingfangx" creationdate="20190830T040739Z">
        <seg>(如果整个序列的单次执行总是产生一个不会通过重新执行该序列的全部或部分而改变的结果，则序列是幂等的。)例如，如果一个序列的结果依赖于一个稍后在同一序列中修改的值，则该序列是非幂等的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(But see section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101705Z" creationid="pingfangx" creationdate="20190829T101705Z">
        <seg>(但有关 HTTP/1.1 中 Host 支持的其他要求，请参阅第 19.6.1.1 节。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Closing the connection cannot be used to indicate the end of a request body, since that would leave no possibility for the server to send back a response.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090049Z" creationid="pingfangx" creationdate="20190829T090049Z">
        <seg>(关闭连接不能用于指示请求正文的结束，因为这样就不会让服务器发回响应。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For instance, a client may be connecting to a machine whose address and hostname are dynamic but the client knows the certificate that the server will present.) In such cases, it is important to narrow the scope of acceptable certificates as much as possible in order to prevent man in the middle attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103733Z" creationid="pingfangx" creationdate="20190901T103733Z">
        <seg>(例如，客户端可能正在连接到一台机器，其地址和主机名是动态的，但客户端知道服务器将提供的证书。)在这种情况下，尽可能缩小可接受证书的范围非常重要，为了防止中间人攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, section 3.6 places restrictions on when certain transfer-codings may be used.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084232Z" creationid="pingfangx" creationdate="20190829T084232Z">
        <seg>(但是，第 3.6 节限制了何时可以使用某些转输编码。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the source Observable does not emit any values, the &lt;c1&gt;AsyncSubject&lt;/c1&gt; also completes without emitting any values.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083942Z" creationid="pingfangx" creationdate="20190620T083942Z">
        <seg>(如果源 Observable 未发射任何值，则 &lt;c1&gt;AsyncSubject&lt;/c1&gt; 也会完成而不会发射任何值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See Appendix A.2.3 of [Kri2001] for details.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082614Z" creationid="pingfangx" creationdate="20190831T082614Z">
        <seg>(详见 [Kri2001] 附录 A.2.3。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The Reactive-Streams specification allows throwing `NullPointerException` if the `onSubscribe`, `onNext` or `onError` receives a `null` value, but RxJava doesn't let `null`s in any way.) This means the following code is no longer legal:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095546Z" creationid="pingfangx" creationdate="20190618T095546Z">
        <seg>（如果 `onSubscribe`，`onNext` 或 `onError` 接收到 `null` 值，Reactive-Streams 规范允许抛出 `NullPointerException`，但 RxJava 不以任何方式接受 `null`。这意味着以下代码不再合法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The last three tags above are not registered tags; all but the last are examples of tags which could be registered in future.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155504Z" creationid="pingfangx" creationdate="20190828T155504Z">
        <seg>(上面的最后三个标签不是注册标签；除了最后一个标签之外的所有标签都是可以在将来注册的标签示例。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The reason for this is twofold: performance and ease of use of the library as a synchronous Java 8 Streams-like processor.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095320Z" creationid="pingfangx" creationdate="20190618T095320Z">
        <seg>(原因有两个：作为同步 Java 8 Streams 类似处理器的库的性能和易用性。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The same approach works with `GroupedFlowable` as well.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064010Z" creationid="pingfangx" creationdate="20190618T064010Z">
        <seg>(同样的方法也适用于 `GroupedFlowable`。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is understandable because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091144Z" creationid="pingfangx" creationdate="20190617T091144Z">
        <seg>(这是可以理解的，因为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This rule differs slightly from the path-abempty rule of RFC 3986, which allows for an empty path to be used in references, and path-absolute rule, which does not allow paths that begin with "//".)  A "partial-URI" rule is defined for protocol elements that can contain a relative URI but not a fragment component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T105046Z" creationid="pingfangx" creationdate="20190830T105030Z">
        <seg>(此规则略微不同于 RFC 3986 的路径优先规则，它允许在引用中使用空路径，而 path-absolute 规则则不允许以“//”开头的路径。)“partial-URI”规则是为可以包含相对 URI 但不包含片段组件的协议元素定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We never had a use for it in 1.x and the original `Subject&lt;T, R&gt;` came from .NET where there is a `Subject&lt;T&gt;` overload because .NET allows the same class name with a different number of type arguments.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062556Z" creationid="pingfangx" creationdate="20190618T062556Z">
        <seg>(我们从来没有在 1.x 中使用它，原来的 `Subject&lt;T, R&gt;` 来自 .NET，其中有一个 `Subject&lt;T&gt;` 重载，因为 .NET 允许相同的类名具有不同数量的类型参数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(b)  Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021729Z" creationid="pingfangx" creationdate="20190828T021729Z">
        <seg>(b) 确定已经确认了报文段所占用的所有序列号(例如，从重发队列中删除该报文段)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(c)  Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021745Z" creationid="pingfangx" creationdate="20190828T021745Z">
        <seg>(c) 确定传入报文段包含预期的序列号(即，报文段“重叠”接收窗口)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*(Remark: this is "experimental" in RC2 and RC3 to see how it feels to program with such mixed-type sequences and whether or not there has to be too much `toObservable`/`toFlowable` back-conversion.)*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060231Z" creationid="pingfangx" creationdate="20190619T060231Z">
        <seg>*(注：这在 RC2 和 RC3 中是“实验性的”，看看用这种混合型序列编程感觉如何，以及是否必须有太多 `toObservable`/`toFlowable` 反向转换。)*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*(You could also consider IxJava which is optimized for Iterable flows supporting Java 6+)*.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054849Z" creationid="pingfangx" creationdate="20190618T054849Z">
        <seg>*(您还可以考虑 IxJava，它针对支持 Java 6+ 的 Iterable 流程进行了优化)*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**Backpressure** is when in an `Flowable` processing pipeline, some asynchronous stages can't process the values fast enough and need a way to tell the upstream producer to slow down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T062429Z" creationid="pingfangx" creationdate="20190621T062429Z">
        <seg>**Backpressure (背压)** 是在 `Flowable` 外理管道中，某些异步阶段无法足够快地处理这些值，需要一种方法来告诉上游生产者减速。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** dropped, use `ignoreElements`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054007Z" creationid="pingfangx" creationdate="20190619T054007Z">
        <seg>**RC3** 删除，请使用 `ignoreElements`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** dropped, use `single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054042Z" creationid="pingfangx" creationdate="20190619T054042Z">
        <seg>**RC3** 已删除，请使用 `single(T)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** no longer signals NoSuchElementException if the source is shorter than the index</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052611Z" creationid="pingfangx" creationdate="20190619T052611Z">
        <seg>如果源短于索引，**RC3** 不再发出 NoSuchElementException 信号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `firstElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052939Z" creationid="pingfangx" creationdate="20190619T052939Z">
        <seg>**RC3** 重命名为 `firstElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `lastElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053135Z" creationid="pingfangx" creationdate="20190619T053135Z">
        <seg>**RC3** 重命名为 `lastElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `singleElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053608Z" creationid="pingfangx" creationdate="20190619T053608Z">
        <seg>**RC3** 重命名为 `singleElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Completable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053116Z" creationid="pingfangx" creationdate="20190619T053116Z">
        <seg>**RC3** 返回 `Completable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053323Z" creationid="pingfangx" creationdate="20190619T053323Z">
        <seg>**RC3** 返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Boolean&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053123Z" creationid="pingfangx" creationdate="20190619T053123Z">
        <seg>**RC3** 返回 `Single&lt;Boolean&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Boolean&gt;` now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115702Z" creationid="pingfangx" creationdate="20190618T115702Z">
        <seg>**RC3** 现在返回 `Single&lt;Boolean&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;List&lt;T&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054014Z" creationid="pingfangx" creationdate="20190619T054014Z">
        <seg>**RC3** 返回 `Single&lt;List&lt;T&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Long&gt;` now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052201Z" creationid="pingfangx" creationdate="20190619T052201Z">
        <seg>**RC3** 现直返回 `Single&lt;Long&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054027Z" creationid="pingfangx" creationdate="20190619T054027Z">
        <seg>**RC3** 返回 `Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Map&lt;K, V&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054020Z" creationid="pingfangx" creationdate="20190619T054020Z">
        <seg>**RC3** 返回 `Single&lt;Map&lt;K, V&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;U&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115759Z" creationid="pingfangx" creationdate="20190618T115759Z">
        <seg>**RC3** 返回 `Single&lt;U&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**The `Flowable`-based sources and operators are, as of 2.0.7, fully Reactive-Streams version 1.0.0 specification compliant.**</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073813Z" creationid="pingfangx" creationdate="20190618T073813Z">
        <seg>**从 2.0.7 开始，基于 `Flowable` 的源和运算符完全符合 Reactive-Streams 版本 1.0.0 规范。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-  Authentication: The server side of the channel is always authenticated; the client side is optionally authenticated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122453Z" creationid="pingfangx" creationdate="20190901T122453Z">
        <seg> - 身份验证：通道的服务器端始终进行身份验证；客户端可选择进行身份验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-  Confidentiality: Data sent over the channel after establishment is only visible to the endpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122851Z" creationid="pingfangx" creationdate="20190901T122851Z">
        <seg>- 保密性：建立后通过信道发送的数据仅对端点可见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-  Integrity: Data sent over the channel after establishment cannot be modified by attackers without detection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T123339Z" creationid="pingfangx" creationdate="20190901T123339Z">
        <seg>- 完整性：无须检测，攻击者无法修改建立后通过信道发送的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- 1xx: Informational - Request received, continuing process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105635Z" creationid="pingfangx" creationdate="20190829T105635Z">
        <seg>- 1xx：信息 - 收到请求，继续处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- 2xx: Success - The action was successfully received, understood, and accepted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105652Z" creationid="pingfangx" creationdate="20190829T105652Z">
        <seg>- 2xx：成功 - 操作已成功收到，理解并被接受</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- 3xx: Redirection - Further action must be taken in order to complete the request</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105702Z" creationid="pingfangx" creationdate="20190829T105702Z">
        <seg>- 3xx：重定向 - 必须采取进一步措施才能完成请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- 4xx: Client Error - The request contains bad syntax or cannot be fulfilled</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105712Z" creationid="pingfangx" creationdate="20190829T105712Z">
        <seg>- 4xx：客户端错误 - 请求包含错误的语法或无法满足</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- 5xx: Server Error - The server failed to fulfill an apparently valid request</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105725Z" creationid="pingfangx" creationdate="20190829T105725Z">
        <seg>- 5xx：服务器错误 - 服务器无法满足明显有效的请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- A client MUST NOT send an Expect request-header field (section 14.20) with the "100-continue" expectation if it does not intend to send a request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024530Z" creationid="pingfangx" creationdate="20190830T024530Z">
        <seg> - 如果客户端不打算发送请求正文，则不得发送具有“100-continue”期望的 Expect 请求首部字段(第 14.20 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- A port that is empty or not given is equivalent to the default port for that URI-reference;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112847Z" creationid="pingfangx" creationdate="20190828T112847Z">
        <seg>- 空的或未给出的端口等同于该 URI 引用的默认端口；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- A proxy MUST NOT forward a 100 (Continue) response if the request message was received from an HTTP/1.0 (or earlier) client and did not include an Expect request-header field with the "100-continue" expectation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025916Z" creationid="pingfangx" creationdate="20190830T025916Z">
        <seg>- 如果从 HTTP/1.0(或更早版本)客户端收到请求消息，并且未包含具有“100-continue”期望的 Expect 请求首部字段，则代理不得转发 100(继续)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- An empty abs_path is equivalent to an abs_path of "/".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112936Z" creationid="pingfangx" creationdate="20190828T112936Z">
        <seg>- 空的 abs_path 相当于 “/” 的 abs_path。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- An origin server MAY omit a 100 (Continue) response if it has already received some or all of the request body for the corresponding request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025318Z" creationid="pingfangx" creationdate="20190830T025318Z">
        <seg> - 如果原始服务器已经收到相应请求的部分或全部请求主体，则可以省略 100(继续)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- An origin server SHOULD NOT send a 100 (Continue) response if the request message does not include an Expect request-header field with the "100-continue" expectation, and MUST NOT send a 100 (Continue) response if such a request comes from an HTTP/1.0 (or earlier) client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025115Z" creationid="pingfangx" creationdate="20190830T025115Z">
        <seg> - 如果请求消息不包含具有“100-continue”期望的 Expect 请求首部字段，则原始服务器不应发送 100(继续)响应，如果此请求来自 HTTP/1.0(或更早版本)的客户端，则不得发送 100(继续)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- An origin server that sends a 100 (Continue) response MUST ultimately send a final status code, once the request body is received and processed, unless it terminates the transport connection prematurely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025459Z" creationid="pingfangx" creationdate="20190830T025459Z">
        <seg>- 发送 100(继续)响应的源服务器必须在收到并处理请求主体后最终发送最终状态代码，除非它过早终止传输连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Annotation of existing resources;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064128Z" creationid="pingfangx" creationdate="20190830T064128Z">
        <seg>- 现有资源的注释；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144351Z" creationid="pingfangx" creationdate="20190829T144351Z">
        <seg> - 通过打开和关闭较少的 TCP 连接，CPU 时间减少在路由器和主机(客户端，服务器，代理，网关，隧道或缓存)中，用于 TCP 协议控制块的内存可以减少在主机中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Comparisons of host names MUST be case-insensitive;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112902Z" creationid="pingfangx" creationdate="20190828T112902Z">
        <seg>- 主机名的比较必须不区分大小写；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Comparisons of scheme names MUST be case-insensitive;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112913Z" creationid="pingfangx" creationdate="20190828T112913Z">
        <seg>- 方案名称的比较必须不区分大小写；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Dealing with 10k+ of elements that are generated in some fashion somewhere and thus the chain can tell the source to limit the amount it generates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055019Z" creationid="pingfangx" creationdate="20190618T055019Z">
        <seg>- 处理以某种方式在某处生成的 10k+ 元素，因此链可以告诉源限制它产生的量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Extending a database through an append operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064224Z" creationid="pingfangx" creationdate="20190830T064224Z">
        <seg>- 通过追加操作扩展数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150021Z" creationid="pingfangx" creationdate="20190829T150021Z">
        <seg>- HTTP 可以更优雅地发展，因为可以报告错误而不必关闭 TCP 连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- HTTP requests and responses can be pipelined on a connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144948Z" creationid="pingfangx" creationdate="20190829T144948Z">
        <seg>- HTTP 请求和响应可以在连接上流水线化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If a client will wait for a 100 (Continue) response before sending the request body, it MUST send an Expect request-header field (section 14.20) with the "100-continue" expectation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024508Z" creationid="pingfangx" creationdate="20190830T024508Z">
        <seg> - 如果客户端在发送请求主体之前将等待 100(继续)响应，它必须发送具有“100-continue”期望的 Expect 请求报首部字段(第 14.20 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If a proxy receives a request that includes an Expect request- header field with the "100-continue" expectation, and the proxy either knows that the next-hop server complies with HTTP/1.1 or higher, or does not know the HTTP version of the next-hop server, it MUST forward the request, including the Expect header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025725Z" creationid="pingfangx" creationdate="20190830T025725Z">
        <seg>- 如果代理收到包含具有“100-continue”期望的 Expect 请求首部字段的请求，并且代理知道下一跳服务器符合 HTTP/1.1 或更高版本，或者不知道在下一跳服务器上的 HTTP 版本，它必须转发请求，包括 Expect 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If an origin server receives a request that does not include an Expect request-header field with the "100-continue" expectation, the request includes a request body, and the server responds with a final status code before reading the entire request body from the transport connection, then the server SHOULD NOT close the transport connection until it has read the entire request, or until the client closes the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025551Z" creationid="pingfangx" creationdate="20190830T025551Z">
        <seg> - 如果源服务器收到的请求不包含具有“100-continue”期望的 Expect 请求首部字段，该请求包括请求主体，并且服务器在读取整个请求主体之前使用最终状态代码进行响应传输连接，然后服务器不应关闭传输连接，直到它已读取整个请求，或直到客户端关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If the proxy knows that the version of the next-hop server is HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST respond with a 417 (Expectation Failed) status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025843Z" creationid="pingfangx" creationdate="20190830T025735Z">
        <seg>- 如果代理知道下一跳服务器的版本是 HTTP/1.0 或更低，它不复转发请求，它必须以 417(期望失败)状态响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Java 8 lambda-friendly API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065159Z" creationid="pingfangx" creationdate="20190617T065159Z">
        <seg>- Java 8 lambda 友好的 API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Latency on subsequent requests is reduced since there is no time spent in TCP's connection opening handshake.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T145948Z" creationid="pingfangx" creationdate="20190829T145948Z">
        <seg>- 由于没有花费在 TCP 连接打开时握手上的时间，因此减少了后续请求的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Many blocking and/or pull-based data sources which may eventually get a non-blocking reactive API/driver in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055442Z" creationid="pingfangx" creationdate="20190618T055442Z">
        <seg>- 许多阻塞和/或基于拉的数据源，最终可能会在未来获得非阻塞的响应 API/驱动程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Network (Streaming) IO where either the network helps or the protocol used supports requesting some logical amount.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055402Z" creationid="pingfangx" creationdate="20190618T055402Z">
        <seg>- 网络(流)IO，其中网络帮助或使用的协议支持请求一些逻辑量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T145919Z" creationid="pingfangx" creationdate="20190829T145919Z">
        <seg>- 通过减少 TCP 打开引起的数据包数量，并允许 TCP 有足够的时间来确定网络的拥塞状态，从而减少网络拥塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064141Z" creationid="pingfangx" creationdate="20190830T064141Z">
        <seg>- 在公告板，新闻组，邮件列表或类似的文章组中发布消息；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Providing a block of data, such as the result of submitting a form, to a data-handling process;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064215Z" creationid="pingfangx" creationdate="20190830T064215Z">
        <seg>- 向数据处理过程提供一组数据，例如提交表单的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Proxies SHOULD maintain a cache recording the HTTP version numbers received from recently-referenced next-hop servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025856Z" creationid="pingfangx" creationdate="20190830T025856Z">
        <seg>- 代理应该保持一个缓存，记录从最近引用的下一跳服务器收到的 HTTP 版本号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Reading (parsing) files from disk is inherently blocking and pull-based which works well with backpressure as you control, for example, how many lines you read from this for a specified request amount).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055258Z" creationid="pingfangx" creationdate="20190618T055258Z">
        <seg>- 从磁盘读取（解析）文件本质上是阻塞和基于拉取的，当您控制时，它可以很好地处理背压，例如，您为指定的请求数量控制读取多少行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Reading from a database through JDBC is also blocking and pull-based and is controlled by you by calling `ResultSet.next()` for likely each downstream request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055324Z" creationid="pingfangx" creationdate="20190618T055324Z">
        <seg>- 通过 JDBC 从数据库读取也是阻塞和基于拉取的，并且可以通过调用 `ResultSet.next()` 来控制每个下游请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- SHOULD NOT continue and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030543Z" creationid="pingfangx" creationdate="20190830T030543Z">
        <seg>- 不应该继续并且</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- SHOULD close the connection if it has not completed sending the request message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030621Z" creationid="pingfangx" creationdate="20190830T030621Z">
        <seg>- 应该关闭连接如果连接尚未完成发送请求消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Upon receiving a request which includes an Expect request-header field with the "100-continue" expectation, an origin server MUST either respond with 100 (Continue) status and continue to read from the input stream, or respond with a final status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024817Z" creationid="pingfangx" creationdate="20190830T024817Z">
        <seg> - 收到包含具有“100-continue”期望的 Expect 请求首部字段的请求后，源服务器必须以 100(继续)状态响应并继续从输入流中读取，或以最终状态代码进行响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- You deal with GUI events such as mouse moves or touch events: these can rarely be backpressured reasonably and aren't that frequent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054621Z" creationid="pingfangx" creationdate="20190618T054621Z">
        <seg>- 您处理 GUI 事件，例如鼠标移动或触摸事件：这些事件很少能够合理地背压并且不那么频繁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- You have a flow of no more than 1000 elements at its longest: i.e., you have so few elements over time that there is practically no chance for OOME in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054407Z" creationid="pingfangx" creationdate="20190618T054407Z">
        <seg>- 最长流不超过 1000 个元素：即，随着时间的推移元素会很少，因此在您的应用程序中几乎不会出现 OOME。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Your flow is essentially synchronous but your platform doesn't support Java Streams or you miss features from it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054808Z" creationid="pingfangx" creationdate="20190618T054808Z">
        <seg>- 您的流基本上是同步的，但您的平台不支持 Java Streams，或者您错过了它的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Base reactive interfaces](#base-reactive-interfaces)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052438Z" creationid="pingfangx" creationdate="20190618T052438Z">
        <seg>- [基本响应接口](#base-reactive-interfaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Maven address and base package](#maven-address-and-base-package)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052409Z" creationid="pingfangx" creationdate="20190618T052409Z">
        <seg>- [Maven 地址和基础包](#maven-address-and-base-package)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Miscellaneous changes](#miscellaneous-changes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052533Z" creationid="pingfangx" creationdate="20190618T052533Z">
        <seg>- [杂项更改](#miscellaneous-changes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Observable and Flowable](#observable-and-flowable)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052413Z" creationid="pingfangx" creationdate="20190618T052413Z">
        <seg>- [Observable 和 Flowable](#observable-and-flowable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Other classes](#other-classes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052452Z" creationid="pingfangx" creationdate="20190618T052452Z">
        <seg>- [其他类](#other-classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Subjects and Processors](#subjects-and-processors)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052444Z" creationid="pingfangx" creationdate="20190618T052444Z">
        <seg>- [Subjects 和 Processors](#subjects-and-processors)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): a flow without items but only a completion or error signal,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070349Z" creationid="pingfangx" creationdate="20190617T070349Z">
        <seg>- [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): 没有项目但只有完成或错误信号的流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Flowable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html): 0..N flows, supporting Reactive-Streams and backpressure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070240Z" creationid="pingfangx" creationdate="20190617T070240Z">
        <seg>- [`io.reactivex.Flowable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html): 0..N 流，支持响应式流和背压</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): a flow with no items, exactly one item or an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070416Z" creationid="pingfangx" creationdate="20190617T070416Z">
        <seg>- [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): 没有项目，只有一个项目或错误的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N flows, no backpressure,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070329Z" creationid="pingfangx" creationdate="20190617T070250Z">
        <seg>- [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N 流，无背压，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): a flow of exactly 1 item or an error,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070327Z" creationid="pingfangx" creationdate="20190617T070319Z">
        <seg>- [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): 仅 1 个项目或错误的流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `CompositeSubscription` to `CompositeDisposable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073146Z" creationid="pingfangx" creationdate="20190618T073146Z">
        <seg>- `CompositeSubscription` 变为 `CompositeDisposable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DEFAULT`: currently it is the same as `ON_OVERFLOW_ERROR`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014531Z" creationid="pingfangx" creationdate="20190624T014531Z">
        <seg>- `ON_OVERFLOW_DEFAULT`：目前它与 `ON_OVERFLOW_ERROR` 相同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DROP_LATEST` : if an overflow would happen, the current value will be simply ignored and only the old values will be delivered once the downstream requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014549Z" creationid="pingfangx" creationdate="20190624T014549Z">
        <seg>- `ON_OVERFLOW_DROP_LATEST`：如果发生溢出，将简单地忽略当前值，并且只有下游请求才会传递旧值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DROP_OLDEST` : drops the oldest element in the buffer and adds the current value to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014614Z" creationid="pingfangx" creationdate="20190624T014614Z">
        <seg>- `ON_OVERFLOW_DROP_OLDEST`：删除缓冲区中最旧的元素并将当前值添加到缓冲区中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_ERROR`: this is the default behavior of the previous two overloads, signalling a `BufferOverflowException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014521Z" creationid="pingfangx" creationdate="20190624T014521Z">
        <seg>- `ON_OVERFLOW_ERROR`：这是前两个重载的默认行为，表示 `BufferOverflowException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `OnErrorNotImplementedException`: reintroduced to detect when the user forgot to add error handling to `subscribe()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091126Z" creationid="pingfangx" creationdate="20190618T091126Z">
        <seg>- `OnErrorNotImplementedException`：重新引入以检测用户何时忘记向 `subscribe()` 添加错误处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ProtocolViolationException`: indicates a bug in an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091133Z" creationid="pingfangx" creationdate="20190618T091133Z">
        <seg>- `ProtocolViolationException`：表示运算符中的错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `RefCountSubscription` has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073214Z" creationid="pingfangx" creationdate="20190618T073214Z">
        <seg>- `RefCountSubscription` 已被移除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.computation()`: Run computation intensive work on a fixed number of dedicated threads in the background.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073217Z" creationid="pingfangx" creationdate="20190617T073217Z">
        <seg>- `Schedulers.computation()`: 在后台固定数量的专用线程上，运行计算密集型工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.io()`: Run I/O-like or blocking operations on a dynamically changing set of threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073321Z" creationid="pingfangx" creationdate="20190617T073321Z">
        <seg>- `Schedulers.io()`: 在动态变化的线程集上运行类似 I/O 或阻塞操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.single()`: Run work on a single thread in a sequential and FIFO manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073336Z" creationid="pingfangx" creationdate="20190617T073336Z">
        <seg>- `Schedulers.single()`: 以顺序和 FIFO 方式在单个线程上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.trampoline()`: Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073400Z" creationid="pingfangx" creationdate="20190617T073400Z">
        <seg>- `Schedulers.trampoline()`: 在一个参与线程中以顺序和 FIFO 方式运行，通常用于测试目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `SerialSubscription` and `MultipleAssignmentSubscription` have been merged into `SerialDisposable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073154Z" creationid="pingfangx" creationdate="20190618T073154Z">
        <seg>- `SerialSubscription` 和 `MultipleAssignmentSubscription` 已合并到 `SerialDisposable` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `UndeliverableException`: wraps the original exception that can't be delivered due to lifecycle restrictions on a `Subscriber`/`Observer`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091154Z" creationid="pingfangx" creationdate="20190618T091154Z">
        <seg>- `UndeliverableException`：包装因 `Subscriber`/`Observer` 的生命周期限制而无法传递的原始异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertFailure(Class&lt;? extends Throwable&gt; clazz, T... items)`: asserts if subscribed, received exactly the given items in the given order followed by a `Throwable` error of wich `clazz.isInstance()` returns true.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101401Z" creationid="pingfangx" creationdate="20190618T101401Z">
        <seg>- `assertFailure(Class&lt;? extends Throwable&gt; clazz, T... items)`：断言如果订阅，按给定顺序接收到给定项后，跟一个 `Throwable` 错误，其 `clazz.isInstance()` 返回 true。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertFailureAndMessage(Class&lt;? extends Throwable&gt; clazz, String message, T... items)`: same as `assertFailure` plus validates the `getMessage()` contains the specified message</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101434Z" creationid="pingfangx" creationdate="20190618T101434Z">
        <seg>- `assertFailureAndMessage(Class&lt;? extends Throwable&gt; clazz, String message, T... items)`：与 `assertFailure` 相同，加上验证 `getMessage()` 包含指定的消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertOf(Consumer&lt;TestSubscriber&lt;T&gt;&gt; consumer)` compose some assertions into the fluent chain (used internally for fusion test as operator fusion is not part of the public API right now).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101538Z" creationid="pingfangx" creationdate="20190618T101538Z">
        <seg>- `assertOf(Consumer&lt;TestSubscriber&lt;T&gt;&gt; consumer)` 将一些断言组合到流畅的链中(内部用于融合测试，因为运算符融合现在不是公共 API 的一部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertResult(T... items)`: asserts if subscribed, received exactly the given items in the given order followed by `onComplete` and no errors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100201Z" creationid="pingfangx" creationdate="20190618T100201Z">
        <seg>- `assertResult(T... items)`：断言如果已订阅，则在 `onComplete` 之后按给定顺序接收给定的项，并且没有错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `awaitDone(long time, TimeUnit unit)` awaits a terminal event (blockingly) and cancels the sequence if the timeout elapsed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101454Z" creationid="pingfangx" creationdate="20190618T101454Z">
        <seg>- `awaitDone(long time, TimeUnit unit)` 等待终端事件(阻塞)并在超时结束时取消序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `concatMapEager` which runs all inner flows "at once" but the output flow will be in the order those inner flows were created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083254Z" creationid="pingfangx" creationdate="20190617T083254Z">
        <seg>- `concatMapEager`，它“同时”运行所有内部流，但输出流将按照创建内部流的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `concatMap` that maps and runs one inner flow at a time and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083218Z" creationid="pingfangx" creationdate="20190617T083218Z">
        <seg>- `concatMap` 一次映射并运行一个内部流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- a `BackpressureStrategy` enumeration that mandates the developer to specify the backpressure behavior to be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021957Z" creationid="pingfangx" creationdate="20190624T021957Z">
        <seg>- 一个 `BackpressureStrategy` 枚举，要求开发人员指定要应用的背压行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- a callback that will be called with an instance of the `Emitter&lt;T&gt;` interface for each incoming subscriber,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021941Z" creationid="pingfangx" creationdate="20190624T021941Z">
        <seg>-将为每个传入的订阅者调用的回调，回调时带 `Emitter&lt;T&gt;` 接口实例，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- async or synchronous execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065441Z" creationid="pingfangx" creationdate="20190617T065441Z">
        <seg> - 异步或同步执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- continued support for Java 6+ &amp; [Android](https://github.com/ReactiveX/RxAndroid) 2.3+</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065015Z" creationid="pingfangx" creationdate="20190617T065015Z">
        <seg>- 继续支持 Java 6+ 和 [Android](https://github.com/ReactiveX/RxAndroid) 2.3+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- performance gains through design changes learned through the 1.x cycle and through [Reactive-Streams-Commons](https://github.com/reactor/reactive-streams-commons) research project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065138Z" creationid="pingfangx" creationdate="20190617T065138Z">
        <seg>- 从 1.x 周期和 [Reactive-Streams-Commons](https://github.com/reactor/reactive-streams-commons) 研究项目获得的设计变更带来的性能提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- single dependency: [Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064948Z" creationid="pingfangx" creationdate="20190617T064943Z">
        <seg>- 单一依赖：[Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- virtual time and schedulers for parameterized concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065452Z" creationid="pingfangx" creationdate="20190617T065452Z">
        <seg> - 参数化并发的虚拟时间和调度程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §1.3 relaxation: `onSubscribe` may run concurrently with `onNext` in case the `FlowableSubscriber` calls `request()` from inside `onSubscribe` and it is the resposibility of `FlowableSubscriber` to ensure thread-safety between the remaining instructions in `onSubscribe` and `onNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084037Z" creationid="pingfangx" creationdate="20190618T074115Z">
        <seg>- §1.3 宽松：`onSubscribe` 可以与 `onNext` 同时运行，以防 `FlowableSubscriber` 从 `onSubscribe` 内部调用 `request()`，并且它是 `FlowableSubscriber` 的责任以确保在 `onSubscribe` 和 `onNext` 中的其余指令之间的线程安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §2.12 relaxation: if the same `FlowableSubscriber` instance is subscribed to multiple sources, it must ensure its `onXXX` methods remain thread safe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084111Z" creationid="pingfangx" creationdate="20190618T074147Z">
        <seg>- §2.12 宽松：如果同一个 `FlowableSubscriber` 实例订阅了多个源，它必须确保它的 `onXXX` 方法保持线程安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §2.3 relaxation: calling `Subscription.cancel` and `Subscription.request` from `FlowableSubscriber.onComplete()` or `FlowableSubscriber.onError()` is considered a no-operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084051Z" creationid="pingfangx" creationdate="20190618T074127Z">
        <seg>- §2.3 宽松：从 `FlowableSubscriber.onComplete()` 或 `FlowableSubscriber.onError()` 调用 `Subscription.cancel` 和 `Subscription.request` 被认为是无操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §3.9 relaxation: issuing a non-positive `request()` will not stop the current stream but signal an error via `RxJavaPlugins.onError`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084133Z" creationid="pingfangx" creationdate="20190618T074156Z">
        <seg>- §3.9 宽松：发出一个非肯定的 `request()` 不会停止当前流，但会通过 `RxJavaPlugins.onError` 发出错误信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- "how does the TCP identify duplicate segments from previous incarnations of the connection?"  This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023223Z" creationid="pingfangx" creationdate="20190828T023223Z">
        <seg> - “TCP 如何识别以前连接的复制报文段？”如果快速连续打开和关闭连接，或者连接因内存丢失而中断然后重新建立，则此问题变得明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If Java 8 lambdas are supported</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090817Z" creationid="pingfangx" creationdate="20190618T090817Z">
        <seg>//如果支持 Java 8 lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If no Retrolambda or Jack</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090828Z" creationid="pingfangx" creationdate="20190618T090828Z">
        <seg>//如果没有 Retrolambda 或 Jack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 - old sequence numbers which have been acknowledged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111911Z" creationid="pingfangx" creationdate="20190827T111911Z">
        <seg>1 - 已确认的序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.Any response message which "MUST NOT" include a message-body (such as the 1xx, 204, and 304 responses and any response to a HEAD request) is always terminated by the first empty line after the header fields, regardless of the entity-header fields present in the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085102Z" creationid="pingfangx" creationdate="20190829T085102Z">
        <seg>1.任何“绝不”包括消息体的响应消息(例如 1xx，204 和 304 响应以及对 HEAD 请求的任何响应)始终由首部字段之后的第一个空行终止，而不管消息中存在实体首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 - sequence numbers allowed for new reception</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111916Z" creationid="pingfangx" creationdate="20190827T111916Z">
        <seg>2 - 允许新接收的序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2-9 argument version dropped, use `startWithArray` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053722Z" creationid="pingfangx" creationdate="20190619T053722Z">
        <seg>2-9 参数版本删除，使用 `startWithArray` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2.If a Transfer-Encoding header field (section 14.41) is present and has any value other than "identity", then the transfer-length is defined by use of the "chunked" transfer-coding (section 3.6), unless the message is terminated by closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085140Z" creationid="pingfangx" creationdate="20190829T085140Z">
        <seg>2.如果存在 Transfer-Encoding 首部字段(第 14.41 节)并且具有“identity”以外的任何值，则使用“chunked”传输编码(第 3.6 节)定义传输长度，除非消息通过关闭连接终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2xx (Successful) responses to a CONNECT request method (Section 4.3.6 of [RFC7231]) switch to tunnel mode instead of having a message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090419Z" creationid="pingfangx" creationdate="20190831T090419Z">
        <seg>对 CONNECT 请求方法的 2xx(成功)响应([RFC7231] 的第 4.3.6 节)切换到隧道模式而不是具有消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3 - future sequence numbers which are not yet allowed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111921Z" creationid="pingfangx" creationdate="20190827T111921Z">
        <seg>3 - 未来允许的序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.If a Content-Length header field (section 14.13) is present, its decimal value in OCTETs represents both the entity-length and the transfer-length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085218Z" creationid="pingfangx" creationdate="20190829T085218Z">
        <seg>3.如果存在 Content-Length 首部字段(第 14.13 节)，则其八位字节的十进制值代表实体长度和传输长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4.If the message uses the media type "multipart/byteranges", and the ransfer-length is not otherwise specified, then this self- elimiting media type defines the transfer-length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085542Z" creationid="pingfangx" creationdate="20190829T085542Z">
        <seg>4.如果消息使用媒体类型“multipart/byteranges”，并且未指定 ransfer-length，则此自我修饰媒体类型定义传输长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5-9 source overloads dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054154Z" creationid="pingfangx" creationdate="20190619T054154Z">
        <seg>5-9 源重载删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.By the server closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090004Z" creationid="pingfangx" creationdate="20190829T090004Z">
        <seg>5.由服务器关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;"&gt;            = &lt;US-ASCII double-quote mark (34)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095358Z" creationid="pingfangx" creationdate="20190828T095358Z">
        <seg>&lt;"&gt;            = &lt;US-ASCII 双引号 (34)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;t1&gt;Single&lt;/t1&gt;&lt;/a0&gt; — a specialized version of an Observable that emits only a single item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044426Z" creationid="pingfangx" creationdate="20190620T044426Z">
        <seg>&lt;a0&gt;&lt;t1&gt;Single&lt;/t1&gt;&lt;/a0&gt; — 特殊版本的 Observable，仅发射单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Another &lt;c1&gt;Scheduler&lt;/c1&gt; method&lt;/a0&gt; allows you to schedule an action to take place at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092613Z" creationid="pingfangx" creationdate="20190620T092613Z">
        <seg>&lt;a0&gt;另一个 &lt;c1&gt;Scheduler&lt;/c1&gt; 方法&lt;/a0&gt; 允许您调度定期执行的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;The &lt;c1&gt;Subscribe&lt;/c1&gt; method&lt;/a0&gt; is how you connect an observer to an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055947Z" creationid="pingfangx" creationdate="20190620T055947Z">
        <seg>&lt;a0&gt;&lt;c1&gt;Subscribe&lt;/c1&gt; 方法&lt;/a0&gt; 是将观察者连接到 Observable 的方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;The &lt;c1&gt;TestScheduler&lt;/c1&gt;&lt;/a0&gt; allows you to exercise fine-tuned manual control over how the Scheduler’s clock behaves.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091811Z" creationid="pingfangx" creationdate="20190620T091811Z">
        <seg>&lt;a0&gt;The &lt;c1&gt;TestScheduler&lt;/c1&gt;&lt;/a0&gt; 允许您对调度器的时钟行为进行微调手动控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt; is a single abstraction that can be used for any of these use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035601Z" creationid="pingfangx" creationdate="20190620T035601Z">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt; 是一个可用于任何这些用例的抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;PublishSubject&lt;/c0&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084605Z" creationid="pingfangx" creationdate="20190620T084605Z">
        <seg>&lt;c0&gt;PublishSubject&lt;/c0&gt; 仅向观察者发射订阅时间之后由源 Observable 发射的那些项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ReplaySubject&lt;/c0&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084938Z" creationid="pingfangx" creationdate="20190620T084938Z">
        <seg>无论观察者何时订阅，&lt;c0&gt;ReplaySubject&lt;/c0&gt; 都会向任何观察者发射源 Observable 发射的所有项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;m&gt; occurrences of element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093332Z" creationid="pingfangx" creationdate="20190828T093332Z">
        <seg>&lt;m&gt; 个元素的出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;ObserveOn&lt;/s1&gt;, on the other hand, affects the thread that the Observable will use &lt;e2&gt;below&lt;/e2&gt; where that operator appears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090449Z" creationid="pingfangx" creationdate="20190620T090449Z">
        <seg>另一方面，&lt;s1&gt;ObserveOn&lt;/s1&gt; 会影响 Observable 将在 &lt;e2&gt;下面&lt;/e2&gt; 出现的操作符使用的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;1&lt;/sup&gt;: When turning a multi-valued source into a single valued source, one should decide which of the many source values should be considered as the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095426Z" creationid="pingfangx" creationdate="20190617T095426Z">
        <seg>&lt;sup&gt;1&lt;/sup&gt;：当将多值源转换为单值源时，应该决定应该将多个源值中的哪一个视为结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;1&lt;/sup&gt;The `org.reactivestreams.Publisher` is part of the external Reactive Streams library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104341Z" creationid="pingfangx" creationdate="20190617T104341Z">
        <seg>&lt;sup&gt;1&lt;/sup&gt; `org.reactivestreams.Publisher` 是外部 Reactive Streams 库的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;2&lt;/sup&gt;: Turning an `Observable` into `Flowable` requires an additional decision: what to do with the potential unconstrained flow</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095444Z" creationid="pingfangx" creationdate="20190617T095444Z">
        <seg>&lt;sup&gt;2&lt;/sup&gt;：将 `Observable` 转换为 `Flowable` 需要另外一个决定：如何处理潜在的无约束流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;2&lt;/sup&gt;The naming convention of the interface was to append `Source` to the semi-traditional class name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104446Z" creationid="pingfangx" creationdate="20190617T104446Z">
        <seg>&lt;sup&gt;2&lt;/sup&gt; 接口的命名约定是将 `Source` 附加到半传统类名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;3&lt;/sup&gt;: When there is only (at most) one source item, there is no problem with backpressure as it can be always stored until the downstream is ready to consume.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100635Z" creationid="pingfangx" creationdate="20190617T100635Z">
        <seg>&lt;sup&gt;3&lt;/sup&gt;：当只有(最多)一个源项时，背压没有问题，因为它可以一直存储，直到下游准备好消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "cache" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102207Z" creationid="pingfangx" creationdate="20190830T102207Z">
        <seg>“缓存”是先前响应消息的本地存储，以及控制其消息存储，检索和删除的子系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "gateway" (a.k.a."reverse proxy") is an intermediary that acts as an origin server for the outbound connection but translates received requests and forwards them inbound to another server or servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101515Z" creationid="pingfangx" creationdate="20190830T101515Z">
        <seg>“网关”(也称为“反向代理”)是充当出站连接的源服务器但是转换所接收的请求并将它们转发到另一个或多个服务器的中介。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "non-transparent proxy" is a proxy that modifies the request or response in order to provide some added service to the user agent, such as group annotation services, media type transformation, protocol reduction, or anonymity filtering.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081542Z" creationid="pingfangx" creationdate="20190828T081542Z">
        <seg>“非透明代理”是修改请求或响应以便向用户代理提供一些附加服务的代理，例如组注释服务，媒体类型转换，协议减少或匿名过滤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "proxy" is a message-forwarding agent that is selected by the client, usually via local configuration rules, to receive requests for some type(s) of absolute URI and attempt to satisfy those requests via translation through the HTTP interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101341Z" creationid="pingfangx" creationdate="20190830T101341Z">
        <seg>“代理”是客户端(通常通过本地配置规则)选择的消息转发代理，以接收对某些类型的绝对 URI 的请求，并尝试通过 HTTP 接口转换来满足这些请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "strong entity tag" MAY be shared by two entities of a resource only if they are equivalent by octet equality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155812Z" creationid="pingfangx" creationdate="20190828T155812Z">
        <seg>只有当资源的两个实体八位字节相等时，“强实体标记”才可由资源的两个实体共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "transparent proxy" is a proxy that does not modify the request or response beyond what is required for proxy authentication and identification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081522Z" creationid="pingfangx" creationdate="20190828T081522Z">
        <seg>“透明代理”是一种代理，它不会修改超出代理身份验证和标识所需的请求或响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "tunnel" acts as a blind relay between two connections without changing the messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101606Z" creationid="pingfangx" creationdate="20190830T101606Z">
        <seg>“隧道”充当两个连接之间的盲中继，而不改变消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A "weak entity tag," indicated by the "W/" prefix, MAY be shared by two entities of a resource only if the entities are equivalent and could be substituted for each other with no significant change in semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155838Z" creationid="pingfangx" creationdate="20190828T155838Z">
        <seg>由“W/”前缀表示的“弱实体标签”可以由资源的两个实体共享，只有当实体是等效的并且可以彼此替换而语义没有显着变化时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A --&gt; B  ACK your sequence number is Y</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023933Z" creationid="pingfangx" creationdate="20190828T023933Z">
        <seg>A --&gt; B  ACK 你的序列号是 Y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A --&gt; B  SYN my sequence number is X</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023843Z" creationid="pingfangx" creationdate="20190828T023843Z">
        <seg>A --&gt; B  SYN 我的序列号是 X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A 128-bit IPv6 address is divided into eight 16-bit pieces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074709Z" creationid="pingfangx" creationdate="20190902T074709Z">
        <seg>128 位 IPv6 地址分为 8 个 16 位片段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), possibly including extensions not defined by this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042032Z" creationid="pingfangx" creationdate="20190830T042032Z">
        <seg>200 响应应该包括任何首部字段，其指示服务器实现并适用于该资源的可选特征(例如，允许)，可能包括未由本规范定义的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;-- B  ACK your sequence number is X</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023901Z" creationid="pingfangx" creationdate="20190828T023901Z">
        <seg>A &lt;-- B  ACK 你的序列号是 X</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;-- B  SYN my sequence number is Y</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023909Z" creationid="pingfangx" creationdate="20190828T023909Z">
        <seg>A &lt;-- B  SYN 我的序列号是 Y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A CRLF is allowed in the definition of TEXT only as part of a header field continuation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100056Z" creationid="pingfangx" creationdate="20190828T100056Z">
        <seg>TEXT 的定义中仅允许 CRLF 作为头字段连续的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Decision Tree of Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094409Z" creationid="pingfangx" creationdate="20190620T094409Z">
        <seg>Observable 操作符的决策树</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A HEAD response might also have an effect on previously cached responses to GET; see Section 4.3.5 of [RFC7234].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T140340Z" creationid="pingfangx" creationdate="20190831T140340Z">
        <seg>HEAD 响应也可能对以前缓存的 GET 响应产生影响；请参见 [RFC7234] 的第 4.3.5 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A HTTP response with a valid Content-Length header closed before all data has been read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093651Z" creationid="pingfangx" creationdate="20190901T093651Z">
        <seg>在读取所有数据之前关闭了具有有效 Content-Length 首部的 HTTP 响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A HTTP response without a Content-Length header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093243Z" creationid="pingfangx" creationdate="20190901T093243Z">
        <seg>没有 Content-Length 首部的 HTTP 响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Host header field is also sent, as defined in Section 5.4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124028Z" creationid="pingfangx" creationdate="20190831T124028Z">
        <seg>还会发送主机首部字段，如第 5.4 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A SYN-ACK is returned (line 3) and causes TCP A to generate a RST (the ACK in line 3 is not acceptable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060402Z" creationid="pingfangx" creationdate="20190828T060402Z">
        <seg>返回 SYN-ACK(第 3 行)并使 TCP A 生成 RST(第 3 行中的 ACK 不可接受)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073414Z" creationid="pingfangx" creationdate="20190620T073414Z">
        <seg>Single 就像一个 Observable，但它不发射一系列值 - 从零个到无限个 - 它总是发射一个值或一个错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Single will call only one of these methods, and will only call it once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073740Z" creationid="pingfangx" creationdate="20190620T073740Z">
        <seg>Single 将只调用其中一个方法，并且只调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T082956Z" creationid="pingfangx" creationdate="20190620T082956Z">
        <seg>Subject 是一种桥梁或代理，在 ReactiveX 的某些实现中可用，它既充当观察者又充当 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP connection progresses from one state to another in response to events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112939Z" creationid="pingfangx" creationdate="20190827T112939Z">
        <seg>TCP 连接从一个状态进展到另一个状态以响应事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP header follows the internet header, supplying information specific to the TCP protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104706Z" creationid="pingfangx" creationdate="20190827T104706Z">
        <seg>TCP 首部跟随 IP 首部，提供特定于 TCP 协议的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP must implement all options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110949Z" creationid="pingfangx" creationdate="20190827T110949Z">
        <seg>TCP 必须实现所有选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TCP will reliably deliver all buffers SENT before the connection was CLOSED so a user who expects no data in return need only wait to hear the connection was CLOSED successfully to know that all his data was received at the destination TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063448Z" creationid="pingfangx" creationdate="20190828T063048Z">
        <seg>TCP 将在连接被 CLOSED 之前可靠地 SENT 传递所有缓冲区，因此期望没有数据返回的用户只需等待成功地听到连接已成功 CLOSED，以便知道他的所有数据都在目标 TCP 上接收。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TLS implementation MAY, after sending a closure alert, close the connection without waiting for the peer to send its closure alert, generating an "incomplete close".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091842Z" creationid="pingfangx" creationdate="20190901T091842Z">
        <seg>在发送关闭警报后，TLS 实现可以关闭连接，而无需等待对等方发送其关闭警报，从而生成“未完成关闭”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TRACE request MUST NOT include an entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074150Z" creationid="pingfangx" creationdate="20190830T074150Z">
        <seg>TRACE 请求不得包含实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI can be further classified as a locator, a name, or both.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T062138Z" creationid="pingfangx" creationdate="20190902T062138Z">
        <seg>URI 可以进一步分类为定位符，名称或两者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI is an identifier consisting of a sequence of characters matching the syntax rule named &lt;URI&gt; in Section 3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061023Z" creationid="pingfangx" creationdate="20190902T061023Z">
        <seg>URI 是一个标识符，由一系列符合第 3 节中名为 &lt;URI&gt; 的语法规则的字符组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI is composed from a limited set of characters consisting of digits, letters, and a few graphic symbols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065108Z" creationid="pingfangx" creationdate="20190902T065108Z">
        <seg>URI 由一组有限的字符组成，这些字符由数字，字母和一些图形符号组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI reference (Section 2.7) is typically used as an identifier for the "target resource", which a user agent would resolve to its absolute form in order to obtain the "target URI".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123407Z" creationid="pingfangx" creationdate="20190831T123407Z">
        <seg>URI 引用(第 2.7 节)通常用作“target resource”的标识符，用户代理将其解析为其绝对形式以获得“target URI”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI resolution implementation might use DNS, host tables, yellow pages, NetInfo, WINS, or any other system for lookup of registered names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075755Z" creationid="pingfangx" creationdate="20190902T075755Z">
        <seg>URI 解析实现可能使用 DNS，主机表，黄页，NetInfo，WINS 或任何其他系统来查找已注册的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI with a fragment identifier may be used to refer to the secondary resource without any implication that the primary resource is accessible or will ever be accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083805Z" creationid="pingfangx" creationdate="20190902T083805Z">
        <seg>具有片段标识符的 URI 可以用于指代辅助资源，而不暗示主资源是可访问的或将被访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI-reference is either a URI or a relative reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084119Z" creationid="pingfangx" creationdate="20190902T084119Z">
        <seg>URI 引用是 URI 或相对引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URI-reference is typically parsed first into the five URI components, in order to determine what components are present and whether the reference is relative.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084404Z" creationid="pingfangx" creationdate="20190902T084404Z">
        <seg>通常首先将 URI 引用解析为五个 URI 组件，以便确定存在哪些组件以及引用是否是相对的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042445Z" creationid="pingfangx" creationdate="20190902T042445Z">
        <seg>统一资源标识符(URI)是一种紧凑的字符序列，用于标识抽象或物理资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Uniform Resource Identifier (URI) is a compact string of characters for identifying an abstract or physical resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035448Z" creationid="pingfangx" creationdate="20190902T035448Z">
        <seg>统一资源标识符 (Uniform Resource Identifier) (URI)是用于标识抽象或物理资源的紧凑字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T043034Z" creationid="pingfangx" creationdate="20190902T043034Z">
        <seg>统一资源标识符(URI)提供了一种用于标识资源的简单且可扩展的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A cache behaves in a "semantically transparent" manner, with respect to a particular response, when its use affects neither the requesting client nor the origin server, except to improve performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144722Z" creationid="pingfangx" creationdate="20190828T082158Z">
        <seg>当缓存的使用既不影响请求客户端也不影响源服务器时，缓存在“语义透明”方式中表现为特定响应，除了提高性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081722Z" creationid="pingfangx" creationdate="20190828T081722Z">
        <seg>缓存存储可缓存的响应，以减少对未来等效请求的响应时间和网络带宽消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;e0&gt;in turn&lt;/e0&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093948Z" creationid="pingfangx" creationdate="20190620T073225Z">
        <seg>链式 Observable 操作符不能在原始的 Observable 上独立运行，它们是依次 &lt;e0&gt;操作&lt;/e0&gt;，每个操作符操作的 Observable 由链中的前一个操作符生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;e1&gt;in turn&lt;/e1&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093956Z" creationid="pingfangx" creationdate="20190620T093858Z">
        <seg>链式 Observable 操作符不能在原始的 Observable 上独立运行，它们是依次 &lt;e1&gt;操作&lt;/e1&gt;，每个操作符操作的 Observable 由链中的前一个操作符生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MAY discard or truncate received header fields that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085431Z" creationid="pingfangx" creationdate="20190831T085431Z">
        <seg>如果字段语义使得可以安全地忽略删除的值而不改变消息成帧或响应语义，则客户端可以删除或截断大于客户端希望处理的接收的首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MAY send a Max-Forwards header field in an OPTIONS request to target a specific recipient in the request chain (see Section 5.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143721Z" creationid="pingfangx" creationdate="20190831T143721Z">
        <seg>客户端可以在 OPTIONS 请求中发送 Max-Forwards 首部字段，以定位请求链中的特定接收者(请参阅第 5.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MAY send a list of protocols in the Upgrade header field of a request to invite the server to switch to one or more of those protocols, in order of descending preference, before sending the final response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113034Z" creationid="pingfangx" creationdate="20190831T113034Z">
        <seg>客户端可以在请求的升级首部字段中发送协议列表，以便在发送最终响应之前按照优先级降序的顺序邀请服务器切换到这些协议中的一个或多个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103834Z" creationid="pingfangx" creationdate="20190830T103834Z">
        <seg>如果已知服务器错误地实现 HTTP 规范，则客户端可以发送较低请求版本，但仅在客户端尝试了至少一个正常请求并且从响应状态代码或首部字段(例如，服务器)确定服务器不正确地处理更高的请求版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MAY send additional requests on a persistent connection until it sends or receives a "close" connection option or receives an HTTP/1.0 response without a "keep-alive" connection option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111222Z" creationid="pingfangx" creationdate="20190831T111222Z">
        <seg>客户端可以在持久连接上发送其他请求，直到它发送或接收“close”连接选项或接收没有“keep-alive”连接选项的 HTTP/1.0 响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST NOT generate header fields in a TRACE request containing sensitive data that might be disclosed by the response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144020Z" creationid="pingfangx" creationdate="20190831T144020Z">
        <seg>客户端不得在包含可能由响应公开的敏感数据的 TRACE 请求中生成首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102524Z" creationid="pingfangx" creationdate="20190831T102524Z">
        <seg>客户端不得将此类额外数据作为单独的响应进行处理，缓存或转发，因为此类行为容易受到缓存中毒的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST NOT send a message body in a TRACE request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144142Z" creationid="pingfangx" creationdate="20190831T144142Z">
        <seg>客户端不得在 TRACE 请求中发送消息正文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092820Z" creationid="pingfangx" creationdate="20190831T092820Z">
        <seg>客户端不得发送包含 Transfer-Encoding 的请求，除非它知道服务器将处理 HTTP/1.1(或更高版本)请求；这些知识可以是特定用户配置的形式，也可以是记住先前接收的响应的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST NOT send a version to which it is not conformant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103822Z" creationid="pingfangx" creationdate="20190830T103822Z">
        <seg>客户端不得发送不符合的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to CONNECT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143358Z" creationid="pingfangx" creationdate="20190831T143358Z">
        <seg>客户端必须忽略在成功响应 CONNECT 时收到的任何 Content-Length 或 Transfer-Encoding 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101504Z" creationid="pingfangx" creationdate="20190831T101504Z">
        <seg>客户端必须忽略在这样的消息中接收的任何 Content-Length 或 Transfer-Encoding 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST send a Host header field in all HTTP/1.1 request messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125403Z" creationid="pingfangx" creationdate="20190831T125403Z">
        <seg>客户端必须在所有 HTTP/1.1 请求消息中发送 Host 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125929Z" creationid="pingfangx" creationdate="20190831T125929Z">
        <seg>客户端必须在 HTTP/1.1 请求中发送 Host 首部字段，即使请求目标是绝对形式，因为这允许主机信息通过可能没有实现主机的古老 HTTP/1.0 代理转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client SHOULD NOT automatically retry a failed automatic retry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111525Z" creationid="pingfangx" creationdate="20190831T111525Z">
        <seg>客户端不应该自动重试失败的自动重试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client SHOULD ignore the reason-phrase content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081256Z" creationid="pingfangx" creationdate="20190831T081256Z">
        <seg>客户端应该忽略原因 - 短语内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client SHOULD send a request version equal to the highest version to which the client is conformant and whose major version is no higher than the highest version supported by the server, if this is known.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103817Z" creationid="pingfangx" creationdate="20190830T103817Z">
        <seg>客户端应该发送一个请求版本，该版本等于客户端符合的最高版本，其主要版本不高于服务器支持的最高版本(如果已知)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a Range header field in the request ([RFC7233]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135618Z" creationid="pingfangx" creationdate="20190831T135618Z">
        <seg>客户端可以通过在请求中发送 Range 首部字段来将 GET 的语义改变为“范围请求”，请求仅传输所选表示的一些部分（[RFC7233]）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113758Z" creationid="pingfangx" creationdate="20190831T113758Z">
        <seg>在完全发送请求消息之前，客户端不能开始在连接上使用升级的协议(即，客户端不能在消息中间改变它正在发送的协议)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client constructs request messages to communicate specific intentions, examines received responses to see if the intentions were carried out, and determines how to interpret the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121633Z" creationid="pingfangx" creationdate="20190831T121633Z">
        <seg>客户构建请求消息以传达特定意图，检查收到的响应以查看意图是否已执行，并确定如何解释结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client detecting an incomplete close SHOULD recover gracefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T094002Z" creationid="pingfangx" creationdate="20190901T094002Z">
        <seg>检测到不完整关闭的客户端应该优雅地恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client or server that wishes to time out SHOULD issue a graceful close on the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112410Z" creationid="pingfangx" creationdate="20190831T112410Z">
        <seg>希望超时的客户端或服务器应该在连接上发出正常关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client ought to limit the number of simultaneous open connections that it maintains to a given server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112114Z" creationid="pingfangx" creationdate="20190831T112114Z">
        <seg>客户端应该限制它维护到给定服务器的同时打开的连接数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client sending a CONNECT request MUST send the authority form of request-target (Section 5.3 of [RFC7230]); i.e., the request-target consists of only the host name and port number of the tunnel destination, separated by a colon.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143107Z" creationid="pingfangx" creationdate="20190831T143107Z">
        <seg>发送 CONNECT 请求的客户端必须发送请求目标的权限形式([RFC7230] 的第 5.3 节);即，请求目标仅包含隧道目的地的主机名和端口号，用冒号分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112506Z" creationid="pingfangx" creationdate="20190831T112506Z">
        <seg>发送消息体的客户端应该在发送请求时监视网络连接以获得错误响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client sends a request to the server in the form of a request method, URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and possible body content over a connection with a server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T084926Z" creationid="pingfangx" creationdate="20190828T084926Z">
        <seg>客户端以请求方法，URI 和协议版本的形式向服务器发送请求，然后是类似 MIME 的消息，其中包含与服务器连接的请求修饰符，客户端信息和可能的正文内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client sends an HTTP request to a server in the form of a request message, beginning with a request-line that includes a method, URI, and protocol version (Section 3.1.1), followed by header fields containing request modifiers, client information, and representation metadata (Section 3.2), an empty line to indicate the end of the header section, and finally a message body containing the payload body (if any, Section 3.3).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190830T100150Z">
        <seg>客户端以请求消息的形式向服务器发送 HTTP 请求，从包含方法、URI 和协议版本的请求行开始(第 3.1.1 节)，后跟包含请求修饰符、客户端信息和表示元数据的首部字段(第 3.2 节)，一个空行表示首部部分的结尾，最后是一个包含有效载荷主体的消息主体(如果有的话，第 3.3 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client sends request header fields to provide more information about the request context, make the request conditional based on the target resource state, suggest preferred formats for the response, supply authentication credentials, or modify the expected request processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144223Z" creationid="pingfangx" creationdate="20190831T144223Z">
        <seg>客户端发送请求首部字段以提供有关请求上下文的更多信息，根据目标资源状态使请求成为条件的，建议响应的首选格式，提供身份验证凭据或修改预期的请求处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that does not support persistent connections MUST send the "close" connection option in every request message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110902Z" creationid="pingfangx" creationdate="20190831T110902Z">
        <seg>不支持持久连接的客户端必须在每个请求消息中发送“关闭”连接选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that generates an OPTIONS request containing a payload body MUST send a valid Content-Type header field describing the representation media type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T143814Z">
        <seg>生成包含有效载荷主体的 OPTIONS 请求的客户端必须发送描述表示媒体类型的有效 Content-Type 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132249Z" creationid="pingfangx" creationdate="20190831T132249Z">
        <seg>在连接上有多个未完成请求的客户端必须在发送的顺序中维护未完成请求的列表，并且必须将该连接上的每个接收到的响应消息与尚未收到最终请求的最高有序请求相关联(非 1xx)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111723Z" creationid="pingfangx" creationdate="20190831T111704Z">
        <seg>如果连接在收到所有相应响应之前关闭，则流水线请求的客户端应该重试未响应的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that receives a "close" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the "close"; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112802Z" creationid="pingfangx" creationdate="20190831T112802Z">
        <seg>接收“close”连接选项的客户端必须停止在该连接上发送请求，并在读取包含“close”的响应消息后关闭连接；如果在连接上发送了额外的流水线请求，客户端不应该假设它们将由服务器处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102723Z" creationid="pingfangx" creationdate="20190831T102723Z">
        <seg>接收不完整响应消息的客户端，当连接过早关闭或解码所谓的分块传输编码失败时，可能会发生，必须将消息记录为不完整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that sends a "close" connection option MUST NOT send further requests on that connection (after the one containing "close") and MUST close the connection after reading the final response message corresponding to this request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112633Z" creationid="pingfangx" creationdate="20190831T112633Z">
        <seg>发送“close”连接选项的客户端不得在该连接上发送进一步的请求(在包含“close”的连接之后)，并在读取与该请求对应的最终响应消息后必须关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151316Z" creationid="pingfangx" creationdate="20190829T151316Z">
        <seg>支持持久连接的客户端可以“流水线化”其请求(即，在不等待每个响应的情况下发送多个请求)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151556Z" creationid="pingfangx" creationdate="20190829T151556Z">
        <seg>希望发送非幂等请求的客户端应该等待发送该请求，直到它收到前一个请求的响应状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client, server, or proxy MAY close the transport connection at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152215Z" creationid="pingfangx" creationdate="20190829T152215Z">
        <seg>客户端，服务器或代理可以随时关闭传输连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A companion document describes a method for using HTTP/TLS over the same port as normal HTTP [RFC2817].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T085804Z" creationid="pingfangx" creationdate="20190901T085804Z">
        <seg>配套文档 [RFC2817] 描述了在与普通 HTTP 相同的端口上使用 HTTP/TLS 的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component's ABNF syntax rule will not use the reserved or gen-delims rule names directly; instead, each syntax rule lists the characters allowed within that component (i.e., not delimiting it), and any of those characters that are also in the reserved set are "reserved" for use as subcomponent delimiters within the component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070922Z" creationid="pingfangx" creationdate="20190902T070922Z">
        <seg>组件的 ABNF 语法规则不会直接使用保留或 gen-delims 规则名称；相反，每个语法规则列出该组件内允许的字符(即，不对其进行分隔)，并且也保留在保留集中的那些字符中的任何一个都被“保留”以用作组件内的子组件分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062341Z" creationid="pingfangx" creationdate="20190830T062341Z">
        <seg>条件 GET 方法请求仅在条件首部字段描述的情况下传送实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A connection is defined by a pair of sockets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023136Z" creationid="pingfangx" creationdate="20190828T023136Z">
        <seg>连接由一对套接字定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A connection might be used for multiple request/response exchanges, as defined in Section 6.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100341Z" creationid="pingfangx" creationdate="20190830T100341Z">
        <seg>连接可用于多个请求/响应交换，如第 6.3 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A connection progresses through a series of states during its lifetime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112040Z" creationid="pingfangx" creationdate="20190827T112040Z">
        <seg>连接在其生命周期中通过一系列状态进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A construct "#" is defined, similar to "*", for defining lists of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093742Z" creationid="pingfangx" creationdate="20190828T093742Z">
        <seg>定义“#”结构，类似于“*”，用于定义元素列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071602Z" creationid="pingfangx" creationdate="20190828T071602Z">
        <seg>HTTP 的一个特性是数据表示的输入和协商，允许系统独立于正在传输的数据而构建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A field value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field-value is preferred for consistent readability by humans.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083631Z" creationid="pingfangx" creationdate="20190831T083631Z">
        <seg>字段值可以在之前和/或之后有一个可选空格(OWS)；在字段值之前最好有单个 SP 用于人类的一致可读性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fragment identifier component is indicated by the presence of a number sign ("#") character and terminated by the end of the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083510Z" creationid="pingfangx" creationdate="20190902T083510Z">
        <seg>片段标识符组件由数字符号(“#”)字符的存在表示，并由 URI 的末尾终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T020934Z" creationid="pingfangx" creationdate="20190828T020934Z">
        <seg>设计中的一个基本概念是通过 TCP 连接发送的每个八位字节数据都有一个序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A gateway communicates with inbound servers using any protocol that it desires, including private extensions to HTTP that are outside the scope of this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101548Z" creationid="pingfangx" creationdate="20190830T101548Z">
        <seg>网关使用它期望的任何协议与入站服务器通信，包括超出本规范范围的 HTTP 的私有扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A gateway is a receiving agent, acting as a layer above some other server(s) and, if necessary, translating the requests to the underlying server's protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085938Z" creationid="pingfangx" creationdate="20190828T085744Z">
        <seg>网关是接收代理，充当某些其他服务器之上的层，并在必要时将请求转换为底层服务器的协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A given entity tag value MAY be used for entities obtained by requests on different URIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155956Z" creationid="pingfangx" creationdate="20190828T155956Z">
        <seg>给定的实体标签值可以用于通过不同 URI 上的请求获得的实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A host identified by a registered name is a sequence of characters usually intended for lookup within a locally defined host or service name registry, though the URI's scheme-specific semantics may require that a specific registry (or fixed name table) be used instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075210Z" creationid="pingfangx" creationdate="20190902T075210Z">
        <seg>由注册名称标识的主机是通常用于在本地定义的主机或服务名称注册表中查找的字符序列，尽管 URI 的特定于方案的语义可能要求使用特定的注册表(或固定名称表)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A host identified by an IPv4 literal address is represented in dotted-decimal notation (a sequence of four decimal numbers in the range 0 to 255, separated by "."), as described in [RFC1123] by reference to [RFC0952].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074936Z" creationid="pingfangx" creationdate="20190902T074936Z">
        <seg>由 IPv4 文字地址标识的主机以点分十进制表示法(由 0 到 255 的四个十进制数字的序列，由“.”分隔)表示，如 [RFC1123] 中参考 [RFC0952] 所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A host identified by an IPv6 literal address is represented inside the square brackets without a preceding version flag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074632Z" creationid="pingfangx" creationdate="20190902T074632Z">
        <seg>由 IPv6 文字地址标识的主机在方括号内表示，没有前面的版本标志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A host identified by an Internet Protocol literal address, version 6 [RFC3513] or later, is distinguished by enclosing the IP literal within square brackets ("[" and "]").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074445Z" creationid="pingfangx" creationdate="20190902T074445Z">
        <seg>由互联网协议文字地址版本 6 [RFC3513] 或更高版本标识的主机通过将 IP 文本括在方括号(“[”和“]”)中来区分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154518Z" creationid="pingfangx" creationdate="20190828T154518Z">
        <seg>语言标签识别人类所说的，书写的或以其他方式传达的自然语言，用于将信息传递给其他人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102952Z" creationid="pingfangx" creationdate="20190831T102952Z">
        <seg>如果尚未接收到终止编码的零大小的块，则使用分块传输编码的消息体是不完整的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103011Z" creationid="pingfangx" creationdate="20190831T103011Z">
        <seg>如果收到的消息体的大小(以八位字节为单位)小于 Content-Length 给出的值，则使用有效 Content-Length 的消息不完整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084411Z" creationid="pingfangx" creationdate="20190829T084411Z">
        <seg>如果请求方法的规范(第 5.1.1 节)不允许在请求中发送实体主体，则消息主体不得包含在请求中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more complete &lt;c0&gt;subscribe&lt;/c0&gt; call example looks like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060713Z" creationid="pingfangx" creationdate="20190620T060713Z">
        <seg>更完整的 &lt;c0&gt;subscribe&lt;/c0&gt; 调用示例如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more complicated situation occurs when one or more intermediaries are present in the request/response chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085516Z" creationid="pingfangx" creationdate="20190828T085516Z">
        <seg>当请求/响应链中存在一个或多个中介时，会出现更复杂的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more subtle bug happens if the call to `request(1)` triggers an asynchronous call to `onNext` on some other thread and reading `name` in `onNext` races writing it in `onStart` post `request`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084520Z" creationid="pingfangx" creationdate="20190621T083839Z">
        <seg>还可能发生更微妙的错误，如果对 `request(1)` 的调用在某个其他线程上触发对 `onNext` 的异步调用，该调用在 `onNext` 中读取 `name`，而在 `onStart` 中 `request` 之后才会写入。（译注：不知道对不对，太难了）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A network data object or service that can be identified by a URI, as defined in section 3.2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080943Z" creationid="pingfangx" creationdate="20190828T080943Z">
        <seg>可以通过 URI 标识的网络数据对象或服务，如第 3.2 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022101Z" creationid="pingfangx" creationdate="20190828T022101Z">
        <seg>新的确认(称为“可接受的确认”)是下面的不等式所持有的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parser of the generic URI syntax can parse any URI reference into its major components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T062006Z" creationid="pingfangx" creationdate="20190902T062006Z">
        <seg>通用 URI 语法的解析器可以将任何 URI 引用解析为其主要组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A partial GET requests that only part of the entity be transferred, as described in section 14.35.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062810Z" creationid="pingfangx" creationdate="20190830T062810Z">
        <seg>部分 GET 请求仅传输实体的一部分，如第 14.35 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A path consists of a sequence of path segments separated by a slash ("/") character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082132Z" creationid="pingfangx" creationdate="20190902T082132Z">
        <seg>路径由一系列由斜杠(“/”)字符分隔的路径段组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A path is always defined for a URI, though the defined path may be empty (zero length).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082142Z" creationid="pingfangx" creationdate="20190902T082142Z">
        <seg>始终为 URI 定义路径，但定义的路径可能为空(零长度)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A path segment that contains a colon character (e.g., "this:that") cannot be used as the first segment of a relative-path reference, as it would be mistaken for a scheme name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085206Z" creationid="pingfangx" creationdate="20190902T085206Z">
        <seg>包含冒号字符(例如，“this:that”)的路径段不能用作相对路径引用的第一个段，因为它会被误认为是方案名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T143409Z">
        <seg>CONNECT 请求消息中的有效载荷没有定义的语义；在 CONNECT 请求上发送有效载荷主体可能会导致某些现有实现拒绝该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T135703Z">
        <seg>GET 请求消息中的有效载荷没有定义的语义；在 GET 请求上发送有效载荷主体可能会导致某些现有实现拒绝该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T140221Z">
        <seg>HEAD 请求消息中的有效载荷没有定义的语义；在 HEAD 请求上发送有效载荷主体可能会导致某些现有实现拒绝该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A percent-encoded octet is encoded as a character triplet, consisting of the percent character "%" followed by the two hexadecimal digits representing that octet's numeric value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065440Z" creationid="pingfangx" creationdate="20190902T065440Z">
        <seg>百分比编码的八位字节被编码为字符三元组，由百分号“%”后跟两个十六进制数字组成，后者表示该八位字节的数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A percent-encoding mechanism is used to represent a data octet in a component when that octet's corresponding character is outside the allowed set or is being used as a delimiter of, or within, the component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065408Z" creationid="pingfangx" creationdate="20190902T065408Z">
        <seg>百分比编码机制用于表示一个组件中的数据八位字节，当该八位字节的对应字符在允许的集之外，或用作该组件的分隔符或在该组件内时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A program that establishes connections for the purpose of sending requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081259Z" creationid="pingfangx" creationdate="20190828T081259Z">
        <seg>为发送请求而建立连接的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A program's local store of response messages and the subsystem that controls its message storage, retrieval, and deletion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081706Z" creationid="pingfangx" creationdate="20190828T081706Z">
        <seg>程序的本地响应消息存储以及控制其消息存储，检索和删除的子系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol element (e.g., an entity tag or a Last-Modified time) that is used to find out whether a cache entry is an equivalent copy of an entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144733Z" creationid="pingfangx" creationdate="20190828T082227Z">
        <seg>用于确定缓存条目是否是实体的等效副本的协议元素(例如，实体标签或最后修改时间)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy MUST NOT automatically retry non-idempotent requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111425Z" creationid="pingfangx" creationdate="20190831T111425Z">
        <seg>代理不得自动重试非幂等请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy MUST NOT generate a Max-Forwards header field while forwarding a request unless that request was received with a Max-Forwards field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143805Z" creationid="pingfangx" creationdate="20190831T143805Z">
        <seg>除非收到的请求包含 Max-Forwards 字段，否则代理不得在转发请求时生成 Max-Forwards 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy MUST forward unrecognized header fields unless the field-name is listed in the Connection header field (Section 6.1) or the proxy is specifically configured to block, or otherwise transform, such fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082100Z" creationid="pingfangx" creationdate="20190831T082100Z">
        <seg>除非在 Connection 首部字段(第 6.1 节)中列出了字段名称，否则代理必须转发无法识别的首部字段，或者代理专门配置为阻止或以其他方式转换此类字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy MUST implement both the client and server requirements of this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081507Z" creationid="pingfangx" creationdate="20190828T081507Z">
        <seg>代理必须实现此规范的客户端和服务器要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083522Z" creationid="pingfangx" creationdate="20190831T083522Z">
        <seg>在转发下游消息之前，代理必须从响应消息中删除任何此类空格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152625Z" creationid="pingfangx" creationdate="20190829T152625Z">
        <seg>代理应该使用最多 2 * N 个连接到另一个服务器或代理，其中 N 是同时活动用户的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy is a forwarding agent, receiving requests for a URI in its absolute form, rewriting all or part of the message, and forwarding the reformatted request toward the server identified by the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085844Z" creationid="pingfangx" creationdate="20190828T085624Z">
        <seg>代理是转发代理，以绝对形式接收 URI 请求，重写全部或部分消息，并将重新格式化的请求转发到由 URI 标识的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy or gateway MUST parse a received Connection header field before a message is forwarded and, for each connection-option in this field, remove any header field(s) from the message with the same name as the connection-option, and then remove the Connection header field itself (or replace it with the intermediary's own connection options for the forwarded message).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110317Z" creationid="pingfangx" creationdate="20190831T110317Z">
        <seg>在转发消息之前，代理或网关必须解析收到的 Connection 首部字段，对于此字段中的每个连接选项，从消息中删除任何与 connection-option 同名的首部字段，然后删除 Connection 首部字段本身（或用中间人自己的转发消息连接选项替换它）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T084230Z" creationid="pingfangx" creationdate="20190831T084230Z">
        <seg>在不在 message/http 容器中的响应消息中接收 obs 折叠的代理或网关必须要么丢弃该消息并用 502(坏网关)响应替换它，最好使用解释接收到不可接受的行折叠的表示，或者在解释字段值或向下游转发消息之前，用一个或多个 SP 八位字节替换每个接收到的 obs 折叠。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy server MUST NOT establish a HTTP/1.1 persistent connection with an HTTP/1.0 client (but see RFC 2068 [33] for information and discussion of the problems with the Keep-Alive header implemented by many HTTP/1.0 clients).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151920Z" creationid="pingfangx" creationdate="20190829T151920Z">
        <seg>代理服务器不得与 HTTP/1.0 客户端建立 HTTP/1.1 持久连接(但请参阅 RFC 2068 [33] 以获取有关许多 HTTP/1.0 客户端实现的 Keep-Alive 首部问题的信息和讨论)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111321Z" creationid="pingfangx" creationdate="20190831T111321Z">
        <seg>代理服务器不得与 HTTP/1.0 客户端保持持久连接(有关许多 HTTP/1.0 客户端实现的 Keep-Alive 首部字段问题的信息和讨论，请参见 [RFC2068] 的第 19.7.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A proxy that forwards such a request MUST generate a new Host field-value based on the received request-target rather than forward the received Host field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130112Z" creationid="pingfangx" creationdate="20190831T130112Z">
        <seg>转发此类请求的代理必须根据接收到的请求目标生成新的主机字段值，而不是转发接收到的主机字段值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A range header might be forwarded by a 1.0 proxy that does not understand multipart/byteranges; in this case the server MUST delimit the message using methods defined in items 1,3 or 5 of this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085952Z" creationid="pingfangx" creationdate="20190829T085952Z">
        <seg>范围首部可能由 1.0 代理转发，该代理不理解 multipart/byteranges;在这种情况下，服务器必须使用本节第 1,3 或 5 项中定义的方法来分隔消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient MAY combine multiple header fields with the same field name into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082519Z" creationid="pingfangx" creationdate="20190831T082519Z">
        <seg>接收者可以将具有相同字段名称的多个首部字段组合成一个“field-name: field-value”对，而不改变消息的语义，方法是将每个后续字段值按顺序附加到组合字段值，由逗号分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient MAY replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095907Z" creationid="pingfangx" creationdate="20190828T095907Z">
        <seg>在解释字段值或向下游转发消息之前，接收方可以用单个 SP 替换任何线性空白区域。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient MUST be able to parse the chunked transfer coding (Section 4.1) because it plays a crucial role in framing messages when the payload body size is not known in advance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091406Z" creationid="pingfangx" creationdate="20190831T091406Z">
        <seg>接收方必须能够解析分块传输编码(第 4.1 节)，因为它在预先知道有效载荷主体大小时在帧消息中起着至关重要的作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102909Z" creationid="pingfangx" creationdate="20190830T102909Z">
        <seg>接收方必须根据本规范为其定义的语义解释接收的协议元素，包括对此规范的扩展，除非接收方已经(通过经验或配置)确定发送方错误地实现了这些语义隐含的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T062659Z" creationid="pingfangx" creationdate="20190831T062659Z">
        <seg>接收者必须将 HTTP 消息解析为编码中的八位字节序列，该编码是 US-ASCII [USASCII] 的超集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082850Z" creationid="pingfangx" creationdate="20190831T082850Z">
        <seg>接收者必须解析这样的坏空格并在解释协议元素之前将其删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070743Z" creationid="pingfangx" creationdate="20190831T070743Z">
        <seg>接收者不应尝试自动更正，然后在没有重定向的情况下处理请求，因为可能会故意制造无效的请求行以绕过请求链中的安全过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient SHOULD treat other octets in field content (obs-text) as opaque data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085017Z" creationid="pingfangx" creationdate="20190831T085017Z">
        <seg>接收者应该将字段内容(obs-text)中的其他八位字节视为不透明数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104225Z" creationid="pingfangx" creationdate="20190830T104225Z">
        <seg>接收者可以假设具有较高次要版本的邮件在发送给尚未表示支持该较高版本的接收者时，具有足够的向后兼容性，可由相同主要版本的任何实现安全地处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient determines whether a connection is persistent or not based on the most recently received message's protocol version and Connection header field (if any):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111004Z" creationid="pingfangx" creationdate="20190831T111004Z">
        <seg>接收者根据最近收到的消息的协议版本和 Connection 首部字段(如果有)确定连接是否持久：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient that processes such a URI reference MUST reject it as invalid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044207Z" creationid="pingfangx" creationdate="20190831T044207Z">
        <seg>处理此类 URI 引用的接收者必须将其拒绝为无效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T063352Z" creationid="pingfangx" creationdate="20190831T063352Z">
        <seg>在起始行和第一个首部字段之间接收空格的接收者必须将消息拒绝为无效，或者消耗每个前面的空行而不进一步处理它(即忽略整行，以及前面有空格的任何后续行，直到收到正确形式的首部字段或终止首部部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A registered name intended for lookup in the DNS uses the syntax defined in Section 3.5 of [RFC1034] and Section 2.1 of [RFC1123].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075242Z" creationid="pingfangx" creationdate="20190902T075242Z">
        <seg>用于在 DNS 中查找的注册名称使用 [RFC1034] 的第 3.5 节和 [RFC1123] 的第 2.1 节中定义的语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A relative reference takes advantage of the hierarchical syntax (Section 1.2.3) to express a URI reference relative to the name space of another hierarchical URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084909Z" creationid="pingfangx" creationdate="20190902T084909Z">
        <seg>相对引用利用分层语法(第 1.2.3 节)来表示相对于另一个分层 URI 的名称空间的 URI 引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A relative reference that begins with a single slash character is termed an absolute-path reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085120Z" creationid="pingfangx" creationdate="20190902T085120Z">
        <seg>以单个斜杠字符开头的相对引用称为绝对路径引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A relative reference that begins with two slash characters is termed a network-path reference; such references are rarely used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085114Z" creationid="pingfangx" creationdate="20190902T085114Z">
        <seg>以两个斜杠字符开头的相对引用称为网络路径引用；这种参考很少使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A relative reference that does not begin with a slash character is termed a relative-path reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085135Z" creationid="pingfangx" creationdate="20190902T085135Z">
        <seg>不以斜杠字符开头的相对引用称为相对路径引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request message from a client to a server includes, within the first line of that message, the method to be applied to the resource, the identifier of the resource, and the protocol version in use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T093534Z" creationid="pingfangx" creationdate="20190829T093534Z">
        <seg>从客户端到服务器的请求消息在该消息的第一行内包括要应用于资源的方法，资源的标识符和正在使用的协议版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134403Z" creationid="pingfangx" creationdate="20190831T134403Z">
        <seg>如果使用该方法对服务器的多个相同请求的预期效果与单个此类请求的效果相同，则请求方法被视为“幂等”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request or response message that travels the whole chain will pass through four separate connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090100Z" creationid="pingfangx" creationdate="20190828T090100Z">
        <seg>传输整个链的请求或响应消息将通过四个单独的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request-line begins with a method token, followed by a single space (SP), the request-target, another single space (SP), the protocol version, and ends with CRLF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070431Z" creationid="pingfangx" creationdate="20190831T070431Z">
        <seg>请求行以方法标记开头，后跟单个空格(SP)，请求目标，另一个空格(SP)，协议版本，以 CRLF 结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reserved subset of those characters may be used to delimit syntax components within a URI while the remaining characters, including both the unreserved set and those reserved characters not acting as delimiters, define each component's identifying data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065205Z" creationid="pingfangx" creationdate="20190902T065205Z">
        <seg>这些字符的保留子集可用于界定 URI 内的语法组件，而其余字符(包括未保留集和未充当分隔符的保留字符)定义每个组件的标识数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reset is valid if its sequence number is in the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061734Z" creationid="pingfangx" creationdate="20190828T061734Z">
        <seg>如果序列号在窗口中，则重置有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reset must not be sent if it is not clear that this is the case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060541Z" creationid="pingfangx" creationdate="20190828T060533Z">
        <seg>如果不清楚情况是否如此，则不得发送重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A resource can be anything that has identity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040104Z" creationid="pingfangx" creationdate="20190902T040104Z">
        <seg>资源可以是任何具有标识的东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A resource is not necessarily accessible via the Internet; e.g., human beings, corporations, and bound books in a library can also be resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060606Z" creationid="pingfangx" creationdate="20190902T060606Z">
        <seg>资源不一定通过互联网访问；例如，人，公司和图书馆中的装订书籍也可以是资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A resource may have one, or more than one, representation(s) associated with it at any given instant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081230Z" creationid="pingfangx" creationdate="20190828T081230Z">
        <seg>资源可以在任何给定时刻具有与其相关联的一个或多于一个表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response is "cacheable" if a cache is allowed to store a copy of the response message for use in answering subsequent requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102310Z" creationid="pingfangx" creationdate="20190830T102310Z">
        <seg>如果允许高速缓存存储响应消息的副本以用于回答后续请求，则响应是“可高速缓存的”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response is also first-hand if its validity has just been checked directly with the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081853Z" creationid="pingfangx" creationdate="20190828T081853Z">
        <seg>如果直接使用原始服务器检查其有效性，则响应也是第一手的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response is cacheable if a cache is allowed to store a copy of the response message for use in answering subsequent requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081800Z" creationid="pingfangx" creationdate="20190828T081800Z">
        <seg>如果允许缓存存储响应消息的副本以用于回答后续请求，则响应是可缓存的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response is first-hand if it comes directly and without unnecessary delay from the origin server, perhaps via one or more proxies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081843Z" creationid="pingfangx" creationdate="20190828T081843Z">
        <seg>如果直接来自原始服务器而没有不必要的延迟，可能是通过一个或多个代理，则响应是第一手的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response is fresh if its age has not yet exceeded its freshness lifetime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T082017Z" creationid="pingfangx" creationdate="20190828T082017Z">
        <seg>如果它的年龄尚未超过其新鲜寿命，则响应是新鲜的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response is stale if its age has passed its freshness lifetime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T082057Z" creationid="pingfangx" creationdate="20190828T082057Z">
        <seg>如果其年龄已超过其新鲜度，则响应是陈旧的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, thus, is considered complete regardless of the number of message body octets received, provided that the header section was received intact.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103112Z" creationid="pingfangx" creationdate="20190831T103112Z">
        <seg>通过关闭连接来终止既没有分块传输编码也没有内容长度的响应，因此，无论接收到的消息体八位字节的数量是多少都被认为是完整的，只要首部部分被完整地接收。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scheme may define a default port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081322Z" creationid="pingfangx" creationdate="20190902T081322Z">
        <seg>方案可以定义默认端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A segment is judged to occupy a portion of valid receive sequence space if</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022317Z" creationid="pingfangx" creationdate="20190828T022317Z">
        <seg>判断报文段占用有效接收序列空间的一部分，如果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less or equal than the acknowledgment value in the incoming segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022114Z" creationid="pingfangx" creationdate="20190828T022114Z">
        <seg>如果重传队列的序列号和长度之和小于或等于传入报文段中的确认值，则完全确认该报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A semi-colon, set off some distance to the right of rule text, starts a comment that continues to the end of line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094211Z" creationid="pingfangx" creationdate="20190828T094211Z">
        <seg>一个分号，在规则文本右侧偏离一段距离，开始继续到行尾的注释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT apply chunked more than once to a message body (i.e., chunking an already chunked message is not allowed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091436Z" creationid="pingfangx" creationdate="20190831T091436Z">
        <seg>发送方不得多次对消息体应用分块(即，不允许对已经分块的消息进行分块)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate BWS in messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082836Z" creationid="pingfangx" creationdate="20190831T082836Z">
        <seg>发送者不得在消息中生成 BWS。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083831Z" creationid="pingfangx" creationdate="20190831T083831Z">
        <seg>发送者不得生成包含行折叠的消息(即，具有包含与遮蔽折叠规则匹配的任何字段值)，除非该消息用于在 message/http 媒体类型内打包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate an "http" URI with an empty host identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044159Z" creationid="pingfangx" creationdate="20190831T044159Z">
        <seg>发送者不得生成带有空主机标识符的“http”URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate multiple header fields with the same field name in a message unless either the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or the header field is a well-known exception (as noted below).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082428Z" creationid="pingfangx" creationdate="20190831T082428Z">
        <seg>发送者不得在消息中生成具有相同字段名称的多个首部字段，除非该首部字段的整个字段值定义为以逗号分隔的列表 [ 即, #(values)] 或首部字段是一个众所周知的例外(如下所述)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate protocol elements that convey a meaning that is known by that sender to be false.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102614Z" creationid="pingfangx" creationdate="20190830T102614Z">
        <seg>发送方不得生成协议元素，以传达该发送方已知的错误含义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102625Z" creationid="pingfangx" creationdate="20190830T102625Z">
        <seg>发送方不得生成与相应 ABNF 规则定义的语法不匹配的协议元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT generate the userinfo subcomponent (and its "@" delimiter) when an "http" URI reference is generated within a message as a request target or header field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T055231Z" creationid="pingfangx" creationdate="20190831T055231Z">
        <seg>当在消息中生成“http”URI 引用作为请求目标或首部字段值时，发送方不得生成 userinfo 子组件(及其“@”分隔符)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T094721Z" creationid="pingfangx" creationdate="20190831T094721Z">
        <seg>发送方不得在包含 Transfer-Encoding 首部字段的任何消息中发送 Content-Length 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT send a connection option corresponding to a header field that is intended for all recipients of the payload.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T110647Z">
        <seg>发送方不得发送与首部字段相对应的连接选项，该首部字段适用于有效载荷的所有接收者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST NOT send whitespace between the start-line and the first header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T063255Z" creationid="pingfangx" creationdate="20190831T063255Z">
        <seg>发送者不得在起始行和第一个首部字段之间发送空格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101942Z" creationid="pingfangx" creationdate="20190831T101942Z">
        <seg>发送方必须在向下游转发此类消息之前删除收到的 Content-Length 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses ["(" and ")"] and backslash octets occurring within that comment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085834Z" creationid="pingfangx" creationdate="20190831T085834Z">
        <seg>发送者不应该在注释中生成引用对，除非必要引用括号 [“(”和“)”] 和在该注释中出现的反斜杠八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085817Z" creationid="pingfangx" creationdate="20190831T085817Z">
        <seg>发送者不应该在带引号的字符串中生成带引号对，除非必要引用该字符串中出现的 DQUOTE 和反斜杠八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sender SHOULD generate RWS as a single SP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082753Z" creationid="pingfangx" creationdate="20190831T082753Z">
        <seg>发送者应该将 RWS 生成为单个 SP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequence of one or more consecutive zero-valued 16-bit pieces within the address may be elided, omitting all their digits and leaving exactly two consecutive colons in their place to mark the elision.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074758Z" creationid="pingfangx" creationdate="20190902T074758Z">
        <seg>可以省略地址内的一个或多个连续的零值 16 位片段的序列，省略它们的所有数字并在它们的位置留下恰好两个连续的冒号以标记省略号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed on the same set of resources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T040802Z" creationid="pingfangx" creationdate="20190830T040802Z">
        <seg>根据定义，从不具有副作用的序列是幂等的(假设在同一组资源上没有执行并发操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113215Z" creationid="pingfangx" creationdate="20190831T113215Z">
        <seg>服务器可以选择忽略客户端指示的优先顺序，并根据其他因素选择新协议，例如请求的性质或服务器上的当前负载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113049Z" creationid="pingfangx" creationdate="20190831T113049Z">
        <seg>如果服务器希望继续使用该连接上的当前协议，则可以忽略收到的 Upgrade 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 4.2.1 of [RFC7231]), but it MUST send the corresponding responses in the same order that the requests were received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111644Z" creationid="pingfangx" creationdate="20190831T111644Z">
        <seg>如果服务器都有安全的方法([RFC7231] 的第 4.2.1 节)，它可以并行处理一系列流水线请求，但它必须按照接收请求的相同顺序发送相应的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102330Z" creationid="pingfangx" creationdate="20190831T102330Z">
        <seg>服务器可以通过响应 411(需要长度)来拒绝包含消息体但不包含 Content-Length 的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 4.1 of [RFC7232]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T100639Z">
        <seg>服务器可以在 304(未修改)响应中向条件 GET 请求发送 Content-Length 首部字段([RFC7232] 的第 4.1 节);服务器不得在这样的响应中发送 Content-Length，除非它的字段值等于在相同请求的 200(OK)响应的有效载荷体中发送的十进制八位字节数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY send a Content-Length header field in a response to a HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T100221Z">
        <seg>服务器可以在对 HEAD 请求的响应中发送 Content-Length 首部字段([RFC7231] 的第 4.3.2 节);但是是有条件的，只有在它的字段值等于使用 GET 方法的相同的请求的有效载荷主体的长度时，服务器才能在这样的响应中发送 Content-Length，表示的是有效载荷主体的八位字节的十进制数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY send an HTTP/1.0 response to a request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103908Z" creationid="pingfangx" creationdate="20190830T103908Z">
        <seg>如果服务器已知或怀疑客户端错误地实现了 HTTP 规范并且无法正确处理更高版本的响应(例如客户端无法正确解析版本号或何时)，则可以向请求发送 HTTP/1.0 响应已知中介即使在不符合协议的给定次要版本的情况下也盲目地转发 HTTP 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113238Z" creationid="pingfangx" creationdate="20190831T113238Z">
        <seg>服务器可以在任何其他响应中发送升级首部字段，以通告它实现对升级到列出的协议的支持，按照优先级降序的顺序，适用于将来的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT apply a request to the target resource until the entire request header section is received, since later header fields might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082319Z" creationid="pingfangx" creationdate="20190831T082319Z">
        <seg>在收到整个请求首部部分之前，服务器不得向目标资源应用请求，因为后面的首部字段可能包括条件，身份验证凭据或故意误导重复的首部字段，这些字段会影响请求处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T100701Z" creationid="pingfangx" creationdate="20190831T100701Z">
        <seg>服务器不得在对 CONNECT 请求的任何 2xx(成功)响应中发送 Content-Length 首部字段([RFC7231] 的第 4.3.6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T100653Z" creationid="pingfangx" creationdate="20190831T100653Z">
        <seg>服务器不得在状态代码为 1xx(信息)或 204(无内容)的任何响应中发送 Content-Length 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092733Z" creationid="pingfangx" creationdate="20190831T092733Z">
        <seg>服务器不得在对 CONNECT 请求的任何 2xx(成功)响应中发送 Transfer-Encoding 首部字段([RFC7231] 的第 4.3.6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092725Z" creationid="pingfangx" creationdate="20190831T092725Z">
        <seg>服务器不得在状态代码为 1xx(信息)或 204(无内容)的任何响应中发送 Transfer-Encoding 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092831Z" creationid="pingfangx" creationdate="20190831T092831Z">
        <seg>除非相应的请求指示 HTTP/1.1(或更高版本)，否则服务器不得发送包含 Transfer-Encoding 的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send a version to which it is not conformant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103845Z" creationid="pingfangx" creationdate="20190830T103845Z">
        <seg>服务器不得发送不符合的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143351Z" creationid="pingfangx" creationdate="20190831T143351Z">
        <seg>服务器不得在对 CONNECT 的 2xx(成功)响应中发送任何 Transfer-Encoding 或 Content-Length 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT send transfer-codings to an HTTP/1.0 client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143529Z" creationid="pingfangx" creationdate="20190828T143529Z">
        <seg>服务器不得向 HTTP/1.0 客户端发送传输编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113510Z" creationid="pingfangx" creationdate="20190831T113510Z">
        <seg>服务器不得切换协议，除非新协议能够接受所接收的消息语义；任何协议都可以遵守 OPTIONS 请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113203Z" creationid="pingfangx" creationdate="20190831T113203Z">
        <seg>服务器不得切换到客户端在相应请求的 Upgrade 首部字段中未指示的协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST generate a Content-Length field with a value of "0" if no payload body is to be sent in the response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143647Z" creationid="pingfangx" creationdate="20190831T143647Z">
        <seg>如果在响应中没有要发送有效载荷主体，则服务器必须生成值为“0”的 Content-Length 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113747Z" creationid="pingfangx" creationdate="20190831T113747Z">
        <seg>服务器必须忽略 HTTP/1.0 请求中收到的 Upgrade 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111257Z" creationid="pingfangx" creationdate="20190831T111257Z">
        <seg>服务器必须在发送响应后读取整个请求消息体或关闭连接，否则持久连接上的剩余数据将被误解为下一个请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST reject any received request message that contains whitespace between a header field-name and colon with a response code of 400 (Bad Request).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083512Z" creationid="pingfangx" creationdate="20190831T083512Z">
        <seg>服务器必须拒绝任何收到的包含首部字段名和冒号之间的空格的请求消息，以响应代码为 400(错误请求)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field or a Host header field with an invalid field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130350Z" creationid="pingfangx" creationdate="20190831T130350Z">
        <seg>服务器必须使用 400(错误请求)状态代码响应任何缺少主机首部字段的 HTTP/1.1 请求消息，以及包含多个主机首部字段的任何请求消息或具有无效字段值的主机首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server MUST send its responses to those requests in the same order that the requests were received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151326Z" creationid="pingfangx" creationdate="20190829T151326Z">
        <seg>服务器必须按照收到请求的顺序发送对这些请求的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T080436Z" creationid="pingfangx" creationdate="20190829T084445Z">
        <seg>服务器应该在任何请求上读取和转发消息主体；如果请求方法不包含实体主体的定义语义，那么在处理请求时应该忽略消息主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T110749Z" creationid="pingfangx" creationdate="20190828T110749Z">
        <seg>如果 URI 长于服务器可以处理的长度，服务器应该返回 414(Request-URI Too Long)状态(参见 10.4.15 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103841Z" creationid="pingfangx" creationdate="20190830T103841Z">
        <seg>服务器应该发送一个响应版本，该版本等于服务器符合的最高版本，其主要版本小于或等于请求中收到的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads, rather than terminate connections with the expectation that clients will retry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112500Z" creationid="pingfangx" creationdate="20190831T112500Z">
        <seg>服务器应尽可能维持持久连接，并允许底层传输的流控制机制解决临时重载，而不是终止连接，期望客户端将重试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103853Z" creationid="pingfangx" creationdate="20190830T103853Z">
        <seg>如果服务器因任何原因希望拒绝服务客户端的主要协议版本，则可以发送 505(HTTP 版本不支持)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server generating a successful response to OPTIONS SHOULD send any header fields that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143611Z" creationid="pingfangx" creationdate="20190831T143611Z">
        <seg>生成对 OPTIONS 的成功响应的服务器应该发送任何可能指示由服务器实现并且适用于目标资源(例如，Allow)的可选特征的首部字段，包括未由该规范定义的潜在扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server listens on a connection for a request, parses each message received, interprets the message semantics in relation to the identified request target, and responds to that request with one or more response messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121456Z" creationid="pingfangx" creationdate="20190831T121456Z">
        <seg>服务器监听请求的连接，解析收到的每个消息，解释与标识的请求目标相关的消息语义，并使用一个或多个响应消息响应该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server responds to a client's request by sending one or more HTTP response messages, each beginning with a status line that includes the protocol version, a success or error code, and textual reason phrase (Section 3.1.2), possibly followed by header fields containing server information, resource metadata, and representation metadata (Section 3.2), an empty line to indicate the end of the header section, and finally a message body containing the payload body (if any, Section 3.3).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190830T100335Z">
        <seg>服务器通过发送一条或多条 HTTP 响应消息来响应客户端的请求，每条消息都以包含协议版本、成功或错误代码以及文本原因短语的状态行开头(第 3.1.2 节)，可能后跟包含服务器信息、资源元数据和表示元数据的首部字段(第 3.2 节)，一个空行表示首部部分的结尾，最后是一个包含有效载荷主体的消息主体(如果有的话，第 3.3 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that does not support persistent connections MUST send the "close" connection option in every response message that does not have a 1xx (Informational) status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110916Z" creationid="pingfangx" creationdate="20190831T110916Z">
        <seg>不支持持久连接的服务器必须在每个没有 1xx(信息)状态代码的响应消息中发送“close”连接选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that does not support such an extension MAY discard the request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041808Z" creationid="pingfangx" creationdate="20190830T041808Z">
        <seg>不支持此类扩展的服务器可以丢弃请求正文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives a "close" connection option MUST initiate a close of the connection (see below) after it sends the final response to the request that contained "close".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112649Z" creationid="pingfangx" creationdate="20190831T112649Z">
        <seg>接收“close”连接选项的服务器必须在向包含“close”的请求发送最终响应后启动连接关闭(见下文)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T080857Z" creationid="pingfangx" creationdate="20190831T080857Z">
        <seg>接收比其实现的任何方法更长的方法的服务器应该使用 501(未实现)状态代码进行响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives a request header field, or set of fields, larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085344Z" creationid="pingfangx" creationdate="20190831T085344Z">
        <seg>接收大于其希望处理的请求首部字段或字段集的服务器必须以适当的 4xx(客户端错误)状态代码进行响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T093156Z" creationid="pingfangx" creationdate="20190831T093156Z">
        <seg>接收带有不可理解的传输编码的请求消息的服务器应该响应 501(未实现)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 6.5.12 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T080941Z" creationid="pingfangx" creationdate="20190831T080941Z">
        <seg>如果服务器接收到的请求目标比它希望解析的任何 URI 都长，则该服务器必须使用 414(URI 太长)状态代码响应(请参阅 [RFC7231] 的第 6.5.12 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102708Z" creationid="pingfangx" creationdate="20190831T102708Z">
        <seg>接收不完整请求消息的服务器(通常由于取消请求或触发超时异常)可能会在关闭连接之前发送错误响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that receives an obs-fold in a request message that is not within a message/http container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T084027Z" creationid="pingfangx" creationdate="20190831T084027Z">
        <seg>接收到请求消息中的 obs 折叠（不在 message/http 容器中）的服务器必须要么通过发送 400（错误的请求）来拒绝该消息，最好使用一个表示来解释过时的行折叠是不可接受的，或者将每个接收到的 obs 折叠替换为一个或多个八位字节的 sp 在解释字段值或将消息转发到下游之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that sends a "close" connection option MUST initiate a close of the connection (see below) after it sends the response containing "close".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112718Z" creationid="pingfangx" creationdate="20190831T112718Z">
        <seg>发送“close”连接选项的服务器必须在发送包含“close”的响应后启动连接关闭(见下文)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113107Z" creationid="pingfangx" creationdate="20190831T113107Z">
        <seg>发送 101（交换协议）响应的服务器必须发送升级首部字段，以指示正在切换连接的新协议；如果正在切换多个协议层，则发送方必须按层升序列出协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113227Z" creationid="pingfangx" creationdate="20190831T113227Z">
        <seg>发送 426(需要升级)响应的服务器必须按优先级降序发送升级首部字段以指示可接受的协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following is true:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144112Z" creationid="pingfangx" creationdate="20190828T144112Z">
        <seg>在响应中使用分块传输编码的服务器绝不能将 trailer 用于任何首部字段，除非至少满足下列条件之一：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server which acts as an intermediary for some other server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081559Z" creationid="pingfangx" creationdate="20190828T081559Z">
        <seg>作为其他服务器的中介的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A server which receives an entity-body with a transfer-coding it does not understand SHOULD return 501 (Unimplemented), and close the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143522Z" creationid="pingfangx" creationdate="20190828T143522Z">
        <seg>如果接收到具有不理解的传输编码的实体主体，服务器应该返回 501(未实现)，并关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A significant difference between HTTP/1.1 and earlier versions of HTTP is that persistent connections are the default behavior of any HTTP connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150250Z" creationid="pingfangx" creationdate="20190829T150250Z">
        <seg>HTTP/1.1 和早期版本的 HTTP 之间的显着差异是持久连接是任何 HTTP 连接的默认行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simultaneous CLOSE by users at both ends of a connection causes FIN segments to be exchanged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063912Z" creationid="pingfangx" creationdate="20190828T063912Z">
        <seg>连接两端的用户同时发生 CLOSE 会导致 FIN 报文段被交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single resource MAY be identified by many different URIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T071045Z" creationid="pingfangx" creationdate="20190830T071045Z">
        <seg>单个资源可以由许多不同的 URI 标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152614Z" creationid="pingfangx" creationdate="20190829T152614Z">
        <seg>单用户客户端不应该与任何服务器或代理保持 2 个以上的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A small regret about introducing backpressure in RxJava 0.x is that instead of having a separate base reactive class, the `Observable` itself was retrofitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053113Z" creationid="pingfangx" creationdate="20190618T053113Z">
        <seg>关于在 RxJava 0.x 中引入背压的一个小遗憾是，不再使用单独的基础响应类，`Observable` 本身就进行了改造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143630Z" creationid="pingfangx" creationdate="20190831T143630Z">
        <seg>此规范未定义此类表示的标准格式，但可能由 HTTP 的未来扩展定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string of text is parsed as a single value if it is quoted using double-quote marks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085725Z" creationid="pingfangx" creationdate="20190831T085725Z">
        <seg>如果使用双引号引用，则将一串文本解析为单个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string of text is parsed as a single word if it is quoted using double-quote marks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101630Z" creationid="pingfangx" creationdate="20190828T101621Z">
        <seg>如果使用双引号引用，则将一串文本解析为简单单词。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subset of the reserved characters (gen-delims) is used as delimiters of the generic URI components described in Section 3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070811Z" creationid="pingfangx" creationdate="20190902T070811Z">
        <seg>保留字符的子集(gen-delims)用作第 3 节中描述的通用 URI 组件的分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142501Z" creationid="pingfangx" creationdate="20190831T142501Z">
        <seg>成功地 PUT 一个给定的表示将意味着随后对同一目标资源的获取将导致在 200(OK)响应中发送一个等价的表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T073900Z" creationid="pingfangx" creationdate="20190830T073900Z">
        <seg>如果响应包括描述状态的实体，则成功响应应为 200(OK)，如果操作尚未执行，则应为 202(已接受);如果操作已执行但响应不包括一个实体，则应为 204(无内容)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142711Z" creationid="pingfangx" creationdate="20190831T142711Z">
        <seg>成功的响应仅意味着用户代理的意图是在原始服务器处理时实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN's.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024227Z" creationid="pingfangx" creationdate="20190828T024227Z">
        <seg>三次握手是必要的，因为序列号不依赖于网络中的全局时钟，并且 TCP 可能具有用于挑选 ISN 的不同机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A toolbox of useful Operators for working with Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101906Z" creationid="pingfangx" creationdate="20190620T101906Z">
        <seg>用于处理 Observable 的有用操作符的工具箱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A transparent proxy MUST NOT rewrite the "abs_path" part of the received Request-URI when forwarding it to the next inbound server, except as noted above to replace a null abs_path with "/".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101404Z" creationid="pingfangx" creationdate="20190829T101404Z">
        <seg>透明代理在转发到下一个入站服务器时，不得重写收到的 Request-URI 的“abs_path”部分，除非是上面提到的用“/”替换 null abs_path。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A transport layer virtual circuit established between two programs for the purpose of communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080854Z" creationid="pingfangx" creationdate="20190828T080854Z">
        <seg>在两个程序之间建立的传输层虚电路，用于通信目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tunnel acts as a relay point between two connections without changing the messages; tunnels are used when the communication needs to pass through an intermediary (such as a firewall) even when the intermediary cannot understand the contents of the messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090023Z" creationid="pingfangx" creationdate="20190828T090023Z">
        <seg>隧道充当两个连接之间的中继点而不改变消息；当通信需要通过中介(例如防火墙)时，即使中间人无法理解消息的内容，也会使用隧道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tunnel ceases to exist when both ends of the relayed connection are closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101624Z" creationid="pingfangx" creationdate="20190830T101624Z">
        <seg>当中继连接的两端都闭合时，隧道不再存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary MUST attempt to send any outstanding data that came from the closed side to the other side, close both connections, and then discard any remaining data left undelivered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143239Z" creationid="pingfangx" creationdate="20190831T143239Z">
        <seg>当隧道中介检测到任何一方已关闭其连接时，隧道将关闭：中间设备必须尝试将来自关闭侧的任何未完成数据发送到另一侧，关闭两个连接，然后丢弃任何未传递的剩余数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent MUST NOT automatically retry a request with a non-idempotent method unless it has some means to know that the request semantics are actually idempotent, regardless of the method, or some means to detect that the original request was never applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111445Z" creationid="pingfangx" creationdate="20190831T111445Z">
        <seg>用户代理不得使用非幂等方法自动重试请求，除非它有一些方法可以知道请求语义实际上是幂等的，无论方法如何，或者某些方法来检测原始请求从未应用过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111857Z" creationid="pingfangx" creationdate="20190831T111857Z">
        <seg>用户代理不应该在非幂等方法之后对请求进行流水线处理，直到收到该方法的最终响应状态代码，除非用户代理具有检测和恢复涉及流水线序列的部分故障条件的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T094842Z">
        <seg>当请求消息不包含有效载荷主体且方法语义不预期这样的主体时，用户代理应该不发送 Content-Length 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134228Z" creationid="pingfangx" creationdate="20190831T134228Z">
        <seg>在向用户呈现潜在操作时，用户代理应该区分安全和不安全方法，以便在请求用户之前可以使用户知道不安全的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T094754Z">
        <seg>当没有发送 Transfer-Encoding 并且请求方法定义封闭的有效载荷主体的含义时，用户代理应该在请求消息中发送 Content-Length。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent that receives an obs-fold in a response message that is not within a message/http container MUST replace each received obs-fold with one or more SP octets prior to interpreting the field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T084741Z" creationid="pingfangx" creationdate="20190831T084741Z">
        <seg>在不在 message/http 容器中的响应消息中接收 obs 折叠的用户代理在解释字段值之前，必须用一个或多个 sp 八位字节替换每个接收到的 obs 折叠。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102451Z" creationid="pingfangx" creationdate="20190831T102451Z">
        <seg>发送包含消息体的请求的用户代理必须发送有效的 Content-Length 首部字段，如果它不知道服务器将处理 HTTP/1.1(或更高版本)请求；这种知识可以是特定用户配置的形式，或者通过记住先前接收的响应的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variety of other cases are possible, all of which are accounted for by the following rules for RST generation and processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060454Z" creationid="pingfangx" creationdate="20190828T060454Z">
        <seg>可能存在各种其他情况，所有这些情况都由以下 RST 生成和处理规则来解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T080523Z" creationid="pingfangx" creationdate="20190620T080523Z">
        <seg>超时操作符的一个版本允许你在超时到期时切换到备份的 Single，而不是发送错误通知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A weak entity tag can only be used for weak comparison.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155843Z" creationid="pingfangx" creationdate="20190828T155843Z">
        <seg>弱实体标签只能用于弱比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A weight is normalized to a real number in the range 0 through 1, where 0 is the minimum and 1 the maximum value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154027Z" creationid="pingfangx" creationdate="20190828T154027Z">
        <seg>权重归一化为 0 到 1 范围内的实数，其中 0 是最小值，1 是最大值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070005Z" creationid="pingfangx" creationdate="20190620T070005Z">
        <seg>另一方面，“冷” Observable 会一直等待，直到有观察者订阅它才开始发射数据项，因此观察者保证能从开头看到整个序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T065453Z" creationid="pingfangx" creationdate="20190620T065453Z">
        <seg>“热” Observable 可能在创建后立即开始发射项目，因此任何后来订阅该 Observable 的观察者可能会在序列中间某处开始观察。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACK:  Acknowledgment field significant</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105408Z" creationid="pingfangx" creationdate="20190827T105408Z">
        <seg>ACK：指明确认字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API designers may instead choose to define `Observable&lt;Object&gt;` with no guarantee on what `Object` will be (which should be irrelevant anyway).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052849Z" creationid="pingfangx" creationdate="20190618T052849Z">
        <seg>API 设计者可能会选择定义 `Observable&lt;Object&gt;` 而不保证 `Object` 将是什么(无论如何都应该是无关的)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the [`@Beta`][beta source link] annotation at the class or method level are subject to change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105234Z" creationid="pingfangx" creationdate="20190617T105234Z">
        <seg>在类或方法级别标有 [`@Beta`][beta source link] 注释的 API 可能会发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the [`@Experimental`][experimental source link] annotation at the class or method level will almost certainly change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105322Z" creationid="pingfangx" creationdate="20190617T105322Z">
        <seg>在类或方法级别用 [`@Experimental`][experimental source link] 注释标记的 API 几乎肯定会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the `@Deprecated` annotation at the class or method level will remain supported until the next major release but it is recommended to stop using them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105356Z" creationid="pingfangx" creationdate="20190617T105356Z">
        <seg>在类或方法级别标记有 `@Deprecated` 注释的 API 将保持支持，直到下一个主要版本，但建议停止使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About This Document</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071208Z" creationid="pingfangx" creationdate="20190828T071208Z">
        <seg>关于本文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Absolute URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042845Z" creationid="pingfangx" creationdate="20190902T042845Z">
        <seg>绝对 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070936Z" creationid="pingfangx" creationdate="20190828T070936Z">
        <seg>摘要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abuse of Server Log Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074319Z" creationid="pingfangx" creationdate="20190828T074319Z">
        <seg>滥用服务器日志信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Authentication</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073210Z" creationid="pingfangx" creationdate="20190828T073210Z">
        <seg>访问验证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074439Z" creationid="pingfangx" creationdate="20190828T074439Z">
        <seg>致谢</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Active Side Causes Half-Open Connection Discovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060319Z" creationid="pingfangx" creationdate="20190828T060319Z">
        <seg>活动侧导致半开连接发现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, it is a little more complicated than this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022404Z" creationid="pingfangx" creationdate="20190828T022404Z">
        <seg>实际上，它比这复杂一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional (social) requirements are placed on implementations, resource owners, and protocol element registrations when they apply beyond the scope of a single communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102519Z" creationid="pingfangx" creationdate="20190830T102519Z">
        <seg>当实现，资源所有者和协议元素注册超出单个通信的范围时，其他(社交)要求被放置在实现，资源所有者和协议元素注册上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional Features</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074630Z" creationid="pingfangx" creationdate="20190828T074630Z">
        <seg>附加功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional information about the encoding parameters can be provided by other header fields not defined by this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092121Z" creationid="pingfangx" creationdate="20190831T092121Z">
        <seg>有关编码参数的其他信息可以由本规范未定义的其他首部字段提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional methods, outside the scope of this specification, have been standardized for use in HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133902Z" creationid="pingfangx" creationdate="20190831T133902Z">
        <seg>在本说明书范围之外的其他方法已被标准化以用于 HTTP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional tokens ought to be registered with IANA using the registration procedure defined in Section 8.6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113848Z" creationid="pingfangx" creationdate="20190831T113848Z">
        <seg>其他标记应使用第 8.6 节中定义的注册程序在 IANA 注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, version numbers have been restricted to single digits, due to the fact that implementations are known to handle multi-digit version numbers incorrectly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091624Z" creationid="pingfangx" creationdate="20190830T091624Z">
        <seg>此外，由于已知实现不正确地处理多位数版本号，因此版本号限制为单个数字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advice for designers of new URI schemes can be found in [RFC2718].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T055443Z" creationid="pingfangx" creationdate="20190902T055443Z">
        <seg>有关新 URI 方案的设计者的建议可以在 [RFC2718] 中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After TCP A crashes, the user attempts to re-open the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055839Z" creationid="pingfangx" creationdate="20190828T055839Z">
        <seg>TCP A 崩溃后，用户尝试重新打开连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After receiving and interpreting a request message, a server responds with an HTTP response message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T104430Z" creationid="pingfangx" creationdate="20190829T104430Z">
        <seg>在接收并解释请求消息之后，服务器以 HTTP 响应消息进行响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Agent-driven Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150449Z" creationid="pingfangx" creationdate="20190828T073225Z">
        <seg>代理驱动的协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alert Protocol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122207Z" creationid="pingfangx" creationdate="20190901T122207Z">
        <seg>警报协议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All 1xx (Informational), 204 (No Content), and 304 (Not Modified) responses do not include a message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090427Z" creationid="pingfangx" creationdate="20190831T090427Z">
        <seg>所有 1xx(信息)，204(无内容)和 304(未修改)响应都不包含消息正文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a message-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084657Z" creationid="pingfangx" creationdate="20190829T084657Z">
        <seg>所有 1xx(信息)，204(无内容)和 304(未修改)响应不得包含消息主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All HTTP data MUST be sent as TLS "application data".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091504Z" creationid="pingfangx" creationdate="20190901T091504Z">
        <seg>所有 HTTP 数据必须作为 TLS“应用程序数据”发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All HTTP date/time stamps MUST be represented in Greenwich Mean Time (GMT), without exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113858Z" creationid="pingfangx" creationdate="20190828T113858Z">
        <seg>所有 HTTP 日期/时间戳必须以格林威治标准时间(GMT)表示，无一例外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All HTTP requirements applicable to an origin server also apply to the outbound communication of a gateway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101538Z" creationid="pingfangx" creationdate="20190830T101538Z">
        <seg>适用于源服务器的所有 HTTP 要求也适用于网关的出站通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All HTTP/1.1 applications MUST be able to receive and decode the "chunked" transfer-coding, and MUST ignore chunk-extension extensions they do not understand.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144450Z" creationid="pingfangx" creationdate="20190828T144450Z">
        <seg>所有 HTTP/1.1 应用程序必须能够接收和解码“分块”传输编码，并且必须忽略他们不理解的块扩展扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All HTTP/1.1 applications that receive entities MUST accept the "chunked" transfer-coding (section 3.6), thus allowing this mechanism to be used for messages when the message length cannot be determined in advance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090341Z" creationid="pingfangx" creationdate="20190829T090341Z">
        <seg>接收实体的所有 HTTP/1.1 应用程序必须接受“chunked”传输编码(第 3.6 节)，从而允许在无法提前确定消息长度时将此机制用于消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All HTTP/1.1 messages consist of a start-line followed by a sequence of octets in a format similar to the Internet Message Format [RFC5322]: zero or more header fields (collectively referred to as the "headers" or the "header section"), an empty line indicating the end of the header section, and an optional message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T062548Z" creationid="pingfangx" creationdate="20190831T062548Z">
        <seg>所有 HTTP/1.1 消息都包含一个起始行，后跟一系列八位字节，格式类似于互联网消息格式 [RFC5322]：零个或多个首部字段（统称为“首部 (headers)”或“首部部分”） ），一个表示首部部分结尾的空行和一个可选的消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All code inside the `io.reactivex.internal.*` packages is considered private API and should not be relied upon at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105411Z" creationid="pingfangx" creationdate="20190617T105411Z">
        <seg>`io.reactivex.internal.*` 包中的所有代码都被视为私有 API，根本不应该依赖它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All content-coding values are case-insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T135954Z" creationid="pingfangx" creationdate="20190828T135954Z">
        <seg>所有内容编码值都不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All defined header fields ought to be registered with IANA in the "Message Headers" registry, as described in Section 8.3 of [RFC7231].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082148Z" creationid="pingfangx" creationdate="20190831T082148Z">
        <seg>所有定义的首部字段都应该在 IANA 的“消息首部”注册表中注册，如 [RFC7231] 的第 8.3 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All general-purpose servers MUST support the methods GET and HEAD.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133831Z" creationid="pingfangx" creationdate="20190831T133831Z">
        <seg>所有通用服务器必须支持 GET 和 HEAD 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All linear white space, including folding, has the same semantics as SP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095836Z" creationid="pingfangx" creationdate="20190828T095836Z">
        <seg>所有线性空白区域(包括折叠)都具有与 SP 相同的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All multipart types share a common syntax, as defined in section 5.1.1 of RFC 2046 [40], and MUST include a boundary parameter as part of the media type value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152314Z" creationid="pingfangx" creationdate="20190828T152314Z">
        <seg>所有 multipart 类型共享一个通用语法，如 RFC 2046 [40] 的 5.1.1 节中所定义，并且必须包含边界参数作为媒体类型值的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the mechanisms specified in this document are described in both prose and an augmented Backus-Naur Form (BNF) similar to that used by RFC 822 [9].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092448Z" creationid="pingfangx" creationdate="20190828T092448Z">
        <seg>本文档中指定的所有机制都以散文和增强的 Backus-Naur 形式(BNF)描述，类似于 RFC 822 [9] 使用的形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the requirements listed above for the "http" scheme are also requirements for the "https" scheme, except that TCP port 443 is the default if the port subcomponent is empty or not given, and the user agent MUST ensure that its connection to the origin server is secured through the use of strong encryption, end-to-end, prior to sending the first HTTP request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060555Z" creationid="pingfangx" creationdate="20190831T060555Z">
        <seg>上面列出的“http”方案的所有要求也是“https”方案的要求，但如果端口子组件为空或未给出，TCP 端口默认值是 443，并且用户代理必须确保其到源服务器的连接，在发送第一个 HTTP 请求之前，通过端到端使用强加密来保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All options are included in the checksum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110811Z" creationid="pingfangx" creationdate="20190827T110811Z">
        <seg>所有选项都包含在校验和中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other methods are OPTIONAL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133834Z" creationid="pingfangx" creationdate="20190831T133834Z">
        <seg>所有其他方法都是可选的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other methods are OPTIONAL; however, if the above methods are implemented, they MUST be implemented with the same semantics as those specified in section 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094607Z" creationid="pingfangx" creationdate="20190829T094607Z">
        <seg>所有其他方法都是可选的；但是，如果实现上述方法，则必须使用与第 9 节中指定的语义相同的语义来实现它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other responses do include a message body, although the body might be of zero length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090447Z" creationid="pingfangx" creationdate="20190831T090447Z">
        <seg>所有其他响应都包含消息正文，尽管正文可能长度为零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other responses do include a message-body, although it MAY be of zero length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T080509Z" creationid="pingfangx" creationdate="20190829T084707Z">
        <seg>所有其他响应都包含一个消息主体，尽管它的长度可能为零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All responses to the HEAD request method MUST NOT include a message-body, even though the presence of entity- header fields might lead one to believe they do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T080504Z" creationid="pingfangx" creationdate="20190829T084637Z">
        <seg>对 HEAD 请求方法的所有响应都不得包含消息主体，即使实体首部字段的存在可能导致人们以为它们包含消息主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All segments preceding and including FIN will be retransmitted until acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070131Z" creationid="pingfangx" creationdate="20190828T063559Z">
        <seg>FIN 之前（包含 FIN ）的所有报文段都将被重传，直到被确认为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All significant changes from RFC 2396 are noted in Appendix D.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T055503Z" creationid="pingfangx" creationdate="20190902T055503Z">
        <seg>从 RFC 2396 的所有重大更改都在附录 D 中注明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All significant changes from the prior RFCs are noted in Appendix G.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035913Z" creationid="pingfangx" creationdate="20190902T035913Z">
        <seg>附录 G 中记录了之前 RFC 的所有重大变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry" maintained by IANA, as defined in Section 8.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133917Z" creationid="pingfangx" creationdate="20190831T133917Z">
        <seg>所有这些方法都应该在 IANA 维护的“超文本传输​​协议(HTTP)方法注册表”中注册，如第 8.1 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All transfer-coding values are case-insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142436Z" creationid="pingfangx" creationdate="20190828T142436Z">
        <seg>所有传输编码值都不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, "hop-by-hop" header fields are required to appear in the Connection header field; just because they're defined as hop-by-hop in this specification doesn't exempt them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092156Z" creationid="pingfangx" creationdate="20190830T092156Z">
        <seg>此外，“逐跳”首部字段需要出现在 Connection 首部字段中；仅仅因为它们在本规范中被逐跳定义并不能免除它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093759Z" creationid="pingfangx" creationdate="20190620T093759Z">
        <seg>此外，每个实现都倾向于将其操作符命名为类似于该语言中其他上下文已熟悉的类似方法的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, some extraneous requirements about when servers are allowed to close connections prematurely have been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092220Z" creationid="pingfangx" creationdate="20190830T092220Z">
        <seg>此外，还删除了一些关于何时允许服务器过早关闭连接的无关要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T040539Z" creationid="pingfangx" creationdate="20190830T040539Z">
        <seg>此外，方法 OPTIONS 和 TRACE 不应该有副作用，因此本质上是幂等的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the `Flowable.parallel()` operator and the `ParallelFlowable` type help achieve the same parallel processing pattern:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083319Z" creationid="pingfangx" creationdate="20190617T083319Z">
        <seg>或者，`Flowable.parallel()` 运算符和 `ParallelFlowable` 类型有助于实现相同的并行处理模式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the `doFinally` operator (introduced in 2.0.1 and standardized in 2.1) calls a developer specified `Action` that gets executed after a source completed, failed with an error or got cancelled/disposed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115415Z" creationid="pingfangx" creationdate="20190618T115415Z">
        <seg>或者，`doFinally` 操作符(在 2.0.1 中引入，在 2.1 中标准化)调用开发人员指定的 `Action`，它在源完成后，带错误失败或被取消/释放时执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can use the `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)` (and similar) methods to provide a callback/lambda that can throw:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095717Z" creationid="pingfangx" creationdate="20190618T095717Z">
        <seg>或者，您可以使用 `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)`(和类似的)方法来提供可以抛出的回调/lambda：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatives have also been explored, for example, T/TCP [27].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144148Z" creationid="pingfangx" creationdate="20190829T144148Z">
        <seg>还探讨了替代方案，例如 T/TCP [27]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA Character Set registry [19] MUST represent the character set defined by that registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115159Z" creationid="pingfangx" creationdate="20190828T115159Z">
        <seg>虽然 HTTP 允许将任意标记用作字符集值，但在 IANA 字符集注册表 [19] 中具有预定义值的任何标记必须表示该注册表定义的字符集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although HTTP is independent of the transport protocol, the "http" scheme is specific to TCP-based services because the name delegation process depends on TCP for establishing authority.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T054914Z" creationid="pingfangx" creationdate="20190831T054914Z">
        <seg>虽然 HTTP 独立于传输协议，但“http”方案特定于基于 TCP 的服务，因为名称委派过程依赖于 TCP 来建立权限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although any token character MAY appear in a product-version, this token SHOULD only be used for a version identifier (i.e., successive versions of the same product SHOULD only differ in the product-version portion of the product value).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T153346Z" creationid="pingfangx" creationdate="20190828T153346Z">
        <seg>虽然任何标记字符可能出现在产品版本中，但此标记应该仅用于版本标识符(即，同一产品的连续版本应该只在产品值的产品版本部分中有所不同)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although each response header field has a defined meaning, in general, the precise semantics might be further refined by the semantics of the request method and/or response status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144837Z" creationid="pingfangx" creationdate="20190831T144837Z">
        <seg>尽管每个响应首部字段具有定义的含义，但是通常，精确的语义可以通过请求方法和/或响应状态代码的语义进一步细化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although host is case-insensitive, producers and normalizers should use lowercase for registered names and hexadecimal addresses for the sake of uniformity, while only using uppercase letters for percent-encodings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074256Z" creationid="pingfangx" creationdate="20190902T074256Z">
        <seg>尽管 host 不区分大小写，但为了统一性，生产者和规范化器应使用小写的注册名称和十六进制地址，而只使用大写字母表示百分比编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although schemes are case-insensitive, the canonical form is lowercase and documents that specify schemes must do so with lowercase letters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072455Z" creationid="pingfangx" creationdate="20190902T072455Z">
        <seg>虽然方案不区分大小写，但规范形式是小写的，指定方案的文档必须使用小写字母。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the `Flowable` infrastructure guarantees it will be called at most once on each `Subscriber`, the call to `request(1)` may trigger the emission of an element right away.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083229Z" creationid="pingfangx" creationdate="20190621T083229Z">
        <seg>虽然 `Flowable` 基础设施保证在每个 `Subscriber` 上最多只调用一次，但是对 `request(1)` 的调用可能会立即触发一个元素的发射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the diagram is linear, each participant may be engaged in multiple, simultaneous communications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090215Z" creationid="pingfangx" creationdate="20190828T090215Z">
        <seg>尽管该图是线性的，但每个参与者可以参与多个同时通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the diagram is linear, each participant might be engaged in multiple, simultaneous communications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101107Z" creationid="pingfangx" creationdate="20190830T101107Z">
        <seg>尽管该图是线性的，但每个参与者可能参与多个同时通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103547Z" creationid="pingfangx" creationdate="20190831T103547Z">
        <seg>尽管起始行和首部字段的行终止符是序列 CRLF，但是接收者可以将单个 LF 识别为行终止符并忽略任何前面的 CR。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the request-line and status-line grammar rules require that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103632Z" creationid="pingfangx" creationdate="20190831T103632Z">
        <seg>虽然请求行和状态行语法规则要求每个组件元素由单个 SP 八位字节分隔，但是接收者可以改为解析以空格分隔的字边界，并且除了 CRLF 终止符之外，将任何形式的空格视为 SP 分隔符，同时忽略前面或后面的空格；这样的空白包括以下八位字节中的一个或多个：SP，HTAB，VT (%x0B)，FF (%x0C)或裸 CR。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the use of the Common Name is existing practice, it is deprecated and Certification Authorities are encouraged to use the dNSName instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T104334Z" creationid="pingfangx" creationdate="20190901T104334Z">
        <seg>尽管使用 Common Name 是现有做法，但不推荐使用它，并且鼓励证书颁发机构使用 dNSName。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the value describes the content-coding, what is more important is that it indicates what decoding mechanism will be required to remove the encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140137Z" creationid="pingfangx" creationdate="20190828T140137Z">
        <seg>虽然该值描述了内容编码，但更重要的是它指示了移除编码所需的解码机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093543Z" creationid="pingfangx" creationdate="20190620T093543Z">
        <seg>虽然实现之间存在很多重叠，但也有一些操作符仅在某些实现中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although there is no standard set of heuristics for disambiguating a URI suffix, many client implementations allow them to be entered by the user and heuristically resolved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090429Z" creationid="pingfangx" creationdate="20190902T090429Z">
        <seg>虽然没有标准的启发式方法来消除 URI 后缀的歧义，但许多客户端实现允许用户输入并启发式解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although these examples do not show connection synchronization using data-carrying segments, this is perfectly legitimate, so long as the receiving TCP doesn't deliver the data to the user until it is clear the data is valid (i.e., the data must be buffered at the receiver until the connection reaches the ESTABLISHED state).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031823Z" creationid="pingfangx" creationdate="20190828T031823Z">
        <seg>虽然这些示例没有显示使用数据承载报文段的连接同步，但这是完全合法的，只要接收 TCP 不向用户传递数据，直到数据有效（即数据必须在接收器处被缓冲，直到连接达到 ESTABLISHED 状态）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this practice of using suffix references is common, it should be avoided whenever possible and should never be used in situations where long-term references are expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090443Z" creationid="pingfangx" creationdate="20190902T090443Z">
        <seg>尽管这种使用后缀引用的做法很常见，但应尽可能避免使用后缀，并且绝不应在需要长期引用的情况下使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this separate handling is often perceived to be a loss of information, particularly for accurate redirection of references as resources move over time, it also serves to prevent information providers from denying reference authors the right to refer to information within a resource selectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083841Z" creationid="pingfangx" creationdate="20190902T083841Z">
        <seg>虽然这种单独处理通常被认为是信息丢失，特别是随着资源随时间推移而对参考文献进行精确重定向，但它也有助于防止信息提供者拒绝参考作者有选择地引用资源内的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this set can be expanded, additional methods cannot be assumed to share the same semantics for separately extended clients and servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T031719Z" creationid="pingfangx" creationdate="20190830T031719Z">
        <seg>虽然可以扩展此集合，但不能假定其他方法为单独扩展的客户端和服务器共享相同的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041737Z" creationid="pingfangx" creationdate="20190830T041737Z">
        <seg>尽管此规范未定义此类主体的任何用途，但 HTTP 的未来扩展可能使用 OPTIONS 主体在服务器上进行更详细的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this specification does not define any use for such a payload, future extensions to HTTP might use the OPTIONS body to make more detailed queries about the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T143820Z">
        <seg>尽管此规范未定义此类有效载荷的任何用途，但 HTTP 的未来扩展可能会使用 OPTIONS 主体对目标资源进行更详细的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Among the variables stored in the TCB are the local and remote socket numbers, the security and precedence of the connection, pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111529Z" creationid="pingfangx" creationdate="20190827T111529Z">
        <seg>存储在 TCB 中的变量包括本地和远程套接字号，连接的安全性和优先级，指向用户的发送和接收缓冲区的指针，指向重新传输队列和当前报文段的指针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An "XXX" indicates a segment which is lost or rejected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034539Z" creationid="pingfangx" creationdate="20190828T034539Z">
        <seg>“XXX”表示丢失或拒绝的报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An "absolute-path" rule is defined for protocol elements that can contain a non-empty path component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104902Z" creationid="pingfangx" creationdate="20190830T104902Z">
        <seg>为可以包含非空路径组件的协议元素定义“absolute-path”规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;AsyncSubject&lt;/c0&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083933Z" creationid="pingfangx" creationdate="20190620T083933Z">
        <seg>&lt;c0&gt;AsyncSubject&lt;/c0&gt; 发射源 Observable 发射的最后一个值(且仅发射最后一个值)，并且只在该 Observable 源完成后才会发射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Alphabetical List of Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094441Z" creationid="pingfangx" creationdate="20190620T094441Z">
        <seg>按字母顺序排列的 Observable 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP "client" is a program that establishes a connection to a server for the purpose of sending one or more HTTP requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095518Z" creationid="pingfangx" creationdate="20190830T095518Z">
        <seg>HTTP“客户端 (client)”是为了发送一个或多个 HTTP 请求而建立与服务器的连接的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP "server" is a program that accepts connections in order to service HTTP requests by sending HTTP responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095535Z" creationid="pingfangx" creationdate="20190830T095535Z">
        <seg>HTTP“服务器 (server)”是接受连接以通过发送 HTTP 响应来服务 HTTP 请求的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP message can be either a request from client to server or a response from server to client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T065344Z" creationid="pingfangx" creationdate="20190831T065344Z">
        <seg>HTTP 消息可以是从客户端到服务器的请求，也可以是从服务器到客户端的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP message can be parsed as a stream for incremental processing or forwarding downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T063218Z" creationid="pingfangx" creationdate="20190831T063218Z">
        <seg>可以将 HTTP 消息解析为用于增量处理或向下游转发的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP request message, as defined in section 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080924Z" creationid="pingfangx" creationdate="20190828T080924Z">
        <seg>HTTP 请求消息，如第 5 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP response message, as defined in section 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080928Z" creationid="pingfangx" creationdate="20190828T080928Z">
        <seg>HTTP 响应消息，如第 6 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP service based on some other underlying connection protocol would presumably be identified using a different URI scheme, just as the "https" scheme (below) is used for resources that require an end-to-end secured connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T055015Z" creationid="pingfangx" creationdate="20190831T054946Z">
        <seg>基于某些其他基础连接协议的 HTTP 服务可能会使用不同的 URI 方案进行标识，就像“https”方案(下面)用于需要端到端安全连接的资源一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP/1.1 (or later) client sending a message-body SHOULD monitor the network connection for an error status while it is transmitting the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024259Z" creationid="pingfangx" creationdate="20190830T024225Z">
        <seg>发送消息主体的 HTTP/1.1(或更高版本)客户端应该在发送请求时监视网络连接的错误状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP/1.1 client MAY expect a connection to remain open, but would decide to keep it open based on whether the response from a server contains a Connection header with the connection-token close.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150645Z" creationid="pingfangx" creationdate="20190829T150645Z">
        <seg>HTTP/1.1 客户端可能希望连接保持打开状态，但会根据服务器的响应是否包含连接标记关闭的 Connection 首部来决定是否保持打开状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to maintain a persistent connection unless a Connection header including the connection-token "close" was sent in the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150554Z" creationid="pingfangx" creationdate="20190829T150554Z">
        <seg>HTTP/1.1 服务器可以假设 HTTP/1.1 客户端打算维持持久连接，除非在请求中发送包含连接标记“close”的 Connection 首部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103248Z" creationid="pingfangx" creationdate="20190831T103248Z">
        <seg>HTTP/1.1 用户代理不能在请求前面或后面附加一个 CRLF。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An OPTIONS request with an asterisk ("*") as the request-target (Section 5.3 of [RFC7230]) applies to the server in general rather than to a specific resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143458Z" creationid="pingfangx" creationdate="20190831T143458Z">
        <seg>带有星号(“*”)作为请求目标的 OPTIONS 请求([RFC7230] 的第 5.3 节)通常适用于服务器而不是特定资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable &lt;d3&gt;emits&lt;/d3&gt; &lt;d4&gt;items&lt;/d4&gt; or sends &lt;d5&gt;notifications&lt;/d5&gt; to its observers by calling the observers’ methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045830Z" creationid="pingfangx" creationdate="20190620T045830Z">
        <seg>Observable(可观察对象) &lt;d3&gt;emits (发射)&lt;/d3&gt; &lt;d4&gt;items (数据项)&lt;/d4&gt; 或通过调用观察者的方法向其观察者发送 &lt;d5&gt;notifications (通知)&lt;/d5&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method after it has called &lt;c0&gt;onNext&lt;/c0&gt; for the final time, if it has not encountered any errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060356Z" creationid="pingfangx" creationdate="20190620T060356Z">
        <seg>如果 Observable 没有遇到任何错误，则在最后一次调用 &lt;c0&gt;onNext&lt;/c0&gt; 之后调用此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060301Z" creationid="pingfangx" creationdate="20190620T060301Z">
        <seg>Observable 调用此方法以指示它无法生成预期数据或遇到其他一些错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method whenever the Observable emits an item.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060243Z" creationid="pingfangx" creationdate="20190620T060243Z">
        <seg>只要 Observable 发射一个项目，Observable 就会调用此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable has all of the flexibility and elegance associated with its mirror-image cousin the Iterable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035619Z" creationid="pingfangx" creationdate="20190620T035619Z">
        <seg>Observable 具有与 Iterable 镜像相关的所有灵活性和优雅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable is the asynchronous/push &lt;a0&gt;“dual”&lt;/a0&gt; to the synchronous/pull Iterable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040115Z" creationid="pingfangx" creationdate="20190620T035959Z">
        <seg>Observable 是异步的双向(&lt;a0&gt;“dual”&lt;/a0&gt;) push，Iterable 是同步的 pull</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one — that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045630Z" creationid="pingfangx" creationdate="20190620T045630Z">
        <seg>这种方法的一个优点是，当您有一堆不依赖于彼此的任务时，你可以同时启动所有任务，而不是等到每个任务完成后再开始下一个 - 这样，你的整个捆绑任务只会耗费与捆绑中最长的任务一样长的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application program that accepts connections in order to service requests by sending back responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081333Z" creationid="pingfangx" creationdate="20190828T081333Z">
        <seg>一种应用程序，它接受连接以通过发回响应来为请求提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application that sends a request or response message that includes HTTP-Version of "HTTP/1.1" MUST be at least conditionally compliant with this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103825Z" creationid="pingfangx" creationdate="20190828T103825Z">
        <seg>发送包含 HTTP-Version 为 “HTTP/1.1”的请求或响应消息的应用程序必须至少有条件地符合此规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An encoding format produced by the file compression program "gzip" (GNU zip) as described in RFC 1952 [25].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140935Z" creationid="pingfangx" creationdate="20190828T140935Z">
        <seg>由 RFC 1952 [25] 中描述的文件压缩程序“gzip”(GNU zip)生成的编码格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity can be broken down into subranges according to various structural units.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160258Z" creationid="pingfangx" creationdate="20190828T160258Z">
        <seg>可以根据各种结构单元将实体分解为子范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity consists of entity-header fields and an entity-body, although some responses will only include the entity-headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T111755Z" creationid="pingfangx" creationdate="20190829T111755Z">
        <seg>实体由实体首部字段和实体主体组成，但有些响应仅包含实体首部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity consists of metainformation in the form of entity-header fields and content in the form of an entity-body, as described in section 7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081130Z" creationid="pingfangx" creationdate="20190828T081130Z">
        <seg>实体由实体首部字段形式的元信息和实体主体形式的内容组成，如第 7 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity included with a response that is subject to content negotiation, as described in section 12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081140Z" creationid="pingfangx" creationdate="20190828T081140Z">
        <seg>如第 12 节所述，包含在内容协商中的响应的实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity tag MUST be unique across all versions of all entities associated with a particular resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155949Z" creationid="pingfangx" creationdate="20190828T155949Z">
        <seg>实体标签必须在与特定资源相关联的所有实体的所有版本中都是唯一的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155731Z" creationid="pingfangx" creationdate="20190828T155731Z">
        <seg>实体标签由不透明的带引号的字符串组成，可能以弱指示符为前缀。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity-body is only present in a message when a message-body is present, as described in section 4.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T120922Z" creationid="pingfangx" creationdate="20190829T120851Z">
        <seg>如第 4.3 节所述，实体实体仅在存在消息体时出现在消息中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An entity-body transferred via HTTP messages MUST be represented in the appropriate canonical form prior to its transmission except for "text" types, as defined in the next paragraph.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T150830Z" creationid="pingfangx" creationdate="20190828T150830Z">
        <seg>通过 HTTP 消息传输的实体-主体必须在传输之前以适当的规范形式表示，除了“文本”类型，如下一段中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An established connection is said to be  "half-open" if one of the TCPs has closed or aborted the connection at its end without the knowledge of the other, or if the two ends of the connection have become desynchronized owing to a crash that resulted in loss of memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043526Z" creationid="pingfangx" creationdate="20190828T043432Z">
        <seg>如果其中一个 TCP 在其不知道另一个的情况下关闭或中止了连接，或者如果连接的两端由于崩溃而变得不同步导致失去记忆，则建立的连接被称为“半开”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example Request-Line would be:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100710Z" creationid="pingfangx" creationdate="20190829T100710Z">
        <seg>Request-Line 示例如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example URI specifying HTTP/TLS is:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103405Z" creationid="pingfangx" creationdate="20190901T103405Z">
        <seg>指定 HTTP/TLS 的示例 URI 是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example absolute-form of request-line would be:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124614Z" creationid="pingfangx" creationdate="20190831T124614Z">
        <seg>请求行的绝对形式示例如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T094602Z" creationid="pingfangx" creationdate="20190831T094602Z">
        <seg>一个例子是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of an enhancement that would classify as this is adding reactive pull backpressure support to an operator that previously did not support it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105030Z" creationid="pingfangx" creationdate="20190617T105030Z">
        <seg>可归类为此增强功能的一个示例是向先前不支持它的运算符添加反应性拉背压支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example process for decoding a Chunked-Body is presented in appendix 19.4.6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144321Z" creationid="pingfangx" creationdate="20190828T144321Z">
        <seg>解码 Chunked-Body 的示例过程在附录 19.4.6 中给出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An expiration time assigned by a cache when no explicit expiration time is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081922Z" creationid="pingfangx" creationdate="20190828T081922Z">
        <seg>当没有明确的到期时间可用时由缓存分配的到期时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An idempotent sequence of requests is no longer required to be retried.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092206Z" creationid="pingfangx" creationdate="20190830T092206Z">
        <seg>不再需要重试幂等序列的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier embodies the information required to distinguish what is being identified from all other things within its scope of identification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060748Z" creationid="pingfangx" creationdate="20190902T060748Z">
        <seg>标识符包含在其识别范围内区分所识别的内容与所有其他内容所需的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier is an object that can act as a reference to something that has identity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040306Z" creationid="pingfangx" creationdate="20190902T040306Z">
        <seg>标识符是一个对象，可以作为对具有标识的内容的引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102543Z" creationid="pingfangx" creationdate="20190830T102543Z">
        <seg>如果实现符合与其在 HTTP 中共享的角色相关的所有要求，则认为该实现符合要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080531Z" creationid="pingfangx" creationdate="20190828T080531Z">
        <seg>如果实现无法满足其实现的协议的一个或多个 MUST 或 REQUIRED 级别要求，则该实现不符合要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation should accept uppercase letters as equivalent to lowercase in scheme names (e.g., allow "HTTP" as well as "http") for the sake of robustness but should only produce lowercase scheme names for consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072522Z" creationid="pingfangx" creationdate="20190902T072522Z">
        <seg>实现应该接受大写字母等同于方案名称中的小写(例如，允许“HTTP”以及“http”)以保持健壮性，但是应该仅为了一致性而产生小写方案名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be "conditionally compliant."</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080711Z" creationid="pingfangx" creationdate="20190828T080711Z">
        <seg>满足所有 MUST 或 REQUIRED 级别以及所有 SHOULD 级别要求的协议的实现被称为“无条件兼容”;一个满足所有 MUST 级别要求但不满足其协议的所有 SHOULD 级别要求被称为“有条件兼容”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An important change regarding `Subject`s (and by extension, `FlowableProcessor`) that they no longer support `T -&gt; R` like conversion (that is, input is of type `T` and the output is of type `R`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062234Z" creationid="pingfangx" creationdate="20190618T062234Z">
        <seg>关于 `Subject` (以及扩展名 `FlowableProcessor`)的一个重要变化是它们不再支持类似 `T -&gt; R` 的转换(即输入类型为 `T` 且输出类型为 `R` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An individual scheme does not have to be classified as being just one of "name" or "locator".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064031Z" creationid="pingfangx" creationdate="20190902T064031Z">
        <seg>一个单独的方案不必被归类为“名称”或“定位器”中的一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interception proxy is particularly vulnerable if it relies on the Host field-value for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130334Z" creationid="pingfangx" creationdate="20190831T130334Z">
        <seg>如果拦截代理依赖 Host 字段值将请求重定向到内部服务器，或者用作共享缓存中的缓存密钥，而不首先验证截获的连接是否针对该主机的有效 IP 地址，则拦截代理特别容易受到攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interesting alternative case occurs when TCP A crashes and TCP B tries to send data on what it thinks is a synchronized connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060206Z" creationid="pingfangx" creationdate="20190828T060206Z">
        <seg>当 TCP A 崩溃并且 TCP B 尝试发送它认为是同步连接的数据时，会出现一个有趣的替代情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132428Z" creationid="pingfangx" creationdate="20190831T132428Z">
        <seg>中介绝不能将消息转发给自己，除非它受到无限请求循环的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.1, and exclude fields from being forwarded that are only intended for the incoming connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132420Z" creationid="pingfangx" creationdate="20190831T132420Z">
        <seg>不充当隧道的中介必须实现 Connection 首部字段，如第 6.1 节所述，并排除转发中仅用于传入连接的字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An intermediary program which acts as both a server and a client for the purpose of making requests on behalf of other clients.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081445Z" creationid="pingfangx" creationdate="20190828T081445Z">
        <seg>中间程序，作为服务器和客户端，代表其他客户端发出请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An intermediary program which is acting as a blind relay between two connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081629Z" creationid="pingfangx" creationdate="20190828T081629Z">
        <seg>中间程序，充当两个连接之间的盲中继。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111944Z" creationid="pingfangx" creationdate="20190831T111944Z">
        <seg>接收流水线请求的中介可以在转发它们时对这些请求进行流水线处理，因为它可以依赖出站用户代理来确定哪些请求可以安全地流水线化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An old duplicate arriving at TCP B (line 2) stirs B into action.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060353Z" creationid="pingfangx" creationdate="20190828T060353Z">
        <seg>到达 TCP B(第 2 行)的旧副本激起 B 采取行动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An option may begin on any octet boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110814Z" creationid="pingfangx" creationdate="20190827T110814Z">
        <seg>选项可以从任何八位字节边界开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094450Z" creationid="pingfangx" creationdate="20190829T094450Z">
        <seg>如果原始服务器已知该方法但对所请求的资源不允许，则原始服务器应该返回状态代码 405(方法不允许)，如果原始服务器无法识别或未实现该方法，则应返回 501(未实现)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141619Z" creationid="pingfangx" creationdate="20190831T141619Z">
        <seg>源服务器通过根据处理 POST 请求的结果选择适当的状态代码来指示响应语义；几乎所有由本规范定义的状态代码都可能在对 POST 的响应中被接收(异常为 206(部分内容)，304(未修改)和 416(范围不可满足))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133007Z" creationid="pingfangx" creationdate="20190831T133007Z">
        <seg>源服务器可以被提供或能够生成多个表示，每个表示旨在反映目标资源的当前状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An origin server that does differentiate resources based on the host requested (sometimes referred to as virtual hosts or vanity host names) MUST use the following rules for determining the requested resource on an HTTP/1.1 request:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101958Z" creationid="pingfangx" creationdate="20190829T101958Z">
        <seg>根据请求的主机(有时称为虚拟主机或 vanity host names)区分资源的源服务器必须使用以下规则来确定 HTTP/1.1 请求上的请求资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An origin server that does not allow resources to differ by the requested host MAY ignore the Host header field value when determining the resource identified by an HTTP/1.1 request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101902Z" creationid="pingfangx" creationdate="20190829T101652Z">
        <seg>在确定由 HTTP/1.1 请求标识的资源时，不允许与所请求主机的资源不同的源服务器可以忽略 Host 首部字段值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An origin server that receives a CONNECT request for itself MAY respond with a 2xx (Successful) status code to indicate that a connection is established.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143041Z" creationid="pingfangx" creationdate="20190831T143041Z">
        <seg>接收自身 CONNECT 请求的源服务器可以使用 2xx(成功)状态代码进行响应，以指示建立了连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analysis of these performance problems and results from a prototype implementation are available [26] [30].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T143038Z" creationid="pingfangx" creationdate="20190829T143038Z">
        <seg>可以获得这些性能问题的分析和原型实现的结果 [26] [30]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040922Z" creationid="pingfangx" creationdate="20190620T040922Z">
        <seg>而且重要的是：使用 ReactiveX，你可以改变你的观念，你可从根本上改变 Observable 的底层实现，而不会破坏 Observable 的使用者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Angle brackets are used within definitions whenever their presence will facilitate discerning the use of rule names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092719Z" creationid="pingfangx" creationdate="20190828T092719Z">
        <seg>角度括号在定义中使用，只要它们的存在有助于辨别规则名称的使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another significant difference between `rx.Subscriber` (and co) and `org.reactivestreams.Subscriber` (and co) is that in 2.x, your `Subscriber`s and `Observer`s are not allowed to throw anything but fatal exceptions (see `Exceptions.throwIfFatal()`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095501Z" creationid="pingfangx" creationdate="20190618T095501Z">
        <seg>`rx.Subscriber`(及 co) 和 `org.reactivestreams.Subscriber`(及 co)之间的另一个显着区别是在 2.x 中，您的 `Subscriber`s 和 `Observer`s 不允许抛出任何异常，除了致命的异常(参见 `Exceptions.throwIfFatal()`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075544Z" creationid="pingfangx" creationdate="20190620T075544Z">
        <seg>另一个版本需要两个或更多 Singles 并将它们合并到一个 Observable 中，该 Observable 发射源 Singles 发射的项目(以任意顺序)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any 2xx (Successful) response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the blank line that concludes the successful response's header section; data received after that blank line is from the server identified by the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143149Z" creationid="pingfangx" creationdate="20190831T143149Z">
        <seg>任何 2xx(成功)响应都表示发送方(以及所有入站代理)将在结束成功响应的首部部分的空行后立即切换到隧道模式；该空行之后收到的数据来自请求目标标识的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101258Z" creationid="pingfangx" creationdate="20190831T101258Z">
        <seg>对 CONNECT 请求的任何 2xx(成功)响应意味着连接将在结束首部字段的空行之后立即成为隧道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Content-Length field value greater than or equal to zero is valid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T100753Z" creationid="pingfangx" creationdate="20190831T100753Z">
        <seg>任何大于或等于零的 Content-Length 字段值都是有效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any HTTP/1.1 message containing an entity-body SHOULD include a Content-Type header field defining the media type of that body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121332Z" creationid="pingfangx" creationdate="20190829T121332Z">
        <seg>包含实体主体的任何 HTTP/1.1 消息应该包括定义该主体的媒体类型的 Content-Type 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Host header field value in the request MUST be ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102034Z" creationid="pingfangx" creationdate="20190829T102034Z">
        <seg>必须忽略请求中的任何 Host 首部字段值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any LWS that occurs between field-content MAY be replaced with a single SP before interpreting the field value or forwarding the message downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T081259Z" creationid="pingfangx" creationdate="20190829T081259Z">
        <seg>在解释字段值或向下游转发消息之前，在字段内容之间出现的任何 LWS 都可以用单个 SP 替换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any client or server MAY employ a cache, though a cache cannot be used by a server while it is acting as a tunnel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102217Z" creationid="pingfangx" creationdate="20190830T102217Z">
        <seg>任何客户端或服务器都可以使用缓存，但是当服务器充当隧道时，服务器不能使用缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any client or server may include a cache, though a cache cannot be used by a server that is acting as a tunnel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081733Z" creationid="pingfangx" creationdate="20190828T081733Z">
        <seg>任何客户端或服务器都可以包含缓存，但是作为隧道的服务器不能使用缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any given program may be capable of being both a client and a server; our use of these terms refers only to the role being performed by the program for a particular connection, rather than to the program's capabilities in general.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081355Z" creationid="pingfangx" creationdate="20190828T081355Z">
        <seg>任何给定的程序都可以是客户端和服务器；我们对这些术语的使用仅指程序为特定连接执行的角色，而不是程序的一般功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any party to the communication which is not acting as a tunnel may employ an internal cache for handling requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090325Z" creationid="pingfangx" creationdate="20190828T090325Z">
        <seg>不充当隧道的通信的任何一方可以使用内部缓存来处理请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143205Z" creationid="pingfangx" creationdate="20190831T143205Z">
        <seg>除响应成功之外的任何响应都表示尚未形成隧道，并且连接仍由 HTTP 管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101247Z" creationid="pingfangx" creationdate="20190831T101247Z">
        <seg>对 HEAD 请求的任何响应以及具有 1xx(信息)，204(无内容)或 304(未修改)状态代码的任何响应始终由首部字段后的第一个空行终止，而不管首部字段是否存在于消息，因此不能包含消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anyone can mint a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044323Z" creationid="pingfangx" creationdate="20190831T044323Z">
        <seg>任何人都可以制作一个 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from subscribing to the base types with their respective consumers (`Subscriber`, `Observer`, `SingleObserver`, `MaybeObserver` and `CompletableObserver`) and functional-interface based consumers (such as `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)`), the formerly separate 1.x `BlockingObservable` (and similar classes for the others) has been integrated with the main reactive type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095158Z" creationid="pingfangx" creationdate="20190618T095158Z">
        <seg>除了订阅基本类型用他们各自的消费者（`Subscriber`，`Observer`，`SingleObserver`，`MaybeObserver` 和 `CompletableObserver`）和基于函数接口的消费者（例如 `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action`），以前单独的 1.x `BlockingObservable`（以及其他类似的类）已经与主要的响应类型集成在一起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendices</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074453Z" creationid="pingfangx" creationdate="20190828T074453Z">
        <seg>附录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix A. HTTP Version History</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091402Z" creationid="pingfangx" creationdate="20190830T091402Z">
        <seg>附录 A. HTTP 版本历史</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix B shows the collected grammar with all list operators expanded to standard ABNF notation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094735Z" creationid="pingfangx" creationdate="20190830T094735Z">
        <seg>附录 B 显示了收集的语法，所有列表操作符都扩展为标准 ABNF 表示法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix B. Collected ABNF</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091412Z" creationid="pingfangx" creationdate="20190830T091412Z">
        <seg>附录 B.收集的 ABNF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix C describes rules imported from other documents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122011Z" creationid="pingfangx" creationdate="20190831T122011Z">
        <seg>附录 C 描述了从其他文档导入的规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix D shows the collected grammar with all list operators expanded to standard ABNF notation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122019Z" creationid="pingfangx" creationdate="20190831T122019Z">
        <seg>附录 D 显示了收集的语法，所有列表操作符都扩展为标准 ABNF 表示法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications SHOULD limit their use of character sets to those defined by the IANA registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115416Z" creationid="pingfangx" creationdate="20190828T115416Z">
        <seg>应用程序应该将字符集的使用限制为 IANA 注册中心定义的字符集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications may choose to ignore or reject such data when it is received as part of a reference and should reject the storage of such data in unencrypted form.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073704Z" creationid="pingfangx" creationdate="20190902T073704Z">
        <seg>当应用程序作为引用的一部分被接收时，应用程序可以选择忽略或拒绝这些数据，并且应拒绝以未加密的形式存储此类数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications ought to follow "common form", where one is known or indicated, when generating HTTP constructs, since there might exist some implementations that fail to accept anything beyond the common forms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T083031Z" creationid="pingfangx" creationdate="20190829T081140Z">
        <seg>应用程序应该遵循“通用形式”，其中一个是已知的或指示的，在生成 HTTP 构造时，因为可能存在一些实现不能接受除通用形式之外的任何内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications should not render as clear text any data after the first colon (":") character found within a userinfo subcomponent unless the data after the colon is the empty string (indicating no password).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073654Z" creationid="pingfangx" creationdate="20190902T073654Z">
        <seg>在 userinfo 子组件中找到第一个冒号(“:”)字符后，应用程序不应将任何数据呈现为明文，除非冒号后的数据为空字符串(表示无密码)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications that are at least conditionally compliant with this specification SHOULD use an HTTP-Version of "HTTP/1.1" in their messages, and MUST do so for any message that is not compatible with HTTP/1.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103928Z" creationid="pingfangx" creationdate="20190828T103928Z">
        <seg>至少有条件地符合此规范的应用程序应该在其消息中使用 HTTP 版本的“HTTP/1.1”，并且必须对任何与 HTTP/1.0 不兼容的消息执行此操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications that render a URI for the sake of user feedback, such as in graphical hypertext browsing, should render userinfo in a way that is distinguished from the rest of a URI, when feasible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073723Z" creationid="pingfangx" creationdate="20190902T073723Z">
        <seg>为了用户反馈而呈现 URI 的应用程序(例如在图形超文本浏览中)应该在可行时以与 URI 的其余部分区分的方式呈现 userinfo。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090617Z" creationid="pingfangx" creationdate="20190830T090617Z">
        <seg>结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a URI suffix has the same syntax as a relative-path reference, a suffix reference cannot be used in contexts where a relative reference is expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090536Z" creationid="pingfangx" creationdate="20190902T090536Z">
        <seg>由于 URI 后缀与相对路径引用具有相同的语法，因此后缀引用不能用于需要相对引用的上下文中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, the hostname for the server is known to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103518Z" creationid="pingfangx" creationdate="20190901T103518Z">
        <seg>因此，客户端知道服务器的主机名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a convention, ABNF rule names prefixed with "obs-" denote "obsolete" grammar rules that appear for historical reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094913Z" creationid="pingfangx" creationdate="20190830T094913Z">
        <seg>作为惯例，以“obs-”为前缀的 ABNF 规则名称表示出于历史原因出现的“过时”语法规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general rule, reset (RST) must be sent whenever a segment arrives which apparently is not intended for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060524Z" creationid="pingfangx" creationdate="20190828T060524Z">
        <seg>作为一般规则，每当显然不是用于当前连接的报文段到达时必须发送重置(RST)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, A will probably try to OPEN the connection again or try to SEND on the connection it believes open.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055812Z" creationid="pingfangx" creationdate="20190828T055812Z">
        <seg>因此，A 可能会尝试再次打开连接或尝试在它认为打开的连接上发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, suffix references are limited to places where there is no defined base URI, such as dialog boxes and off-line advertisements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090548Z" creationid="pingfangx" creationdate="20190902T090548Z">
        <seg>因此，后缀引用仅限于没有定义基 URI 的位置，例如对话框和离线广告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112141Z" creationid="pingfangx" creationdate="20190831T112141Z">
        <seg>因此，本规范不要求特定的最大连接数，而是鼓励客户机在打开多个连接时保持保守。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a shorthand, segments carrying the SYN bit are also called "SYNs".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023717Z" creationid="pingfangx" creationdate="20190828T023717Z">
        <seg>作为简写，携带 SYN 位的报文段也称为“SYNs”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a simple example of recovery from old duplicates, consider figure 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042858Z" creationid="pingfangx" creationdate="20190828T042858Z">
        <seg>作为从旧重复项恢复的简单示例，请考虑图 9。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative, the 2.x `Observable` doesn't do backpressure at all and is available as a choice to switch over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073717Z" creationid="pingfangx" creationdate="20190618T073717Z">
        <seg>作为替代方案，2.x `Observable` 根本不做背压，可作为切换的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Section 2.3, intermediaries can serve a variety of roles in the processing of HTTP requests and responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132313Z" creationid="pingfangx" creationdate="20190831T132313Z">
        <seg>如 2.3 节所述，中介可以在处理 HTTP 请求和响应时担任各种角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Section 5.2, the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110027Z" creationid="pingfangx" creationdate="20190831T110027Z">
        <seg>如第 5.2 节所述，用于 HTTP 交互的特定连接协议由客户端配置和目标 URI 确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As far as HTTP is concerned, Uniform Resource Identifiers are simply formatted strings which identify--via name, location, or any other characteristic--a resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T105339Z" creationid="pingfangx" creationdate="20190828T105339Z">
        <seg>就 HTTP 而言，统一资源标识符是简单的格式化字符串，通过名称，位置或任何其他特征来识别资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one of the primary goals of RxJava 2, the design focuses on performance and in order enable it, RxJava 2.0.7 adds a custom `io.reactivex.FlowableSubscriber` interface (extends `org.reactivestreams.Subscriber`) but adds no new methods to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073904Z" creationid="pingfangx" creationdate="20190618T073904Z">
        <seg>作为 RxJava 2 的主要目标之一，该设计侧重于性能，为了实现它，RxJava 2.0.7 增加了一个自定义的 `io.reactivex.FlowableSubscriber` 接口(扩展了 `org.reactivestreams.Subscriber`)，但没有添加新的它的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in this illustration, the &lt;s0&gt;SubscribeOn&lt;/s0&gt; operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090322Z" creationid="pingfangx" creationdate="20190620T090322Z">
        <seg>如图所示，&lt;s0&gt;SubscribeOn&lt;/s0&gt; 操作符指定 Observable 将开始操作的线程，无论操作符链中的哪个操作符被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As specified in [RFC2246], any implementation which receives a connection close without first receiving a valid closure alert (a "premature close") MUST NOT reuse that session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T092256Z" creationid="pingfangx" creationdate="20190901T092256Z">
        <seg>如 [RFC2246] 中所述，任何接收到连接关闭而没有首先接收有效闭包警报(“过早关闭”)的实现都不得重用该会话。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, implementations must not provide the version flag for the existing IPv4 and IPv6 literal address forms described below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074600Z" creationid="pingfangx" creationdate="20190902T074600Z">
        <seg>因此，实现不得为下面描述的现有 IPv4 和 IPv6 文字地址表单提供版本标志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, reference authors should not assume that a slightly different, though equivalent, reference URI will (or will not) be interpreted as a same-document reference by any given application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090147Z" creationid="pingfangx" creationdate="20190902T090147Z">
        <seg>因此，引用作者不应假定引用 URI 稍有不同，尽管它是等效的，但任何给定的应用程序都会(或不会)将其解释为相同的文档引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, the URI syntax is a federated and extensible naming system wherein each scheme's specification may further restrict the syntax and semantics of identifiers using that scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061735Z" creationid="pingfangx" creationdate="20190902T061735Z">
        <seg>这样，URI 语法是联合和可扩展的命名系统，其中每个方案的规范可以进一步限制使用该方案的标识符的语法和语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, the fragment identifier is not used in the scheme-specific processing of a URI; instead, the fragment identifier is separated from the rest of the URI prior to a dereference, and thus the identifying information within the fragment itself is dereferenced solely by the user agent, regardless of the URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083832Z" creationid="pingfangx" creationdate="20190902T083832Z">
        <seg>因此，片段标识符不用于 URI 的特定于方案的处理；相反，片段标识符在解除引用之前与 URI 的其余部分分开，因此片段本身内的识别信息仅由用户代理解除引用，而不管 URI 方案如何。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the opportunity to reduce component count, 2.x doesn't define `Action3`-`Action9` and `ActionN` (these were unused within RxJava itself anyway).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064522Z" creationid="pingfangx" creationdate="20190618T064522Z">
        <seg>作为减少组件数量的机会，2.x 没有定义 `Action3`-`Action9` 和 `ActionN`(无论如何这些都在 RxJava 本身中未使用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any URI, use of a fragment identifier component does not imply that a retrieval action will take place.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083758Z" creationid="pingfangx" creationdate="20190902T083758Z">
        <seg>与任何 URI 一样，使用片段标识符组件并不意味着将发生检索操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the `Observable`/`Flowable` split, the backpressure-aware, Reactive-Streams compliant implementations are based on the `FlowableProcessor&lt;T&gt;` class (which extends `Flowable` to give a rich set of instance operators).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062103Z" creationid="pingfangx" creationdate="20190618T062103Z">
        <seg>与 `Observable`/`Flowable` 拆分一样，背压感知，Reactive-Streams 兼容实现基于 `FlowableProcessor&lt;T&gt;` 类(扩展 `Flowable` 以提供丰富的实例操作符集)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aside from dot-segments in hierarchical paths, a path segment is considered opaque by the generic syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082840Z" creationid="pingfangx" creationdate="20190902T082840Z">
        <seg>除了分层路径中的点段之外，通用语法将路径段视为不透明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091954Z" creationid="pingfangx" creationdate="20190620T091954Z">
        <seg>除了将这些调度器传递给 RxJava Observable 操作符之外，您还可以使用它们来安排自己的订阅工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the complete header section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T100722Z" creationid="pingfangx" creationdate="20190831T100722Z">
        <seg>除了上面定义的情况之外，在没有 Transfer-Encoding 的情况下，在发送完整的首部分之前，当有效载荷主体大小已知时，源服务器应该发送 Content-Length 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associating a Response to a Request</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090944Z" creationid="pingfangx" creationdate="20190830T090944Z">
        <seg>将响应与请求相关联</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assume that two user processes A and B are communicating with one another when a crash occurs causing loss of memory to A's TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055708Z" creationid="pingfangx" creationdate="20190828T055708Z">
        <seg>假设发生崩溃时两个用户进程 A 和 B 正在彼此通信，从而导致 A 的 TCP 内存丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025441Z" creationid="pingfangx" creationdate="20190828T025441Z">
        <seg>在 100 兆比特/秒时，循环时间为 5.4 分钟，这可能有点短，但仍然在合理范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At 2 megabits/sec.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025341Z" creationid="pingfangx" creationdate="20190828T025341Z">
        <seg>以 2 兆比特/秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102846Z" creationid="pingfangx" creationdate="20190830T102846Z">
        <seg>接收者必须至少能够解析和处理协议元素长度，该协议元素长度至少与它为其他消息中的那些相同协议元素生成的值一样长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At each invocation, it has to call `onNext` at most once optionally followed by either `onError` or `onComplete`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021246Z" creationid="pingfangx" creationdate="20190624T021246Z">
        <seg>在每次调用时，它必须最多调用 `onNext` 一次，可选地后跟 `onError` 或 `onComplete`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At least one delimiter (LWS and/or separators) MUST exist between any two tokens (for the definition of "token" below), since they would otherwise be interpreted as a single token.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094417Z" creationid="pingfangx" creationdate="20190828T094353Z">
        <seg>任何两个标记之间必须至少有一个分隔符(LWS 和/或分隔符)(对于下面“token”的定义)，因为否则它们将被解释为单个标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At line 3, an old duplicate SYN arrives at TCP B.  TCP B cannot tell that this is an old duplicate, so it responds normally (line 4).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042922Z" creationid="pingfangx" creationdate="20190828T042922Z">
        <seg>在第 3 行，旧的重复的 SYN 到达 TCP B.TCP B 无法判断这是一个旧副本，因此它正常响应(第 4 行)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At line 4, TCP A responds with an empty segment containing an ACK for TCP B's SYN; and in line 5, TCP A sends some data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041742Z" creationid="pingfangx" creationdate="20190828T041742Z">
        <seg>在第 4 行，TCP A 响应一个包含确认 TCP B 的 SYN 的 ACK 空报文段；在第 5 行中，TCP A 发送一些数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the data is not flowing yet and no side-effects are happening.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071727Z" creationid="pingfangx" creationdate="20190617T071727Z">
        <seg>此时，数据尚未流动，并且没有发生任何副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attach the observer to that Observable by &lt;i0&gt;subscribing&lt;/i0&gt; it (this also initiates the actions of the Observable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055804Z" creationid="pingfangx" creationdate="20190620T055804Z">
        <seg>通过 &lt;i0&gt;subscribing (订阅)&lt;/i0&gt; 将观察者附加到该 Observable(这也启动了 Observable 的操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attacks Based On File and Path Names</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074402Z" creationid="pingfangx" creationdate="20190828T074402Z">
        <seg>基于文件和路径名的攻击</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attacks Based on Command, Code, or Query Injection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120058Z" creationid="pingfangx" creationdate="20190831T120058Z">
        <seg>基于命令，代码或查询注入的攻击</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attacks Based on File and Path Names</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120037Z" creationid="pingfangx" creationdate="20190831T120037Z">
        <seg>基于文件和路径名的攻击</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attacks via Protocol Element Length</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091156Z" creationid="pingfangx" creationdate="20190830T091156Z">
        <seg>通过协议元素长度进行攻击</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Audience Language</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115707Z" creationid="pingfangx" creationdate="20190831T115707Z">
        <seg>受众语言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Augmented BNF</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072028Z" creationid="pingfangx" creationdate="20190828T072028Z">
        <seg>增强的 BNF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Challenges</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115915Z" creationid="pingfangx" creationdate="20190831T115915Z">
        <seg>身份验证挑战</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Credentials</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115824Z" creationid="pingfangx" creationdate="20190831T115824Z">
        <seg>身份验证凭据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Credentials and Idle Clients</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074416Z" creationid="pingfangx" creationdate="20190828T074416Z">
        <seg>身份验证凭据和空闲客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication can happen via asymmetric cryptography (e.g., RSA [RSA], the Elliptic Curve Digital Signature Algorithm (ECDSA) [ECDSA], or the Edwards-Curve Digital Signature Algorithm (EdDSA) [RFC8032]) or a symmetric pre-shared key (PSK).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122814Z" creationid="pingfangx" creationdate="20190901T122814Z">
        <seg>身份验证可以通过非对称加密(例如，RSA [RSA]，椭圆曲线数字签名算法(ECDSA)[ECDSA] 或 Edwards 曲线数字签名算法(EdDSA)[RFC8032])或对称预共享密钥( PSK)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Author's Address</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090642Z" creationid="pingfangx" creationdate="20190901T090642Z">
        <seg>作者地址</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authors' Addresses</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074449Z" creationid="pingfangx" creationdate="20190828T074449Z">
        <seg>作者地址</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automated clients MAY provide a configuration setting that disables this check, but MUST provide a setting which enables it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111604Z" creationid="pingfangx" creationdate="20190901T111604Z">
        <seg>自动化客户端可以提供禁用此检查的配置设置，但必须提供启用它的设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automated clients MUST log the error to an appropriate audit log (if available) and SHOULD terminate the connection (with a bad certificate error).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111553Z" creationid="pingfangx" creationdate="20190901T111553Z">
        <seg>自动客户端必须将错误记录到适当的审核日志(如果可用)，并且应该终止连接(证书错误)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Background</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044531Z" creationid="pingfangx" creationdate="20190620T044531Z">
        <seg>背景</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backpressure Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072112Z" creationid="pingfangx" creationdate="20190620T072112Z">
        <seg>背压操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base URI Embedded in Content</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042908Z" creationid="pingfangx" creationdate="20190902T042908Z">
        <seg>内容中嵌入的基本 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base URI from the Encapsulating Entity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042911Z" creationid="pingfangx" creationdate="20190902T042911Z">
        <seg>封装实体的基本 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base URI from the Retrieval URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042917Z" creationid="pingfangx" creationdate="20190902T042917Z">
        <seg>检索 URI 中的基本 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic 3-Way Handshake for Connection Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T040732Z" creationid="pingfangx" creationdate="20190828T040732Z">
        <seg>连接同步的基本三次握手</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Block Size</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122027Z" creationid="pingfangx" creationdate="20190901T122027Z">
        <seg>基本块大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Rules</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072030Z" creationid="pingfangx" creationdate="20190828T072030Z">
        <seg>基本规则</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because HTTP uses connection closure to signal end of server data, client implementations MUST treat any premature closes as errors and the data received as potentially truncated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T092651Z" creationid="pingfangx" creationdate="20190901T092651Z">
        <seg>因为 HTTP 使用连接闭包来指示服务器数据的结束，所以客户端实现必须将任何过早关闭视为错误，并将接收到的数据视为可能被截断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Reactive-Streams base interface, `org.reactivestreams.Publisher` defines the `subscribe()` method as `void`, `Flowable.subscribe(Subscriber)` no longer returns any `Subscription` (or `Disposable`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072916Z" creationid="pingfangx" creationdate="20190618T072916Z">
        <seg>因为 Reactive-Streams 基接口，`org.reactivestreams.Publisher` 将 `subscribe()` 方法定义为 `void`，`Flowable.subscribe(Subscriber)` 不再返回任何 `Subscription`(或 `Disposable`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Reactive-Streams has a different architecture, it mandates changes to some well known RxJava types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051847Z" creationid="pingfangx" creationdate="20190618T051847Z">
        <seg>由于 Reactive-Streams 具有不同的体系结构，因此它要求对一些众所周知的 RxJava 类型进行更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because TLS does not provide document oriented protection, it is impossible to determine whether the server has miscomputed the Content-Length or an attacker has truncated the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093713Z" creationid="pingfangx" creationdate="20190901T093713Z">
        <seg>由于 TLS 不提供面向文档的保护，因此无法确定服务器是否错误计算了 Content-Length，或者攻击者是否截断了连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because TLS is oblivious to HTTP request/response boundaries, it is necessary to examine the HTTP data itself (specifically the Content-Length header) to determine whether the truncation occurred inside a message or between messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T092405Z" creationid="pingfangx" creationdate="20190901T092405Z">
        <seg>由于 TLS 无视 HTTP 请求/响应边界，因此有必要检查 HTTP 数据本身(特别是 Content-Length 首部)以确定截断是发生在消息内还是消息之间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is “cold” — that is, if it waits for a subscription before it begins to emit items).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083553Z" creationid="pingfangx" creationdate="20190620T083553Z">
        <seg>因为 Subject 订阅了 Observable，它会触发 Observable 开始发射项目(如果 Observable 是“冷” - 也就是说，如果它在开始发射项目之前等待订阅)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a URI is a sequence of characters, we must invert that relation in order to understand the URI syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065042Z" creationid="pingfangx" creationdate="20190902T065042Z">
        <seg>因为 URI 是一系列字符，所以我们必须反转该关系才能理解 URI 语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because both 1.x and 2.x is aimed at Java 6+, we can't use the Java 8 functional interfaces such as `java.util.function.Function`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064046Z" creationid="pingfangx" creationdate="20190618T064046Z">
        <seg>因为 1.x 和 2.x 都是针对 Java 6+，所以我们不能使用 Java 8 的函数接口，例如 `java.util.function.Function`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083529Z" creationid="pingfangx" creationdate="20190620T083529Z">
        <seg>因为它是一个观察者，它可以订阅一个或多个 Observable，并且因为它是一个 Observable，它可以通过重新发送来传递它所观察的项目，并且它也可以发射新项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the presence of older implementations, the protocol allows ambiguous situations in which a client may send "Expect: 100- continue" without receiving either a 417 (Expectation Failed) status or a 100 (Continue) status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024614Z" creationid="pingfangx" creationdate="20190830T024614Z">
        <seg>由于存在较旧的实现，该协议允许客户端可以发送“Expect: 100- continue”而不接收 417(期望失败)状态或 100(继续)状态的模糊情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because steps 2 and 3 can be combined in a single message this is called the three way (or three message) handshake.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024008Z" creationid="pingfangx" creationdate="20190828T024008Z">
        <seg>因为步骤 2 和 3 可以组合在单个消息中，所以这称为三向(或三个消息)握手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there could be at most 1 element emitted, the `Maybe` type has no notion of backpressure (because there is no buffer bloat possible as with unknown length `Flowable`s or `Observable`s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060825Z" creationid="pingfangx" creationdate="20190618T060825Z">
        <seg>因为最多可以发射 1 个元素，所以 `Maybe` 类型没有背压概念(因为没有缓冲膨胀可能，而未知长度的 `Flowable` 或 `Observable` 则有这种可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before 2.0.7, the operator `strict()` had to be applied in order to achieve the same level of compliance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073825Z" creationid="pingfangx" creationdate="20190618T073825Z">
        <seg>在 2.0.7 之前，必须应用运算符 `strict()` 才能达到相同的合规水平。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before making use of an "http" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T055323Z" creationid="pingfangx" creationdate="20190831T055259Z">
        <seg>在使用从不受信任的来源收到的“http”URI 引用之前，接收者应该解析 userinfo 并将其存在视为错误；它可能被用来掩盖权限，以防网络钓鱼攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111246Z" creationid="pingfangx" creationdate="20190827T111246Z">
        <seg>在我们详细讨论 TCP 的操作之前，我们需要介绍一些详细的术语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being unbounded means as long as the JVM doesn't run out of memory, it can handle almost any amount coming from a bursty source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092431Z" creationid="pingfangx" creationdate="20190621T092431Z">
        <seg>无限制意味着只要 JVM 没有内存耗尽，它几乎可以处理来自突发源的任何数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that some older, erroneous implementations may not handle such data correctly when it is used as the base URI for relative references (Section 5.1), apparently because they fail to distinguish query data from path data when looking for hierarchical separators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083240Z" creationid="pingfangx" creationdate="20190902T083240Z">
        <seg>请注意，当某些较旧的错误实现用作相对引用的基本 URI 时，可能无法正确处理此类数据(第 5.1 节)，这显然是因为它们在查找分层分隔符时无法区分查询数据和路径数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware that some older, erroneous implementations may not handle this data correctly when it is used as the base URI for relative references (Section 5.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083916Z" creationid="pingfangx" creationdate="20190902T083916Z">
        <seg>请注意，当某些较旧的错误实现用作相对引用的基 URI 时，它们可能无法正确处理此数据(第 5.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond the `PublishProcessor`above, there are other operators that don't support backpressure, mostly due to functional reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T073835Z" creationid="pingfangx" creationdate="20190621T073258Z">
        <seg>除了 `PublishProcessor` 之外，还有其他一些操作符不支持背压，主要是由于函数原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105518Z" creationid="pingfangx" creationdate="20190617T105518Z">
        <seg>可以在 [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava2) 上找到 Maven，Ivy，Gradle 和其他的二进制文件和依赖信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bogus Content-Length header fields are now required to be handled as errors by recipients.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091922Z" creationid="pingfangx" creationdate="20190830T091922Z">
        <seg>Bogus Content-Length 首部字段现在需要由接收者处理为错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both `Publisher` and `SingleSource` appear as functional interfaces (types with one abstract method) and may encourage users to try to provide a lambda expression:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102531Z" creationid="pingfangx" creationdate="20190617T102531Z">
        <seg>`Publisher` 和 `SingleSource` 都显示为函数接口(具有一个抽象方法的类型)，并且可能鼓励用户尝试提供 lambda 表达式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both types of message consist of a start-line, zero or more header fields (also known as "headers"), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header fields, and possibly a message-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T073356Z" creationid="pingfangx" creationdate="20190829T073356Z">
        <seg>两种类型的消息都包括一个起始行，零个或多个首部字段(也称为“headers”)，一个空行(即 CRLF 前面没有任何内容的行)，表示首部字段的结尾，可能还有一个消息正文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both users CLOSE simultaneously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063213Z" creationid="pingfangx" creationdate="20190828T063213Z">
        <seg>两个用户同时关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both will, upon receiving these ACKs, delete the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063927Z" creationid="pingfangx" creationdate="20190828T063927Z">
        <seg>收到这些 ACK 后，两者都将删除该连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Briefly the meanings of the states are:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112508Z" creationid="pingfangx" creationdate="20190827T112508Z">
        <seg>简而言之，各状态的意义是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Browser Fingerprinting</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120114Z" creationid="pingfangx" creationdate="20190831T120114Z">
        <seg>浏览器指纹识别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a0&gt;with nested composition they become unwieldy&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041126Z" creationid="pingfangx" creationdate="20190620T041126Z">
        <seg>但与 Futures 一样，虽然回调很容易使用单层的异步执行，但是 &lt;a0&gt;对于嵌套组合，它们难以处理&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by “observers.” Rather than &lt;e0&gt;calling&lt;/e0&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an “Observable,” and then &lt;e1&gt;subscribe&lt;/e1&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045501Z" creationid="pingfangx" creationdate="20190620T045501Z">
        <seg>但是在 ReactiveX 中，许多指令可以并行执行，并且它们的结果稍后由“观察者”以任意顺序捕获。你不用 &lt;e0&gt;调用&lt;/e0&gt; 方法，而是定义一种获取和转换数据的机制，以“Observable”的形式，然后为它 &lt;e1&gt;subscribe (订阅)&lt;/e1&gt; 一个观察者，一旦 Observable 发射的数据准备好，先前定义的机制就会发射数据，观察者表示的哨兵捕捉并作出响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators &lt;e0&gt;order matters&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072946Z" creationid="pingfangx" creationdate="20190620T072946Z">
        <seg>但是在 Builder 模式中，方法在链中出现的顺序通常并不重要，而 Observable 操作符是 &lt;e0&gt;顺序重要的&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, with an Observable the producer pushes values to the consumer whenever values are available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042145Z" creationid="pingfangx" creationdate="20190620T042145Z">
        <seg>相比之下，对于 Observable，只要值可用，生产者就会将值推送给消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, in this document, calls to &lt;c4&gt;onNext&lt;/c4&gt; are usually called “emissions” of items, whereas calls to &lt;c5&gt;onCompleted&lt;/c5&gt; or &lt;c6&gt;onError&lt;/c6&gt; are called “notifications.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060707Z" creationid="pingfangx" creationdate="20190620T060707Z">
        <seg>按照惯例，在本文档中，对 &lt;c4&gt;onNext&lt;/c4&gt; 的调用通常称为项目的“发射 (emissions)”，而对 &lt;c5&gt;onCompleted&lt;/c5&gt; 或 &lt;c6&gt;onError&lt;/c6&gt; 的调用称为“通知 (notifications)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, standardized methods are defined in all-uppercase US-ASCII letters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133705Z" creationid="pingfangx" creationdate="20190831T133705Z">
        <seg>按照惯例，标准化方法以全大写的 US-ASCII 字母定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, the products are listed in order of their significance for identifying the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T153051Z" creationid="pingfangx" creationdate="20190828T153051Z">
        <seg>按照惯例，产品按其对于识别应用程序的重要性的顺序列出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;c0&gt;Subscribe&lt;/c0&gt; method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090042Z" creationid="pingfangx" creationdate="20190620T085923Z">
        <seg>默认情况下，Observable 和应用于它的操作符链将完成其工作，并通知其观察者，在调用其 &lt;c0&gt;Subscribe&lt;/c0&gt; 方法的同一线程上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By having `Publisher` as input this way, you can compose with other Reactive-Streams compliant libraries without the need to wrap them or convert them into `Flowable` first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061637Z" creationid="pingfangx" creationdate="20190618T061637Z">
        <seg>通过以这种方式输入 `Publisher`，您可以使用其他符合 Reactive-Streams 标准的库进行组合，而无需先将它们包装或转换为 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By the terms of &lt;a0&gt;the Observable contract&lt;/a0&gt;, it may call &lt;c1&gt;onNext&lt;/c1&gt; zero or more times, and then may follow those calls with a call to either &lt;c2&gt;onCompleted&lt;/c2&gt; or &lt;c3&gt;onError&lt;/c3&gt; but not both, which will be its last call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060553Z" creationid="pingfangx" creationdate="20190620T060553Z">
        <seg>根据 &lt;a0&gt;Observable 协议&lt;/a0&gt; 的定义，它可以调用 &lt;c1&gt;onNext&lt;/c1&gt; 零次或多次，然后这些调用可能跟随 &lt;c2&gt;onCompleted&lt;/c2&gt; 或 &lt;c3&gt;onError&lt;/c3&gt; ，但不会同时，这将是它的最后一次调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By themselves they’d be nothing more than a slight extension of the standard observer pattern, better suited to handling a sequence of events rather than a single callback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071412Z" creationid="pingfangx" creationdate="20190620T070347Z">
        <seg>它们本身只不过是标准观察者模式的轻微扩展，使其更适合处理一系列事件而不是单个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAR           = &lt;any US-ASCII character (octets 0 - 127)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094557Z" creationid="pingfangx" creationdate="20190828T094557Z">
        <seg>CHAR           = &lt;任何 US-ASCII 字符(八位字节 0  -  127)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSE is an operation meaning "I have no more data to send."  The notion of closing a full-duplex connection is subject to ambiguous interpretation, of course, since it may not be obvious how to treat the receiving side of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062603Z" creationid="pingfangx" creationdate="20190828T062603Z">
        <seg>CLOSE 是一项操作，意思是“我没有更多数据要发送”。当然，关闭全双工连接的概念会受到模糊解释，因为如何处理连接的接收方可能并不明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSE-WAIT - represents waiting for a connection termination request from the local user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112754Z" creationid="pingfangx" creationdate="20190827T112754Z">
        <seg>CLOSE-WAIT - 表示等待本地用户的连接终止请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSED - represents no connection state at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112930Z" creationid="pingfangx" creationdate="20190827T112930Z">
        <seg>CLOSED - 表示根本没有连接状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112458Z" creationid="pingfangx" creationdate="20190827T112458Z">
        <seg>CLOSED 是虚构的，因为它表示没有 TCB 时的状态，因此没有连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112817Z" creationid="pingfangx" creationdate="20190827T112817Z">
        <seg>CLOSING - 表示等待来自远程 TCP 的连接终止请求确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONNECT is a new, special case in determining message body length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092017Z" creationid="pingfangx" creationdate="20190830T092017Z">
        <seg>CONNECT 是确定邮件正文长度的一个新的特殊情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONNECT is intended only for use in requests to a proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143018Z" creationid="pingfangx" creationdate="20190831T143018Z">
        <seg>CONNECT 仅用于对代理的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CR             = &lt;US-ASCII CR, carriage return (13)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095321Z" creationid="pingfangx" creationdate="20190828T095321Z">
        <seg>CR             = &lt;US-ASCII CR, 回车(13)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CTL            = &lt;any US-ASCII control character (octets 0 - 31) and DEL (127)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095255Z" creationid="pingfangx" creationdate="20190828T095255Z">
        <seg>CTL            = &lt;任何 US-ASCII 控制字符(八位字节 0-31)和 DEL(127)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cache Correctness</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073236Z" creationid="pingfangx" creationdate="20190828T073236Z">
        <seg>缓存正确性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cache Replacement</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074056Z" creationid="pingfangx" creationdate="20190828T074056Z">
        <seg>缓存替换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cache requirements for incomplete responses are defined in Section 3 of [RFC7234].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102727Z" creationid="pingfangx" creationdate="20190831T102727Z">
        <seg>不完整响应的缓存要求在 [RFC7234] 的第 3 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cache-control Mechanisms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073241Z" creationid="pingfangx" creationdate="20190828T073241Z">
        <seg>缓存控制机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cacheable Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115800Z" creationid="pingfangx" creationdate="20190831T115800Z">
        <seg>可缓存方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Caches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090638Z" creationid="pingfangx" creationdate="20190830T090638Z">
        <seg>缓存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Caching Negotiated Responses</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074029Z" creationid="pingfangx" creationdate="20190828T074029Z">
        <seg>缓存协商响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Caching in HTTP</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073233Z" creationid="pingfangx" creationdate="20190828T073233Z">
        <seg>在 HTTP 中缓存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call a method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053007Z" creationid="pingfangx" creationdate="20190620T053007Z">
        <seg>调用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callbacks Have Their Own Problems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040949Z" creationid="pingfangx" creationdate="20190620T040937Z">
        <seg>使用回调会有问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callbacks solve the problem of premature blocking on &lt;c0&gt;Future.get()&lt;/c0&gt; by not allowing anything to block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041019Z" creationid="pingfangx" creationdate="20190620T041019Z">
        <seg>回调通过不允许任何阻塞来解决 &lt;c0&gt;Future.get()&lt;/c0&gt; 上的过早阻塞问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canonicalization and Text Defaults</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072138Z" creationid="pingfangx" creationdate="20190828T072138Z">
        <seg>规范化和文本默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 1:  A single octet of option-kind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110829Z" creationid="pingfangx" creationdate="20190827T110829Z">
        <seg>情况 1：选项类型的单个八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 1:  Local user initiates the close</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063230Z" creationid="pingfangx" creationdate="20190828T063230Z">
        <seg>情况 1：本地用户启动关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 2:  An octet of option-kind, an octet of option-length, and the actual option-data octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110845Z" creationid="pingfangx" creationdate="20190827T110845Z">
        <seg>情况 2：选项类型的八位字节，选项长度的八位字节和实际的选项 - 数据八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 2:  TCP receives a FIN from the network</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063644Z" creationid="pingfangx" creationdate="20190828T063644Z">
        <seg>情况 2：TCP 从网络接收 FIN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case 3:  both users close simultaneously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063756Z" creationid="pingfangx" creationdate="20190828T063756Z">
        <seg>案例 3：两个用户同时关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain basic rules are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092703Z" creationid="pingfangx" creationdate="20190828T092703Z">
        <seg>某些基本规则是大写的，例如 SP，LWS，HT，CRLF，DIGIT，ALPHA 等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain buggy HTTP/1.0 client implementations generate extra CRLF's after a POST request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T073757Z" creationid="pingfangx" creationdate="20190829T073757Z">
        <seg>某些错误的 HTTP/1.0 客户端实现在 POST 请求后生成额外的 CRLF。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072235Z" creationid="pingfangx" creationdate="20190620T072235Z">
        <seg>链接操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes from HTTP/1.0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074639Z" creationid="pingfangx" creationdate="20190828T074639Z">
        <seg>来自 HTTP/1.0 的更改</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes from RFC 2068</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074650Z" creationid="pingfangx" creationdate="20190828T074650Z">
        <seg>从 RFC 2068 的变更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes from RFC 2616</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091416Z" creationid="pingfangx" creationdate="20190830T091416Z">
        <seg>RFC 2616 的变更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Character Sets</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072115Z" creationid="pingfangx" creationdate="20190828T072115Z">
        <seg>字符集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042748Z" creationid="pingfangx" creationdate="20190902T042748Z">
        <seg>字符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters other than those in the "reserved" and "unsafe" sets (see RFC 2396 [42]) are equivalent to their ""%" HEX HEX" encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113025Z" creationid="pingfangx" creationdate="20190828T113025Z">
        <seg>除“保留”和“不安全”集合之外的字符(参见 RFC 2396 [42])等同于它们的 ""%" HEX HEX" 编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters other than those in the "reserved" set are equivalent to their percent-encoded octets: the normal form is to not encode them (see Sections 2.1 and 2.2 of [RFC3986]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T061050Z" creationid="pingfangx" creationdate="20190831T061050Z">
        <seg>除“保留”集合中的字符以外的字符等同于它们的百分比编码八位字节：正常形式是不对它们进行编码(参见 [RFC3986] 的第 2.1 和 2.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters that are allowed in a URI but do not have a reserved purpose are called unreserved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071221Z" creationid="pingfangx" creationdate="20190902T071221Z">
        <seg>URI 中允许但没有保留目的的字符称为 unreserved。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking or Setting Unsubscribed Status</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092143Z" creationid="pingfangx" creationdate="20190620T092143Z">
        <seg>检查或设置取消订阅状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chunk Extensions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090828Z" creationid="pingfangx" creationdate="20190830T090828Z">
        <seg>块扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chunk length does not include the count of the octets in the chunk header and trailer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092040Z" creationid="pingfangx" creationdate="20190830T092040Z">
        <seg>块长度不包括块首部和尾部中八位字节的计数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chunked Trailer Part</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090847Z" creationid="pingfangx" creationdate="20190830T090847Z">
        <seg>块 Trailer 部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chunked Transfer Coding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072132Z" creationid="pingfangx" creationdate="20190828T072132Z">
        <seg>块传输编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090503Z" creationid="pingfangx" creationdate="20190901T090503Z">
        <seg>客户端行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client Behavior if Server Prematurely Closes Connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025931Z" creationid="pingfangx" creationdate="20190830T025931Z">
        <seg>服务器过早关闭连接时的客户端行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client Behavior if Server Prematurely Closes Connection ..50</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073047Z" creationid="pingfangx" creationdate="20190828T073047Z">
        <seg>服务器过早关闭连接时的客户端行为 ..50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client Identity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090607Z" creationid="pingfangx" creationdate="20190901T090607Z">
        <seg>客户标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client code treats all of its interactions with Observables as asynchronous, whether your underlying implementation is blocking or non-blocking and however you choose to implement it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040444Z" creationid="pingfangx" creationdate="20190620T040444Z">
        <seg>客户端代码将其与 Observable 的所有交互视为异步，无论您的底层实现是阻塞还是非阻塞，无论您选择什么实现它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client request:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100441Z" creationid="pingfangx" creationdate="20190830T100441Z">
        <seg>客户端请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client software SHOULD reopen the transport connection and retransmit the aborted sequence of requests without user interaction so long as the request sequence is idempotent (see section 9.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152305Z" creationid="pingfangx" creationdate="20190829T152305Z">
        <seg>客户端软件应该重新打开传输连接并重新传输请求的中止序列而无需用户交互，只要请求序列是幂等的(参见第 9.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client-controlled Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073250Z" creationid="pingfangx" creationdate="20190828T073250Z">
        <seg>客户控制的行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client/Server Messaging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090622Z" creationid="pingfangx" creationdate="20190830T090622Z">
        <seg>客户端/服务器消息传递</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients MUST also be prepared to resend their requests if the server closes the connection before sending all of the corresponding responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151451Z" creationid="pingfangx" creationdate="20190829T151451Z">
        <seg>如果服务器在发送所有相应的响应之前关闭连接，客户端也必须准备重新发送请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients MUST send a closure alert before closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T094353Z" creationid="pingfangx" creationdate="20190901T094353Z">
        <seg>客户端必须在关闭连接之前发送关闭警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151521Z" creationid="pingfangx" creationdate="20190829T151521Z">
        <seg>客户端不应该使用非幂等方法或非幂等方法序列来流水线请求(请参阅第 9.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients and servers SHOULD NOT assume that a persistent connection is maintained for HTTP versions less than 1.1 unless it is explicitly signaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150915Z" creationid="pingfangx" creationdate="20190829T150915Z">
        <seg>客户端和服务器不应该假设为小于 1.1 的 HTTP 版本维护持久连接，除非明确发出信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients and servers SHOULD both constantly watch for the other side of the transport close, and respond to it as appropriate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152200Z" creationid="pingfangx" creationdate="20190829T152200Z">
        <seg>客户和服务器应该经常关注运输关闭的另一侧，并在适当时对其进行响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients and servers are not required to use these formats for user presentation, request logging, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114408Z" creationid="pingfangx" creationdate="20190828T114408Z">
        <seg>客户端和服务器不需要使用这些格式进行用户演示，请求记录等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152601Z" creationid="pingfangx" creationdate="20190829T152601Z">
        <seg>使用持久连接的客户端应该限制它们维护到给定服务器的同时连接数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150140Z" creationid="pingfangx" creationdate="20190829T150140Z">
        <seg>使用未来版本的 HTTP 的客户端可能会乐观地尝试新功能，但如果与旧服务器通信，则在报告错误后重试旧语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients which are unprepared to receive any more data MAY choose not to wait for the server's closure alert and simply close the connection, thus generating an incomplete close on the server side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T095842Z" creationid="pingfangx" creationdate="20190901T095842Z">
        <seg>没有准备好接收任何数据的客户可以选择不等待服务器的关闭警报并简单地关闭连接，从而在服务器端生成不完整的关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients which assume persistent connections and pipeline immediately after connection establishment SHOULD be prepared to retry their connection if the first pipelined attempt fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151353Z" creationid="pingfangx" creationdate="20190829T151353Z">
        <seg>在连接建立后立即采用持久连接和流水线的客户端应准备好在第一次流水线尝试失败时重试其连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing a Connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061836Z" creationid="pingfangx" creationdate="20190828T061836Z">
        <seg>关闭连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Byte Ranges</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074021Z" creationid="pingfangx" creationdate="20190828T074021Z">
        <seg>组合字节范围</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074025Z" creationid="pingfangx" creationdate="20190828T074012Z">
        <seg>组合首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071920Z" creationid="pingfangx" creationdate="20190620T071920Z">
        <seg>结合 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments appear in parentheses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034558Z" creationid="pingfangx" creationdate="20190828T034558Z">
        <seg>注释显示在括号中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are only allowed in fields containing "comment" as part of their field value definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101556Z" creationid="pingfangx" creationdate="20190828T101556Z">
        <seg>注释仅允许在包含“注释”的字段中作为其字段值定义的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments can be included in some HTTP header fields by surrounding the comment text with parentheses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101547Z" creationid="pingfangx" creationdate="20190828T101547Z">
        <seg>通过用括号括起注释文本，可以在一些 HTTP 头字段中包含注释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common HTTP user agents include household appliances, stereos, scales, firmware update scripts, command-line programs, mobile apps, and communication devices in a multitude of shapes and sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100551Z" creationid="pingfangx" creationdate="20190830T100551Z">
        <seg>常见的 HTTP 用户代理包括多种形状和大小的家用电器，立体声，音阶，固件更新脚本，命令行程序，移动应用程序和通信设备。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common Method Properties</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115753Z" creationid="pingfangx" creationdate="20190831T115753Z">
        <seg>常用方法属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparison Ladder</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T043001Z" creationid="pingfangx" creationdate="20190902T043001Z">
        <seg>比较梯</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility with HTTP/1.0 Persistent Connections</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074643Z" creationid="pingfangx" creationdate="20190828T074643Z">
        <seg>与 HTTP/1.0 持久连接的兼容性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility with Previous Versions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074636Z" creationid="pingfangx" creationdate="20190828T074636Z">
        <seg>与先前版本的兼容性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compliance Requirements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122229Z" creationid="pingfangx" creationdate="20190901T122229Z">
        <seg>合规要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composition via Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070213Z" creationid="pingfangx" creationdate="20190620T070213Z">
        <seg>通过 Observable 操作符组合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composition via Single Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073849Z" creationid="pingfangx" creationdate="20190620T073849Z">
        <seg>Single 操作符组合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compute T = R * (2**N), where N is the number of previous retries of this request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030414Z" creationid="pingfangx" creationdate="20190830T030414Z">
        <seg>计算 T = R *(2 ** N)，其中 N 是此请求的先前重试次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computer languages are explicitly excluded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154534Z" creationid="pingfangx" creationdate="20190828T154534Z">
        <seg>明确排除计算机语言。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conceptually, HTTP/TLS is very simple.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091213Z" creationid="pingfangx" creationdate="20190901T091213Z">
        <seg>从概念上讲，HTTP/TLS 非常简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conceptually, it is a union of `Single` and `Completable` providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060448Z" creationid="pingfangx" creationdate="20190618T060448Z">
        <seg>从概念上讲，它是 `Single` 和 `Completable` 的结合，提供捕获发射模式的方法，这些模式可能存在 0 或 1 个项或由某些响应源发出的错误信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091019Z" creationid="pingfangx" creationdate="20190830T091019Z">
        <seg>并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional and Boolean Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072009Z" creationid="pingfangx" creationdate="20190620T072009Z">
        <seg>条件和布尔操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Confirmation by user-agent software with semantic understanding of the application MAY substitute for user confirmation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152523Z" creationid="pingfangx" creationdate="20190829T152523Z">
        <seg>具有对应用程序的语义理解的用户代理软件的确认可以替代用户确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conformance and Error Handling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090642Z" creationid="pingfangx" creationdate="20190830T090642Z">
        <seg>一致性和错误处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121801Z" creationid="pingfangx" creationdate="20190831T121801Z">
        <seg>有关错误处理的一致性标准和注意事项在 [RFC7230] 的第 2.5 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conformance criteria and considerations regarding error handling are defined in Section 2.5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094545Z" creationid="pingfangx" creationdate="20190830T094545Z">
        <seg>有关错误处理的一致性标准和注意事项在第 2.5 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conformance includes both the syntax and semantics of protocol elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102548Z" creationid="pingfangx" creationdate="20190830T102548Z">
        <seg>一致性包括协议元素的语法和语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connectable Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103640Z" creationid="pingfangx" creationdate="20190620T072045Z">
        <seg>Connectable Observable 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting Inbound</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090928Z" creationid="pingfangx" creationdate="20190830T090928Z">
        <seg>连接入站</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091003Z" creationid="pingfangx" creationdate="20190830T091003Z">
        <seg>连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Closure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090452Z" creationid="pingfangx" creationdate="20190901T090452Z">
        <seg>连接关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Establishment and Clearing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071237Z" creationid="pingfangx" creationdate="20190828T071237Z">
        <seg>连接建立和清除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Initiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090447Z" creationid="pingfangx" creationdate="20190901T090447Z">
        <seg>连接启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091001Z" creationid="pingfangx" creationdate="20190830T091001Z">
        <seg>连接管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection options are case-insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110352Z" creationid="pingfangx" creationdate="20190831T110352Z">
        <seg>连接选项不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connections</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072952Z" creationid="pingfangx" creationdate="20190828T072952Z">
        <seg>连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connections can be closed at any time, with or without intention.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111343Z" creationid="pingfangx" creationdate="20190831T111343Z">
        <seg>无论是否有意，都可以随时关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, common practice has been to run HTTP/TLS over a separate port in order to distinguish which protocol is being used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103251Z" creationid="pingfangx" creationdate="20190901T103251Z">
        <seg>因此，通常的做法是在单独的端口上运行 HTTP/TLS，以区分正在使用的协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, this specification does not use ABNF rules to define each "Field-Name: Field Value" pair, as was done in previous editions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083333Z" creationid="pingfangx" creationdate="20190831T083333Z">
        <seg>因此，此规范不使用 ABNF 规则来定义每个“Field-Name: Field Value”对，如在先前版本中所做的那样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, we must adopt rules for implicitly assigning sequence numbers to control.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T035208Z" creationid="pingfangx" creationdate="20190828T022556Z">
        <seg>因此，我们必须为控制位采用隐式分配序列号的规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132815Z" creationid="pingfangx" creationdate="20190831T132815Z">
        <seg>考虑到一个资源可以是任何东西，并且 HTTP 提供的统一接口类似于一个窗口，通过这个窗口，只有通过将消息传递给另一方的某个独立的参与者，才能观察和处理这样的东西，因此需要一个抽象来表示(代替)我们通讯中该事物的当前或期望状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructing Responses From Caches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073953Z" creationid="pingfangx" creationdate="20190828T073953Z">
        <seg>从缓存构造响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content Coding Registration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091114Z" creationid="pingfangx" creationdate="20190830T091114Z">
        <seg>内容编码注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content Coding Registry</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115952Z" creationid="pingfangx" creationdate="20190831T115952Z">
        <seg>内容编码注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content Codings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072121Z" creationid="pingfangx" creationdate="20190828T072121Z">
        <seg>内容编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150449Z" creationid="pingfangx" creationdate="20190828T073214Z">
        <seg>内容协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content coding values indicate an encoding transformation that has been or can be applied to an entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T135600Z" creationid="pingfangx" creationdate="20190828T135600Z">
        <seg>内容编码值指示已经或可以应用于实体的编码变换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content codings are primarily used to allow a document to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T135757Z" creationid="pingfangx" creationdate="20190828T135757Z">
        <seg>内容编码主要用于允许文档被压缩或以其他方式有用地转换而不会丢失其基础媒体类型的身份并且不会丢失信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content negotiation MAY be used to select the appropriate response format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042209Z" creationid="pingfangx" creationdate="20190830T042209Z">
        <seg>内容协商可用于选择适当的响应格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content-Disposition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074633Z" creationid="pingfangx" creationdate="20190828T074633Z">
        <seg>内容处置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content-Disposition Issues</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074412Z" creationid="pingfangx" creationdate="20190828T074412Z">
        <seg>内容处理问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content-Encoding may be used to indicate any additional content codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121315Z" creationid="pingfangx" creationdate="20190829T121315Z">
        <seg>内容编码可用于指示应用于数据的任何附加内容编码，通常用于数据压缩的目的，其是所请求资源的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content-Type specifies the media type of the underlying data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121254Z" creationid="pingfangx" creationdate="20190829T121254Z">
        <seg>Content-Type 指定基础数据的媒体类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115909Z" creationid="pingfangx" creationdate="20190831T115909Z">
        <seg>控制数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control information is not physically carried in the segment data space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022547Z" creationid="pingfangx" creationdate="20190828T022547Z">
        <seg>控制信息不是在报文段数据空间中物理携带的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions and Terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121633Z" creationid="pingfangx" creationdate="20190901T121633Z">
        <seg>惯例和术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversion of Date Formats</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074608Z" creationid="pingfangx" creationdate="20190828T074608Z">
        <seg>日期格式的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversion to Canonical Form</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074605Z" creationid="pingfangx" creationdate="20190828T074605Z">
        <seg>转换为规范形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072026Z" creationid="pingfangx" creationdate="20190620T072026Z">
        <seg>转换 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counts the number of elements in the sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061046Z" creationid="pingfangx" creationdate="20190619T061046Z">
        <seg>计算序列中的元素数量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071826Z" creationid="pingfangx" creationdate="20190620T071826Z">
        <seg>创建 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating backpressured data sources is the relatively easier task when dealing with backpressure in general because the library already offers static methods on `Flowable` that handle backpressure for the developer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015503Z" creationid="pingfangx" creationdate="20190624T015503Z">
        <seg>在处理背压时，创建背压数据源是相对容易的任务，因为库已经在 `Flowable` 上提供了静态方法，可以让开发人员处理背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cryptographic Computations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122218Z" creationid="pingfangx" creationdate="20190901T122218Z">
        <seg>密码计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cryptographic Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122125Z" creationid="pingfangx" creationdate="20190901T122125Z">
        <seg>加密协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current Segment Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111956Z" creationid="pingfangx" creationdate="20190827T111956Z">
        <seg>当前报文段变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current practice is to layer HTTP over SSL (the predecessor to TLS), distinguishing secured traffic from insecure traffic by the use of a different server port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T085643Z" creationid="pingfangx" creationdate="20190901T085643Z">
        <seg>当前的做法是通过 SSL(TLS 的前身)对 HTTP 进行分层，通过使用不同的服务器端口来区分安全流量和不安全流量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently defined options include (kind indicated in octal):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111000Z" creationid="pingfangx" creationdate="20190827T111000Z">
        <seg>目前定义的选项包括(以八进制表示的种类)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DIGIT          = &lt;any US-ASCII digit "0".."9"&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100638Z" creationid="pingfangx" creationdate="20190828T095241Z">
        <seg>DIGIT          = &lt;任何 US-ASCII 数字 "0".."9"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DIGIT (decimal digits), DQUOTE (double quote), HEXDIG (hexadecimal digits), LF (line feed), and SP (space).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064819Z" creationid="pingfangx" creationdate="20190902T064819Z">
        <seg>DIGIT(十进制数字)，DQUOTE(双引号)，HEXDIG(十六进制数字)，LF(换行)和 SP(空格)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DNS Spoofing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074404Z" creationid="pingfangx" creationdate="20190828T074404Z">
        <seg>DNS 欺骗</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Communication</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071239Z" creationid="pingfangx" creationdate="20190828T071239Z">
        <seg>数据通讯</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data in character sets other than "ISO-8859-1" or its subsets MUST be labeled with an appropriate charset value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151739Z" creationid="pingfangx" creationdate="20190828T151739Z">
        <seg>除“ISO-8859-1”或其子集之外的字符集中的数据必须用适当的字符集值标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflows can fail, at which point the error is emitted to the consumer(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103130Z" creationid="pingfangx" creationdate="20190617T103130Z">
        <seg>数据流可能会失败，此时错误会发送给消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Date/Time Formats</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072101Z" creationid="pingfangx" creationdate="20190828T072101Z">
        <seg>日期/时间格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decoding Chunked</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090840Z" creationid="pingfangx" creationdate="20190830T090840Z">
        <seg>解码块</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Base URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042920Z" creationid="pingfangx" creationdate="20190902T042920Z">
        <seg>默认基本 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Schedulers for RxGroovy Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091353Z" creationid="pingfangx" creationdate="20190620T091353Z">
        <seg>RxGroovy Observable 操作符的默认调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default values are 0 and infinity so that "#element" allows any number, including zero;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094125Z" creationid="pingfangx" creationdate="20190828T094125Z">
        <seg>默认值为 0 和无穷大，以便“#element”允许任何数字，包括零；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default values are 0 and infinity so that "*(element)" allows any number, including zero; "1*element" requires at least one; and "1*2element" allows one or two.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093457Z" creationid="pingfangx" creationdate="20190828T093457Z">
        <seg>默认值为 0 和无穷大，因此“*(element)”允许任何数字，包括零；“1*element”至少需要一个；并且“1*2element”允许一个或两个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define a method that does something useful with the return value from the asynchronous call; this method is part of the &lt;i0&gt;observer&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055742Z" creationid="pingfangx" creationdate="20190620T055742Z">
        <seg>定义一个方法，该方法对异步调用的返回值执行一些有用的操作；此方法是 &lt;i0&gt;observer&lt;/i0&gt; 的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define the asynchronous call itself as an &lt;i0&gt;Observable&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055748Z" creationid="pingfangx" creationdate="20190620T055748Z">
        <seg>将异步调用本身定义为 &lt;i0&gt;Observable&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a new connection option essentially reserves that potential field-name for carrying additional information related to the connection option, since it would be unwise for senders to use that field-name for anything else.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110834Z" creationid="pingfangx" creationdate="20190831T110834Z">
        <seg>定义新的连接选项实质上保留了潜在的字段名称，用于携带与连接选项相关的附加信息，因为发送者将该字段名称用于其他任何内容是不明智的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delayed and Periodic Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092325Z" creationid="pingfangx" creationdate="20190620T092325Z">
        <seg>延迟和周期调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delimiters are chosen from the set of US-ASCII visual characters not allowed in a token (DQUOTE and "(),/:;&lt;=&gt;?@[\]{}").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085713Z" creationid="pingfangx" creationdate="20190831T085713Z">
        <seg>分隔符是从标记中不允许的 US-ASCII 可视字符集中选择的(DQUOTE 和 "(),/:;&lt;=&gt;?@[\]{}")。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Denial of Service Attacks on Proxies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074432Z" creationid="pingfangx" creationdate="20190828T074432Z">
        <seg>对代理的拒绝服务攻击</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the operating system supporting A's TCP, it is likely that some error recovery mechanism exists.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055717Z" creationid="pingfangx" creationdate="20190828T055717Z">
        <seg>根据支持 A 的 TCP 的操作系统，可能存在一些错误恢复机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Design Considerations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042609Z" creationid="pingfangx" creationdate="20190902T042609Z">
        <seg>设计注意事项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disambiguating Expiration Values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073855Z" creationid="pingfangx" creationdate="20190828T073855Z">
        <seg>消除过期值的歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disambiguating Multiple Responses</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073903Z" creationid="pingfangx" creationdate="20190828T073903Z">
        <seg>消除多个响应的歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disclosure of Fragment after Redirects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120108Z" creationid="pingfangx" creationdate="20190831T120108Z">
        <seg>重定向后的片段披露</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disclosure of Personal Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120101Z" creationid="pingfangx" creationdate="20190831T120101Z">
        <seg>个人信息的披露</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disclosure of Product Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120113Z" creationid="pingfangx" creationdate="20190831T120113Z">
        <seg>产品信息披露</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disclosure of Sensitive Information in URIs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120105Z" creationid="pingfangx" creationdate="20190831T120105Z">
        <seg>在 URI 中披露敏感信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution of this memo is unlimited.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070919Z" creationid="pingfangx" creationdate="20190828T070919Z">
        <seg>本备忘录的分发是无限的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to interoperability problems with HTTP/1.0 proxies discovered since the publication of RFC 2068[33], caching proxies MUST, gateways MAY, and tunnels MUST NOT upgrade the request to the highest version they support.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104145Z" creationid="pingfangx" creationdate="20190828T104145Z">
        <seg>由于自 RFC 2068 [33] 发布以来发现的 HTTP/1.0 代理的互操作性问题，缓存代理必须，网关可以和隧道不得将请求升级到它们支持的最高版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the Reactive-Streams specification, `Publisher.subscribe` returns void and the pattern by itself no longer works in 2.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070624Z" creationid="pingfangx" creationdate="20190618T070624Z">
        <seg>由于 Reactive-Streams 规范，`Publisher.subscribe` 返回 void，该模式本身不再适用于 2.0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the name conflict, replacing the package from `rx` to `org.reactivestreams` is not enough.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065709Z" creationid="pingfangx" creationdate="20190618T065709Z">
        <seg>由于名称冲突，将包从 `rx` 替换为 `org.reactivestreams` 是不够的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to zero windows and zero length segments, we have four cases for the acceptability of an incoming segment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022410Z" creationid="pingfangx" creationdate="20190828T022410Z">
        <seg>由于零窗口和零长度报文段，我们有四种情况可以接受传入的报文段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>E.g., *.a.com matches foo.a.com but not bar.foo.a.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111318Z" creationid="pingfangx" creationdate="20190901T111318Z">
        <seg>例如，*.a.com 匹配 foo.a.com 但不匹配 bar.foo.a.com。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ESTABLISHED - represents an open connection, data received can be delivered to the user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112708Z" creationid="pingfangx" creationdate="20190827T112708Z">
        <seg>ESTABLISHED - 表示开放连接，接收的数据可以传递给用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each Hypertext Transfer Protocol (HTTP) message is either a request or a response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T120734Z" creationid="pingfangx" creationdate="20190831T120734Z">
        <seg>每个超文本传输​​协议(HTTP)消息都是请求或响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041927Z" creationid="pingfangx" creationdate="20190828T041927Z">
        <seg>每个 TCP 从 CLOSED 到 SYN-SENT 循环到 SYN-RECEIVED 到 ESTABLISHED。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each URI begins with a scheme name that refers to a specification for assigning identifiers within that scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071824Z" creationid="pingfangx" creationdate="20190902T071824Z">
        <seg>每个 URI 都以一个方案名称开头，该方案名称引用了在该方案中分配标识符的规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each URI begins with a scheme name, as defined in Section 3.1, that refers to a specification for assigning identifiers within that scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061706Z" creationid="pingfangx" creationdate="20190902T061706Z">
        <seg>每个 URI 都以方案名称开头，如 3.1 节中所定义，它指的是在该方案中分配标识符的规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each connection applies to only one transport link.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110927Z" creationid="pingfangx" creationdate="20190831T110927Z">
        <seg>每个连接仅适用于一个传输链路。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each header field consists of a case-insensitive field name followed by a colon (":"), optional leading whitespace, the field value, and optional trailing whitespace.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081658Z" creationid="pingfangx" creationdate="20190831T081658Z">
        <seg>每个首部字段由不区分大小写的字段名称后跟冒号(“:”)，可选的前导空格，字段值和可选的尾随空格组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each header field consists of a name followed by a colon (":") and the field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T080832Z" creationid="pingfangx" creationdate="20190829T080832Z">
        <seg>每个首部字段由一个名称后跟一个冒号(“:”)和字段值组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each language-specific implementation of ReactiveX has its own naming quirks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064528Z" creationid="pingfangx" creationdate="20190620T064528Z">
        <seg>ReactiveX 的每种语言特定实现都有自己的命名偏好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each language-specific implementation of ReactiveX implements a set of operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093532Z" creationid="pingfangx" creationdate="20190620T093532Z">
        <seg>ReactiveX 的每个特定于语言的实现都实现了一组操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each line is numbered for reference purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033933Z" creationid="pingfangx" creationdate="20190828T033933Z">
        <seg>每行都有编号以供参考。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of these representations is termed a `varriant'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081235Z" creationid="pingfangx" creationdate="20190828T081235Z">
        <seg>这些表示中的每一个都被称为“变体”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator in the chain modifies the Observable that results from the operation of the previous operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072434Z" creationid="pingfangx" creationdate="20190620T072434Z">
        <seg>链中的每个操作符都会修改由前一个操作符的运算产生的 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each persistent connection applies to only one transport link.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151847Z" creationid="pingfangx" creationdate="20190829T151847Z">
        <seg>每个持久连接仅适用于一个传输链路。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each piece is represented numerically in case-insensitive hexadecimal, using one to four hexadecimal digits (leading zeroes are permitted).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074725Z" creationid="pingfangx" creationdate="20190902T074725Z">
        <seg>每个部分用不区分大小写的十六进制数字表示，使用一到四个十六进制数字(允许前导零)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each protocol element in HTTP that allows a URI reference will indicate in its ABNF production whether the element allows any form of reference (URI-reference), only a URI in absolute form (absolute-URI), only the path and optional query components, or some combination of the above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T105215Z" creationid="pingfangx" creationdate="20190830T105215Z">
        <seg>HTTP 中允许 URI 引用的每个协议元素将在其 ABNF 生成中指示该元素是否允许任何形式的引用(URI 引用)，仅允许绝对形式的 URI(absolute-URI)，仅包含路径和可选查询组件，或上述的某种组合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reactive base class features operators that can perform such conversions, including the protocol conversions, to match some other type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T093029Z" creationid="pingfangx" creationdate="20190617T093029Z">
        <seg>每个反应基类都具有可以执行此类转换的运算符，包括协议转换，以匹配其他类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reactive base type `Flowable`, `Observable`, `Single`, `Maybe` and `Completable` feature a safe `create` operator that does the right thing regarding backpressure (for `Flowable`) and cancellation (all):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094823Z" creationid="pingfangx" creationdate="20190618T094823Z">
        <seg>每个响应基类 `Flowable`，`Observable`，`Single`，`Maybe` 和 `Completable` 都有一个安全的 `create` 操作符，可以对背压(对于 `Flowable`)和取消(对于所有)执行正确的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each representation should either define the fragment so that it corresponds to the same secondary resource, regardless of how it is represented, or should leave the fragment undefined (i.e., not found).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083744Z" creationid="pingfangx" creationdate="20190902T083744Z">
        <seg>每个表示应该定义片段，使其对应于相同的辅助资源，而不管它是如何表示的，或者应该使片段未定义(即，未找到)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each requested element triggers a state transition and computation of the returned value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020312Z" creationid="pingfangx" creationdate="20190624T020312Z">
        <seg>每个请求的元素触发状态转换并返回值的计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each resource is identified by a Uniform Resource Identifier (URI), as described in Section 2.7 of [RFC7230].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122750Z" creationid="pingfangx" creationdate="20190831T122750Z">
        <seg>每个资源由统一资源标识符(URI)标识，如 [RFC7230] 第 2.7 节中所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each side must also receive the other side's initial sequence number and send a confirming acknowledgment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023820Z" creationid="pingfangx" creationdate="20190828T023820Z">
        <seg>每一方还必须接收另一方的初始序列号并发送确认确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Effective Request URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090941Z" creationid="pingfangx" creationdate="20190830T090941Z">
        <seg>有效的请求 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements enclosed in parentheses are treated as a single element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093110Z" creationid="pingfangx" creationdate="20190828T093110Z">
        <seg>括在括号中的元素被视为单个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements of the Internetwork System</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071219Z" creationid="pingfangx" creationdate="20190828T071219Z">
        <seg>互联网络系统的要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements separated by a bar ("|") are alternatives, e.g., "yes | no" will accept yes or no.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093046Z" creationid="pingfangx" creationdate="20190828T093020Z">
        <seg>由条(“|”)分隔的元素是可选的，例如，“yes | no”将接受 yes 或 no。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ellipsis (...) indicates a segment which is still in the network (delayed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034527Z" creationid="pingfangx" creationdate="20190828T034527Z">
        <seg>省略号(...)表示仍在网络中的报文段(延迟)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the element at the given index or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061100Z" creationid="pingfangx" creationdate="20190619T061100Z">
        <seg>在给定索引处发出元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the element at the given index or the default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061250Z" creationid="pingfangx" creationdate="20190619T061126Z">
        <seg>发出给定索引的元素或默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the first element or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061200Z" creationid="pingfangx" creationdate="20190619T061200Z">
        <seg>发出第一​​个元素或如果源为空，则 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the indexth element or a `NoSuchElementException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T062204Z" creationid="pingfangx" creationdate="20190619T062204Z">
        <seg>发出索引指示的元素或 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the lastelement or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061325Z" creationid="pingfangx" creationdate="20190619T061325Z">
        <seg>发出最后一个元素，或如果源为空，则 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the one and only element, IndexOutOfBoundsException if the source is longer than 1 item or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061440Z" creationid="pingfangx" creationdate="20190619T061440Z">
        <seg>发出唯一元素，如果源长度超过 1 个项，则发出 IndexOutOfBoundsException，如果源为空，则发出 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the only element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061356Z" creationid="pingfangx" creationdate="20190619T061356Z">
        <seg>发出唯一的元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the only element or the default item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061353Z" creationid="pingfangx" creationdate="20190619T061353Z">
        <seg>发出唯一元素或默认项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the reduced value (or the initial value)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061343Z" creationid="pingfangx" creationdate="20190619T061343Z">
        <seg>发出减少的值(或初始值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the reduced value or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061334Z" creationid="pingfangx" creationdate="20190619T061334Z">
        <seg>发出减少的价值或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very first element or `NoSuchElementException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061133Z" creationid="pingfangx" creationdate="20190619T061133Z">
        <seg>发出第一个元素或 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very first element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061140Z" creationid="pingfangx" creationdate="20190619T061140Z">
        <seg>发出第一个元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very last element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061301Z" creationid="pingfangx" creationdate="20190619T061301Z">
        <seg>发出最后一个元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very last element or the default item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061221Z" creationid="pingfangx" creationdate="20190619T061221Z">
        <seg>发出最后一个元素或默认项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if all elements match the predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061036Z" creationid="pingfangx" creationdate="20190619T061036Z">
        <seg>如果所有元素都与谓词匹配，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if any elements match the predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061041Z" creationid="pingfangx" creationdate="20190619T061041Z">
        <seg>如果任何元素与谓词匹配，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061212Z" creationid="pingfangx" creationdate="20190619T061212Z">
        <seg>如果源为空，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty list elements in list productions (e.g., a list header field containing ", ,") have been deprecated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092332Z" creationid="pingfangx" creationdate="20190830T092332Z">
        <seg>列表生成中的空列表元素(例如，包含“,,”的列表首部字段)已被弃用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encoding Sensitive Information in URI's</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074327Z" creationid="pingfangx" creationdate="20190828T074327Z">
        <seg>在 URI 中编码敏感信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encoding for Compression or Integrity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115703Z" creationid="pingfangx" creationdate="20190831T115703Z">
        <seg>压缩或完整性编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end and Hop-by-hop Headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074005Z" creationid="pingfangx" creationdate="20190828T074005Z">
        <seg>端到端和逐跳首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Endpoint Identification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090539Z" creationid="pingfangx" creationdate="20190901T090539Z">
        <seg>端点识别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enhancements and bugfixes will be synchronized between the two in a timely manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104702Z" creationid="pingfangx" creationdate="20190617T104702Z">
        <seg>增强功能和错误修正将在两者之间及时同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072928Z" creationid="pingfangx" creationdate="20190828T072928Z">
        <seg>实体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity Body</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072942Z" creationid="pingfangx" creationdate="20190828T072942Z">
        <seg>实体主体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity Header Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072935Z" creationid="pingfangx" creationdate="20190828T072935Z">
        <seg>实体首部字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity Length</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072950Z" creationid="pingfangx" creationdate="20190828T072950Z">
        <seg>实体长度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity Tag Cache Validators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073917Z" creationid="pingfangx" creationdate="20190828T073917Z">
        <seg>实体标记缓存验证器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity Tags</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072210Z" creationid="pingfangx" creationdate="20190828T072210Z">
        <seg>实体标签</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity tags are used for comparing two or more entities from the same requested resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155543Z" creationid="pingfangx" creationdate="20190828T155543Z">
        <seg>实体标签用于比较来自相同请求资源的两个或更多个实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entity-header fields define metainformation about the entity-body or, if no body is present, about the resource identified by the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T120430Z" creationid="pingfangx" creationdate="20190829T120430Z">
        <seg>实体首部字段定义关于实体主体的元信息，或者，如果不存在主体，则定义关于由请求标识的资源的元信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042957Z" creationid="pingfangx" creationdate="20190902T042957Z">
        <seg>等价</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error Handling Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071925Z" creationid="pingfangx" creationdate="20190620T071925Z">
        <seg>错误处理操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Errors or Incomplete Response Cache Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074041Z" creationid="pingfangx" creationdate="20190828T074041Z">
        <seg>错误或不完整的响应缓存行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing Authority</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091153Z" creationid="pingfangx" creationdate="20190830T091153Z">
        <seg>建立认证</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing Observers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T050058Z" creationid="pingfangx" creationdate="20190620T050058Z">
        <seg>创建观察者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing a Base URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042903Z" creationid="pingfangx" creationdate="20190902T042903Z">
        <seg>建立基本 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing a connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030228Z" creationid="pingfangx" creationdate="20190828T030228Z">
        <seg>建立连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091008Z" creationid="pingfangx" creationdate="20190830T091008Z">
        <seg>建立</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025621Z" creationid="pingfangx" creationdate="20190828T025621Z">
        <seg>即使能够记住一天中的时间并且用它来选择初始序列号值的主机也不能免于这个问题(即，即使使用时间来为每个新的连接化身选择初始序列号)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if a resource is cacheable, there may be additional constraints on whether a cache can use the cached copy for a particular request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081825Z" creationid="pingfangx" creationdate="20190828T081825Z">
        <seg>即使资源是可缓存的，也可能存在关于缓存是否可以将缓存副本用于特定请求的附加约束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though certain operators have no problems from type erasure, their signature may turn up being ambiguous, especially if one uses Java 8 and lambdas.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102233Z" creationid="pingfangx" creationdate="20190617T102233Z">
        <seg>即使某些操作符没有类型擦除的问题，它们的签名也可能变得有歧义，特别是如果使用 Java 8 和 lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even when a response is cacheable, there might be additional constraints placed by the client or by the origin server on when that cached response can be used for a particular request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102321Z" creationid="pingfangx" creationdate="20190830T102321Z">
        <seg>即使响应是可缓存的，客户端或源服务器也可能会对缓存响应何时用于特定请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135457Z" creationid="pingfangx" creationdate="20190831T135457Z">
        <seg>即使 URI 映射机制绑定到文件系统，源服务器也可能配置为以请求作为输入执行文件，并将输出作为表示发送，而不是直接传输文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071305Z" creationid="pingfangx" creationdate="20190828T071305Z">
        <seg>事件处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly when "close" connection options have to be sent has been clarified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092144Z" creationid="pingfangx" creationdate="20190830T092144Z">
        <seg>明确了“close”连接选项的发送时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 1: the following message received over an insecure TCP connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131915Z" creationid="pingfangx" creationdate="20190831T131915Z">
        <seg>示例 1：通过不安全的 TCP 连接收到以下消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 2: the following message received over a TLS-secured TCP connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131930Z" creationid="pingfangx" creationdate="20190831T131930Z">
        <seg>示例 2：通过 TLS 安全的 TCP 连接接收的以下消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042214Z" creationid="pingfangx" creationdate="20190620T042214Z">
        <seg>示例代码显示了如何将类似的高阶函数应用于 Iterable 和 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example for Gradle:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105522Z" creationid="pingfangx" creationdate="20190617T105522Z">
        <seg>Gradle 示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example tags include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155206Z" creationid="pingfangx" creationdate="20190828T155206Z">
        <seg>示例标签包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042556Z" creationid="pingfangx" creationdate="20190902T042556Z">
        <seg>示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except where either transparent or non-transparent behavior is explicitly stated, the HTTP proxy requirements apply to both types of proxies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081552Z" creationid="pingfangx" creationdate="20190828T081552Z">
        <seg>除非明确声明透明或非透明行为，否则 HTTP 代理要求适用于两种类型的代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except where noted otherwise, linear white space (LWS) can be included between any two adjacent words (token or quoted-string), and between adjacent words and separators, without changing the interpretation of a field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094331Z" creationid="pingfangx" creationdate="20190828T094331Z">
        <seg>除非另有说明，否则线性空白(LWS)可以包含在任何两个相邻单词(标记或引用字符串)之间，以及相邻单词和分隔符之间，而不会改变字段的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions to the Rules and Warnings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073247Z" creationid="pingfangx" creationdate="20190828T073247Z">
        <seg>规则和警告的例外情况</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Existing fields are defined in each part of this specification and in many other specifications outside this document set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081958Z" creationid="pingfangx" creationdate="20190831T081958Z">
        <seg>现有字段在本规范的每个部分以及本文档集之外的许多其他规范中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expiration Calculations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073851Z" creationid="pingfangx" creationdate="20190828T073851Z">
        <seg>过期计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expiration Model</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073256Z" creationid="pingfangx" creationdate="20190828T073256Z">
        <seg>过期模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit User Agent Warnings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073244Z" creationid="pingfangx" creationdate="20190828T073244Z">
        <seg>显式用户代理警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressing backpressure in end-consumers is rarely necessary (because they are synchronous in respect to their immediate upstream and backpressure naturally happens due to call-stack blocking), but it may be easier to understand the workings of it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083119Z" creationid="pingfangx" creationdate="20190621T083119Z">
        <seg>在最终消费者中很少需要表达背压(因为它们与上游是同步的，背压自然是由于调用堆栈阻塞而发生)，但是可能更容易理解它的工作原理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112735Z" creationid="pingfangx" creationdate="20190827T112735Z">
        <seg>FIN-WAIT-1 - 表示等待来自远程 TCP 的连接终止请求，或者对先前发送的连接终止请求的确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112741Z" creationid="pingfangx" creationdate="20190827T112741Z">
        <seg>FIN-WAIT-2 - 表示等待来自远程 TCP 的连接终止请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIN:  No more data from sender</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105435Z" creationid="pingfangx" creationdate="20190827T105435Z">
        <seg>FIN：没有来自发送者的更多数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FUNCTIONAL SPECIFICATION</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T100456Z" creationid="pingfangx" creationdate="20190827T100456Z">
        <seg>功能说明书</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134349Z" creationid="pingfangx" creationdate="20190831T134349Z">
        <seg>如果为了链接维护，预取，构建搜索索引等，自动化进程对每个 URI 引用执行 GET 时，如果不这样做将导致不幸的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failures and Timeouts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091022Z" creationid="pingfangx" creationdate="20190830T091022Z">
        <seg>失败和超时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Familiar examples include an electronic document, an image, a service (e.g., "today's weather report for Los Angeles"), and a collection of other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040140Z" creationid="pingfangx" creationdate="20190902T040140Z">
        <seg>熟悉的示例包括电子文档，图像，服务(例如，“今天洛杉矶的天气报告”)以及其他资源的集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Familiar examples include an electronic document, an image, a source of information with a consistent purpose (e.g., "today's weather report for Los Angeles"), a service (e.g., an HTTP-to-SMS gateway), and a collection of other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060544Z" creationid="pingfangx" creationdate="20190902T060544Z">
        <seg>熟悉的示例包括电子文档，图像，具有一致目的的信息源(例如，“今天洛杉矶的天气报告”)，服务(例如，HTTP 到 SMS 网关)以及其他的资源集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Extensibility</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090725Z" creationid="pingfangx" creationdate="20190830T090725Z">
        <seg>字段可扩展性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Limits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090739Z" creationid="pingfangx" creationdate="20190830T090739Z">
        <seg>字段限制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Order</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090728Z" creationid="pingfangx" creationdate="20190830T090728Z">
        <seg>字段顺序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Parsing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082917Z" creationid="pingfangx" creationdate="20190830T090734Z">
        <seg>字段解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Value Components</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090742Z" creationid="pingfangx" creationdate="20190830T090742Z">
        <seg>字段值组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field names are case-insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T080836Z" creationid="pingfangx" creationdate="20190829T080836Z">
        <seg>字段名称不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filtering Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071907Z" creationid="pingfangx" creationdate="20190620T071907Z">
        <seg>过滤 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the server fully closes the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112935Z" creationid="pingfangx" creationdate="20190831T112935Z">
        <seg>最后，服务器完全关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094212Z" creationid="pingfangx" creationdate="20190620T094212Z">
        <seg>最后，有一个按字母顺序排列的操作符列表，表示在大多数 ReactiveX 的特定于语言的实现中可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, the server performs a half-close by closing only the write side of the read/write connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112909Z" creationid="pingfangx" creationdate="20190831T112909Z">
        <seg>首先，服务器通过仅关闭读/写连接的写侧来执行半关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flows in RxJava are sequential in nature split into processing stages that may run **concurrently** with each other:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075403Z" creationid="pingfangx" creationdate="20190617T075403Z">
        <seg>RxJava 中的流本质上是顺序的，分为处理阶段，这些阶段可以彼此 **并发** 运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following the style of extending the Reactive-Streams `Publisher&lt;T&gt;` in `Flowable`, the other base reactive classes now extend similar base interfaces (in package `io.reactivex`):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061442Z" creationid="pingfangx" creationdate="20190618T061442Z">
        <seg>遵循在 `Flowable` 中扩展 Reactive-Streams `Publisher&lt;T&gt;` 的方式，其他基本响应类现在继承了类似的基接口(在包 `io.reactivex` 中)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a connection to be established or initialized, the two TCPs must synchronize on each other's initial sequence numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023509Z" creationid="pingfangx" creationdate="20190828T023509Z">
        <seg>对于要建立或初始化的连接，两个 TCP 必须在彼此的初始序列号上同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a user agent, the effective request URI is the target URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130617Z" creationid="pingfangx" creationdate="20190831T130617Z">
        <seg>对于用户代理，有效请求 URI 是目标 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For bugs, questions and discussions please use the [Github Issues](https://github.com/ReactiveX/RxJava/issues).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105641Z" creationid="pingfangx" creationdate="20190617T105641Z">
        <seg>有关错误，问题和讨论，请使用 [Github Issues](https://github.com/ReactiveX/RxJava/issues)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For cases where an origin server wishes the client to be able to cache the result of a POST in a way that can be reused by a later GET, the origin server MAY send a 200 (OK) response containing the result and a Content-Location header field that has the same value as the POST's effective request URI (Section 3.1.4.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142031Z" creationid="pingfangx" creationdate="20190831T142031Z">
        <seg>对于原始服务器希望客户端能够以稍后 GET 可以重用的方式缓存 POST 结果的情况，源服务器可以发送包含结果和Content-Location 首部字段的 200(OK)响应。其首部字段值与 POST 的有效请求 URI 相同(第 3.1.4.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090122Z" creationid="pingfangx" creationdate="20190829T090122Z">
        <seg>为了与 HTTP/1.0 应用程序兼容，包含消息体的 HTTP/1.1 请求必须包含有效的 Content-Length 首部字段，除非已知服务器符合 HTTP/1.1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compatibility with previous implementations of HTTP, applications SHOULD consider "x-gzip" and "x-compress" to be equivalent to "gzip" and "compress" respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141200Z" creationid="pingfangx" creationdate="20190828T141200Z">
        <seg>为了与以前的 HTTP 实现兼容，应用程序应该认为“x-gzip”和“x-compress”分别等同于“gzip”和“compress”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For consistency, URI producers and normalizers should use uppercase hexadecimal digits for all percent-encodings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065907Z" creationid="pingfangx" creationdate="20190902T065907Z">
        <seg>为保持一致性，URI 生成器和规范化器应对所有百分比编码使用大写十六进制数字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For consistency, percent-encoded octets in the ranges of ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E) should not be created by URI producers and, when found in a URI, should be decoded to their corresponding unreserved characters by URI normalizers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071529Z" creationid="pingfangx" creationdate="20190902T071520Z">
        <seg>为保持一致，ALPHA（%41-%5A 和 %61-%7A），DIGIT（%30-%39），连字符（%2D），句点（%2E），下划线（%5F）或波浪号（%7E）范围内的百分比编码八位字节不应该由 URI 生成器创建，并且当在 URI 中找到时，应该通过 URI 规范化器将其解码为其对应的未保留字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For convenience (and avoiding warnings about generic array creation) there are 2 to 10 argument overloads to `just` that internally delegate to `from`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020236Z" creationid="pingfangx" creationdate="20190624T020236Z">
        <seg>为了方便(并避免关于泛型数组创建的警告)，内部委托给 `from` 的 `just` 有 2 到 10 个参数重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For definitive information on URL syntax and semantics, see "Uniform Resource Identifiers (URI): Generic Syntax and Semantics," RFC 2396 [42] (which replaces RFCs 1738 [4] and RFC 1808 [11]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T110237Z" creationid="pingfangx" creationdate="20190828T110237Z">
        <seg>有关 URL 语法和语义的确切信息，请参阅“统一资源标识符(URI)：通用语法和语义”，RFC 2396 [42](它取代了 RFC 1738 [4] 和 RFC 1808 [11])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each connection there is a send sequence number and a receive sequence number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023425Z" creationid="pingfangx" creationdate="20190828T023425Z">
        <seg>对于每个连接，存在发送序列号和接收序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example there is the &lt;c0&gt;on&lt;i1&gt;Event&lt;/i1&gt;&lt;/c0&gt; naming pattern (e.g. &lt;c2&gt;onNext&lt;/c2&gt;, &lt;c3&gt;onCompleted&lt;/c3&gt;, &lt;c4&gt;onError&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064718Z" creationid="pingfangx" creationdate="20190620T064718Z">
        <seg>例如，有 &lt;c0&gt;on&lt;i1&gt;Event&lt;/i1&gt;&lt;/c0&gt; 命名模式上(例如 &lt;c2&gt;onNext&lt;/c2&gt;，&lt;c3&gt;onCompleted&lt;/c3&gt;，&lt;c4&gt;onError&lt;/c4&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091546Z" creationid="pingfangx" creationdate="20190831T091546Z">
        <seg>例如，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, "%20" is the percent-encoding for the binary octet "00100000" (ABNF: %x20), which in US-ASCII corresponds to the space character (SP).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065517Z" creationid="pingfangx" creationdate="20190902T065517Z">
        <seg>例如，“%20”是二进制八位字节“00100000”(ABNF：%x20)的百分比编码，其在 US-ASCII 中对应于空格字符(SP)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, "http://localhost/" has the same interpretation for every user of that reference, even though the network interface corresponding to "localhost" may be different for each end-user: interpretation is independent of access.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061354Z" creationid="pingfangx" creationdate="20190902T061354Z">
        <seg>例如，“http://localhost/”对于该引用的每个用户具有相同的解释，即使对应于“localhost”的网络接口对于每个最终用户可能是不同的：解释与访问无关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, B may be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090259Z" creationid="pingfangx" creationdate="20190828T090259Z">
        <seg>例如，B 可能正在接收来自除 A 之外的许多客户端的请求，和/或在处理 A 的请求的同时将请求转发到除 C 之外的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, B might be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101143Z" creationid="pingfangx" creationdate="20190830T101143Z">
        <seg>例如，B 可能正在接收来自除 A 之外的许多客户端的请求，和/或在处理 A 的请求的同时将请求转发到除 C 之外的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [RFC7234]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110712Z" creationid="pingfangx" creationdate="20190831T110712Z">
        <seg>例如，Cache-Control 永远不适合作为连接选项([RFC7234] 的第 5.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, POST is used for the following functions (among others):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141417Z" creationid="pingfangx" creationdate="20190831T141417Z">
        <seg>例如，POST 用于以下功能(以及其他功能)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a CONNECT to a request-target of "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143330Z" creationid="pingfangx" creationdate="20190831T143330Z">
        <seg>例如，对“example.com:25”的请求目标的 CONNECT 将建议代理连接到 SMTP 流量的保留端口；如果允许，可能会欺骗代理转发垃圾邮件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T094820Z">
        <seg>例如，Content-Length 首部字段通常在 POST 请求中发送，即使该值为 0(表示空的有效载荷主体)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a GET request to the origin server for &lt;http://www.example.org/pub/WWW/&gt; would begin with:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125624Z" creationid="pingfangx" creationdate="20190831T125624Z">
        <seg>例如，对 &lt;http://www.example.org/pub/WWW/&gt; 的源服务器的 GET 请求将以以下开头：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103041Z" creationid="pingfangx" creationdate="20190830T103041Z">
        <seg>例如，Web 浏览器可能希望透明地从 Location 首部字段不根据 ABNF 解析的响应中恢复，而系统控制客户端可能认为任何形式的错误恢复都是危险的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a client can send conditional request header fields (Section 5.2) to make the requested action conditional on the current state of the target resource ([RFC7232]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133345Z" creationid="pingfangx" creationdate="20190831T133345Z">
        <seg>例如，客户端可以发送条件请求首部字段(第 5.2 节)，以使请求的操作以目标资源的当前状态为条件([RFC7232])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a client might have started to send a new request at the same time that the server has decided to close the "idle" connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152231Z" creationid="pingfangx" creationdate="20190829T152231Z">
        <seg>例如，在服务器决定关闭“空闲”连接的同时，客户机可能已经开始发送新的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a client wishing to retrieve a representation of the resource identified as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124142Z" creationid="pingfangx" creationdate="20190831T124142Z">
        <seg>例如，如果一个客户端希望获取的资源的表示，资源标识为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a client wishing to retrieve the resource above directly from the origin server would create a TCP connection to port 80 of the host "www.w3.org" and send the lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101102Z" creationid="pingfangx" creationdate="20190829T101102Z">
        <seg>例如，希望直接从源服务器检索上述资源的客户端将创建到主机“www.w3.org”的端口 80 的 TCP 连接并发送以下行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a representation in the payload of a PUT request (Section 4.3.4) represents the desired state of the target resource if the request is successfully applied, whereas a representation in the payload of a POST request (Section 4.3.3) represents information to be processed by the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190902T025433Z">
        <seg>例如，PUT 请求的有效载荷中的表示(第 4.3.4 节)表示成功应用请求时目标资源的期望状态，而 POST 请求的有效载荷中的表示(第 4.3.3 节)表示目标资源要处理的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111455Z" creationid="pingfangx" creationdate="20190831T111455Z">
        <seg>例如，知道(通过设计或配置)对给定资源的 POST 请求是安全的用户代理可以自动重复该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an "interception proxy" [RFC3040] (also commonly known as a "transparent proxy" [RFC1919] or "captive portal") differs from an HTTP proxy because it is not selected by the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101812Z" creationid="pingfangx" creationdate="20190830T101812Z">
        <seg>例如，“拦截代理”[RFC3040](通常也称为“透明代理”[RFC1919] 或“强制门户”)与 HTTP 代理不同，因为它不是由客户端选择的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an article might have a URI for identifying "the current version" which is separate from the URI identifying each particular version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T071521Z" creationid="pingfangx" creationdate="20190830T071521Z">
        <seg>例如，文章可能具有用于标识“当前版本”的 URI，该 URI 与标识每个特定版本的 URI 分开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an intermediary forwarding a message might parse a header-field into generic field-name and field-value components, but then forward the header field without further parsing inside the field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102725Z" creationid="pingfangx" creationdate="20190830T102725Z">
        <seg>例如，转发消息的中间人可能会将首部字段解析为通用字段名和字段值组件，但随后转发首部字段而不进一步解析字段值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102959Z" creationid="pingfangx" creationdate="20190830T102959Z">
        <seg>例如，如果对 User-Agent 首部字段的检查指示已知在接收到某些内容编码时失败的特定实现版本，则源服务器可以忽略所接收的 Accept-Encoding 首部字段的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an origin server that publishes very long URI references to its own resources needs to be able to parse and process those same references when received as a request target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102857Z" creationid="pingfangx" creationdate="20190830T102857Z">
        <seg>例如，发布对其自己的资源的非常长的 URI 引用的源服务器需要能够在作为请求目标接收时解析和处理这些相同的引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, defining a base URI for later use by relative references calls for an absolute-URI syntax rule that does not allow a fragment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085340Z" creationid="pingfangx" creationdate="20190902T085340Z">
        <seg>例如，定义基 URI 以供以后使用相对引用调用绝对 URI 语法规则，该规则不允许片段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a service that returns a `Flowable`, we'd like to call another service with values emitted by the first service:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083518Z" creationid="pingfangx" creationdate="20190617T083518Z">
        <seg>例如，给定一个返回 `Flowable` 的服务，我们想要使用第一个服务发出的值调用另一个服务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134451Z" creationid="pingfangx" creationdate="20190831T134451Z">
        <seg>例如，如果客户端发送 PUT 请求并且在收到任何响应之前关闭了底层连接，则客户端可以建立新连接并重试幂等请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110110Z" creationid="pingfangx" creationdate="20190829T110110Z">
        <seg>例如，如果客户端收到无法识别的状态代码 431，则可以安全地假设其请求有问题并将响应视为已收到 400 状态代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if an unrecognized status code of 471 is received by a client, the client can assume that there was something wrong with its request and treat the response as if it had received a 400 (Bad Request) status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144422Z" creationid="pingfangx" creationdate="20190831T144422Z">
        <seg>例如，如果客户端收到无法识别的状态代码 471，则客户端可以认为其请求有问题，并将响应视为已收到 400(错误请求)状态代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if one needs a signaller-like source, a shared enum can be defined and its solo instance `onNext`'d:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052921Z" creationid="pingfangx" creationdate="20190618T052921Z">
        <seg>例如，如果需要类似信号器的源，则可以定义共享枚举并将其独立实例 `onNext`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if one wants to perform some periodic background task but each iteration may last longer than the period, it is safe to drop the excess interval notification as there will be more later on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014924Z" creationid="pingfangx" creationdate="20190624T014924Z">
        <seg>例如，如果想要执行一些定期后台任务但每次迭代可能持续的时间超过后台任务周期，则可以安全地删除多余的间隔通知，因为稍后会有更多：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the TCP were to start all connections with sequence number 0, then upon crashing and restarting, a TCP might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025536Z" creationid="pingfangx" creationdate="20190828T025536Z">
        <seg>例如，如果 TCP 要启动序列号为 0 的所有连接，则在崩溃并重新启动时，TCP 可能会重新形成先前的连接(可能在半开连接解析之后)并发射序列号相同或重叠的数据包数据包仍在网络中，这些数据包是在同一连接的早期版本中发射的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the URI was obtained by clicking on an HTML page which was itself obtained without using HTTP/TLS, a man in the middle could have replaced the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T112850Z" creationid="pingfangx" creationdate="20190901T112850Z">
        <seg>例如，如果通过单击不使用 HTTP/TLS 获得的 HTML 页面获得 URI，则中间的人可以替换 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113418Z" creationid="pingfangx" creationdate="20190831T113418Z">
        <seg>例如，如果在 GET 请求中收到 Upgrade 首部字段并且服务器决定切换协议，它首先在 HTTP/1.1 中用 101(交换协议)消息进行响应，然后立即使用新协议等效的响应进行响应到目标资源的 GET。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the user clicks a lot on the screen, we'd still want to react to its latest input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015255Z" creationid="pingfangx" creationdate="20190624T015255Z">
        <seg>例如，如果用户在屏幕上点击了很多地方，我们仍然希望对其最新的输入做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the inventory example above, `getDemandAsync` could return a `Single&lt;DemandRecord&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092742Z" creationid="pingfangx" creationdate="20190617T092742Z">
        <seg>例如，在上面的清单示例中，`getDemandAsync` 可以返回 `Single &lt;DemandRecord&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134305Z" creationid="pingfangx" creationdate="20190831T134245Z">
        <seg>例如，基于 Web 的内容编辑软件通常在查询参数中使用动作，例如“page?do=delete”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it would be foolish for a user agent to send stored user credentials [RFC7235] or cookies [RFC6265] in a TRACE request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144034Z" creationid="pingfangx" creationdate="20190831T144034Z">
        <seg>例如，用户代理在 TRACE 请求中发送存储的用户凭证 [RFC7235] 或 cookie [RFC6265] 是愚蠢的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134136Z" creationid="pingfangx" creationdate="20190831T134136Z">
        <seg>例如，大多数服务器在每个响应完成时附加请求信息以访问日志文件，而不管方法如何，即使日志存储可能已满并使服务器崩溃，也会认为这是安全的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, one URI producer might use a segment such as "name;v=1.1" to indicate a reference to version 1.1 of "name", whereas another might use a segment such as "name,1.1" to indicate the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082959Z" creationid="pingfangx" creationdate="20190902T082959Z">
        <seg>例如，一个 URI 生成器可能使用诸如“name;v=1.1”之类的段来表示对“name”的版本 1.1 的引用，而另一个 URI 生成器可能使用诸如“name,1.1”之类的段来表示相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the "file" URI scheme is defined so that no authority, an empty host, and "localhost" all mean the end-user's machine, whereas the "http" scheme considers a missing authority or empty host invalid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075625Z" creationid="pingfangx" creationdate="20190902T075625Z">
        <seg>例如，定义“file”URI 方案，使得没有权限，空主机和“localhost”都表示最终用户的机器，而“http”方案认为缺少权限或空主机无效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the "http" URI scheme (Section 2.7.1) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110110Z" creationid="pingfangx" creationdate="20190831T110110Z">
        <seg>例如，“http”URI 方案(第 2.7.1 节)表示 TCP over IP 的默认连接，默认 TCP 端口为 80，但客户端可能配置为通过某个其他连接，端口或协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the "http" scheme defines a default port of "80", corresponding to its reserved TCP port number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081333Z" creationid="pingfangx" creationdate="20190902T081333Z">
        <seg>例如，“http”方案定义了默认端口“80”，对应于其保留的 TCP 端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the Date header field is defined in Section 7.1.1.2 of [RFC7231] as containing the origination timestamp for the message in which it appears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081900Z" creationid="pingfangx" creationdate="20190831T081900Z">
        <seg>例如，Date 首部字段在 [RFC7231] 的第 7.1.1.2 节中定义为包含它出现的消息的起始时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the URI &lt;mailto:fred@example.com&gt; has a path of "fred@example.com", whereas the URI &lt;foo://info.example.com?fred&gt; has an empty path.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082324Z" creationid="pingfangx" creationdate="20190902T082324Z">
        <seg>例如，URI &lt;mailto:fred@example.com&gt; 的路径为“fred@example.com”，而 URI &lt;foo://info.example.com?fred&gt; 的路径为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following three URIs are equivalent:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113036Z" creationid="pingfangx" creationdate="20190828T113036Z">
        <seg>例如，以下三个 URI 是等效的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the operator `interval` emits values periodically, backpressuring it would lead to shifting in the period relative to a wall clock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T074254Z" creationid="pingfangx" creationdate="20190621T074254Z">
        <seg>例如，操作符 `interval` 周期性地发射值，背压它会导致相对于挂钟的周期偏移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the payload of a 200 (OK) response to GET (Section 4.3.1) represents the current state of the target resource, as observed at the time of the message origination date (Section 7.1.1.2), whereas the payload of the same status code in a response to POST might represent either the processing result or the new state of the target resource after applying the processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025806Z" creationid="pingfangx" creationdate="20190902T025806Z">
        <seg>例如，对 GET 的 200(OK)响应的有效载荷(第 4.3.1 节)表示目标资源的当前状态，如在消息发起日期(第 7.1.1.2 节)所观察到的，而有效载荷是 POST 响应中的相同状态代码可能表示应用处理后的目标资源的处理结果或新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the request</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125224Z" creationid="pingfangx" creationdate="20190831T125224Z">
        <seg>例如，请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received request-target or Host header field differs from the host or port upon which the connection has been made.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132033Z" creationid="pingfangx" creationdate="20190831T132033Z">
        <seg>例如，该请求可能是有意或无意地误导的，使得所接收的请求目标或主机首部字段内的信息不同于已建立连接的主机或端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the semicolon (";") and equals ("=") reserved characters are often used to delimit parameters and parameter values applicable to that segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082905Z" creationid="pingfangx" creationdate="20190902T082905Z">
        <seg>例如，分号(“;”)和等于(“=”)保留字符通常用于分隔适用于该段的参数和参数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there are several overloads of `concatWith` taking the various other reactive base types as arguments (for providing convenience and performance benefits in the underlying implementation):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102323Z" creationid="pingfangx" creationdate="20190617T102323Z">
        <seg>例如，有几个 `concatWith` 重载将各种其他响应基类型作为参数(为了在底层实现中提供方便和性能优势)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041933Z" creationid="pingfangx" creationdate="20190830T041933Z">
        <seg>例如，这可以用于测试 HTTP/1.1 代理的合规性(或缺乏)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143546Z" creationid="pingfangx" creationdate="20190831T143546Z">
        <seg>例如，这可以用于测试 HTTP/1.1 一致性(或缺少)的代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For further details, consult the [wiki](https://github.com/ReactiveX/RxJava/wiki).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104625Z" creationid="pingfangx" creationdate="20190617T104625Z">
        <seg>有关详细信息，请参阅 [wiki](https://github.com/ReactiveX/RxJava/wiki)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For messages that do include a payload body, the Content-Length field-value provides the framing information necessary for determining where the body (and message) ends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T094539Z">
        <seg>对于包含有效载荷主体的消息，Content-Length 字段值提供确定主体(和消息)结束位置所需的成帧信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For messages that do not include a payload body, the Content-Length indicates the size of the selected representation (Section 3 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T094559Z">
        <seg>对于不包含有效载荷主体的消息，Content-Length 表示所选表示的大小([RFC7231] 的第 3 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details on when to send specific HTTP-Version values, see RFC 2145 [36].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103945Z" creationid="pingfangx" creationdate="20190828T103945Z">
        <seg>有关何时发送特定 HTTP-Version 的更多详细信息，请参阅 RFC 2145 [36]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about ReactiveX, see the [Introduction to ReactiveX](http://reactivex.io/intro.html) page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113458Z" creationid="pingfangx" creationdate="20190617T113458Z">
        <seg>有关 ReactiveX 的详细信息，请参阅 [ReactiveX 简介](http://reactivex.io/intro.html) 页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to white out invalid or unwanted protocol elements during in-place message filtering.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082742Z" creationid="pingfangx" creationdate="20190831T082742Z">
        <seg>对于优选可选空格以提高可读性的协议元素，发送方应该将可选空白生成为单个 SP;否则，发送方不应生成可选的空格，除非在就地消息过滤期间使无效或不需要的协议元素变成空白。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For response messages, whether or not a message-body is included with a message is dependent on both the request method and the response status code (section 6.1.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084555Z" creationid="pingfangx" creationdate="20190829T084555Z">
        <seg>对于响应消息，消息主体是否包含在消息中取决于请求方法和响应状态代码(第 6.1.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022748Z" creationid="pingfangx" creationdate="20190828T022748Z">
        <seg>出于序列号的目的，SYN 被认为发生在它发生的报文段的第一个实际数据八位位组之前，而 FIN 被认为发生在它发生的报文段中的最后一个实际数据八位位组之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some URI schemes, the visible hierarchy is limited to the scheme itself:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064524Z" creationid="pingfangx" creationdate="20190902T064524Z">
        <seg>对于某些 URI 方案，可见层次结构仅限于方案本身：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For technical details on how to write operators for 2.x, please visit the [Writing Operators](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0) wiki page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051956Z" creationid="pingfangx" creationdate="20190618T051932Z">
        <seg>有关如何为 2.x 编写运算符的技术细节，请访问 [编写运算符](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0) wiki 页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113914Z" creationid="pingfangx" creationdate="20190828T113914Z">
        <seg>出于 HTTP 的目的，GMT 完全等于 UTC(协调世界时)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol, and that consists of a set of representation metadata and a potentially unbounded stream of representation data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132958Z" creationid="pingfangx" creationdate="20190831T132958Z">
        <seg>出于 HTTP 的目的，“表示”是旨在以可以通过协议容易地传达的格式反映给定资源的过去，当前或期望状态的信息，并且由一组表示元数据和可能无限制的表示数据流组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the rest, this gives an opportunity to "extend their internal buffer" by having a larger number with `onBackpressureBuffer` than their default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093329Z" creationid="pingfangx" creationdate="20190621T093329Z">
        <seg>对于其余操作符，这提供了一个“扩展其内部缓冲区”的机会，通过使用 `onBackpressureBuffer` 而不是默认值来扩展它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the same reason, `unsubscribeOn` is not called on the regular termination path but only when there is an actual `cancel` (or `dispose`) call on the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115016Z" creationid="pingfangx" creationdate="20190618T115016Z">
        <seg>出于同样的原因，`unsubscribeOn` 不会在常规终止路径上调用，而是仅在链上有一个实际的 `cancel`(或 `dispose`)调用时调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (&lt;t0&gt;onNext&lt;/t0&gt;, &lt;t1&gt;onError&lt;/t1&gt;, and &lt;t2&gt;onCompleted&lt;/t2&gt;), you only use two methods to subscribe:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073552Z" creationid="pingfangx" creationdate="20190620T073552Z">
        <seg>出于这个原因，不用使用三个方法订阅 Single，来响应来自 Observable 的通知(&lt;t0&gt;onNext&lt;/t0&gt;，&lt;t1&gt;onError&lt;/t1&gt; 和 &lt;t2&gt;onCompleted&lt;/t2&gt;)，你只需要使用两个方法进行订阅：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, you may call &lt;s3&gt;ObserveOn&lt;/s3&gt; multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090714Z" creationid="pingfangx" creationdate="20190620T090714Z">
        <seg>因此，您可以在 Observable 操作符链中的不同点多次调用 &lt;s3&gt;ObserveOn&lt;/s3&gt;，以便更改某些操作符运行的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this specification the MSL is taken to be 2 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024416Z" creationid="pingfangx" creationdate="20190828T024416Z">
        <seg>对于此规范，MSL 为 2 分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 6.4 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113835Z" creationid="pingfangx" creationdate="20190831T113835Z">
        <seg>出于这些目的，使用 3xx(重定向)响应([RFC7231] 的第 6.4 节)更合适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103616Z" creationid="pingfangx" creationdate="20190830T103616Z">
        <seg>转发 HTTP 消息而不重写 HTTP 版本可能会导致通信错误，当下游接收者使用邮件发送者的版本来确定哪些功能可以安全地用于以后与该发送者的通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fragment identifier semantics are independent of the URI scheme and thus cannot be redefined by scheme specifications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083648Z" creationid="pingfangx" creationdate="20190902T083648Z">
        <seg>片段标识符语义独立于 URI 方案，因此不能由方案规范重新定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fragment identifiers have a special role in information retrieval systems as the primary form of client-side indirect referencing, allowing an author to specifically identify aspects of an existing resource that are only indirectly provided by the resource owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083819Z" creationid="pingfangx" creationdate="20190902T083819Z">
        <seg>片段标识符在信息检索系统中具有特殊作用，作为客户端间接引用的主要形式，允许作者专门识别仅由资源所有者间接提供的现有资源的方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frequently, the entity is stored in coded form, transmitted directly, and only decoded by the recipient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T135947Z" creationid="pingfangx" creationdate="20190828T135947Z">
        <seg>通常，实体以编码形式存储，直接传输，并且仅由接收者解码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From a user's perspective, if one was using the the `subscribe` methods other than `Flowable.subscribe(Subscriber&lt;? super T&gt;)`, there is no need to do anything regarding this change and there is no extra penalty for it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085030Z" creationid="pingfangx" creationdate="20190618T085030Z">
        <seg>从用户的角度来看，如果使用 `subscribe` 而不是 `Flowable.subscribe(Subscriber&lt;? super T&gt;)` 方法，则无需对此更改执行任何操作，也不会对其进行额外惩罚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the Observer’s point of view, it doesn’t matter!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040634Z" creationid="pingfangx" creationdate="20190620T040634Z">
        <seg>从观察者的角度来看，这并不重要！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152242Z" creationid="pingfangx" creationdate="20190829T152242Z">
        <seg>从服务器的角度来看，连接在空闲时被关闭，但从客户端的角度来看，请求正在进行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full Copyright Statement</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074655Z" creationid="pingfangx" creationdate="20190828T074655Z">
        <seg>完整的版权声明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full Date</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072103Z" creationid="pingfangx" creationdate="20190828T072103Z">
        <seg>完整日期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functional Specification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041850Z" creationid="pingfangx" creationdate="20190828T041850Z">
        <seg>Functional Specification</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further details on building can be found on the [Getting Started](https://github.com/ReactiveX/RxJava/wiki/Getting-Started) page of the wiki.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105621Z" creationid="pingfangx" creationdate="20190617T105621Z">
        <seg>有关构建的更多详细信息，请参见 Wiki 的 [Getting Started](https://github.com/ReactiveX/RxJava/wiki/Getting-Started) 页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further information on Internet Standards is available in Section 2 of RFC 5741.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090502Z" creationid="pingfangx" creationdate="20190830T090502Z">
        <seg>有关互联网标准的更多信息，请参见 RFC 5741 的第 2 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, it implies end-to-end security.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091723Z" creationid="pingfangx" creationdate="20190830T091723Z">
        <seg>此外，它意味着端到端的安全性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064628Z" creationid="pingfangx" creationdate="20190620T064628Z">
        <seg>此外，这些名称中的一些在其他情境中具有不同的含义，或者在特定实现语言的习语中看起来很怪异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, the ordering in the field value is now significant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092234Z" creationid="pingfangx" creationdate="20190830T092234Z">
        <seg>此外，字段值的排序现在很重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, they can lead to security issues along the lines of those described in [RFC1535].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090525Z" creationid="pingfangx" creationdate="20190902T090525Z">
        <seg>此外，它们可能导致 [RFC1535] 中描述的安全问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, using multiple connections can cause undesirable side effects in congested networks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112213Z" creationid="pingfangx" creationdate="20190831T112213Z">
        <seg>此外，使用多个连接可能会在拥挤的网络中造成不良副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past two decades of HTTP use and is expected to continue changing in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102830Z" creationid="pingfangx" creationdate="20190830T102830Z">
        <seg>此外，在过去二十年的 HTTP 使用过程中，通常被理解为某些协议元素的合理长度已经发生了变化，并且预计将来会继续发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future specifications and related documentation should use the general term "URI" rather than the more restrictive terms "URL" and "URN" [RFC3305].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064136Z" creationid="pingfangx" creationdate="20190902T064136Z">
        <seg>未来的规范和相关文档应使用通用术语“URI”而不是限制性更强的术语“URL”和“URN”[RFC3305]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135234Z" creationid="pingfangx" creationdate="20190831T135234Z">
        <seg>GET 是信息检索的主要机制，也是几乎所有性能优化的重点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GLOSSARY</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071309Z" creationid="pingfangx" creationdate="20190828T071309Z">
        <seg>词汇表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gateways are often used to encapsulate legacy or untrusted information services, to improve server performance through "accelerator" caching, and to enable partitioning or load balancing of HTTP services across multiple machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101529Z" creationid="pingfangx" creationdate="20190830T101529Z">
        <seg>网关通常用于封装传统或不受信任的信息服务，通过“加速器”缓存提高服务器性能，并在多台计算机上启用 HTTP 服务的分区或负载平衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gateways do not need to generate Via header fields anymore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092128Z" creationid="pingfangx" creationdate="20190830T092128Z">
        <seg>网关不再需要生成 Via 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General Header Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072729Z" creationid="pingfangx" creationdate="20190828T072302Z">
        <seg>普通首部字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General Syntax</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072044Z" creationid="pingfangx" creationdate="20190828T072044Z">
        <seg>一般语法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General-header field names can be extended reliably only in combination with a change in the protocol version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T093043Z" creationid="pingfangx" creationdate="20190829T093043Z">
        <seg>只有在协议版本发生变化的情况下，才能可靠地扩展通用首部字段名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, `generate` uses 3 callbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021056Z" creationid="pingfangx" creationdate="20190624T021056Z">
        <seg>通常，`generate` 使用 3 个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, many operators gained overloads that now allow specifying the internal buffer size or prefetch amount they should run their upstream (or inner sources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111231Z" creationid="pingfangx" creationdate="20190618T111129Z">
        <seg>通常，许多操作符获得了重载，现在允许指定内部缓冲区大小或它们应该运行其上游(或内部源)的预取量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Syntax</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042551Z" creationid="pingfangx" creationdate="20190902T042551Z">
        <seg>通用语法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an asynchronous source, fluent blocking for a terminal event is now possible:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101831Z" creationid="pingfangx" creationdate="20190618T101831Z">
        <seg>给定异步源，现在可以对终端事件进行流畅阻塞：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the overflowing example in the introduction, we can just increase the buffer size of `observeOn` to have enough room for all values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090705Z" creationid="pingfangx" creationdate="20190621T090705Z">
        <seg>鉴于介绍中的溢出示例，我们可以增加 `observeOn` 的缓冲区大小，以便为所有值提供足够的空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go on with your business; whenever the call returns, the observer’s method will begin to operate on its return value or values — the &lt;i0&gt;items&lt;/i0&gt; emitted by the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055859Z" creationid="pingfangx" creationdate="20190620T055859Z">
        <seg>继续你的业务；每当调用返回时，观察者的方法将开始对其返回值或返回值值 -  Observable 发射的 &lt;i0&gt;items (数据项)&lt;/i0&gt; 进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HT             = &lt;US-ASCII HT, horizontal-tab (9)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095349Z" creationid="pingfangx" creationdate="20190828T095349Z">
        <seg>HT             = &lt;US-ASCII HT, 水平制表符 (9)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP Message</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072215Z" creationid="pingfangx" creationdate="20190828T072215Z">
        <seg>HTTP 消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP Version</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072035Z" creationid="pingfangx" creationdate="20190828T072035Z">
        <seg>HTTP 版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP [RFC2616] was originally used in the clear on the Internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090852Z" creationid="pingfangx" creationdate="20190901T090852Z">
        <seg>HTTP [RFC2616] 最初没有危险的(in the clear)用于互联网上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP allows an open-ended set of methods and headers that indicate the purpose of a request [47].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075605Z" creationid="pingfangx" creationdate="20190828T075605Z">
        <seg>HTTP 允许一组开放式的方法和首部来指示请求的目的 [47]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP applications MUST accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151503Z" creationid="pingfangx" creationdate="20190828T151503Z">
        <seg>HTTP 应用程序必须接受 CRLF，单独 CR 和单独 LF，以表示通过 HTTP 接收的文本媒体中的换行符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110011Z" creationid="pingfangx" creationdate="20190829T110011Z">
        <seg>HTTP 应用程序不需要理解所有已注册状态代码的含义，尽管这种理解显然是可取的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP applications have historically allowed three different formats for the representation of date/time stamps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113201Z" creationid="pingfangx" creationdate="20190828T113201Z">
        <seg>历史上，HTTP 应用程序允许使用三种不同的格式来表示日期/时间戳：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP character sets are identified by case-insensitive tokens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115050Z" creationid="pingfangx" creationdate="20190828T115050Z">
        <seg>HTTP 字符集由不区分大小写的标记标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP clients are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144347Z" creationid="pingfangx" creationdate="20190831T144347Z">
        <seg>HTTP 客户端不需要理解所有已注册状态代码的含义，尽管这种理解显然是可取的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP communication is initiated by a user agent for some purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123219Z" creationid="pingfangx" creationdate="20190831T123219Z">
        <seg>出于某种目的，HTTP 通信由用户代理启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP communication usually takes place over TCP/IP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092026Z" creationid="pingfangx" creationdate="20190828T092026Z">
        <seg>HTTP 通信通常通过 TCP/IP 连接进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP content negotiation (section 12) uses short "floating point" numbers to indicate the relative importance ("weight") of various negotiable parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T153605Z" creationid="pingfangx" creationdate="20190828T153605Z">
        <seg>HTTP 内容协商(第 12 节)使用短“浮点”数字来指示各种可协商参数的相对重要性(“权重”)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103027Z" creationid="pingfangx" creationdate="20190830T103027Z">
        <seg>HTTP 没有定义特定的错误处理机制，除非它们对安全性有直接影响，因为协议的不同应用程序需要不同的错误处理策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102811Z" creationid="pingfangx" creationdate="20190830T102811Z">
        <seg>HTTP 对其许多协议元素没有特定的长度限制，因为可能适当的长度会有很大差异，具体取决于部署上下文和实现的目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP does not include a request identifier for associating a given request message with its corresponding one or more response messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132202Z" creationid="pingfangx" creationdate="20190831T132202Z">
        <seg>HTTP 不包括用于将给定请求消息与其对应的一个或多个响应消息相关联的请求标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122642Z" creationid="pingfangx" creationdate="20190831T122642Z">
        <seg>HTTP 不限制资源的性质；它只定义了一个可能用于与资源交互的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070758Z" creationid="pingfangx" creationdate="20190831T070758Z">
        <seg>HTTP 不会对请求行的长度设置预定义的限制，如第 2.5 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP does not place a predefined limit on the length of each header field or on the length of the header section as a whole, as described in Section 2.5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085221Z" creationid="pingfangx" creationdate="20190831T085221Z">
        <seg>HTTP 没有对每个首部字段的长度或整个首部的长度设置预定义的限制，如第 2.5 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP enables the use of intermediaries to satisfy requests through a chain of connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101035Z" creationid="pingfangx" creationdate="20190830T101035Z">
        <seg>HTTP 允许使用中介通过一系列连接来满足请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP has been in use by the World-Wide Web global information initiative since 1990.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071614Z" creationid="pingfangx" creationdate="20190828T071614Z">
        <seg>自 1990 年以来，万维网全球信息倡议一直在使用 HTTP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP header fields, which include general-header (section 4.5), request-header (section 5.3), response-header (section 6.2), and entity-header (section 7.1) fields, follow the same generic format as that given in Section 3.1 of RFC 822 [9].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T080617Z" creationid="pingfangx" creationdate="20190829T080617Z">
        <seg>HTTP 首部字段，包括通用首部(第 4.5 节)，请求首部(第 5.3 节)，响应首部(第 6.2 节)和实体首部(第 7.1 节)字段，遵循与 RFC 822 [9] 的  3.1 节中给出的相同的通用格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP implementations SHOULD implement persistent connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150148Z" creationid="pingfangx" creationdate="20190829T150148Z">
        <seg>HTTP 实现应该实现持久连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP implementations SHOULD support persistent connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110952Z" creationid="pingfangx" creationdate="20190831T110952Z">
        <seg>HTTP 实现应该支持持久连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP implementations are expected to engage in connection management, which includes maintaining the state of current connections, establishing a new connection or reusing an existing connection, processing messages received on a connection, detecting connection failures, and closing each connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110134Z" creationid="pingfangx" creationdate="20190831T110134Z">
        <seg>HTTP 实现预计将参与连接管理，包括维护当前连接的状态，建立新连接或重用现有连接，处理连接上接收的消息，检测连接失败以及关闭每个连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP is a generic interface protocol for information systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094149Z" creationid="pingfangx" creationdate="20190830T094149Z">
        <seg>HTTP 是信息系统的通用接口协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP is a stateless request/response protocol that operates by exchanging messages (Section 3) across a reliable transport- or session-layer "connection" (Section 6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095459Z" creationid="pingfangx" creationdate="20190830T095459Z">
        <seg>HTTP 是一种无状态请求/响应协议，通过在可靠的传输层或会话层“连接”(第 6 节)之间交换消息(第 3 节)来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP is also designed for use as an intermediation protocol for translating communication to and from non-HTTP information systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094249Z" creationid="pingfangx" creationdate="20190830T094249Z">
        <seg>HTTP 还被设计用作中介协议，用于转换与非 HTTP 信息系统之间的通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet systems, including those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2], and WAIS [10] protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080141Z" creationid="pingfangx" creationdate="20190828T080141Z">
        <seg>HTTP 还用作用户代理和代理/网关与其他 Internet 系统之间通信的通用协议，包括 SMTP [16]，NNTP [13]，FTP [18]，Gopher [2] 和 WAIS [ 10] 协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP is defined as a stateless protocol, meaning that each request message can be understood in isolation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101852Z" creationid="pingfangx" creationdate="20190830T101852Z">
        <seg>HTTP 被定义为无状态协议，这意味着可以孤立地理解每个请求消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP is used in a wide variety of applications, ranging from general-purpose computers to home appliances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123201Z" creationid="pingfangx" creationdate="20190831T123201Z">
        <seg>HTTP 用于各种应用程序，从通用计算机到家用电器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP messages can be (and often are) buffered by implementations; despite it sometimes being available as a stream, HTTP is fundamentally a message-oriented protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091741Z" creationid="pingfangx" creationdate="20190830T091741Z">
        <seg>HTTP 消息可以(通常是)由实现缓冲；尽管它有时可用作流，但 HTTP 基本上是面向消息的协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP messages consist of requests from client to server and responses from server to client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T013323Z" creationid="pingfangx" creationdate="20190829T013323Z">
        <seg>HTTP 消息包括从客户端到服务器的请求以及从服务器到客户端的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103827Z" creationid="pingfangx" creationdate="20190831T103827Z">
        <seg>HTTP 消息传递独立于底层传输层或会话层连接协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110011Z" creationid="pingfangx" creationdate="20190831T110011Z">
        <seg>HTTP 仅假定可靠的传输，具有按顺序递送请求和相应的有序响应传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used; the mapping of the HTTP/1.1 request and response structures onto the transport data units of the protocol in question is outside the scope of this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092154Z" creationid="pingfangx" creationdate="20190828T092154Z">
        <seg>HTTP 只假定可靠的传输；可以使用任何提供此类保证的协议；HTTP/1.1 请求和响应结构到所讨论协议的传输数据单元的映射超出了本规范的范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP provides a uniform interface for interacting with a resource (Section 2), regardless of its type, nature, or implementation, via the manipulation and transfer of representations (Section 3).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121657Z" creationid="pingfangx" creationdate="20190831T121657Z">
        <seg>HTTP 提供了一个统一的接口，用于与资源交互(第 2 节)，无论其类型，性质或实现，通过表示的操作和传输(第 3 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP proxies and gateways can provide access to alternative information services by translating their diverse protocols into a hypertext format that can be viewed and manipulated by clients in the same way as HTTP services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094301Z" creationid="pingfangx" creationdate="20190830T094301Z">
        <seg>HTTP 代理和网关可以通过将其不同的协议转换为超文本格式来提供对替代信息服务的访问，该超文本格式可以由客户端以与 HTTP 服务相同的方式查看和操纵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP relaxes this requirement and allows the transport of text media with plain CR or LF alone representing a line break when it is done consistently for an entire entity-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151355Z" creationid="pingfangx" creationdate="20190828T151355Z">
        <seg>HTTP 放宽了这一要求，并允许传输具有普通 CR 或 LF 表示换行符的文本媒体，当在整个实体主体一致时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP relies upon the Uniform Resource Identifier (URI) standard [RFC3986] to indicate the target resource (Section 5.1) and relationships between resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095850Z" creationid="pingfangx" creationdate="20190830T095850Z">
        <seg>HTTP 依赖于统一资源标识符(URI)标准 [RFC3986] 来指示目标资源(第 5.1 节)和资源之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123035Z" creationid="pingfangx" creationdate="20190831T123035Z">
        <seg>HTTP 请求消息路由由每个客户端基于目标资源，客户端的代理配置以及入站连接的建立或重用来确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP requirements for cache behavior and cacheable responses are defined in Section 2 of [RFC7234].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102342Z" creationid="pingfangx" creationdate="20190830T102342Z">
        <seg>缓存行为和可缓存响应的 HTTP 要求在 [RFC7234] 的第 2 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP requirements for cache behavior and cacheable responses are defined in section 13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T091155Z" creationid="pingfangx" creationdate="20190828T091155Z">
        <seg>缓存行为和可缓存响应的 HTTP 要求在第 13 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP requirements regarding connection management are defined in Section 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123750Z" creationid="pingfangx" creationdate="20190831T123750Z">
        <seg>有关连接管理的 HTTP 要求在第 6 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP semantics include the intentions defined by each request method (Section 4), extensions to those semantics that might be described in request header fields (Section 5), the meaning of status codes to indicate a machine-readable response (Section 6), and the meaning of other control data and resource metadata that might be given in response header fields (Section 7).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121732Z" creationid="pingfangx" creationdate="20190831T121732Z">
        <seg>HTTP 语义包括每个请求方法定义的意图(第 4 节)，可能在请求首部字段(第 5 节)中描述的那些语义的扩展，用于指示机器可读响应的状态代码的含义(第 6 节)，以及可能在响应首部字段中给出的其他控制数据和资源元数据的含义(第 7 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP status codes are extensible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105948Z" creationid="pingfangx" creationdate="20190829T105948Z">
        <seg>HTTP 状态代码是可扩展的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP systems are used in corporate intranets over high-bandwidth links, and for access via PDAs with low-power radio links and intermittent connectivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T091458Z" creationid="pingfangx" creationdate="20190828T091458Z">
        <seg>HTTP 系统通过高带宽链路在企业内部网中使用，并通过具有低功率无线电链路和间歇性连接的 PDA 进行访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP uses Internet Media Types [17] in the Content-Type (section 14.17) and Accept (section 14.1) header fields in order to provide open and extensible data typing and type negotiation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144802Z" creationid="pingfangx" creationdate="20190828T144802Z">
        <seg>HTTP 在 Content-Type(第 14.17 节)和 Accept(第 14.1 节)首部字段中使用互联网媒体类型 [17]，以提供开放和可扩展的数据类型和类型协商。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103012Z" creationid="pingfangx" creationdate="20190828T103012Z">
        <seg>HTTP 使用“&lt;major&gt;.&lt;minor&gt;”编号方案来指示协议的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP uses language tags within the Accept-Language and Content-Language fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154626Z" creationid="pingfangx" creationdate="20190828T154626Z">
        <seg>HTTP 使用 Accept-Language 和 Content-Language 字段中的语言标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP uses the same definition of the term "character set" as that described for MIME:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114819Z" creationid="pingfangx" creationdate="20190828T114819Z">
        <seg>HTTP 使用与 MIME 描述的术语“字符集”相同的定义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP was created for the World Wide Web (WWW) architecture and has evolved over time to support the scalability needs of a worldwide hypertext system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094941Z" creationid="pingfangx" creationdate="20190830T094941Z">
        <seg>HTTP 是为万维网(WWW)架构创建的，并且随着时间的推移不断发展以支持全球超文本系统的可扩展性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP was originally designed to be usable as an interface to distributed object systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133358Z" creationid="pingfangx" creationdate="20190831T133358Z">
        <seg>HTTP 最初设计为可用作分布式对象系统的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP's approach to error handling has been explained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091605Z" creationid="pingfangx" creationdate="20190830T091605Z">
        <seg>已经解释了 HTTP 的错误处理方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP-date is case sensitive and MUST NOT include additional LWS beyond that specifically included as SP in the grammar.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114125Z" creationid="pingfangx" creationdate="20190828T114125Z">
        <seg>HTTP-date 区分大小写，并且不得包含超出语法中特定包含的 SP 的额外的 LWS。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP-version is case-sensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103158Z" creationid="pingfangx" creationdate="20190830T103158Z">
        <seg>HTTP 版本区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.0, as defined by RFC 1945 [6], improved the protocol by allowing messages to be in the format of MIME-like messages, containing metainformation about the data transferred and modifiers on the request/response semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075437Z" creationid="pingfangx" creationdate="20190828T075437Z">
        <seg>RFC 1945 [6] 定义的 HTTP/1.0 通过允许消息采用类似 MIME 的消息格式改进了协议，包含有关传输数据的元信息和请求/响应语义的修饰符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 allows a client to request that only part (a range of) the response entity be included within the response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160059Z" creationid="pingfangx" creationdate="20190828T160059Z">
        <seg>HTTP/1.1 允许客户端请求响应实体中仅包含部分(一系列)响应实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 applications MUST NOT generate more than three digits after the decimal point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154157Z" creationid="pingfangx" creationdate="20190828T154157Z">
        <seg>HTTP/1.1 应用程序在小数点后不得生成超过三位数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 clients and servers that parse the date value MUST accept all three formats (for compatibility with HTTP/1.0), though they MUST only generate the RFC 1123 format for representing HTTP-date values in header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113719Z" creationid="pingfangx" creationdate="20190828T113719Z">
        <seg>解析日期值的 HTTP/1.1 客户端和服务器必须接受所有三种格式(为了与 HTTP/1.0 兼容)，但它们必须只生成 RFC 1123 格式以在头字段中表示 HTTP 日期值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 defaults to the use of "persistent connections", allowing multiple requests and responses to be carried over a single connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110935Z" creationid="pingfangx" creationdate="20190831T110935Z">
        <seg>HTTP/1.1 默认使用“持久连接”，允许通过单个连接传输多个请求和响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all protocol elements except the entity-body (see appendix 19.3 for tolerant applications).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100913Z" creationid="pingfangx" creationdate="20190828T095548Z">
        <seg>HTTP/1.1 将序列 CR LF 定义为除实体主体之外的所有协议元素的行尾标记(有关 tolerant 应用程序，请参见附录 19.3)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 does not define how a PUT method affects the state of an origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T071546Z" creationid="pingfangx" creationdate="20190830T071546Z">
        <seg>HTTP/1.1 没有定义 PUT 方法如何影响原始服务器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 has been designed to allow implementations of applications that do not depend on knowledge of ranges.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160737Z" creationid="pingfangx" creationdate="20190828T160737Z">
        <seg>HTTP/1.1 旨在允许不依赖于范围知识的应用程序的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 header field values can be folded onto multiple lines if the continuation line begins with a space or horizontal tab.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095824Z" creationid="pingfangx" creationdate="20190828T095824Z">
        <seg>如果连续行以空格或水平制表符开头，则 HTTP/1.1 首部字段值可以折叠到多行上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 implementations MAY ignore ranges specified using other units.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160449Z" creationid="pingfangx" creationdate="20190828T160449Z">
        <seg>HTTP/1.1 实现可以忽略使用其他单元指定的范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 recipients MUST respect the charset label provided by the sender; and those user agents that have a provision to "guess" a charset MUST use the charset from the content-type field if they support that charset, rather than the recipient's preference, when initially displaying a document.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190828T115818Z">
        <seg>HTTP/1.1 收件人必须尊重提供的字符集标签；那些有“猜测”字符集的用户代理必须使用内容类型字段中的字符集而不是收件人的首选项，如果它们在最初显示文档时支持该字符集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's flow control mechanisms to resolve temporary overloads, rather than terminating connections with the expectation that clients will retry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024156Z" creationid="pingfangx" creationdate="20190830T024156Z">
        <seg>HTTP/1.1 服务器应该保持持久连接并使用 TCP 的流控制机制来解决临时过载，而不是终止连接，期望客户端重试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 user agents MUST notify the user when an invalid length is received and detected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T091122Z" creationid="pingfangx" creationdate="20190829T091122Z">
        <seg>HTTP/1.1 用户代理必须在收到并检测到无效长度时通知用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 uses content-coding values in the Accept-Encoding (section 14.3) and Content-Encoding (section 14.11) header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140112Z" creationid="pingfangx" creationdate="20190828T140112Z">
        <seg>HTTP/1.1 使用 Accept-Encoding(第 14.3 节)和 Content-Encoding(第 14.11 节)头部字段中的内容编码值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 uses entity tags in the ETag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155634Z" creationid="pingfangx" creationdate="20190828T155634Z">
        <seg>HTTP/1.1 使用 ETag(第 14.19 节)，If-Match(第 14.24 节)，If-None-Match(第 14.26 节)和 If-Range(第 14.27 节)首部字段中的实体标签。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 uses range units in the Range (section 14.35) and Content-Range (section 14.16) header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160146Z" creationid="pingfangx" creationdate="20190828T160146Z">
        <seg>HTTP/1.1 使用 Range (第 14.35 节)和 Content-Range (第 14.16 节)首部字段中的范围单位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/1.1 uses transfer-coding values in the TE header field (section 14.39) and in the Transfer-Encoding header field (section 14.41).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142646Z" creationid="pingfangx" creationdate="20190828T142646Z">
        <seg>HTTP/1.1 使用 TE 首部字段(第 14.39 节)和 Transfer-Encoding 首部字段(第 14.41 节)中的传输编码值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTTP/TLS is differentiated from HTTP URIs by using the 'https' protocol identifier in place of the 'http' protocol identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103401Z" creationid="pingfangx" creationdate="20190901T103401Z">
        <seg>通过使用“https”协议标识符代替“http”协议标识符，来区别 HTTP/TLS 与 HTTP URI 的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-Open Connection Discovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055922Z" creationid="pingfangx" creationdate="20190828T055922Z">
        <seg>半开连接发现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-Open Connections and Other Anomalies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043351Z" creationid="pingfangx" creationdate="20190828T043351Z">
        <seg>半开连接和其他异常</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Incomplete Messages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090803Z" creationid="pingfangx" creationdate="20190830T090803Z">
        <seg>处理不完整的消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handshake Protocol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122108Z" creationid="pingfangx" creationdate="20190901T122108Z">
        <seg>握手协议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having identified a resource, a system may perform a variety of operations on the resource, as might be characterized by such words as `access', `update', `replace', or `find attributes'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040349Z" creationid="pingfangx" creationdate="20190902T040349Z">
        <seg>在识别出资源之后，系统可以对资源执行各种操作，其特征可以是诸如“访问”，“更新”，“替换”或“查找属性”之类的单词。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header Field Definitions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074105Z" creationid="pingfangx" creationdate="20190828T074105Z">
        <seg>首部字段定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header Field Registration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091043Z" creationid="pingfangx" creationdate="20190830T091043Z">
        <seg>首部字段注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header Field Registry</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115944Z" creationid="pingfangx" creationdate="20190831T115944Z">
        <seg>首部字段注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090722Z" creationid="pingfangx" creationdate="20190830T090722Z">
        <seg>首部字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header Format</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T100654Z" creationid="pingfangx" creationdate="20190827T100654Z">
        <seg>首部格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header field extensibility is discussed in Section 3.2.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103449Z" creationid="pingfangx" creationdate="20190830T103449Z">
        <seg>首部字段可扩展性在第 3.2.1 节中讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header fields are fully extensible: there is no limit on the introduction of new field names, each presumably defining new semantics, nor on the number of header fields used in a given message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081947Z" creationid="pingfangx" creationdate="20190831T081947Z">
        <seg>首部字段是完全可扩展的：新字段名称的引入没有限制，每个字段名称可能定义新的语义，也不限于给定消息中使用的首部字段的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header fields can be extended over multiple lines by preceding each extra line with at least one SP or HT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T080934Z" creationid="pingfangx" creationdate="20190829T080934Z">
        <seg>通过在每个额外的行前面至少有一个 SP 或 HT，可以将首部字段扩展到多行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header fields that span multiple lines ("line folding") are deprecated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091833Z" creationid="pingfangx" creationdate="20190830T091833Z">
        <seg>不推荐使用跨越多行的首部字段(“行折叠”)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Header fields that specifically describe the payload, rather than the associated representation, are referred to as "payload header fields".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025843Z" creationid="pingfangx" creationdate="20190902T025843Z">
        <seg>专门描述有效载荷而不是相关表示的首部字段被称为“有效载荷首部字段”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, HTTP requirements are placed on senders, recipients, clients, servers, user agents, intermediaries, origin servers, proxies, gateways, or caches, depending on what behavior is being constrained by the requirement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102456Z" creationid="pingfangx" creationdate="20190830T102456Z">
        <seg>因此，HTTP 要求被放置在发送者，接收者，客户端，服务器，用户代理，中介，源服务器，代理，网关或缓存上，具体取决于要求约束的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101920Z" creationid="pingfangx" creationdate="20190830T101920Z">
        <seg>因此，服务器绝不能假设同一连接上的两个请求来自同一个用户代理，除非该连接是安全的并且特定于该代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102819Z" creationid="pingfangx" creationdate="20190830T102819Z">
        <seg>因此，发送者和接收者之间的互操作性取决于对每个协议元素的合理长度的共同期望。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132214Z" creationid="pingfangx" creationdate="20190831T132214Z">
        <seg>因此，它依赖于响应到达的顺序，以完全对应于在同一连接上进行请求的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the Connection header field provides a declarative way of distinguishing header fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110325Z" creationid="pingfangx" creationdate="20190831T110325Z">
        <seg>因此，Connection 首部字段提供了一种声明性方法，用于区分仅针对直接接收者(“逐跳”)的首部字段，以及针对链上所有接收者的那些字段(“端到端” “)，使消息具有自我描述性，允许部署未来特定于连接的扩展，而不必担心旧的中介会盲目地转发它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISN's.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023742Z" creationid="pingfangx" creationdate="20190828T023742Z">
        <seg>因此，该解决方案需要合适的机制来挑选初始序列号和稍微涉及的握手以交换 ISN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135250Z" creationid="pingfangx" creationdate="20190831T135250Z">
        <seg>因此，当人们谈到通过 HTTP 检索某些可识别信息时，他们通常指的是发出 GET 请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the `computeValue` is executed only when a subscriber subscribes and for each of them, printing the expected 1 and 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015926Z" creationid="pingfangx" creationdate="20190624T015926Z">
        <seg>这里的 `computeValue` 仅在订阅者订阅时执行，并且每个订阅者都打印预期的 1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the `onStart` implementation indicates `range` to produce its first value, which is then received in `onNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082052Z" creationid="pingfangx" creationdate="20190621T082052Z">
        <seg>这里 `onStart` 实现指示 `range` 产生它的第一个值，然后在 `onNext` 中接收它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, `flatMap` works as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083927Z" creationid="pingfangx" creationdate="20190617T083927Z">
        <seg>这里，`flatMap` 也适用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, if we imagine ourselves on `operator2`, looking to the left towards the source, is called the **upstream**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070815Z" creationid="pingfangx" creationdate="20190617T070815Z">
        <seg>在这里，如果我们想象自己在 `operator2`，向左看向源，则称为 **upstream**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the original `value` will be available inside the inner `flatMap`, courtesy of lambda variable capture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083803Z" creationid="pingfangx" creationdate="20190617T083803Z">
        <seg>在这里，原始的 `value` 将在内部 `flatMap` 中可用，由 lambda 变量捕获提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heuristic Expiration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073303Z" creationid="pingfangx" creationdate="20190828T073303Z">
        <seg>启发式过期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hexadecimal numeric characters are used in several protocol elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100111Z" creationid="pingfangx" creationdate="20190828T100111Z">
        <seg>十六进制数字字符用于多个协议元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchical Identifiers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060447Z" creationid="pingfangx" creationdate="20190902T060447Z">
        <seg>分层标识符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Historically, HTTP has allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T084949Z" creationid="pingfangx" creationdate="20190831T084804Z">
        <seg>在历史上，HTTP 允许字段内容使用在 ISO-8859-1 字符集 [ISO-8859-1] 中的文本，仅通过使用 [RFC2047] 编码支持其他字符集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Historically, HTTP header field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083744Z" creationid="pingfangx" creationdate="20190831T083744Z">
        <seg>历史上，HTTP 首部字段值可以通过在每个额外行之前用至少一个空格或水平制表符(obs-fold)在多行上扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History Lists</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074059Z" creationid="pingfangx" creationdate="20190828T074059Z">
        <seg>历史名单</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hosts which prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the "quite time".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025847Z" creationid="pingfangx" creationdate="20190828T025847Z">
        <seg>希望避免等待的主机愿意冒险在给定目的地处可能混淆新旧分组可能选择不等待“相当时间”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is this Observable implemented?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040459Z" creationid="pingfangx" creationdate="20190620T040459Z">
        <seg>Observable 是如何实现的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How that identification is accomplished, assigned, or enabled is delegated to each scheme specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061055Z" creationid="pingfangx" creationdate="20190902T061055Z">
        <seg>如何完成，分配或启用该标识将委托给每个方案规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How that is accomplished is dependent on the target URI scheme and defined by its associated specification, similar to how this specification defines origin server access for resolution of the "http" (Section 2.7.1) and "https" (Section 2.7.2) schemes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123745Z" creationid="pingfangx" creationdate="20190831T123745Z">
        <seg>如何实现取决于目标 URI 方案并由其相关规范定义，类似于此规范如何定义原始服务器访问以解析“http”(第 2.7.1 节)和“https”(第 2.7.2 节)方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Android is more strict and terminates the application in such uncaught exception cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090336Z" creationid="pingfangx" creationdate="20190618T090336Z">
        <seg>但是，Android 更严格，并在此类未捕获的异常情况下终止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, HTTP/1.0 does not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or virtual hosts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075453Z" creationid="pingfangx" creationdate="20190828T075453Z">
        <seg>但是，HTTP/1.0 没有充分考虑分层代理，缓存，持久连接需求或虚拟主机的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, POST caching is not widely implemented.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141735Z" creationid="pingfangx" creationdate="20190831T141735Z">
        <seg>但是，POST 缓存并未广泛实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, RxJava's reactive types are immutable; each of the method calls returns a new `Flowable` with added behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072714Z" creationid="pingfangx" creationdate="20190617T072714Z">
        <seg>但是，RxJava 的反应类型是不可变的；每个方法调用都返回一个带有添加行为的新的 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, URI comparison implementations do not always perform normalization prior to comparison (see Section 6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071353Z" creationid="pingfangx" creationdate="20190902T071353Z">
        <seg>但是，URI 比较实现并不总是在比较之前执行规范化(参见第 6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a client MUST understand the class of any status code, as indicated by the first digit, and treat an unrecognized status code as being equivalent to the x00 status code of that class, with the exception that a recipient MUST NOT cache a response with an unrecognized status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144410Z" creationid="pingfangx" creationdate="20190831T144410Z">
        <seg>但是，客户端必须理解任何状态代码的类，如第一个数字所示，并将无法识别的状态代码视为等同于该类的 x00 状态代码，但接收者不得缓存响应无法识别的状态代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a globally scoped naming system, such as DNS fully qualified domain names, is necessary for URIs intended to have global scope.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075918Z" creationid="pingfangx" creationdate="20190902T075918Z">
        <seg>但是，对于具有全局范围的 URI，必须使用全局范围的命名系统，例如 DNS 完全限定的域名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, an HTTP-to-HTTP gateway that wishes to interoperate with third-party HTTP servers ought to conform to user agent requirements on the gateway's inbound connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101558Z" creationid="pingfangx" creationdate="20190830T101558Z">
        <seg>但是，希望与第三方 HTTP 服务器进行互操作的 HTTP 到 HTTP 网关应该符合网关入站连接上的用户代理要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, an action made on the basis of that reference will take place in relation to the end-user's context, which implies that an action intended to refer to a globally unique thing must use a URI that distinguishes that resource from all other things.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061420Z" creationid="pingfangx" creationdate="20190902T061420Z">
        <seg>但是，基于该引用而做出的动作将与最终用户的上下文相关联，这意味着旨在引用全局唯一事物的动作必须使用区分该资源与所有其他事物的 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, an extension to HTTP that is defined to apply to entire host domains, such as the Cookie protocol [RFC6265], can allow information set by one service to impact communication with other services within a matching group of host domains.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060757Z" creationid="pingfangx" creationdate="20190831T060757Z">
        <seg>但是，定义为应用于整个主机域的 HTTP 扩展(例如 Cookie 协议 [RFC6265])可以允许一个服务设置的信息影响与匹配的主机域组内的其他服务的通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response MUST NOT be cached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144817Z" creationid="pingfangx" creationdate="20190829T110048Z">
        <seg>但是，应用程序必须理解任何状态代码的类，如第一个数字所示，并将任何无法识别的响应视为等同于该类的 x00 状态代码，但不得缓存无法识别的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as URI identification and usage have become commonplace, traditional media (television, radio, newspapers, billboards, etc.) have increasingly used a suffix of the URI as a reference, consisting of only the authority and path portions of the URI, such as www.w3.org/Addressing/ or simply a DNS registered name on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090342Z" creationid="pingfangx" creationdate="20190902T090342Z">
        <seg>然而，随着 URI 识别和使用变得普遍，传统媒体(电视，广播，报纸，广告牌等)越来越多地使用 URI 的后缀作为参考，仅由 URI 的权限和路径部分组成，例如如 www.w3.org/Addressing/或仅仅是 DNS 注册名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as query components are often used to carry identifying information in the form of "key=value" pairs and one frequently used value is a reference to another URI, it is sometimes better for usability to avoid percent-encoding those characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083354Z" creationid="pingfangx" creationdate="20190902T083354Z">
        <seg>但是，由于查询组件通常用于携带“key=value”对形式的标识信息，而一个常用值是对另一个 URI 的引用，因此有时避免对这些字符进行百分比编码对于可用性更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, backpressure is present more subtly in regular cold sequences (which don't and shouldn't yield `MissingBackpressureException`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080321Z" creationid="pingfangx" creationdate="20190621T080321Z">
        <seg>然而，背压在常规冷序列中更微妙地存在(它不会也不应该产生 `MissingBackpressureException`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, each connection consumes server resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112208Z" creationid="pingfangx" creationdate="20190831T112208Z">
        <seg>但是，每个连接都会占用服务器资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even when the receive window is zero, a TCP must process the RST and URG fields of all incoming segments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022507Z" creationid="pingfangx" creationdate="20190828T022507Z">
        <seg>但是，即使接收窗口为零，TCP 也必须处理所有传入报文段的 RST 和 URG 字报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, half-open connections are expected to be unusual, and the recovery procedure is mildly involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043551Z" creationid="pingfangx" creationdate="20190828T043551Z">
        <seg>但是，预计半开连接是不寻常的，并且恢复过程涉及到温和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source Observable terminates with an error, the &lt;c0&gt;AsyncSubject&lt;/c0&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084042Z" creationid="pingfangx" creationdate="20190620T084042Z">
        <seg>但是，如果源 Observable 以错误终止，则 &lt;c0&gt;AsyncSubject&lt;/c0&gt; 将不会发射任何项，而只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source Observable terminates with an error, the &lt;c0&gt;BehaviorSubject&lt;/c0&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084214Z" creationid="pingfangx" creationdate="20190620T084214Z">
        <seg>但是，如果源 Observable 以错误终止，则 &lt;c0&gt;BehaviorSubject&lt;/c0&gt; 将不会向后续观察者发射任何项，而只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113325Z" creationid="pingfangx" creationdate="20190831T113325Z">
        <seg>但是，在发送 101(交换协议)响应之后，服务器应该立即继续响应原始请求，就好像它已经在新协议中接收到它的等价物一样(即，服务器仍然有一个未完成的请求在协议之后满足已被更改，并且预计会这样做而不要求重复请求)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, increased use of HTTP for sensitive applications has required security measures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091048Z" creationid="pingfangx" creationdate="20190901T091048Z">
        <seg>但是，敏感应用程序使用 HTTP 的增加需要采取安全措施。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is "good practice" to send general-header fields first, followed by request-header or response- header fields, and ending with the entity-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T081348Z" creationid="pingfangx" creationdate="20190829T081348Z">
        <seg>但是，首先发送常规首部字段，然后发送请求首部或响应首部字段，最后发送实体首部字段是“良好实践”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is good practice to send header fields that contain control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082244Z" creationid="pingfangx" creationdate="20190831T082244Z">
        <seg>但是，优良作法是首先发送包含控制数据的首部字段，例如请求上的 Host 和响应上的 Date，以便实现可以尽早决定何时不处理消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is possible that a sequence of several requests is non- idempotent, even if all of the methods executed in that sequence are idempotent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T040630Z" creationid="pingfangx" creationdate="20190830T040630Z">
        <seg>但是，有可能多个请求的序列是非等幂的，即使在该序列中执行的所有方法都是等幂的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, lenient parsing can result in security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 9.5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103645Z" creationid="pingfangx" creationdate="20190831T103645Z">
        <seg>但是，如果消息有多个接收者，并且每个消息都有自己独特的健壮性解释，那么宽松的解析可能会导致安全漏洞(参见第 9.5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, most HTTP clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123215Z" creationid="pingfangx" creationdate="20190831T123215Z">
        <seg>但是，大多数 HTTP 客户端依赖于与通用 Web 浏览器相同的资源识别机制和配置技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, most origin servers do not implement CONNECT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143044Z" creationid="pingfangx" creationdate="20190831T143044Z">
        <seg>但是，大多数源服务器都不实现 CONNECT。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, new or experimental header fields MAY be given the semantics of request- header fields if all parties in the communication recognize them to be request-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102344Z" creationid="pingfangx" creationdate="20190829T102344Z">
        <seg>但是，如果通信中的所有各方都认为它们是请求首部字段，则可以给新的或实验的首部字段赋予请求首部字段的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, new or experimental header fields MAY be given the semantics of response- header fields if all parties in the communication recognize them to be response-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110930Z" creationid="pingfangx" creationdate="20190829T110930Z">
        <seg>但是，如果通信中的所有各方都认为它们是响应首部字段，则可以给新的或实验的首部字段赋予响应首部字段的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, new or experimental header fields may be given the semantics of general header fields if all parties in the communication recognize them to be general-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T093105Z" creationid="pingfangx" creationdate="20190829T093105Z">
        <seg>然而，如果通信中的所有各方将它们识别为通用报首部字段，则可以给新的或实验的报首部字段赋予通用报首部字段的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or payload transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T063246Z">
        <seg>但是，接收者不能依赖于部分消息的增量传递，因为一些实现将缓冲或延迟消息转发，以便进行网络效率，安全检查或有效载荷转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, safe transport has a different focus for an 8bit-clean transfer protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142914Z" creationid="pingfangx" creationdate="20190828T142914Z">
        <seg>但是，安全传输对于 8 位清洁传输协议有不同的侧重点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, scheme specifications are encouraged to include a wide range of examples, including examples that show use of the scheme's URIs with fragment identifiers when such usage is appropriate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085524Z" creationid="pingfangx" creationdate="20190902T085524Z">
        <seg>但是，鼓励方案规范包括各种示例，包括在适当使用时显示使用带有片段标识符的方案的 URI 的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since multiple clients might act in parallel and perhaps at cross-purposes, we cannot require that such changes be observable beyond the scope of a single response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094403Z" creationid="pingfangx" creationdate="20190830T094403Z">
        <seg>但是，由于多个客户端可能并行运行，并且可能是交叉目的，因此我们不能要求在单个响应的范围之外可以观察到此类更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, such use comes with its own costs: domain name ownership may change over time for reasons not anticipated by the URI producer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074041Z" creationid="pingfangx" creationdate="20190902T074041Z">
        <seg>但是，此类使用需要自己承担费用：域名所有权可能会因 URI 生产者未预料到的原因而发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064719Z" creationid="pingfangx" creationdate="20190830T064719Z">
        <seg>但是，303(请参阅其他)响应可用于指示用户代理检索可缓存资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the definition associated with a MIME character set name MUST fully specify the mapping to be performed from octets to characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114956Z" creationid="pingfangx" creationdate="20190828T114956Z">
        <seg>但是，与 MIME 字符集名称关联的定义必须完全指定要从八位字节到字符执行的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the following will call since the `take` operator cancels after the set amount of `onNext` events have been delivered:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115236Z" creationid="pingfangx" creationdate="20190618T115236Z">
        <seg>但是，以下内容将调用，因为 `take` 操作符在已经传递了 `onNext` 事件的设定数量后取消：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the lambda `v -&gt; v * v` doesn't run in parallel for this flow; it receives the values 1 to 10 on the same computation thread one after the other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075726Z" creationid="pingfangx" creationdate="20190617T075726Z">
        <seg>但是，lambda `v -&gt; v * v` 不会并行运行；它一个接一个地在同一个计算线程上接收值 1 到 10。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the minor version was not incremented for the changes introduced between [RFC2068] and [RFC2616], and this revision has specifically avoided any such changes to the protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104027Z" creationid="pingfangx" creationdate="20190830T104027Z">
        <seg>但是，对于 [RFC2068] 和 [RFC2616] 之间引入的更改，次要版本没有增加，并且此修订版特别避免了对协议的任何此类更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the producing thread with the for loop can't know this and keeps `onNext`ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072156Z" creationid="pingfangx" creationdate="20190621T072156Z">
        <seg>但是，带有 for 循环的生产线程无法知道这一点，并保持调用 `onNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T073805Z" creationid="pingfangx" creationdate="20190830T073805Z">
        <seg>但是，服务器不应该指示成功，除非在给出响应时，它打算删除资源或将其移动到不可访问的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the set of allowed methods can change dynamically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133934Z" creationid="pingfangx" creationdate="20190831T133934Z">
        <seg>但是，允许的方法集可以动态更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are no such limitations in practice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135351Z" creationid="pingfangx" creationdate="20190831T135351Z">
        <seg>但是，在实践中没有这样的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142702Z" creationid="pingfangx" creationdate="20190831T142702Z">
        <seg>但是，不能保证这样的状态改变是可观察的，因为目标资源可能被其他用户代理并行地操作，或者在接收到任何后续 GET 之前可能受到源服务器的动态处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is not true for `onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083151Z" creationid="pingfangx" creationdate="20190621T083151Z">
        <seg>但是，对于 `onStart` 来说，情况并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this requirement is not be construed as preventing a server from defending itself against denial-of-service attacks, or from badly broken client implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025628Z" creationid="pingfangx" creationdate="20190830T025628Z">
        <seg>然而，这一要求并不能被解释为阻止服务器防御拒绝服务攻击或严重破坏的客户机实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, unlike in a file system, these dot-segments are only interpreted within the URI path hierarchy and are removed as part of the resolution process (Section 5.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082509Z" creationid="pingfangx" creationdate="20190902T082509Z">
        <seg>但是，与文件系统不同，这些点段仅在 URI 路径层次结构中进行解释，并作为解析过程的一部分被删除(第 5.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable that does not start emitting items to subscribers until asked</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110131Z" creationid="pingfangx" creationdate="20190620T110131Z">
        <seg>我想要一个 Observable，直到被问到才开始向订阅者发送项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable that will notify observers of an error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110039Z" creationid="pingfangx" creationdate="20190620T110039Z">
        <seg>我想要一个 Observable 来通知观察者一个错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable to invoke a particular action when certain events occur</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110026Z" creationid="pingfangx" creationdate="20190620T110026Z">
        <seg>我希望 Observable 在发生某些事件时调用特定的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable to recover gracefully</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110050Z" creationid="pingfangx" creationdate="20190620T110050Z">
        <seg>我希望 Observable 能够优雅地恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an operator to operate on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110007Z" creationid="pingfangx" creationdate="20190620T105954Z">
        <seg>我希望操作符在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to collect items from an Observable and reemit them as buffers of items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105208Z" creationid="pingfangx" creationdate="20190620T105208Z">
        <seg>我想从 Observable 收集项目并将它们重新作为项目的缓冲区重新提交</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to convert the entire sequence of items emitted by an Observable into some other data structure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105950Z" creationid="pingfangx" creationdate="20190620T105950Z">
        <seg>我想将 Observable 发射的整个项目序列转换为其他一些数据结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create a new Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104859Z" creationid="pingfangx" creationdate="20190620T104216Z">
        <seg>我想创建一个新 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create a resource that has the same lifespan as the Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110113Z" creationid="pingfangx" creationdate="20190620T110113Z">
        <seg>我想创建一个与 Observable 具有相同生命周期的资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create an Observable by combining other Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104904Z" creationid="pingfangx" creationdate="20190620T104525Z">
        <seg>我想通过组合其他 Observable 来创建一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to emit the items from an Observable after transforming them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104848Z" creationid="pingfangx" creationdate="20190620T104848Z">
        <seg>我希望在转换后从 Observable 中发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to evaluate the entire sequence of items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105736Z" creationid="pingfangx" creationdate="20190620T105736Z">
        <seg>我想计算 Observable 发射的整个项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105119Z" creationid="pingfangx" creationdate="20190620T105119Z">
        <seg>我想忽略 Observable 发射的所有项目，只传递完成/错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to mirror an Observable but prefix items to its sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105157Z" creationid="pingfangx" creationdate="20190620T105157Z">
        <seg>我想镜像 Observable 仅要它的序列前缀项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105726Z" creationid="pingfangx" creationdate="20190620T105726Z">
        <seg>我想重新发射 Observable 中的项目，条件是它是 Observables 的第一个发射项目的条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to reemit only certain items from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105256Z" creationid="pingfangx" creationdate="20190620T105256Z">
        <seg>我想仅重新提交 Observable 中的某些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to retrieve a particular item emitted by an Observable:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105238Z" creationid="pingfangx" creationdate="20190620T105238Z">
        <seg>我想检索一个 Observable 发射的特定项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to shift the items emitted by an Observable forward in time before reemitting them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105033Z" creationid="pingfangx" creationdate="20190620T105033Z">
        <seg>我希望在重新发送之前向前移动 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to split one Observable into multiple Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105222Z" creationid="pingfangx" creationdate="20190620T105222Z">
        <seg>我想将一个 Observable 拆分成多个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to subscribe to an Observable and receive a &lt;c0&gt;Future&lt;/c0&gt; that blocks until the Observable completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110122Z" creationid="pingfangx" creationdate="20190620T110122Z">
        <seg>我想订阅一个 Observable 并接收一个阻塞的 &lt;c0&gt;Future&lt;/c0&gt;，直到 Observable 完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to transform items &lt;e0&gt;and&lt;/e0&gt; notifications from an Observable into items and reemit them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105054Z" creationid="pingfangx" creationdate="20190620T105054Z">
        <seg>我想将来自 Observable 的项目 &lt;e0&gt;和&lt;/e0&gt; 通知转换为项目并重新发送它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IANA Considerations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091040Z" creationid="pingfangx" creationdate="20190830T091040Z">
        <seg>IANA 注意事项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>INTRODUCTION</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071153Z" creationid="pingfangx" creationdate="20190828T071153Z">
        <seg>介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IRS     - initial receive sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111817Z" creationid="pingfangx" creationdate="20190827T111817Z">
        <seg>IRS     - 初始接收序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ISS     - initial send sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111745Z" creationid="pingfangx" creationdate="20190827T111745Z">
        <seg>ISS     - 初始发送序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073100Z" creationid="pingfangx" creationdate="20190828T073100Z">
        <seg>幂等方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to pipelining because they can be automatically retried after a connection failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111840Z" creationid="pingfangx" creationdate="20190831T111840Z">
        <seg>幂等方法([RFC7231] 的第 4.2.2 节)对流水线操作很重要，因为它们可以在连接失败后自动重试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134442Z" creationid="pingfangx" creationdate="20190831T134442Z">
        <seg>幂等方法是有区别的，因为如果在客户端能够读取服务器响应之前发生通信故障，则可以自动重复请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115713Z" creationid="pingfangx" creationdate="20190831T115713Z">
        <seg>鉴别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifying Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042814Z" creationid="pingfangx" creationdate="20190902T042814Z">
        <seg>识别数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifying a Target Resource</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090926Z" creationid="pingfangx" creationdate="20190830T090926Z">
        <seg>识别目标资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifying the source and reason for these exceptions can be tiresome, especially if they originate from a source and get routed to `RxJavaPlugins.onError` somewhere lower the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091000Z" creationid="pingfangx" creationdate="20190618T091000Z">
        <seg>识别这些异常的来源和原因可能很烦人，特别是如果它们来自一个源并且在链的某个地方被路由到 `RxJavaPlugins.onError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Request-URI is an absoluteURI, the host is part of the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102021Z" creationid="pingfangx" creationdate="20190829T102021Z">
        <seg>如果 Request-URI 是 absoluteURI，host 是 Request-URI 的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105030Z" creationid="pingfangx" creationdate="20190827T105030Z">
        <seg>如果存在 SYN，则序列号是初始序列号(ISN)，第一个数据八位字节是 ISN + 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a Transfer-Encoding header field is present and the chunked transfer coding (Section 4.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101549Z" creationid="pingfangx" creationdate="20190831T101549Z">
        <seg>如果存在传输编码首部字段并且分块传输编码(部分 4.1)是最终编码，则通过读取和解码分块数据来确定消息体长度，直到传输编码指示数据完成为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101618Z" creationid="pingfangx" creationdate="20190831T101618Z">
        <seg>如果请求中存在 Transfer-Encoding 首部字段并且分块传输编码不是最终编码，则不能可靠地确定消息体长度；服务器必须使用 400(错误请求)状态代码进行响应，然后关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding, the message body length is determined by reading the connection until it is closed by the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101604Z" creationid="pingfangx" creationdate="20190831T101604Z">
        <seg>如果响应中存在 Transfer-Encoding 首部字段并且分块传输编码不是最终编码，则通过读取连接来确定消息体长度，直到服务器关闭它为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a URI containing an IP-literal that starts with "v" (case-insensitive), indicating that the version flag is present, is dereferenced by an application that does not know the meaning of that version flag, then the application should return an appropriate error for "address mechanism not supported".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074626Z" creationid="pingfangx" creationdate="20190902T074626Z">
        <seg>如果包含以“v”（不区分大小写）开头的 IP 文本的 URI（表示存在版本标志）被不知道该版本标志含义的应用程序取消引用，则应用程序应返回“不支持地址机制”的相应错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073402Z" creationid="pingfangx" creationdate="20190902T073402Z">
        <seg>如果 URI 包含权限组件，则路径组件必须为空或以斜杠(“/”)字符开头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081625Z" creationid="pingfangx" creationdate="20190902T081625Z">
        <seg>如果 URI 不包含权限组件，则路径不能以两个斜杠字符(“//”)开头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a client does such a retry, it MUST NOT pipeline before it knows the connection is persistent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151440Z" creationid="pingfangx" creationdate="20190829T151440Z">
        <seg>如果客户端进行了这样的重试，它必须在它知道连接是持久的之前才进行流水线传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a client or server does not detect the other side's close promptly it could cause unnecessary resource drain on the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152209Z" creationid="pingfangx" creationdate="20190829T152209Z">
        <seg>如果客户端或服务器没有及时检测到另一方的关闭，则可能导致网络上不必要的资源消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a custom class implementing `Subscriber` was employed before, subscribing it to a `Flowable` adds an internal wrapper that ensures observing the Flowable is 100% compliant with the specification at the cost of some per-item overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085333Z" creationid="pingfangx" creationdate="20190618T085333Z">
        <seg>如果之前使用了实现 `Subscriber` 的自定义类，则将它订阅到 `Flowable` 会添加一个内部包装器，以确保观察 Flowable 100% 符合规范，代价是每个项目的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a higher version request is received, the proxy/gateway MUST either downgrade the request version, or respond with an error, or switch to tunnel behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104111Z" creationid="pingfangx" creationdate="20190828T104111Z">
        <seg>如果收到更高版本的请求，代理/网关必须降级请求版本，或者响应错误，或切换到隧道行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T062637Z" creationid="pingfangx" creationdate="20190831T062637Z">
        <seg>如果已指示消息体，则将其作为流读取，直到读取等于消息体长度的八位字节数或关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., "Content-Length: 42, 42"), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101108Z" creationid="pingfangx" creationdate="20190831T101108Z">
        <seg>如果收到的消息具有多个 Content-Length 首部字段，其字段值包含相同的十进制值，或者单个 Content-Length 首部字段，其字段值包含相同十进制值的列表(例如，"Content-Length: 42, 42")，表示上游消息处理器生成或组合了重复的 Content-Length 首部字段，然后接收者必须要么拒绝该消息为无效，要么用单个有效的包含十进制值的 Content-Length 字段替换重复的字段值，在确定消息正文长度或转发消息之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101625Z" creationid="pingfangx" creationdate="20190831T101625Z">
        <seg>如果收到包含 Transfer-Encoding 和 Content-Length 首部字段的消息，则 Transfer-Encoding 将覆盖 Content-Length。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085256Z" creationid="pingfangx" creationdate="20190829T085256Z">
        <seg>如果收到带有 Transfer-Encoding 首部字段和 Content-Length 首部字段的消息，则必须忽略后者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102056Z" creationid="pingfangx" creationdate="20190831T102056Z">
        <seg>如果在没有 Transfer-Encoding 的情况下收到消息并且具有不同字段值的多个 Content-Length 首部字段或具有无效值的单个 Content-Length 首部字段，则消息成帧无效且接收者必须将其视为不可恢复的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064927Z" creationid="pingfangx" creationdate="20190830T064927Z">
        <seg>如果创建了新资源，则源服务器必须通过 201(已创建)响应通知用户代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a parameter has a quality value of 0, then content with this parameter is `not acceptable' for the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154054Z" creationid="pingfangx" creationdate="20190828T154054Z">
        <seg>如果参数的质量值为 0，则具有此参数的内容对于客户端来说是“不可接受的”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123659Z" creationid="pingfangx" creationdate="20190831T123659Z">
        <seg>如果代理适用，则客户端通过建立(或重用)与该代理的连接来连接入站。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a proxy receives a fully qualified domain name, the proxy MUST NOT change the host name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112725Z" creationid="pingfangx" creationdate="20190828T112725Z">
        <seg>如果代理收到完全限定的域名，则代理不得更改主机名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a proxy receives a host name which is not a fully qualified domain name, it MAY add its domain to the host name it received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112717Z" creationid="pingfangx" creationdate="20190828T112717Z">
        <seg>如果代理收到的主机名不是完全限定的域名，则可以将其域添加到收到的主机名中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of "*" when it forwards the request to the indicated origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125221Z" creationid="pingfangx" creationdate="20190831T125221Z">
        <seg>如果代理接收到具有绝对形式的 request-target 的 OPTIONS 请求，其中 URI 具有空路径且没有查询组件，那么请求链上的最后一个代理必须在转发时发送请求目标“*”对指定的源服务器的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a request contains a message-body and a Content-Length is not given, the server SHOULD respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes to insist on receiving a valid Content-Length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090310Z" creationid="pingfangx" creationdate="20190829T090310Z">
        <seg>如果一个请求包含一个消息体并且没有给出 Content-Length，那么服务器应该响应 400(错误的请求)，如果它不能确定消息的长度，或者如果它坚持希望收到有效的内容长度，则应该响应 411(需要的长度)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a reserved character is found in a URI component and no delimiting role is known for that character, then it must be interpreted as representing the data octet corresponding to that character's encoding in US-ASCII.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071045Z" creationid="pingfangx" creationdate="20190902T071045Z">
        <seg>如果在 URI 组件中找到保留字符且该字符不知道分隔角色，则必须将其解释为表示与 US-ASCII 中该字符的编码对应的数据八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064653Z" creationid="pingfangx" creationdate="20190830T064653Z">
        <seg>如果在源服务器上创建了资源，则响应应该是 201(已创建)并包含描述请求状态的实体，并引用新资源和 Location 首部(请参阅第 14.30 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102941Z" creationid="pingfangx" creationdate="20190831T102941Z">
        <seg>如果响应终止于首部部分的中间(在接收空行之前)并且状态代码可能依赖于首部字段来传达响应的完整含义，则客户端不能假定已经传达了意义；客户端可能需要重复请求以确定接下来要采取的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105958Z" creationid="pingfangx" creationdate="20190827T105958Z">
        <seg>如果一个报文段包含的求校验和的首部和文本八位字节是奇数，则最后一个八位字节在右边用零填充，形成一个 16 位字用于求校验和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a server has such knowledge (typically from some source external to HTTP or TLS) it SHOULD check the identity as described above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T113151Z" creationid="pingfangx" creationdate="20190901T113151Z">
        <seg>如果服务器具有这样的知识(通常来自 HTTP 或 TLS 外部的某些源)，它应该如上所述检查身份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112817Z" creationid="pingfangx" creationdate="20190831T112817Z">
        <seg>如果服务器立即关闭 TCP 连接，则存在客户端无法读取最后一个 HTTP 响应的重大风险。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a server receives both an Upgrade and an Expect header field with the "100-continue" expectation (Section 5.1.1 of [RFC7231]), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113811Z" creationid="pingfangx" creationdate="20190831T113811Z">
        <seg>如果服务器同时收到具有“100-continue”期望的 Upgrade 和 Expect 首部字段([RFC7231] 的第 5.1.1 节)，则服务器必须在发送 101(交换协议)响应之前发送 100(继续)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subjectAltName extension of type dNSName is present, that MUST be used as the identity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103911Z" creationid="pingfangx" creationdate="20190901T103911Z">
        <seg>如果存在类型为 dNSName 的 subjectAltName 扩展名，则必须将其用作标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102213Z" creationid="pingfangx" creationdate="20190831T102213Z">
        <seg>如果在没有 Transfer-Encoding 的情况下存在有效的 Content-Length 首部字段，则其十进制值以八位字节定义预期的消息体长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an ACK is not forthcoming, after the user timeout the connection is aborted and the user is told.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063752Z" creationid="pingfangx" creationdate="20190828T063752Z">
        <seg>如果没有即将发出 ACK，则在用户超时后，中止连接并告知用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field with the "100-continue" expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the client sees the connection close before receiving any status from the server, the client SHOULD retry the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030314Z" creationid="pingfangx" creationdate="20190830T030314Z">
        <seg>如果 HTTP/1.1 客户端发送包含请求主体的请求，但不包含具有“100-continue”期望的 Expect 请求首部字段，并且客户端未直接连接到 HTTP/1.1 源服务器，如果客户端在从服务器接收任何状态之前看到连接关闭，则客户端应该重试该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an application receives an unrecognized multipart subtype, the application MUST treat it as being equivalent to "multipart/mixed".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152758Z" creationid="pingfangx" creationdate="20190828T152758Z">
        <seg>如果应用程序收到无法识别的多部分子类型，则应用程序必须将其视为等同于“multipart/mixed”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an entity-body is encoded with a content-coding, the underlying data MUST be in a form defined above prior to being encoded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151622Z" creationid="pingfangx" creationdate="20190828T151622Z">
        <seg>如果实体主体使用内容编码进行编码，则基础数据必须采用上面定义的形式，然后再进行编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064949Z" creationid="pingfangx" creationdate="20190830T064949Z">
        <seg>如果修改了现有资源，则应该发送 200(OK)或 204(No Content)响应代码以指示请求的成功完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an incoming segment has a security level, or compartment, or precedence which does not exactly match the level, and compartment, and precedence requested for the connection,a reset is sent and connection goes to the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061654Z" creationid="pingfangx" creationdate="20190828T061654Z">
        <seg>如果传入的报文段具有与连接请求的级别，compartment 和优先级不完全匹配的安全级别，compartment 或优先级，则会发送重置并且连接将进入 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has to offer a reactive base type, however, the user will receive the full reactive class (as giving out an `XSource` is practically useless as it doesn't have operators on it):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061740Z" creationid="pingfangx" creationdate="20190618T061740Z">
        <seg>但是，如果操作符必须提供响应型基类型，则用户将收到完整的响应类(因为它没有运算符，因此发出 `XSource` 实际上是无用的)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an undeliverable exception is an instance/descendant of `NullPointerException`, `IllegalStateException` (`UndeliverableException` and `ProtocolViolationException` extend this), `IllegalArgumentException`, `CompositeException`, `MissingBackpressureException` or `OnErrorNotImplementedException`, the `UndeliverableException` wrapping doesn't happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091305Z" creationid="pingfangx" creationdate="20190618T091305Z">
        <seg>如果一个无法传递的异常是 `NullPointerException` 的实例/后代，`IllegalStateException`(`UndeliverableException` 和 `ProtocolViolationException` 扩展了它)，`IllegalArgumentException`，`CompositeException`，`MissingBackpressureException` 或 `OnErrorNotImplementedException`，那么 `UndeliverableException` 包装不会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an unsolicited FIN arrives from the network, the receiving TCP can ACK it and tell the user that the connection is closing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063719Z" creationid="pingfangx" creationdate="20190828T063719Z">
        <seg>如果未经请求的 FIN 从网络到达，则接收 TCP 可以确认它并告诉用户连接正在关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121400Z" creationid="pingfangx" creationdate="20190829T121400Z">
        <seg>当且仅当媒体类型未由 Content-Type 字段给出时，接收者可以尝试通过检查其内容和/或用于标识资源的 URI 的名称扩展名来猜测媒体类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any transfer coding other than chunked is applied to a request payload body, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091517Z" creationid="pingfangx" creationdate="20190831T091517Z">
        <seg>如果除了 chunked 之外的任何传输编码被应用于请求有效载荷主体，则发送方必须应用 chunked 作为最终传输编码以确保消息被正确地成帧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091543Z" creationid="pingfangx" creationdate="20190831T091543Z">
        <seg>如果除了 chunked 之外的任何传输编码被应用于响应有效载荷主体，则发送方必须应用 chunked 作为最终传输编码或通过关闭连接来终止消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If at any point an error status is received, the client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030525Z" creationid="pingfangx" creationdate="20190830T030525Z">
        <seg>如果在任何时候收到错误状态，则客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If at site A the connection no longer exists, then an attempt by the user at site B to send any data on it will result in the site B TCP receiving a reset control message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043711Z" creationid="pingfangx" creationdate="20190828T043711Z">
        <seg>如果在站点 A 处连接不再存在，则站点 B 处的用户尝试在其上发送任何数据将导致站点 B TCP 接收重置控制消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If client sees that the connection is closed prematurely, repeat from step 1 until the request is accepted, an error response is received, or the user becomes impatient and terminates the retry process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030520Z" creationid="pingfangx" creationdate="20190830T030520Z">
        <seg>如果客户端看到连接过早关闭，则从步骤 1 开始重复，直到接受请求，收到错误响应，或者用户变得不耐烦并终止重试过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If data for a URI component would conflict with a reserved character's purpose as a delimiter, then the conflicting data must be percent-encoded before the URI is formed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070122Z" creationid="pingfangx" creationdate="20190902T070122Z">
        <seg>如果 URI 组件的数据与保留字符作为分隔符的目的冲突，则冲突数据必须在形成 URI 之前进行百分比编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If either the client or the server sends the close token in the Connection header, that request becomes the last one for the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150906Z" creationid="pingfangx" creationdate="20190829T150906Z">
        <seg>如果客户端或服务器在 Connection 首部中发送关闭标记，则该请求将成为连接的最后一个请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If host is a registered name, the registered name is an indirect identifier for use with a name resolution service, such as DNS, to find an address for that origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044246Z" creationid="pingfangx" creationdate="20190831T044246Z">
        <seg>如果 host 是注册名称，则注册名称是与名称解析服务(如 DNS)一起使用的间接标识符，用于查找该源服务器的地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If host matches the rule for IPv4address, then it should be considered an IPv4 address literal and not a reg-name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074237Z" creationid="pingfangx" creationdate="20190902T074237Z">
        <seg>如果主机匹配 IPv4address 的规则，则应将其视为 IPv4 地址文字，而不是注册名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it responds with a final status code, it MAY close the transport connection or it MAY continue to read and discard the rest of the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024938Z" creationid="pingfangx" creationdate="20190830T024938Z">
        <seg>如果它以最终状态代码响应，它可以关闭传输连接，或者它可以继续读取并丢弃请求的其余部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one identity of a given type is present in the certificate (e.g., more than one dNSName name, a match in any one of the set is considered acceptable.) Names may contain the wildcard character * which is considered to match any single domain name component or component fragment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111305Z" creationid="pingfangx" creationdate="20190901T111305Z">
        <seg>如果证书中存在多个给定类型的标识(例如，多个 dNSName 名称，则认为任何一个集合中的匹配都是可接受的。)名称可以包含通配符 *，该通配符被认为与任何单个匹配域名组件或组件片段匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042347Z" creationid="pingfangx" creationdate="20190830T042347Z">
        <seg>如果请求中不存在 Max-Forwards 字段，则转发的请求不得包含 Max-Forwards 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no error response is received, after T seconds transmit the body of the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030452Z" creationid="pingfangx" creationdate="20190830T030452Z">
        <seg>如果没有收到错误响应，则在 T 秒之后发送请求的正文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no proxy is applicable, a typical client will invoke a handler routine, usually specific to the target URI's scheme, to connect directly to an authority for the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123728Z" creationid="pingfangx" creationdate="20190831T123728Z">
        <seg>如果没有适用的代理，典型的客户端将调用通常特定于目标 URI 方案的处理程序例程，以直接连接到目标资源的权限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no response body is included, the response MUST include a Content-Length field with a field-value of "0".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042228Z" creationid="pingfangx" creationdate="20190830T042228Z">
        <seg>如果不包括响应主体，则响应必须包括具有字段值“0”的 Content-Length 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no such representation exists, then the semantics of the fragment are considered unknown and are effectively unconstrained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083641Z" creationid="pingfangx" creationdate="20190902T083641Z">
        <seg>如果不存在这样的表示，则片段的语义被认为是未知的并且实际上是不受约束的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, then if a Host header field is supplied with a non-empty field-value, the authority component is the same as the Host field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131014Z" creationid="pingfangx" creationdate="20190831T131014Z">
        <seg>如果不是，则如果向 Host 首部字段提供非空字段值，则授权组件与 Host 字段值相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, then if the request-target is in authority-form, the effective request URI's authority component is the same as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131002Z" creationid="pingfangx" creationdate="20190831T131002Z">
        <seg>如果不是，那么如果请求目标是权限形式，则有效请求 URI 的权限组件与请求目标相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one decides to add a non-empty global error consumer, here is an example that manages the typical undeliverable exceptions based on whether they represent a likely bug or an ignorable application/network state:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092931Z" creationid="pingfangx" creationdate="20190618T092931Z">
        <seg>如果决定添加一个非空的全局错误消费者，这里有一个例子来管理典型的无法传递的异常，具体取决于它们是代表可能的错误还是可忽略的应用程序/网络状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one has initialization logic after the call to `request(1)` which is needed by `onNext`, you may end up with exceptions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083433Z" creationid="pingfangx" creationdate="20190621T083433Z">
        <seg>如果在调用 `request(1)` 之后有 `onNext` 所需的初始化逻辑，则可能会以异常结束：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one has to handle multiple resources, create a `CompositeSubscription`, associate it with the emitter and then add further resources to the `CompositeSubscription` itself:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022827Z" creationid="pingfangx" creationdate="20190624T022827Z">
        <seg>如果必须处理多个资源，创建一个 `CompositeSubscription`，将它与发射器关联，然后将更多资源添加到 `CompositeSubscription` 本身：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one needs those customization, using `NONE` as the backpressure mode and applying the relevant `onBackpressureXXX` on the resulting `Flowable` is the way to go.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022124Z" creationid="pingfangx" creationdate="20190624T022124Z">
        <seg>如果需要那些定制，使用 `NONE` 作为背压模式并在生成的 `Flowable` 上应用相关的 `onBackpressureXXX` 是可行的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created (Section 7.1.2) and a representation that describes the status of the request while referring to the new resource(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141714Z" creationid="pingfangx" creationdate="20190831T141714Z">
        <seg>如果由于成功处理 POST 请求而在源服务器上创建了一个或多个资源，则源服务器应该发送包含 Location 首部字段的 201（Created）响应，该字段提供所创建的主资源的标识符（第 7.1.2 节）以及在引用新资源时描述请求状态的表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one was using `Flowable.subscribe(Subscriber&lt;? super T&gt;)` with the built-in RxJava `Subscriber` implementations such as `DisposableSubscriber`, `TestSubscriber` and `ResourceSubscriber`, there is a small runtime overhead (one `instanceof` check) associated when the code is not recompiled against 2.0.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085238Z" creationid="pingfangx" creationdate="20190618T085238Z">
        <seg>如果使用 `Flowable.subscribe(Subscriber&lt;? super T&gt;)` 和内置的 RxJava `Subscriber` 实现，如 `DisposableSubscriber`，`TestSubscriber` 和 `ResourceSubscriber`，那么在不根据 2.0.7 重新编译代码时，会有一个较小的运行时开销（一个 `instanceof` 检查）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If our SYN has been acknowledged (perhaps in this incoming segment) the precedence level of the incoming segment must match the local precedence level exactly, if it does not a reset must be sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061024Z" creationid="pingfangx" creationdate="20190828T061024Z">
        <seg>如果我们的 SYN 已被确认(可能在此传入报文段中)，则传入报文段的优先级必须与本地优先级完全匹配，如果不是，则必须发送重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If our SYN has not been acknowledged and the precedence level of the incoming segment is higher than the precedence level requested then either raise the local precedence level (if allowed by the user and the system) or send a reset; or if the precedence level of the incoming segment is lower than the precedence level requested then continue as if the precedence matched exactly (if the remote TCP cannot raise the precedence level to match ours this will be detected in the next segment it sends, and the connection will be terminated then).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061003Z" creationid="pingfangx" creationdate="20190828T061003Z">
        <seg>如果我们的 SYN 未被确认且传入报文段的优先级高于请求的优先级，则提高本地优先级(如果用户和系统允许)或发送重置；或者如果传入报文段的优先级低于请求的优先级，则继续，就好像优先级完全匹配一样(如果远程 TCP 不能提高优先级以匹配我们的优先级将在它发送的下一个报文段中检测到，并且连接将被终止)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If some of the values can be safely ignored, one can use the sampling (with time or another `Flowable`) and throttling operators (`throttleFirst`, `throttleLast`, `throttleWithTimeout`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091633Z" creationid="pingfangx" creationdate="20190621T091633Z">
        <seg>如果可以安全地忽略某些值，可以使用采样(使用时间或其他 `Flowable`)和限制操作符(`throttleFirst`，`throttleLast`，`throttleWithTimeout`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103404Z" creationid="pingfangx" creationdate="20190831T103404Z">
        <seg>如果需要使用行结束来终止请求消息体，则用户代理必须将终止 CRLF 八位字节计为消息体长度的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105220Z" creationid="pingfangx" creationdate="20190827T105220Z">
        <seg>如果设置了 ACK 控制位，则该字段包含该报文段的发送者期望接收的下一个序列号的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042338Z" creationid="pingfangx" creationdate="20190830T042338Z">
        <seg>如果 Max-Forwards 字段值是大于零的整数，则代理必须在转发请求时递减字段值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Max-Forwards field-value is zero ("0"), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042326Z" creationid="pingfangx" creationdate="20190830T042326Z">
        <seg>如果 Max-Forwards 字段值为零(“0”)，则代理不得转发该消息；相反，代理应该响应自己的通信选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then the media type MUST be indicated by a Content-Type field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041719Z" creationid="pingfangx" creationdate="20190830T041719Z">
        <seg>如果 OPTIONS 请求包括实体主体(由 Content-Length 或 Transfer-Encoding 的存在指示)，则媒体类型必须由 Content-Type 字段指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064915Z" creationid="pingfangx" creationdate="20190830T064915Z">
        <seg>如果 Request-URI 未指向现有资源，并且该 URI 能够被请求用户代理定义为新资源，则源服务器可以使用该 URI 创建资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI is an asterisk ("*"), the OPTIONS request is intended to apply to the server in general rather than to a specific resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041822Z" creationid="pingfangx" creationdate="20190830T041822Z">
        <seg>如果 Request-URI 是星号(“*”)，则 OPTIONS 请求通常应用于服务器而不是特定资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI is encoded using the "% HEX HEX" encoding [42], the origin server MUST decode the Request-URI in order to properly interpret the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101317Z" creationid="pingfangx" creationdate="20190829T101317Z">
        <seg>如果使用 "% HEX HEX" 编码 [42] 对 Request-URI 进行编码，则源服务器必须解码 Request-URI 以正确解释请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI is not an absoluteURI, and the request includes a Host header field, the host is determined by the Host header field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102103Z" creationid="pingfangx" creationdate="20190829T102103Z">
        <seg>如果 Request-URI 不是 absoluteURI，并且请求包括 Host 首部字段，则主机由 Host 首部字段值确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041956Z" creationid="pingfangx" creationdate="20190830T041956Z">
        <seg>如果 Request-URI 不是星号，则 OPTIONS 请求仅适用于与该资源通信时可用的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062214Z" creationid="pingfangx" creationdate="20190830T062214Z">
        <seg>如果 Request-URI 引用数据生成过程，则生成的数据应作为响应中的实体而不是过程的源文本返回，除非该文本恰好是过程的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064855Z" creationid="pingfangx" creationdate="20190830T064855Z">
        <seg>如果 Request-URI 引用已经存在的资源，则包含的实体应该被视为驻留在源服务器上的实体的修改版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the SYN at line 6 had arrived before the RST, a more complex exchange might have occurred with RST's sent in both directions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043340Z" creationid="pingfangx" creationdate="20190828T043340Z">
        <seg>如果第 6 行的 SYN 在 RST 之前到达，则可能在两个方向上发送 RST 时发生更复杂的交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the TCP is in one of the synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it aborts the connection and informs its user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042627Z" creationid="pingfangx" creationdate="20190828T042627Z">
        <seg>如果 TCP 处于同步状态之一(ESTABLISHED，FIN-WAIT-1，FIN-WAIT-2，CLOSE-WAIT，CLOSING，LAST-ACK，TIME-WAIT)，它将中止连接并通知其用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the URI scheme defines a default for host, then that default applies when the host subcomponent is undefined or when the registered name is empty (zero length).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075551Z" creationid="pingfangx" creationdate="20190902T075551Z">
        <seg>如果 URI 方案定义了 host 的默认值，那么当主机子组件未定义或注册名称为空(零长度)时，该默认值适用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the URI-reference's prefix does not match the syntax of a scheme followed by its colon separator, then the URI-reference is a relative reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084349Z" creationid="pingfangx" creationdate="20190902T084325Z">
        <seg>如果 URI 引用的前缀，与方案后跟冒号分隔符的语法不匹配，则 URI 引用是相对引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the `initialRequest` is given, the `TestSubscriber` offers the `requestMore(long)` method to keep requesting in a fluent manner:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101754Z" creationid="pingfangx" creationdate="20190618T101754Z">
        <seg>如果给出 `initialRequest`，那么 `TestSubscriber` 提供 `requestMore(long)` 方法来以流畅的方式继续请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the abs_path is not present in the URL, it MUST be given as "/" when used as a Request-URI for a resource (section 5.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112636Z" creationid="pingfangx" creationdate="20190828T112636Z">
        <seg>如果 URL 中不存在 abs_path，则在用作资源的 Request-URI 时必须以“/”形式给出(第 5.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125539Z" creationid="pingfangx" creationdate="20190831T125539Z">
        <seg>如果目标 URI 缺少或未定义权限组件，则客户端必须发送具有空字段值的 Host 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the body is being sent using a "chunked" encoding (section 3.6), a zero length chunk and empty trailer MAY be used to prematurely mark the end of the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024325Z" creationid="pingfangx" creationdate="20190830T024325Z">
        <seg>如果正在使用“分块”编码发送正文(第 3.6 节)，则可以使用零长度块和空 trailer 来过早标记消息的结尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the body was preceded by a Content-Length header, the client MUST close the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024338Z" creationid="pingfangx" creationdate="20190830T024338Z">
        <seg>如果正文前面有 Content-Length 首部，则客户端必须关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the call is rewritten, it becomes obvious why it works so:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015836Z" creationid="pingfangx" creationdate="20190624T015806Z">
        <seg>如果调用被重写，为什么它会这样的原因就很明显：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the client does retry this request, it MAY use the following "binary exponential backoff" algorithm to be assured of obtaining a reliable response:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030327Z" creationid="pingfangx" creationdate="20190830T030327Z">
        <seg>如果客户端重试此请求，它可以使用以下“二进制指数退避”算法来确保获得可靠的响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the client has a cache [RFC7234] and the request can be satisfied by it, then the request is usually directed there first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123548Z" creationid="pingfangx" creationdate="20190831T123548Z">
        <seg>如果客户端具有缓存 [RFC7234] 并且请求可以被它满足，则通常首先将请求指向该请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the client has external information as to the expected identity of the server, the hostname check MAY be omitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103648Z" creationid="pingfangx" creationdate="20190901T103648Z">
        <seg>如果客户端具有关于服务器的预期标识的外部信息，则可以省略主机名检查。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112522Z" creationid="pingfangx" creationdate="20190831T112522Z">
        <seg>如果客户端看到响应，指示服务器不希望接收消息正文并且正在关闭连接，则客户端应该立即停止传输正文并关闭其连接端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the client sees an error status, it SHOULD immediately cease transmitting the body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024257Z" creationid="pingfangx" creationdate="20190830T024257Z">
        <seg>如果客户端看到错误状态，它应该立即停止传输消息主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code example is left unchanged, this will result in a compile time error (however, often with misleading error message about lack of overload).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092815Z" creationid="pingfangx" creationdate="20190617T092815Z">
        <seg>如果代码示例保持不变，这将导致编译时错误(但是，通常会出现关于缺少重载的误导性错误消息)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the communication is considered in isolation, then successful actions ought to be reflected in corresponding changes to the observable interface provided by servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094352Z" creationid="pingfangx" creationdate="20190830T094352Z">
        <seg>如果单独考虑通信，那么成功的操作应该反映在服务器提供的可观察接口的相应更改中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection does not exist (CLOSED) then a reset is sent in response to any incoming segment except another reset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060605Z" creationid="pingfangx" creationdate="20190828T060605Z">
        <seg>如果连接不存在(CLOSED)，则发送复位以响应除另一个复位之外的任何传入报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection is from a trusted gateway, that inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132139Z" creationid="pingfangx" creationdate="20190831T132139Z">
        <seg>如果连接来自可信网关，则可能会出现这种不一致；否则，它可能表示试图绕过安全过滤器，欺骗服务器传递非公共内容或中毒缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), any unacceptable segment (out of window sequence number or unacceptible acknowledgment number) must elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating the next sequence number expected to be received, and the connection remains in the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061158Z" creationid="pingfangx" creationdate="20190828T061158Z">
        <seg>如果连接处于同步状态（ESTABLISHED，FIN-WAIT-1，FIN-WAIT-2，CLOSE-WAIT，CLOSING，LAST-ACK，TIME-WAIT），则任何不可接受的报文段（序列号不在窗口内或不可接授的确认）必须仅引出包含当前发送序列号的空确认报文段和指示预期接收的下一个序列号的确认，并且连接保持相同状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED), and the incoming segment acknowledges something not yet sent (the segment carries an unacceptable ACK), or if an incoming segment has a security level or compartment which does not exactly match the level and compartment requested for the connection, a reset is sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060851Z" creationid="pingfangx" creationdate="20190828T060851Z">
        <seg>如果连接处于任何非同步状态(LISTEN，SYN-SENT，SYN-RECEIVED)，并且传入报文段确认尚未发送的内容(该报文段带有不可接受的 ACK)，或者传入的报文段具有的安全级别或 compartment 与连接请求的级别和 compartment 不完全匹配，则发送重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the data is already available as an array of objects, a list of objects or any `Iterable` source, the respective `from` overloads will handle the backpressure and emission of such sources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020156Z" creationid="pingfangx" creationdate="20190624T020156Z">
        <seg>如果数据已经作为一个对象数组，一个对象列表或任何 `Iterable` 源提供，则相应的 `from` 重载将处理这些源的背压和发射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file doesn't exist or can't be read properly, the end consumer will print out `IOException` directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064328Z" creationid="pingfangx" creationdate="20190618T064328Z">
        <seg>如果文件不存在或无法正确读取，最终消费者将直接打印出 `IOException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102513Z" creationid="pingfangx" creationdate="20190831T102513Z">
        <seg>如果已完全接收到对连接的最后一个请求的最终响应并且仍有其他数据需要读取，则用户代理可以丢弃剩余数据或尝试确定该数据是否属于先前响应主体的一部分，这可能是如果先前消息的 Content-Length 值不正确的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first example is rewritten:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080334Z" creationid="pingfangx" creationdate="20190621T080334Z">
        <seg>如果第一个示例被重写为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the host as determined by rule 1 or 2 is not a valid host on the server, the response MUST be a 400 (Bad Request) error message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102119Z" creationid="pingfangx" creationdate="20190829T102119Z">
        <seg>如果规则 1 或 2 确定的主机不是服务器上的有效主机，则响应必须是 400(错误请求)错误消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the host identifier is provided as an IP address, the origin server is the listener (if any) on the indicated TCP port at that IP address.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044226Z" creationid="pingfangx" creationdate="20190831T044226Z">
        <seg>如果主机标识符作为 IP 地址提供，则源服务器是该 IP 地址上指示的 TCP 端口上的监听器(如果有)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the hostname does not match the identity in the certificate, user oriented clients MUST either notify the user (clients MAY give the user the opportunity to continue with the connection in any case) or terminate the connection with a bad certificate error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111538Z" creationid="pingfangx" creationdate="20190901T111538Z">
        <seg>如果主机名与证书中的标识不匹配，则面向用户的客户端必须通知用户(客户端可以在任何情况下为用户提供继续连接的机会)或终止具有错误证书错误的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the hostname is available, the client MUST check it against the server's identity as presented in the server's Certificate message, in order to prevent man-in-the-middle attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103604Z" creationid="pingfangx" creationdate="20190901T103604Z">
        <seg>如果主机名可用，客户端必须根据服务器的证书消息中显示的服务器身份进行检查，以防止中间人攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112005Z" creationid="pingfangx" creationdate="20190831T112005Z">
        <seg>如果入站连接在接收响应之前失败，则流水线中介可以尝试重试尚未接收响应的请求序列（如果请求都具有幂等方法）;否则，流水线中介应该转发任何收到的响应，然后关闭相应的出站连接，以便出站用户代理可以相应地恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment, otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060658Z" creationid="pingfangx" creationdate="20190828T060658Z">
        <seg>如果传入报文段具有 ACK 字段，则复位从报文段的 ACK 字段获取其序列号，否则复位具有序列号零，并且 ACK 字段被设置为传入报文段的序列号和报文段长度的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the library/code already did this, the undeliverable `InterruptedException`s should stop now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092847Z" creationid="pingfangx" creationdate="20190618T092847Z">
        <seg>如果库/代码已经这样做了，那么无法传递的 `InterruptedException` 应该立即停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the media type remains unknown, the recipient SHOULD treat it as type "application/octet-stream".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121415Z" creationid="pingfangx" creationdate="20190829T121415Z">
        <seg>如果媒体类型仍然未知，则接收者应该将其视为“application/octet-stream”类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the message does include a non- identity transfer-coding, the Content-Length MUST be ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090508Z" creationid="pingfangx" creationdate="20190829T090508Z">
        <seg>如果消息确实包含非标识传输编码，则必须忽略 Content-Length。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063748Z" creationid="pingfangx" creationdate="20190830T063748Z">
        <seg>如果新字段值指示缓存的实体与当前实体不同(如 Content-Length，Content-MD5，ETag 或 Last-Modified 中的更改所示)，则缓存必须将缓存条目视为陈旧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the port is empty or not given, port 80 is assumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T111627Z" creationid="pingfangx" creationdate="20190828T111627Z">
        <seg>如果端口为空或未给出，则假定端口 80。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the port is equal to the default port for a scheme, the normal form is to omit the port subcomponent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060926Z" creationid="pingfangx" creationdate="20190831T060926Z">
        <seg>如果端口等于方案的默认端口，则通常的形式是省略端口子组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044258Z" creationid="pingfangx" creationdate="20190831T044258Z">
        <seg>如果端口子组件为空或未给定，则 TCP 端口 80(WWW 服务的保留端口)是默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the primary resource has multiple representations, as is often the case for resources whose representation is selected based on attributes of the retrieval request (a.k.a., content negotiation), then whatever is identified by the fragment should be consistent across all of those representations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083727Z" creationid="pingfangx" creationdate="20190902T083727Z">
        <seg>如果主要资源具有多个表示，那么对于其表示基于检索请求的属性(例如，内容协商)来选择的资源通常是这种情况，则片段所标识的任何表示应该在所有这些表示中是一致的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134322Z" creationid="pingfangx" creationdate="20190831T134322Z">
        <seg>如果此类资源的目的是执行不安全的操作，那么资源所有者必须在使用安全请求方法访问该操作时禁用或禁止该操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiver was in SYN-RECEIVED state and had previously been in the LISTEN state, then the receiver returns to the LISTEN state, otherwise the receiver aborts the connection and goes to the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061815Z" creationid="pingfangx" creationdate="20190828T061815Z">
        <seg>如果接收器处于 SYN-RECEIVED 状态并且之前一直处于 LISTEN 状态，则接收器返回 LISTEN 状态，否则接收器中止连接并进入 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiver was in any other state, it aborts the connection and advises the user and goes to the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061833Z" creationid="pingfangx" creationdate="20190828T061833Z">
        <seg>如果接收器处于任何其他状态，它将中止连接并通知用户并进入 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiver was in the LISTEN state, it ignores it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061759Z" creationid="pingfangx" creationdate="20190828T061759Z">
        <seg>如果接收器处于 LISTEN 状态，则忽略它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the receiving TCP is in a  non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042612Z" creationid="pingfangx" creationdate="20190828T042612Z">
        <seg>如果接收 TCP 处于非同步状态(即，SYN-SENT，SYN-RECEIVED)，则在接收到可接受的重置时它返回到 LISTEN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025757Z" creationid="pingfangx" creationdate="20190828T025757Z">
        <seg>如果恢复足够快地发生，则 S1 附近的净承载序列号中的任何旧重复可以到达并且被连接的新化身的接收器视为新分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123600Z" creationid="pingfangx" creationdate="20190831T123600Z">
        <seg>如果缓存不满足请求，则典型客户端将检查其配置以确定是否使用代理来满足请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of "message/http".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074418Z" creationid="pingfangx" creationdate="20190830T074418Z">
        <seg>如果请求有效，则响应应该在实体主体中包含整个请求消息，其内容类型为“message/http”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T065055Z" creationid="pingfangx" creationdate="20190830T065055Z">
        <seg>如果请求通过缓存并且 Request-URI 标识一个或多个当前缓存的实体，则这些条目应该被视为陈旧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request-target is in absolute-form, the effective request URI is the same as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130650Z" creationid="pingfangx" creationdate="20190831T130650Z">
        <seg>如果请求目标是绝对格式，则有效请求 URI 与请求目标相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request-target is in authority-form or asterisk-form, the effective request URI's combined path and query component is empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131826Z" creationid="pingfangx" creationdate="20190831T131229Z">
        <seg>如果 request-target 是 authority-form 或 asterisk-from，则有效请求 URI 组合 path 和 query 组件为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request-target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143554Z" creationid="pingfangx" creationdate="20190831T143554Z">
        <seg>如果请求目标不是星号，则 OPTIONS 请求将应用于与目标资源通信时可用的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064959Z" creationid="pingfangx" creationdate="20190830T064959Z">
        <seg>如果无法使用 Request-URI 创建或修改资源，则应该给出适当的错误响应，以反映问题的性质。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142059Z" creationid="pingfangx" creationdate="20190831T142059Z">
        <seg>如果处理 POST 的结果等同于现有资源的表示，则源服务器可以通过在位置字段中发送具有现有资源标识符的 303(请参阅其他)响应来将用户代理重定向到该资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102226Z" creationid="pingfangx" creationdate="20190831T102226Z">
        <seg>如果发送方关闭连接或接收方在收到指定的八位字节数之前超时，则接收方必须认为该消息不完整并关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server chooses to close the connection immediately after sending the response, it SHOULD send a Connection header including the connection-token close.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150630Z" creationid="pingfangx" creationdate="20190829T150630Z">
        <seg>如果服务器在发送响应后选择立即关闭连接，它应该发送一个包含连接标记关闭的 Connection 首部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T070830Z" creationid="pingfangx" creationdate="20190830T070830Z">
        <seg>如果服务器希望将请求应用于不同的 URI，它必须发送 301(永久移动)响应；然后，用户代理可以自己决定是否重定向请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server receives additional data from the client on a fully closed connection, such as another request that was sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112853Z" creationid="pingfangx" creationdate="20190831T112853Z">
        <seg>如果服务器在完全关闭的连接上从客户端接收到其他数据，例如客户端在接收服务器响应之前发送的另一个请求，则服务器的 TCP 堆栈将向客户端发送重置数据包；遗憾的是，重置数据包可能会擦除客户端未确认的输入缓冲区，然后客户端的 HTTP 解析器才能读取和解释它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server responds to that request with a non-interim HTTP response message, as described in Section 6 of [RFC7231], then that response is considered an authoritative answer to the client's request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T054841Z" creationid="pingfangx" creationdate="20190831T054841Z">
        <seg>如果服务器使用非临时 HTTP 响应消息响应该请求，如 [RFC7231] 的第 6 节中所述，那么该响应被视为客户端请求的权威回复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server's configuration (or outbound gateway) provides a fixed URI authority component, that authority is used for the effective request URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130953Z" creationid="pingfangx" creationdate="20190831T130953Z">
        <seg>如果服务器的配置(或出站网关)提供固定的 URI 授权组件，则该授权用于有效的请求 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server's configuration (or outbound gateway) provides a fixed URI scheme, that scheme is used for the effective request URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130855Z" creationid="pingfangx" creationdate="20190831T130855Z">
        <seg>如果服务器的配置(或出站网关)提供固定的 URI 方案，则该方案用于有效的请求 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the source Observable terminates with an error, the &lt;c0&gt;PublishSubject&lt;/c0&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084906Z" creationid="pingfangx" creationdate="20190620T084906Z">
        <seg>如果源 Observable 以错误终止，则 &lt;c0&gt;PublishSubject&lt;/c0&gt; 将不会向后续观察者发射任何项，但只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the target URI includes an authority component, then a client MUST send a field-value for Host that is identical to that authority component, excluding any userinfo subcomponent and its "@" delimiter (Section 2.7.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125521Z" creationid="pingfangx" creationdate="20190831T125521Z">
        <seg>如果目标 URI 包含授权组件，则客户端必须发送与该授权组件相同的 Host 的字段值，不包括任何 userinfo 子组件及其“@”分隔符(第 2.7.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the target URI's path component is empty, the client MUST send "/" as the path within the origin-form of request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123943Z" creationid="pingfangx" creationdate="20190831T123943Z">
        <seg>如果目标 URI 的路径组件为空，则客户端必须发送“/”作为 request-target 的 origin-form 中的路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142802Z" creationid="pingfangx" creationdate="20190831T142802Z">
        <seg>如果目标资源具有一个或多个当前表示，它们可能会或可能不会被源服务器销毁，并且相关存储可能会或可能不会被回收，完全取决于资源的性质及其由源服务器的实现(这超出了本规范的范围)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 4.2.1, the method semantics take precedence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123005Z" creationid="pingfangx" creationdate="20190831T123005Z">
        <seg>如果方法语义与 URI 本身隐含的任何语义之间存在冲突，如第 4.2.1 节所述，则方法语义优先。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this behavior is desirable can be debated, but in any case, if you want to avoid such calls to the uncaught exception handler, the **final application** that uses RxJava 2 (directly or transitively) should set a no-op handler:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090732Z" creationid="pingfangx" creationdate="20190618T090647Z">
        <seg>如果这种行为值得商榷，但无论如何，如果您想避免对未捕获的异常处理程序的这种调用，使用 RxJava 2(直接或传递)的 **最终应用程序** 应该设置一个无操作处理程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a request message and none of the above are true, then the message body length is zero (no message body is present).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102243Z" creationid="pingfangx" creationdate="20190831T102243Z">
        <seg>如果这是请求消息而且以上都不是真的，那么消息体长度为零(不存在消息体)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102124Z" creationid="pingfangx" creationdate="20190831T102124Z">
        <seg>如果这是请求消息，则服务器必须以 400(错误请求)状态代码响应，然后关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102150Z" creationid="pingfangx" creationdate="20190831T102150Z">
        <seg>如果这是代理收到的响应消息，则代理必须关闭与服务器的连接，丢弃收到的响应，并向客户端发送 502(Bad Gateway)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102155Z" creationid="pingfangx" creationdate="20190831T102155Z">
        <seg>如果这是用户代理收到的响应消息，则用户代理必须关闭与服务器的连接并丢弃收到的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this pattern was not employed before, we encourage updating the code/library in question.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092855Z" creationid="pingfangx" creationdate="20190618T092855Z">
        <seg>如果之前没有使用此模式，我们鼓励更新相关代码/库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If two URIs differ only in the case of hexadecimal digits used in percent-encoded octets, they are equivalent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065854Z" creationid="pingfangx" creationdate="20190902T065854Z">
        <seg>如果两个 URI 仅在百分比编码八位字节中使用的十六进制数字的大小写不同，则它们是等效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we'd consume the `iterator` via classic for-loop, that would result in an infinite loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020542Z" creationid="pingfangx" creationdate="20190624T020542Z">
        <seg>如果我们通过经典的 for 循环使用 `iterator`，那将导致无限循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a &lt;c0&gt;Subject&lt;/c0&gt; and you want to pass it along to some other agent without exposing its &lt;c1&gt;Subscriber&lt;/c1&gt; interface, you can mask it by calling its &lt;c2&gt;asObservable&lt;/c2&gt; method, which will return the Subject as a pure &lt;c3&gt;Observable&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085411Z" creationid="pingfangx" creationdate="20190620T085411Z">
        <seg>如果您有一个 &lt;c0&gt;Subject&lt;/c0&gt; 并且想要将其传递给其他代理而不暴露其 &lt;c1&gt;Subscriber&lt;/c1&gt; 接口，则可以通过调用其 &lt;c2&gt;asObservable&lt;/c2&gt; 方法来掩盖它，它将 Subject 作为纯 &lt;c3&gt;Observable&lt;/c3&gt; 返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with &lt;a1&gt;&lt;c2&gt;Create&lt;/c2&gt;&lt;/a1&gt; so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a &lt;c3&gt;ReplaySubject&lt;/c3&gt; instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084854Z" creationid="pingfangx" creationdate="20190620T084854Z">
        <seg>如果您需要保证从 Observable 源传递所有项目，您需要使用 &lt;a1&gt;&lt;c2&gt;Create&lt;/c2&gt;&lt;/a1&gt; 形成 Observable，以便您可以手动重新引入“冷” Observable 行为(在开始发射项目之前检查所有观察者是否已订阅)，或转而使用 &lt;c3&gt;ReplaySubject&lt;/c3&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to perform cleanup on both regular termination or cancellation, consider the operator `using` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115251Z" creationid="pingfangx" creationdate="20190618T115251Z">
        <seg>如果您需要在常规终止或取消时执行清理，请考虑使用操作符 `using`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a &lt;c0&gt;ReplaySubject&lt;/c0&gt; as an observer, take care not to call its &lt;c1&gt;onNext&lt;/c1&gt; method (or its other &lt;c2&gt;on&lt;/c2&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a3&gt;the Observable contract&lt;/a3&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085148Z" creationid="pingfangx" creationdate="20190620T085148Z">
        <seg>如果您使用 &lt;c0&gt;ReplaySubject&lt;/c0&gt; 作为观察者，请注意不要从多个线程调用其 &lt;c1&gt;onNext&lt;/c1&gt; 方法(或其他 &lt;c2&gt;on&lt;/c2&gt; 方法)，这可能导致重合(非顺序)调用，这违反了 &lt;a3&gt;Observable 协议&lt;/a3&gt;，并在结果主题中产生了关于应首先重播哪个项目或通知的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to implement your own operator, see &lt;a1&gt;Implementing Your Own Operators&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094342Z" creationid="pingfangx" creationdate="20190620T094342Z">
        <seg>如果要实现自己的操作符，请参阅 &lt;a1&gt;Implementing Your Own Operators&lt;/a1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular &lt;d0&gt;Schedulers&lt;/d0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085651Z" creationid="pingfangx" creationdate="20190620T085651Z">
        <seg>如果要将多线程引入到 Observable 操作符链中，可以通过指示这些操作符(或特定的 Observable)在特定的 &lt;d0&gt;Schedulers (调度器)&lt;/d0&gt; 操作来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard, shading, etc).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105307Z" creationid="pingfangx" creationdate="20190617T105307Z">
        <seg>如果您的代码本身就是一个库(即它在您自己控制之外的用户的 CLASSPATH 上使用)，则不应使用 beta API，除非您重新打包它们(例如使用 ProGuard，shading 等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform doesn't support Java 8 lambdas (yet), you have to create an inner class of `Consumer` manually:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065916Z" creationid="pingfangx" creationdate="20190617T065916Z">
        <seg>如果您的平台(还)不支持 Java 8 lambdas，您必须手动创建一个内部类`Consumer`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore all but the terminal events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061209Z" creationid="pingfangx" creationdate="20190619T061209Z">
        <seg>忽略除终端事件之外的所有事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 9.5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085402Z" creationid="pingfangx" creationdate="20190831T085402Z">
        <seg>忽略这些首部字段会增加服务器对请求走私攻击的脆弱性(第 9.5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation Diversity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090629Z" creationid="pingfangx" creationdate="20190830T090629Z">
        <seg>实现多样性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation experience and measurements of actual HTTP/1.1 (RFC 2068) implementations show good results [39].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T143052Z" creationid="pingfangx" creationdate="20190829T143052Z">
        <seg>实际 HTTP/1.1(RFC 2068)实现的实施经验和测量结果显示出良好的结果 [39]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation note: In HTTP implementations which do not use persistent connections, the server ordinarily expects to be able to signal end of data by closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103042Z" creationid="pingfangx" creationdate="20190901T103042Z">
        <seg>实现说明：在不使用持久连接的 HTTP 实现中，服务器通常希望能够通过关闭连接来发送数据结束信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112441Z" creationid="pingfangx" creationdate="20190831T112441Z">
        <seg>实现应该不断监视接收到的闭包信号的开放连接，并在适当时对其进行响应，因为连接两端的快速关闭可以回收分配的系统资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations of `request()` in operators ensure proper happens-before relation  (or in other terms, memory release or full fence) when necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084142Z" creationid="pingfangx" creationdate="20190621T084142Z">
        <seg>操作符中 `request()` 的实现确保在必要时有正确的 happens-before 关系(或在其他术语中，内存释放或完全隔离)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations ought to anticipate the need to recover from asynchronous close events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111352Z" creationid="pingfangx" creationdate="20190831T111352Z">
        <seg>实现应该预计需要从异步关闭事件中恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementors may provide TCP users with the ability to select on a connection by connection basis whether to wait after a crash, or may informally implement the "quite time" for all connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025856Z" creationid="pingfangx" creationdate="20190828T025856Z">
        <seg>实现者可以为 TCP 用户提供在连接基础上选择是否在崩溃之后等待的能力，或者可以非正式地实现所有连接的“相当时间”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementors should be aware of IETF character set requirements [38] [41].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115422Z" creationid="pingfangx" creationdate="20190828T115422Z">
        <seg>实现者应该了解 IETF 字符集要求 [38] [41]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementors should be aware that some pre-HTTP/1.1 proxies have been known to rewrite the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101506Z" creationid="pingfangx" creationdate="20190829T101506Z">
        <seg>实现人员应该知道，已经知道一些 HTTP/1.1 之前的代理会重写请求 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementors should be aware that the software represents the user in their interactions over the Internet, and should be careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves or others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T031909Z" creationid="pingfangx" creationdate="20190830T031909Z">
        <seg>实现者应该意识到软件代表用户在互联网上的交互，并且应该小心地让用户知道他们可能采取的任何可能对他们自己或他人有意想不到的意义的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementors will need to be familiar with the notation in order to understand this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092504Z" creationid="pingfangx" creationdate="20190828T092504Z">
        <seg>实现者需要熟悉符号才能理解该规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.x, the `doOnUnsubscribe` was always executed on a terminal event because 1.x' `SafeSubscriber` called `unsubscribe` on itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114822Z" creationid="pingfangx" creationdate="20190618T114822Z">
        <seg>在 1.x 中，`doOnUnsubscribe` 总是在终端事件上执行，因为 1.x 的 `SafeSubscriber` 本身调用 `unsubscribe`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.x, you could create an instance with `GroupedObservable.from()` which was used internally by 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063829Z" creationid="pingfangx" creationdate="20190618T063829Z">
        <seg>在 1.x 中，您可以使用 `GroupedObservable.from()` 创建一个实例，该实例由 1.x 内部使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2.0.7, the operator `strict()` returns `this`, is deprecated and will be removed completely in 2.1.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073837Z" creationid="pingfangx" creationdate="20190618T073837Z">
        <seg>在 2.0.7 中，运算符 `strict()` 返回 `this`，不推荐使用，将在 2.1.0 中完全删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2.x, all use cases now extend `GroupedObservable` directly thus the factory methods are no longer available; the whole class is now abstract.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063859Z" creationid="pingfangx" creationdate="20190618T063859Z">
        <seg>在 2.x 中，所有用例现在都直接继承了 `GroupedObservable`，因此工厂方法不再可用；整个类现在都是抽象的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091121Z" creationid="pingfangx" creationdate="20190831T091121Z">
        <seg>在 HTTP 的情况下，Transfer-Encoding 主要用于准确地界定动态生成的有效载荷，并区分仅用于传输效率或安全性，作为所选资源的特征的有效载荷编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In HTTP, the only unsafe characteristic of message-bodies is the difficulty in determining the exact body length (section 7.2.2), or the desire to encrypt data over a shared transport.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142948Z" creationid="pingfangx" creationdate="20190828T142948Z">
        <seg>在 HTTP 中，消息体的唯一不安全特征是难以确定确切的主体长度(第 7.2.2 节)，或者希望通过共享传输加密数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In HTTP/1.0, most implementations used a new connection for each request/response exchange.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092205Z" creationid="pingfangx" creationdate="20190828T092205Z">
        <seg>在 HTTP/1.0 中，大多数实现为每个请求/响应交换使用了新连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In HTTP/1.1, a connection may be used for one or more request/response exchanges, although connections may be closed for a variety of reasons (see section 8.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092323Z" creationid="pingfangx" creationdate="20190828T092323Z">
        <seg>在 HTTP/1.1 中，连接可以用于一个或多个请求/响应交换，尽管由于各种原因可能会关闭连接(请参阅第 8.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ReactiveX an &lt;d0&gt;observer&lt;/d0&gt; &lt;d1&gt;subscribes&lt;/d1&gt; to an &lt;d2&gt;Observable&lt;/d2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043135Z" creationid="pingfangx" creationdate="20190620T042910Z">
        <seg>在 ReactiveX 中，一个&lt;d0&gt;observer (观察者)&lt;/d0&gt; &lt;d1&gt;subscribes (订阅)&lt;/d1&gt; 一个 &lt;d2&gt;Observable (可观察对象)&lt;/d2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ReactiveX, however, they name the event handlers themselves.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064811Z" creationid="pingfangx" creationdate="20190620T064811Z">
        <seg>但是，在 ReactiveX 中，它们是事件处理程序的名字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava 1.x, the interface `rx.Subscription` was responsible for stream and resource lifecycle management, namely unsubscribing a sequence and releasing general resources such as scheduled tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072636Z" creationid="pingfangx" creationdate="20190618T072636Z">
        <seg>在 RxJava 1.x 中，接口 `rx.Subscription` 负责流和资源生命周期管理，即取消订阅序列并释放一般资源(如计划任务)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava the default `Scheduler`s run on daemon threads, which means once the Java main thread exits, they all get stopped and background computations may never happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073938Z" creationid="pingfangx" creationdate="20190617T073938Z">
        <seg>在 RxJava 中，默认的 `Scheduler` 在守护线程上运行，这意味着一旦 Java 主线程退出，它们都会被停止并且后台计算可能永远不会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava's documentation, **emission**, **emits**, **item**, **event**, **signal**, **data** and **message** are considered synonyms and represent the object traveling along the dataflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071117Z" creationid="pingfangx" creationdate="20190617T071117Z">
        <seg>在 RxJava 的文档中，**emission**, **emits**, **item**, **event**, **signal**, **data** and **message** 被视为同义词并代表沿数据流传播的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava, the dedicated `Flowable` class is designated to support backpressure and `Observable` is dedicated for the non-backpressured operations (short sequences, GUI interactions, etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071432Z" creationid="pingfangx" creationdate="20190617T071432Z">
        <seg>在 RxJava 中，专用的“Flowable”类被指定为支持背压，而“Observable”专用于非背压操作(短序列，GUI 交互等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In `range`'s terms, it will remember that there was a `request(1)` call while it called `onNext()` and once `onNext()` returns, it will make another round and call `onNext()` with the next integer value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T032615Z" creationid="pingfangx" creationdate="20190621T082709Z">
        <seg>在 `range` 的术语中，它会记住在调用 `onNext()` 时有一个 `request(1)` 调用，一旦 `onNext()` 返回，它将进行另一轮，调用指定整数次数的 `onNext()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a later section, more detail is offered with respect to the reaction of the TCP to events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T113237Z" creationid="pingfangx" creationdate="20190827T113237Z">
        <seg>在后面的部分中，提供了有关 TCP 对事件的反应的更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a naive implementation of `range`, such call would recursively call `onNext`, leading to `StackOverflowError` which is of course undesirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082214Z" creationid="pingfangx" creationdate="20190621T082214Z">
        <seg>在 `range` 的简单实现中，这样的调用将递归调用 `onNext`，导致 `StackOverflowError`，这当然是不可取的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025002Z" creationid="pingfangx" creationdate="20190902T025002Z">
        <seg>在对 HEAD 请求的响应中，表示首部字段描述了如果相同的请求是 GET 则将包含在有效载荷主体中的表示数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a response, the payload's purpose is defined by both the request method and the response status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190902T025445Z">
        <seg>在响应中，有效载荷的目的由请求方法和响应状态代码定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition several variables relating to the send and receive sequence numbers are stored in the TCB.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111545Z" creationid="pingfangx" creationdate="20190827T111545Z">
        <seg>另外，与发送和接收序列号有关的几个变量存储在 TCB 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to aiding the readability of such identifiers through the consistent use of familiar syntax, this uniform representation of hierarchy across naming schemes allows scheme-independent references to be made relative to that hierarchy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064737Z" creationid="pingfangx" creationdate="20190902T064737Z">
        <seg>除了通过一致使用熟悉的语法来帮助这些标识符的可读性之外，这种跨命名方案的层次结构的统一表示允许相对于该层次结构进行与方案无关的引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, `org.reactivestreams.Subscriber` has no notion of adding resources to it, cancelling it or requesting from the outside.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065745Z" creationid="pingfangx" creationdate="20190618T065745Z">
        <seg>此外，`org.reactivestreams.Subscriber` 没有向其添加资源，取消或从外部请求的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, a URI reference (Section 4.1) may be a relative-path reference, in which case the first path segment cannot contain a colon (":") character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081650Z" creationid="pingfangx" creationdate="20190902T081650Z">
        <seg>此外，URI 引用(第 4.1 节)可以是相对路径引用，在这种情况下，第一个路径段不能包含冒号(“:”)字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, if the text is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of CR and LF for line breaks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151532Z" creationid="pingfangx" creationdate="20190828T151532Z">
        <seg>此外，如果文本以不分别对 CR 和 LF 使用八位字节 13 和 10 的字符集表示，就像某些多字节字符集的情况一样，HTTP 允许使用由此定义的任何八位字节序列。字符集表示换行符的 CR 和 LF 的等效值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, if the wrapped API supports cancellation (such as the listener removal in the example), one can use the `setCancellation` (or `setSubscription` for `Subscription`-like resources) to register a cancellation callback that gets invoked when the downstream unsubscribes or the `onError`/`onComplete` is called on the provided `Emitter`instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022718Z" creationid="pingfangx" creationdate="20190624T022718Z">
        <seg>此外，如果包装的 API 支持取消(例如示例中的侦听器删除)，则可以使用 `setCancellation`(或 `setSubscription` 用于类似 Subscription` 的资源)，来注册在下游取消订阅或在提供的 `Emitter` 实例上调用 `onError`/`onComplete` 时调用的取消回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134216Z" creationid="pingfangx" creationdate="20190831T134216Z">
        <seg>此外，它允许用户代理在处理可能不受信任的内容时对自动使用不安全方法应用适当的约束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, operators requiring a predicate no longer use `Func1&lt;T, Boolean&gt;` but have a separate, primitive-returning type of `Predicate&lt;T&gt;` (allows better inlining due to no autoboxing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065124Z" creationid="pingfangx" creationdate="20190618T065124Z">
        <seg>另外，需要谓词的运算符不再使用 `Func1&lt;T, Boolean&gt;`，但是有一个单独的，原始返回类型的 `Predicate&lt;T&gt;`(由于没有自动装箱，允许更好的内联)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, some 3rd party libraries/code throw when they get interrupted by a cancel/dispose call which leads to an undeliverable exception most of the time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091422Z" creationid="pingfangx" creationdate="20190618T091345Z">
        <seg>此外，一些第三方库/代码在被取消/dispose 调用中断时抛出，这导致大多数时间无法传递的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the proliferation of incompletely-implemented applications calling themselves "HTTP/1.0" has necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075520Z" creationid="pingfangx" creationdate="20190828T075520Z">
        <seg>此外，自称为“HTTP/1.0”的不完全实现的应用程序的激增使得必须进行协议版本更改，以便两个通信应用程序确定彼此的真实能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, there is option to wrap an existing `Executor` (and its subtypes such as `ExecutorService`) into a `Scheduler` via `Schedulers.from(Executor)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073659Z" creationid="pingfangx" creationdate="20190617T073659Z">
        <seg>此外，还可以选择通过 `Schedulers.from(Executor)` 将现有的 `Executor`(及其子类型，如 `ExecutorService`) 包装到 `Scheduler` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, they won't signal `BufferOverflowException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014658Z" creationid="pingfangx" creationdate="20190624T014658Z">
        <seg>另外，它们不会发出 `BufferOverflowException` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152700Z" creationid="pingfangx" creationdate="20190828T152700Z">
        <seg>在所有其他情况下，HTTP 用户代理应该遵循与 MIME 用户代理在收到多部分类型时相同或类似的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other fields, parentheses are considered part of the field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101607Z" creationid="pingfangx" creationdate="20190828T101607Z">
        <seg>在所有其他字段中，括号被视为字段值的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all states except SYN-SENT, all reset (RST) segments are validated by checking their SEQ-fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061721Z" creationid="pingfangx" creationdate="20190828T061721Z">
        <seg>在除 SYN-SENT 之外的所有状态中，通过检查其 SEQ-字段来验证所有复位(RST)报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an attempt to establish the connection, A's TCP will send a segment containing SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055831Z" creationid="pingfangx" creationdate="20190828T055831Z">
        <seg>在尝试建立连接时，A 的 TCP 将发送包含 SYN 的报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an ordinary method call — that is, &lt;e0&gt;not&lt;/e0&gt; the sort of asynchronous, parallel calls typical in ReactiveX — the flow is something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T052930Z" creationid="pingfangx" creationdate="20190620T052930Z">
        <seg>在一个普通的方法调用中 - 也就是说，&lt;e0&gt;非&lt;/e0&gt; ReactiveX 中典型的异步并行调用 - 流程是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In anticipation of future, as-yet-undefined IP literal address formats, an implementation may use an optional version flag to indicate such a format explicitly rather than rely on heuristic determination.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074509Z" creationid="pingfangx" creationdate="20190902T074509Z">
        <seg>在预期未来，尚未定义的 IP 文字地址格式时，实现可以使用可选的版本标志来明确地指示这种格式而不是依赖于启发式确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the client does not want to maintain a connection for more than that request, it SHOULD send a Connection header including the connection-token close.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150739Z" creationid="pingfangx" creationdate="20190829T150739Z">
        <seg>如果客户端不希望维护一个超过该请求的连接，它应该发送包含连接标记关闭的 Connection 首部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the computation itself should be delayed until the downstream actually requests, we can use `just` with `map`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020054Z" creationid="pingfangx" creationdate="20190624T020040Z">
        <seg>如果计算本身应该延迟到下游实际请求时，我们可以使用 `just` 和 `map`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the source data can be processed more efficiently in batch, one can reduce the likelihood of `MissingBackpressureException` by using one of the standard batching operators (by size and/or by time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091349Z" creationid="pingfangx" creationdate="20190621T091349Z">
        <seg>如果可以批量处理源数据，则可以通过使用标准批处理操作符(按大小和/或按时间)之一减少 `MissingBackpressureException` 的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a connection-specific header field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110803Z" creationid="pingfangx" creationdate="20190831T110803Z">
        <seg>相反，在没有相应连接选项的情况下接收的特定于连接的首部字段通常表示该字段已被中间设备不正确地转发并且应该被接收者忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T065159Z" creationid="pingfangx" creationdate="20190830T065159Z">
        <seg>相反，PUT 请求中的 URI 标识请求附带的实体 - 用户代理知道 URI 的用途，服务器不得尝试将请求应用于其他资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142607Z" creationid="pingfangx" creationdate="20190831T142607Z">
        <seg>实际上，此方法类似于 UNIX 中的 rm 命令：它表示对源服务器的 URI 映射执行删除操作，而不是期望删除先前关联的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, since version 2.1.10, it doesn't</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102558Z" creationid="pingfangx" creationdate="20190617T102558Z">
        <seg>事实上，从版本 2.1.10 开始，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that is how many resources are implemented (see Section 9.1 for related security considerations).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135347Z" creationid="pingfangx" creationdate="20190831T135347Z">
        <seg>实际上，这就是很多资源的实现(有关相关的安全性考虑，请参见第 9.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, there are a wide variety of architectures and configurations of caches and proxies currently being experimented with or deployed across the World Wide Web.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144757Z" creationid="pingfangx" creationdate="20190828T091303Z">
        <seg>事实上，目前正在万维网上试验或部署各种缓存和代理的体系结构和配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In figure 12, we find the two TCPs A and B with passive connections waiting for SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060341Z" creationid="pingfangx" creationdate="20190828T060341Z">
        <seg>在图 12 中，我们发现两个 TCP A 和 B 具有等待 SYN 的被动连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, HTTP treats a multipart message-body no differently than any other media type: strictly as payload.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190828T152609Z">
        <seg>通常，HTTP 处理多部分消息体与任何其他媒体类型没有区别：严格地作为有效载荷。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, HTTP/TLS requests are generated by dereferencing a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103511Z" creationid="pingfangx" creationdate="20190901T103511Z">
        <seg>通常，通过解除引用 URI 来生成 HTTP/TLS 请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152748Z" creationid="pingfangx" creationdate="20190828T152748Z">
        <seg>通常，HTTP 用户代理应该遵循与 MIME 用户代理在收到多部分类型时相同或类似的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132449Z" creationid="pingfangx" creationdate="20190831T132449Z">
        <seg>通常，中介应该识别其自己的服务器名称，包括任何别名，本地变体或文字 IP 地址，并直接响应此类请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, safe methods that do not depend on a current or authoritative response are defined as cacheable; this specification defines GET, HEAD, and POST as cacheable, although the overwhelming majority of cache implementations only support GET and HEAD.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134538Z" creationid="pingfangx" creationdate="20190831T134538Z">
        <seg>通常，不依赖于当前或权威响应的安全方法被定义为可缓存的；尽管绝大多数缓存实现仅支持 GET 和 HEAD，但此规范将 GET，HEAD 和 POST 定义为可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In line 2 of figure 7, TCP A begins by sending a SYN segment indicating that it will use sequence numbers starting with sequence number 100.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041309Z" creationid="pingfangx" creationdate="20190828T041309Z">
        <seg>在图 7 的第 2 行中，TCP A 通过发送 SYN 报文段开始，该 SYN 报文段指示它将使用以序列号 100 开始的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In line 3, TCP B sends a SYN and acknowledges the SYN it received from TCP A.  Note that the acknowledgment field indicates TCP B is now expecting to hear sequence 101, acknowledging the SYN which occupied sequence 100.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041635Z" creationid="pingfangx" creationdate="20190828T041635Z">
        <seg>在第 3 行中，TCP B 发送 SYN 并确认它从 TCP A 收到的 SYN。注意，确认字段指示 TCP B 现在期望收到序列 101，并确认了占用序列号 100 的 SYN 报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many cases, a user agent is installed or configured to run in the background and save its results for later inspection (or save only a subset of those results that might be interesting or erroneous).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100651Z" creationid="pingfangx" creationdate="20190830T100651Z">
        <seg>在许多情况下，安装或配置用户代理以在后台运行并保存其结果以供以后检查(或仅保存可能有趣或错误的那些结果的子集)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many cases, the host syntax is used only for the sake of reusing the existing registration process created and deployed for DNS, thus obtaining a globally unique name without the cost of deploying another registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074004Z" creationid="pingfangx" creationdate="20190902T074004Z">
        <seg>在许多情况下，主机语法仅用于重用为 DNS 创建和部署的现有注册过程，从而获得全局唯一名称，而无需部署其他注册表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044643Z" creationid="pingfangx" creationdate="20190620T044643Z">
        <seg>在许多软件编程任务中，您或多或少地期望您编写的指令将按照您编写的顺序逐个执行并逐步完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In modern RxJava, most asynchronous operators now have a bounded internal buffer, like `observeOn` above and any attempt to overflow this buffer will terminate the whole sequence with `MissingBackpressureException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T075250Z" creationid="pingfangx" creationdate="20190621T075250Z">
        <seg>在现代的 RxJava 中，大多数异步操作符现在都有一个有界的内部缓冲区，如上面的 `observeOn`，任何溢出此缓冲区的尝试都将带 `MissingBackpressureException` 终止整个序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110236Z" creationid="pingfangx" creationdate="20190831T110236Z">
        <seg>为了避免混淆下游接收者，代理或网关必须在转发消息之前删除或替换任何收到的连接选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to avoid request loops, a proxy MUST be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100707Z" creationid="pingfangx" creationdate="20190829T100707Z">
        <seg>为了避免请求循环，代理必须能够识别其所有服务器名称，包括任何别名，本地变体和数字 IP 地址。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to disambiguate the syntax, we apply the "first-match-wins" algorithm:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074228Z" creationid="pingfangx" creationdate="20190902T074228Z">
        <seg>为了消除语法歧义，我们应用“first-match-wins”算法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to help lift these extra overheads, a new method `Flowable.subscribe(FlowableSubscriber&lt;? super T&gt;)` has been added which exposes the original behavior from before 2.0.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085441Z" creationid="pingfangx" creationdate="20190618T085441Z">
        <seg>为了帮助解除这些额外的开销，添加了一个新的方法 `Flowable.subscribe(FlowableSubscriber&lt;? super T&gt;)`，它暴露了 2.0.7 之前的原始行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to prevent this form of attack, users should carefully examine the certificate presented by the server to determine if it meets their expectations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T112933Z" creationid="pingfangx" creationdate="20190901T112933Z">
        <seg>为了防止这种形式的攻击，用户应仔细检查服务器提供的证书，以确定它是否符合他们的期望。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 3.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111236Z" creationid="pingfangx" creationdate="20190831T111236Z">
        <seg>为了保持持久性，连接上的所有消息都需要具有自定义的消息长度(即，未通过关闭连接定义的消息长度)，如 3.3 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to remain persistent, all messages on the connection MUST have a self-defined message length (i.e., one not defined by closure of the connection), as described in section 4.4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150947Z" creationid="pingfangx" creationdate="20190829T150947Z">
        <seg>为了保持持久性，连接上的所有消息必须具有自定义的消息长度(即，未通过关闭连接定义的消息长度)，如 4.4 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other cases, the data within the host component identifies a registered name that has nothing to do with an Internet host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074134Z" creationid="pingfangx" creationdate="20190902T074134Z">
        <seg>在其他情况下，主机组件中的数据标识与互联网主机无关的注册名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other documents and other contexts, what we are calling an “observer” is sometimes called a “subscriber,” “watcher,” or “reactor.” This model in general is often referred to as the &lt;a0&gt;“reactor pattern”&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T050044Z" creationid="pingfangx" creationdate="20190620T050044Z">
        <seg>在其他文件和其他场景下，我们所谓的“观察者 (observer)”有时被称为“订阅者 (subscriber)”，“观察者 (watcher)”或“反应者 (reactor)”。这种模型通常被称为 &lt;a0&gt;“反应者模式 (reactor pattern)”&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other scenarios, the result(s) of the first source/dataflow is irrelevant and one would like to continue with a quasi independent another source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083915Z" creationid="pingfangx" creationdate="20190617T083915Z">
        <seg>在其他场景中，第一个源/数据流的结果是无关紧要的，并且人们希望继续使用准独立的另一个源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, if the server is reading the protocol stream at the beginning of a message and receives a CRLF first, it should ignore the CRLF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T073744Z" creationid="pingfangx" creationdate="20190829T073744Z">
        <seg>换句话说，如果服务器在消息开头读取协议流并首先接收 CRLF，则应忽略 CRLF。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the URI generic syntax is a superset of the syntax of all URI schemes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T062025Z" creationid="pingfangx" creationdate="20190902T062025Z">
        <seg>换句话说，URI 通用语法是所有 URI 方案的语法的超集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the origin server is willing to accept the possibility that the trailer fields might be silently discarded along the path to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144252Z" creationid="pingfangx" creationdate="20190828T144252Z">
        <seg>换句话说，源服务器愿意接受 trailer 字段可能沿着到客户端的路径被静默丢弃的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, they are not allowed to blindly forward the first line of an HTTP message without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103510Z" creationid="pingfangx" creationdate="20190830T103510Z">
        <seg>换句话说，不允许它们盲目地转发 HTTP 消息的第一行而不确保该消息中的协议版本与该中介符合接收和发送消息的版本匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, SYNs addressed to a non-existent connection are rejected by this means.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060619Z" creationid="pingfangx" creationdate="20190828T060619Z">
        <seg>特别是，通过这种方式拒绝寻址到不存在的连接的 SYN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, servers SHOULD be prepared to receive an incomplete close from the client, since the client can often determine when the end of server data is.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103019Z" creationid="pingfangx" creationdate="20190901T103019Z">
        <seg>特别是，服务器应该准备好从客户端接收不完整的关闭，因为客户端通常可以确定服务器数据的结束时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the Host and Connection header fields ought to be implemented by all HTTP/1.x implementations whether or not they advertise conformance with HTTP/1.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103439Z" creationid="pingfangx" creationdate="20190830T103439Z">
        <seg>特别是，Host 和 Connection 首部字段应该由所有 HTTP/1.x 实现实现，无论它们是否宣传与 HTTP/1.1 的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T032301Z" creationid="pingfangx" creationdate="20190830T032301Z">
        <seg>特别是，已经建立了这样的惯例：GET 和 HEAD 方法不应该具有采取除检索之外的动作的意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, use of external profiling information to determine the exact mapping is not permitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115008Z" creationid="pingfangx" creationdate="20190828T115008Z">
        <seg>特别是，不允许使用外部分析信息来确定精确的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, most HTTP header field values use only a subset of the US-ASCII charset [USASCII].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T084811Z" creationid="pingfangx" creationdate="20190831T084811Z">
        <seg>实际上，大多数 HTTP 首部字段值仅使用 US-ASCII 字符集 [USASCII] 的子集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In response to sending data the TCP will receive acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021759Z" creationid="pingfangx" creationdate="20190828T021759Z">
        <seg>为响应发送数据，TCP 将收到确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In return, the `observeOn` calls `Subscription.request(n)` with a value to tell the `range` it is allowed to produce (i.e., `onNext` it) that many **additional** elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081412Z" creationid="pingfangx" creationdate="20190621T081412Z">
        <seg>作为回应，`observeOn` 调用 `Subscription.request(n)`，其值为告诉 `range`，它允许生产(即 `onNext`)多少个**额外的**元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some ReactiveX implementations, there is a specialized observer interface, &lt;c0&gt;Subscriber&lt;/c0&gt;, that implements an &lt;c1&gt;unsubscribe&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061644Z" creationid="pingfangx" creationdate="20190620T061644Z">
        <seg>在一些 ReactiveX 实现中，有一个特殊的观察者​器接口 &lt;c0&gt;Subscriber&lt;/c0&gt;，它实现了 &lt;c1&gt;unsubscribe&lt;/c1&gt; 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, a payload might contain only the associated representation's header fields (e.g., responses to HEAD) or only some part(s) of the representation data (e.g., the 206 (Partial Content) status code).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025307Z" creationid="pingfangx" creationdate="20190902T025307Z">
        <seg>在一些情况下，有效载荷可以仅包含关联表示的首部字段（例如，对 HEAD 的响应）或仅包含表示数据的一些部分（例如，206（部分内容）状态代码）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, a single intermediary might act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101052Z" creationid="pingfangx" creationdate="20190830T101052Z">
        <seg>在某些情况下，单个中介可以充当源服务器，代理，网关或隧道，根据每个请求的性质切换行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, communication options are hard-coded in a client's configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123206Z" creationid="pingfangx" creationdate="20190831T123206Z">
        <seg>在某些情况下，通信选项在客户端配置中是硬编码的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, it might either be inappropriate or highly inefficient for the client to send the body if the server will reject the message without looking at the body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024429Z" creationid="pingfangx" creationdate="20190830T024429Z">
        <seg>在某些情况下，如果服务器在不查看正文的情况下拒绝邮件，则客户端发送正文可能不合适或效率极低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, the URI is specified as an IP address rather than a hostname.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111338Z" creationid="pingfangx" creationdate="20190901T111338Z">
        <seg>在某些情况下，URI 被指定为 IP 地址而不是主机名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some contexts such names would indicate methods by means of which event handlers are &lt;e5&gt;registered&lt;/e5&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064833Z" creationid="pingfangx" creationdate="20190620T064740Z">
        <seg>在某些场景中下，此类名称将指示通过哪个事件处理程序 &lt;e5&gt;registered (注册)&lt;/e5&gt; 的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some implementations of ReactiveX, there is also something called a “Connectable” Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070030Z" creationid="pingfangx" creationdate="20190620T070030Z">
        <seg>在 ReactiveX 的一些实现中，还存在称为“Connectable” 的 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In special cases, it may be appropriate for the client to simply ignore the server's identity, but it must be understood that this leaves the connection open to active attack.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103814Z" creationid="pingfangx" creationdate="20190901T103814Z">
        <seg>在特殊情况下，客户端可以简单地忽略服务器的身份，但必须理解的是，这会使连接受到主动攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133015Z" creationid="pingfangx" creationdate="20190831T133015Z">
        <seg>在这种情况下，原始服务器使用某种算法来选择那些表示最适用于给定请求的表示之一，通常基于内容协商。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, user agents SHOULD present to the user the entity returned with the response, since that entity is likely to include human- readable information which will explain the unusual status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110135Z" creationid="pingfangx" creationdate="20190829T110135Z">
        <seg>在这种情况下，用户代理应该向用户呈现随响应返回的实体，因为该实体可能包括将解释异常状态的人类可读信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such situations, there are usually two options to fix the transformation: 1) convert to the desired type or 2) find and use an overload of the specific operator supporting the different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092841Z" creationid="pingfangx" creationdate="20190617T092841Z">
        <seg>在这种情况下，通常有两个选项来修复转换：1)转换为所需类型或 2)查找并使用支持不同类型的特定运算符的重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In summary, a language tag is composed of 1 or more parts: A primary language tag and a possibly empty series of subtags:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154706Z" creationid="pingfangx" creationdate="20190828T154706Z">
        <seg>总之，语言标记由一个或多个部分组成：主要语言标记和可能为空的子标记系列：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Reactive-Streams specification, the `Subject`-like behavior, namely being a consumer and supplier of events at the same time, is done by the `org.reactivestreams.Processor` interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061946Z" creationid="pingfangx" creationdate="20190618T061946Z">
        <seg>在 Reactive-Streams 规范中，类似 `Subject` 的行为，即同时成为事件的消费者和供应者，由 `org.reactivestreams.Processor` 接口完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the SYN-SENT state (a RST received in response to an initial SYN), the RST is acceptable if the ACK field acknowledges the SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061750Z" creationid="pingfangx" creationdate="20190828T061750Z">
        <seg>在 SYN-SENT 状态(响应初始 SYN 而接收的 RST)中，如果 ACK 字段确认 SYN，则 RST 是可接受的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025600Z" creationid="pingfangx" creationdate="20190828T025600Z">
        <seg>在没有关于特定连接上使用的序列号的知识的情况下，TCP 规范建议在连接上发送报文段之前 MSL 秒的源延迟，以允许来自早期连接化身的报文段的时间从系统中消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the asynchronous model the flow goes more like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053052Z" creationid="pingfangx" creationdate="20190620T053052Z">
        <seg>在异步模型中，流程更像是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of URI, the object is a sequence of characters with a restricted syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040331Z" creationid="pingfangx" creationdate="20190902T040331Z">
        <seg>在 URI 的情况下，标识符是具有受限语法的字符序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the classical Rx.NET and early RxJava, these buffers were unbounded, meaning that they would likely hold nearly all 1 million elements from the example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072300Z" creationid="pingfangx" creationdate="20190621T072300Z">
        <seg>在经典的 Rx.NET 和早期的 RxJava 中，这些缓冲区是无界的，这意味着在该示例中，它们可能会持有几乎所有的 100 万个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example we call `onComplete()` if the read byte is negative, indicating and end of file, and call `onError` in case the read throws an `IOException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021304Z" creationid="pingfangx" creationdate="20190624T021304Z">
        <seg>在示例中，如果读取字节为负数，指示和文件结束，则调用 `onComplete()`，并在读取抛出 `IOException` 时调用 `onError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the few cases where this specification requires reporting of errors to the user, it is acceptable for such reporting to only be observable in an error console or log file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100728Z" creationid="pingfangx" creationdate="20190830T100728Z">
        <seg>在此规范要求向用户报告错误的少数情况下，只有在错误控制台或日志文件中才能观察到此类报告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103429Z" creationid="pingfangx" creationdate="20190831T103429Z">
        <seg>为了健状性，期望接收和解析请求行的服务器应该忽略在请求行之前接收的至少一个空行(CRLF)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the interest of robustness, servers SHOULD ignore any empty line(s) received where a Request-Line is expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T073721Z" creationid="pingfangx" creationdate="20190829T073721Z">
        <seg>为了鲁棒性，服务器应该忽略在预期请求行的地方收到的任何空行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the latter case, it receives the error message "connection not open" from the local (A's) TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055822Z" creationid="pingfangx" creationdate="20190828T055822Z">
        <seg>在后一种情况下，它从本地(A)的 TCP 接收错误消息“connection not open”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the original Rx.NET, the operator that emits a single item and then completes is called `Return(T)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101615Z" creationid="pingfangx" creationdate="20190617T101615Z">
        <seg>在原始的 Rx.NET 中，发出单个项然后完成的运算符称为 `Return(T)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the paragraphs below, an explanation for this specification is given.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024658Z" creationid="pingfangx" creationdate="20190828T024658Z">
        <seg>在下面的段落中，给出了对该说明书的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083437Z" creationid="pingfangx" creationdate="20190831T083437Z">
        <seg>过去，处理此类空白的差异导致请求路由和响应处理中的安全漏洞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the simplest case, this may be accomplished via a single connection (v) between the user agent (UA) and the origin server (O).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085253Z" creationid="pingfangx" creationdate="20190828T085253Z">
        <seg>在最简单的情况下，这可以通过用户代理(UA)和源服务器(O)之间的单个连接(v)来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the simplest case, this might be accomplished via a single bidirectional connection (===) between the user agent (UA) and the origin server (O).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095957Z" creationid="pingfangx" creationdate="20190830T095957Z">
        <seg>在最简单的情况下，这可以通过用户代理(UA)和源服务器(O)之间的单个双向连接(===)来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats, but, in practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method) and clients are implemented to only expect a response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T065546Z" creationid="pingfangx" creationdate="20190831T065546Z">
        <seg>理论上，客户端可以接收请求，服务器可以接收响应，通过不同的起始行格式区分它们，但实际上，服务器实现为仅期望请求(响应被解释为未知或无效的请求方法)并且客户端实现为只期望响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case the absolute path of the URI MUST be transmitted (see section 3.2.1, abs_path) as the Request-URI, and the network location of the URI (authority) MUST be transmitted in a Host header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101011Z" creationid="pingfangx" creationdate="20190829T101011Z">
        <seg>在这种情况下，URI 的绝对路径必须作为 Request-URI 传输(参见第 3.2.1 节，abs_path)，并且 URI(authority)的网络位置必须在 Host 首部字段中传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, a FIN segment can be constructed and placed on the outgoing segment queue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063356Z" creationid="pingfangx" creationdate="20190828T063356Z">
        <seg>在这种情况下，可以构造 FIN 报文段并将其放置在传出报文段队列上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T071536Z" creationid="pingfangx" creationdate="20190830T071536Z">
        <seg>在这种情况下，对一般 URI 的 PUT 请求可能会导致原始服务器定义其他几个 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064418Z" creationid="pingfangx" creationdate="20190830T064418Z">
        <seg>在这种情况下，200(OK)或 204(No Content)是适当的响应状态，具体取决于响应是否包括描述结果的实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, one can use one of the following operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091117Z" creationid="pingfangx" creationdate="20190621T091117Z">
        <seg>在这种情况下，可以使用以下操作符之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the data arriving at TCP A from TCP B (line 2) is unacceptable because no such connection exists, so TCP A sends a RST.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060249Z" creationid="pingfangx" creationdate="20190828T060249Z">
        <seg>在这种情况下，从 TCP B(第 2 行)到达 TCP A 的数据是不可接受的，因为不存在这样的连接，因此 TCP A 发送 RST。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the delegation works the same way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022948Z" creationid="pingfangx" creationdate="20190624T022948Z">
        <seg>在这种情况下，委托以相同的方式工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the iPAddress subjectAltName must be present in the certificate and must exactly match the IP in the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111350Z" creationid="pingfangx" creationdate="20190901T111350Z">
        <seg>在这种情况下，iPAddress subjectAltName 必须存在于证书中，并且必须与 URI 中的 IP 完全匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the `observeOn` goes with a very low buffer size yet there is no `MissingBackpressureException` as `onBackpressureBuffer` soaks up all the 1 million values and hands over small batches of it to `observeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092532Z" creationid="pingfangx" creationdate="20190621T092532Z">
        <seg>在这个例子中，`observeOn` 的缓冲区大小非常低，但是不会产生 `MissingBackpressureException`，因为 `onBackpressureBuffer` 吸收了所有 100 万个值并将其小批量交给 `observeOn`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the main thread will produce 1 million items to an end consumer which is processing it on a background thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072031Z" creationid="pingfangx" creationdate="20190621T072031Z">
        <seg>在此示例中，主线程将向最终消费者生产 100 万个项目，该消费者在后台线程上处理项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190829T111810Z">
        <seg>在本节中，和收件人都指客户端或服务器，具体取决于谁发送以及谁接收实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this setup, the `current` starts out with `0` and next time the lambda is invoked, the parameter `current` now holds `1`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021541Z" creationid="pingfangx" creationdate="20190624T021541Z">
        <seg>在这个设置中，`current` 以 `0` 开始，下次调用 lambda 时，参数 `current` 现在保持 `1`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this synchronous case, a `NullPointerException` will be thrown immediately while still executing `onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083450Z" creationid="pingfangx" creationdate="20190621T083450Z">
        <seg>在这种同步的情况下，在执行 `onStart` 时会立即抛出 `NullPointerException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this way, HTTP allows basic hypermedia access to resources available from diverse applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080151Z" creationid="pingfangx" creationdate="20190828T080151Z">
        <seg>通过这种方式，HTTP 允许基本的超媒体访问来自不同应用程序的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inbound and outbound refer to the request and response paths for messages: "inbound" means "traveling toward the origin server", and "outbound" means "traveling toward the user agent"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T082317Z" creationid="pingfangx" creationdate="20190828T082317Z">
        <seg>入站和出站是指消息的请求和响应路径：“入站”表示“向原始服务器行进”，“出站”表示“向用户代理行进”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incorrect DHE Share</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121656Z" creationid="pingfangx" creationdate="20190901T121656Z">
        <seg>DHE 共享不正确</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Index</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074652Z" creationid="pingfangx" creationdate="20190828T074652Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indirect referencing also provides additional flexibility and extensibility to systems that use URIs, as new media types are easier to define and deploy than new schemes of identification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083856Z" creationid="pingfangx" creationdate="20190902T083856Z">
        <seg>间接引用还为使用 URI 的系统提供了额外的灵活性和可扩展性，因为新媒体类​​型比新的识别方案更容易定义和部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual media types may define their own restrictions on or structures within the fragment identifier syntax for specifying different types of subsets, views, or external references that are identifiable as secondary resources by that media type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083709Z" creationid="pingfangx" creationdate="20190902T083709Z">
        <seg>各个媒体类型可以在片段标识符语法中定义它们自己的限制或结构，用于指定可由该媒体类型识别为辅助资源的不同类型的子集，视图或外部引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual schemes are not specified by this document.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072533Z" creationid="pingfangx" creationdate="20190902T072533Z">
        <seg>此文档未指定单个方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7230.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090508Z" creationid="pingfangx" creationdate="20190830T090508Z">
        <seg>有关本文档的当前状态，任何勘误以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc7230。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7231.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115527Z" creationid="pingfangx" creationdate="20190831T115527Z">
        <seg>有关本文档当前状态，任何勘误以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc7231。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Sequence Number Selection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023120Z" creationid="pingfangx" creationdate="20190828T023120Z">
        <seg>初始序列号选择</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialize a variable R to the estimated round-trip time to the server (e.g., based on the time it took to establish the connection), or to a constant value of 5 seconds if the round- trip time is not available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030407Z" creationid="pingfangx" creationdate="20190830T030407Z">
        <seg>将变量 R 初始化为到服务器的估计往返时间(例如，基于建立连接所花费的时间)，或者如果往返时间不可用则将变量 R 初始化为 5 秒的恒定值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, the registry contains the following tokens:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140655Z" creationid="pingfangx" creationdate="20190828T140655Z">
        <seg>最初，注册表包含以下标记：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, the registry contains the following tokens: "chunked" (section 3.6.1), "identity" (section 3.6.2), "gzip" (section 3.5), "compress" (section 3.5), and "deflate" (section 3.5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143349Z" creationid="pingfangx" creationdate="20190828T143349Z">
        <seg>最初，注册表包含以下标记：“chunked”(第 3.6.1 节)，“identity”(第 3.6.2 节)，“gzip”(第 3.5 节)，“compress”(第 3.5 节)和“deflate”(第 3.5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initiate a new connection to the server</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030336Z" creationid="pingfangx" creationdate="20190830T030336Z">
        <seg>启动与服务器的新连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of URIs from any given scheme may have the characteristics of names or locators or both, often depending on the persistence and care in the assignment of identifiers by the naming authority, rather than on any quality of the scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064120Z" creationid="pingfangx" creationdate="20190902T064120Z">
        <seg>来自任何给定方案的 URI 的实例可以具有名称或定位符或两者的特征，通常取决于命名机构对标识符的分配的持久性和关注，而不是该方案的任何质量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, an interception proxy filters or redirects outgoing TCP port 80 packets (and occasionally other common port traffic).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101823Z" creationid="pingfangx" creationdate="20190830T101823Z">
        <seg>相反，拦截代理过滤或重定向传出的 TCP 端口 80 数据包(有时还有其他常见的端口流量)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it delegates the issue of registered name syntax conformance to the operating system of each application performing URI resolution, and that operating system decides what it will allow for the purpose of host identification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075737Z" creationid="pingfangx" creationdate="20190902T075737Z">
        <seg>相反，它将注册名称语法一致性的问题委托给执行 URI 解析的每个应用程序的操作系统，并且该操作系统决定它将允许用于主机识别的目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, this specification uses ABNF rules that are named according to each registered field name, wherein the rule defines the valid grammar for that field's corresponding field values (i.e., after the field-value has been extracted from the header section by a generic field parser).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083411Z" creationid="pingfangx" creationdate="20190831T083411Z">
        <seg>相反，该规范使用根据每个注册的字段名称命名的 ABNF 规则，其中该规则定义该字段的相应字段值的有效语法（即，在通用字段解析器从首部部分提取字段值之后）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we are limited to defining the syntax of communication, the intent of received communication, and the expected behavior of recipients.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094317Z" creationid="pingfangx" creationdate="20190830T094317Z">
        <seg>相反，我们仅限于定义通信语法，接收通信的意图以及接收者的预期行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we defined our own functional interfaces in 1.x and 2.x follows this tradition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064103Z" creationid="pingfangx" creationdate="20190618T064103Z">
        <seg>相反，我们在 1.x 和 2.x 中定义了我们自己的函数接口遵循这一传统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interception proxies are commonly found on public network access points, as a means of enforcing account subscription prior to allowing use of non-local Internet services, and within corporate firewalls to enforce network usage policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101845Z" creationid="pingfangx" creationdate="20190830T101845Z">
        <seg>拦截代理通常位于公共网络接入点上，作为在允许使用非本地互联网服务之前强制执行帐户订阅的方法，以及在企业防火墙内实施网络使用策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interfaces</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071210Z" creationid="pingfangx" creationdate="20190828T071210Z">
        <seg>接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090634Z" creationid="pingfangx" creationdate="20190830T090634Z">
        <seg>中介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103501Z" creationid="pingfangx" creationdate="20190830T103501Z">
        <seg>处理 HTTP 消息的中介(即除充当隧道之外的所有中介)必须在转发的消息中发送自己的 HTTP 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal changes in 2.0.6 now consistently cancel or dispose a `Subscription`/`Disposable` before cancelling/disposing a task or worker (which causes the interrupt on the target thread).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092743Z" creationid="pingfangx" creationdate="20190618T092743Z">
        <seg>2.0.6 中的内部更改现在在取消/释放任务或工作程序(导致目标线程上的中断)之前始终取消或释放 `Subscription`/“Disposable”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, asynchronous operators have buffers to hold such elements until they can be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072208Z" creationid="pingfangx" creationdate="20190621T072208Z">
        <seg>在内部，异步操作符具有缓冲区来保存这些元素，直到它们可以被处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internet Media Type Registration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091048Z" creationid="pingfangx" creationdate="20190830T091048Z">
        <seg>互联网媒体类型注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internet media types are registered with a canonical form.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T150552Z" creationid="pingfangx" creationdate="20190828T150552Z">
        <seg>互联网媒体类型以规范形式注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071846Z" creationid="pingfangx" creationdate="20190828T071846Z">
        <seg>介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction of Content-Encoding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074611Z" creationid="pingfangx" creationdate="20190828T074611Z">
        <seg>内容编码简介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction of Transfer-Encoding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074620Z" creationid="pingfangx" creationdate="20190828T074620Z">
        <seg>传输编码的介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invalid whitespace around field-names is now required to be rejected, because accepting it represents a security vulnerability.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091805Z" creationid="pingfangx" creationdate="20190830T091805Z">
        <seg>现在需要拒绝字段名称周围的无效空格，因为接受它代表了一个安全漏洞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invalidation After Updates or Deletions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074051Z" creationid="pingfangx" creationdate="20190828T074051Z">
        <seg>更新或删除后失效</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issues with the Keep-Alive and Proxy-Connection header fields in requests are pointed out, with use of the latter being discouraged altogether.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092410Z" creationid="pingfangx" creationdate="20190830T092410Z">
        <seg>指出了请求中的 Keep-Alive 和 Proxy-Connection 首部字段的问题，完全不鼓励使用后者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It MAY resume a TLS session closed in this fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T094012Z" creationid="pingfangx" creationdate="20190901T094012Z">
        <seg>它可以以这种方式恢复关闭的 TLS 会话。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It MUST NOT perform the requested method if it returns a final status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024949Z" creationid="pingfangx" creationdate="20190830T024949Z">
        <seg>如果它返回最终状态代码，则它不能执行所请求的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It MUST be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T083612Z" creationid="pingfangx" creationdate="20190829T081550Z">
        <seg>必须可以将多个首部字段组合成一个“字段名: 字段值”对，而不改变消息的语义，方法是将每个后续字段值附加到第一个字段值，每个字段值用逗号分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows different types of resource identifiers to be used in the same context, even when the mechanisms used to access those resources may differ.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060152Z" creationid="pingfangx" creationdate="20190902T060152Z">
        <seg>它允许在同一上下文中使用不同类型的资源标识符，即使用于访问这些资源的机制可能不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows introduction of new types of resource identifiers without interfering with the way that existing identifiers are used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060215Z" creationid="pingfangx" creationdate="20190902T060215Z">
        <seg>它允许引入新类型的资源标识符，而不会干扰现有标识符的使用方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows the identifiers to be reused in many different contexts, thus permitting new applications or protocols to leverage a pre-existing, large, and widely used set of resource identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060231Z" creationid="pingfangx" creationdate="20190902T060231Z">
        <seg>它允许标识符在许多不同的上下文中重用，从而允许新的应用程序或协议利用预先存在的，大量且广泛使用的资源标识符集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows uniform semantic interpretation of common syntactic conventions across different types of resource identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060208Z" creationid="pingfangx" creationdate="20190902T060208Z">
        <seg>它允许跨不同类型的资源标识符对通用语法约定进行统一的语义解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It avoids a situation where compliance with the protocol would have necessitated a possibly infinite buffer on the proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144315Z" creationid="pingfangx" creationdate="20190828T144315Z">
        <seg>它避免了这样一种情况，即遵从协议将需要代理上可能有无限的缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It builds on the discipline of reference provided by the Uniform Resource Identifier (URI) [3], as a location (URL) [4] or name (URN) [20], for indicating the resource to which a method is to be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075933Z" creationid="pingfangx" creationdate="20190828T075933Z">
        <seg>它建立在统一资源标识符(URI)[3] 提供的引用规则的基础上，作为位置(URL)[4] 或名称(URN)[20]，用于指示要应用方法的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can change at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105413Z" creationid="pingfangx" creationdate="20190617T105413Z">
        <seg>它可以随时改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of both a grammar and a description of basic functionality for URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035400Z" creationid="pingfangx" creationdate="20190902T035400Z">
        <seg>它包含语法和 URI 基本功能的描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It depends on the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064956Z" creationid="pingfangx" creationdate="20190620T064956Z">
        <seg>这取决于 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not specify an Internet standard of any kind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T085525Z" creationid="pingfangx" creationdate="20190901T085525Z">
        <seg>它没有指定任何类型的互联网标准。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It enables uniform identification of resources via a separately defined extensible set of naming schemes (Section 3.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061045Z" creationid="pingfangx" creationdate="20190902T061045Z">
        <seg>它可以通过单独定义的可扩展命名方案集来统一识别资源(第 3.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It excludes portions of RFC 1738 that defined the specific syntax of individual URI schemes; those portions will be updated as separate documents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T055352Z" creationid="pingfangx" creationdate="20190902T055352Z">
        <seg>它排除了 RFC 1738 中定义了各个 URI 方案的特定语法的部分；这些部分将作为单独的文件更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It excludes those portions of RFC 1738 that defined the specific syntax of individual URL schemes; those portions will be updated as separate documents, as will the process for registration of new URI schemes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035858Z" creationid="pingfangx" creationdate="20190902T035858Z">
        <seg>它排除了 RFC 1738 中定义了各个 URL 方案的特定语法的那些部分；这些部分将作为单独的文档更新，新 URI 方案的注册过程也将更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends &lt;a0&gt;the observer pattern&lt;/a0&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033455Z" creationid="pingfangx" creationdate="20190620T033244Z">
        <seg>它扩展了 &lt;a0&gt;观察者模式&lt;/a0&gt; 以支持数据和/或事件序列，并添加操作符，允许您以声明方式组合序列，而无需关注底层的线程，同步，线程安全，并发数据结构和非阻塞 I/O 等问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends the [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern) to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064839Z" creationid="pingfangx" creationdate="20190617T064839Z">
        <seg>它扩展了 [观察者模式](http://en.wikipedia.org/wiki/Observer_pattern) 以支持数据/事件序列，并添加运算符，允许您以声明方式组合序列，同时抽象出对低级别线程，同步，线程安全和并发数据结构等的关注。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034456Z" creationid="pingfangx" creationdate="20190620T034456Z">
        <seg>它使您摆脱了纠结的回调网络，从而使您的代码更具可读性，且不易出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090450Z" creationid="pingfangx" creationdate="20190830T090450Z">
        <seg>它已经过公众审查，并已获得互联网工程指导小组(IESG)的批准发布。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the usual modes, similar to `onBackpressureXXX` in addition to signalling a `MissingBackpressureException` or simply ignoring such overflow inside it altogether.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022056Z" creationid="pingfangx" creationdate="20190624T022056Z">
        <seg>它具有通常的模式，类似于 `onBackpressureXXX`，除了发出 `MissingBackpressureException` 信号或完全忽略它内部的溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is &lt;a0&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a0&gt; (or impossible, since latencies of each request vary at runtime).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035228Z" creationid="pingfangx" creationdate="20190620T035228Z">
        <seg>&lt;a0&gt;使用 Futures 难以很好地组合带条件的异步执行流程&lt;/a0&gt;(或者可以说不可能，因为每个请求的延迟在运行时变化)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081002Z" creationid="pingfangx" creationdate="20190831T081002Z">
        <seg>建议所有 HTTP 发送者和接收者至少支持 8000 个八位字节的请求行长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers [47].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071438Z" creationid="pingfangx" creationdate="20190828T071438Z">
        <seg>它是一种通用的、无状态的协议，可以通过扩展其请求方法、错误代码和首部，用于超文本以外的许多任务，如名称服务器和分布式对象管理系统 [47]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is automatically applied by `RxJavaPlugins.onError` with intact stacktrace that may help find which exact operator rerouted the original error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091225Z" creationid="pingfangx" creationdate="20190618T091225Z">
        <seg>它由 `RxJavaPlugins.onError` 自动应用，带有完整的堆栈跟踪，可以帮助找到哪个确切的运算符重新路由了原始错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110921Z" creationid="pingfangx" creationdate="20190831T110921Z">
        <seg>描述如何通过各种传输或会话层协议建立连接超出了本规范的范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is designed to hide the details of how a service is implemented by presenting a uniform interface to clients that is independent of the types of resources provided.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094218Z" creationid="pingfangx" creationdate="20190830T094218Z">
        <seg>它旨在通过向客户端提供独立于所提供资源类型的统一接口来隐藏服务实现方式的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is especially important that proxies correctly implement the properties of the Connection header field as specified in section 14.10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151828Z" creationid="pingfangx" creationdate="20190829T151828Z">
        <seg>代理正确实现第 14.10 节中指定的 Connection 首部字段的属性尤为重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is essential to remember that the actual sequence number space is finite, though very large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021243Z" creationid="pingfangx" creationdate="20190828T021243Z">
        <seg>必须记住，实际的序列号空间是有限的，尽管非常大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is expected that the folding LWS will be replaced with a single SP before interpretation of the TEXT value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100103Z" creationid="pingfangx" creationdate="20190828T100103Z">
        <seg>在解释 TEXT 值之前，预期折叠 LWS 将被单个 SP 替换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process a transfer-encoded payload.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T092801Z">
        <seg>一般认为，只发布 HTTP/1.0 支持的实现将不了解如何处理传输编码的有效载荷。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is implemented as a single JAR that is focused on just the Observable abstraction and related higher-order functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113521Z" creationid="pingfangx" creationdate="20190617T113521Z">
        <seg>它作为单个 JAR 实现，仅关注 Observable 抽象和相关的高阶函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is likely the `compute(int)` method takes some time but the overhead of the `Flowable` operator chain may also add to the time it takes to process items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072107Z" creationid="pingfangx" creationdate="20190621T072107Z">
        <seg>`compute(int)` 方法可能需要一些时间，但 `Flowable` 操作链的开销也可能增加处理项目所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not advised intermediate libraries change the error handler outside their own testing environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090838Z" creationid="pingfangx" creationdate="20190618T090838Z">
        <seg>不建议中间库在自己的测试环境之外更改错误处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often the case also that later sequences would require values from earlier mappings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083734Z" creationid="pingfangx" creationdate="20190617T083734Z">
        <seg>通常情况也是后来的序列需要来自早期映射的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended that new custom consumer implementations extend `FlowableSubscriber` instead of just `Subscriber`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085457Z" creationid="pingfangx" creationdate="20190618T085457Z">
        <seg>建议新的自定义消费者实现继承 `FlowableSubscriber` 而不仅仅是 `Subscriber`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes called “functional reactive programming” but this is a misnomer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033739Z" creationid="pingfangx" creationdate="20190620T033739Z">
        <seg>它有时被称为“函数响应式编程”，但这是用词不当。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135318Z" creationid="pingfangx" creationdate="20190831T135318Z">
        <seg>将资源标识符视为远程文件系统路径名并将表示视为此类文件内容的副本很有诱惑力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the implementation of a trade-off between memory and messages to provide information for this checking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033644Z" creationid="pingfangx" creationdate="20190828T033644Z">
        <seg>它是在为此检查提供信息的内存和消息之间进行权衡的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the main type to interact with other reactive libraries through a standardized mechanism governed by the [Reactive Streams specification](https://github.com/reactive-streams/reactive-streams-jvm#specification).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104412Z" creationid="pingfangx" creationdate="20190617T104412Z">
        <seg>它是通过由 [Reactive Streams 规范 ](https://github.com/reactive-streams/reactive-streams-jvm#specification) 管理的标准化机制与其他响应库交互的主要类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then the `observeOn`'s responsibility to call the `request` method in the right time and with the right value to keep the data flowing but not overflowing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081443Z" creationid="pingfangx" creationdate="20190621T081443Z">
        <seg>然后，`observeOn` 有责任在正确的时间调用 `request` 方法并使用正确的值来保持数据流动但不会溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113002Z" creationid="pingfangx" creationdate="20190831T113002Z">
        <seg>不知道重置问题是否是 TCP 独有的，或者也可能在其他传输连接协议中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134501Z" creationid="pingfangx" creationdate="20190831T134501Z">
        <seg>它知道重复请求将具有相同的预期效果，即使原始请求成功，尽管响应可能不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may be useful in conjunction with the source operator `interval()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014834Z" creationid="pingfangx" creationdate="20190624T014834Z">
        <seg>它可能与源操作符 `interval()` 结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It obsoletes [RFC2732], which introduced syntax for an IPv6 address.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T055144Z" creationid="pingfangx" creationdate="20190902T055144Z">
        <seg>它废弃了 [RFC2732]，它引入了 IPv6 地址的语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It represents the consensus of the IETF community.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090445Z" creationid="pingfangx" creationdate="20190830T090445Z">
        <seg>它代表了 IETF 社区的共识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should initiate a connection to the server on the appropriate port and then send the TLS ClientHello to begin the TLS handshake.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091417Z" creationid="pingfangx" creationdate="20190901T091417Z">
        <seg>它应该在适当的端口上启动与服务器的连接，然后发送 TLS ClientHello 以开始 TLS 握手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes two parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021722Z" creationid="pingfangx" creationdate="20190624T021722Z">
        <seg>它需要两个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It thus defines the syntax and semantics needed to implement a scheme-independent parsing mechanism for URI references, by which the scheme-dependent handling of a URI can be postponed until the scheme-dependent semantics are needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061836Z" creationid="pingfangx" creationdate="20190902T061836Z">
        <seg>因此，它定义了为 URI 引用实现与方案无关的解析机制所需的语法和语义，通过该机制可以推迟 URI 的依赖于方案的处理，直到需要依赖于方案的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was already designed along the Reactive-Streams style for 1.x so no user-level changes there.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060028Z" creationid="pingfangx" creationdate="20190618T060028Z">
        <seg>它已经按照 Reactive-Streams 样式设计了 1.x，因此没有用户级别的更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was frequently misused and didn't implement the `Scheduler` specification correctly anyway; it contained blocking sleep for delayed action and didn't support recursive scheduling at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093611Z" creationid="pingfangx" creationdate="20190618T093611Z">
        <seg>它经常被滥用，并且无论如何都没有正确实现 `Scheduler` 规范；它包含阻塞睡眠以延迟操作，并且根本不支持递归调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will also emit this same final value to any subsequent observers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083957Z" creationid="pingfangx" creationdate="20190620T083957Z">
        <seg>它还将向任何后续观察者发射相同的最终值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not make further calls to &lt;c0&gt;onNext&lt;/c0&gt; or &lt;c1&gt;onCompleted&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060309Z" creationid="pingfangx" creationdate="20190620T060309Z">
        <seg>它不会进一步调用 &lt;c0&gt;onNext&lt;/c0&gt; 或 &lt;c1&gt;onCompleted&lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its architecture now derives from the Reactive-Streams design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055625Z" creationid="pingfangx" creationdate="20190618T055625Z">
        <seg>它的架构现在来自 Reactive-Streams 设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its consumer type (`rx.Single.SingleSubscriber&lt;T&gt;`) has been changed from being a class that accepts `rx.Subscription` resources to be an interface `io.reactivex.SingleObserver&lt;T&gt;` that has only 3 methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055825Z" creationid="pingfangx" creationdate="20190618T055825Z">
        <seg>它的消费者类型(`rx.Single.SingleSubscriber&lt;T&gt;`)变化了，从接受 `rx.Subscription` 资源的类，变为只有 3 个方法的接口 `io.reactivex.SingleObserver&lt;T&gt;`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its functionality can be achieved via `TestScheduler`, `PublishProcessor`/`PublishSubject` and `observeOn(testScheduler)`/scheduler parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063603Z" creationid="pingfangx" creationdate="20190618T063603Z">
        <seg>它的功能可以通过 `TestScheduler`，`PublishProcessor`/`PublishSubject` 和 `observeOn(testScheduler)`/scheduler 参数来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its usefulness is rather limited as there is no other information provided about the overflow than the current call stack.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093512Z" creationid="pingfangx" creationdate="20190621T093512Z">
        <seg>它的实用性相当有限，因为除了当前调用堆栈之外，没有其他关于溢出的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java doesn't consider signatures such as `operator(Function&lt;T, Single&lt;R&gt;&gt;)` and `operator(Function&lt;T, Maybe&lt;R&gt;&gt;)` different (unlike C#) and due to erasure, the two `operator`s would end up as duplicate methods with the same signature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100903Z" creationid="pingfangx" creationdate="20190617T100903Z">
        <seg>由于擦除，Java 不认为 `operator(Function &lt;T，Single &lt;R &gt;&gt;)` 和 `operator(Function &lt;T，Maybe &lt;R &gt;&gt;)` 的签名是不同的(与 C# 不同)，这两个 ` operator` 最终会成为具有相同签名的重复方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange Messages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122111Z" creationid="pingfangx" creationdate="20190901T122111Z">
        <seg>密钥交换消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT" and "MAY" that appear in this document are to be interpreted as described in [RFC2119].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091207Z" creationid="pingfangx" creationdate="20190901T091207Z">
        <seg>本文档中出现的关键词 "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT" 和 "MAY" 应按照 [RFC2119] 中的描述进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Knowing When to Keep Quiet</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024330Z" creationid="pingfangx" creationdate="20190828T024330Z">
        <seg>知道什么时候保持安静</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LAST-ACK - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112839Z" creationid="pingfangx" creationdate="20190827T112839Z">
        <seg>LAST-ACK - 表示等待先前发送到远程 TCP 的连接终止请求的确认(其包括对其连接终止请求的确认)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LF             = &lt;US-ASCII LF, linefeed (10)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095334Z" creationid="pingfangx" creationdate="20190828T095334Z">
        <seg>LF             = &lt;US-ASCII LF, 换行 (10)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LISTEN - represents waiting for a connection request from any remote TCP and port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112612Z" creationid="pingfangx" creationdate="20190827T112612Z">
        <seg>LISTEN - 表示等待来自任何远程 TCP 和端口的连接请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOALPHA        = &lt;any US-ASCII lowercase letter "a".."z"&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094618Z" creationid="pingfangx" creationdate="20190828T094618Z">
        <seg>LOALPHA        = &lt;任何 US-ASCII 小写字母 "a".."z"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language Tags</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072208Z" creationid="pingfangx" creationdate="20190828T072208Z">
        <seg>语言标签</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language-Specific Information:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090906Z" creationid="pingfangx" creationdate="20190620T090906Z">
        <seg>语言特定信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last-Modified Dates</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073913Z" creationid="pingfangx" creationdate="20190828T073913Z">
        <seg>最后修改日期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading zeros MUST be ignored by recipients and MUST NOT be sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103709Z" creationid="pingfangx" creationdate="20190828T103709Z">
        <seg>收件人必须忽略前导零，且不得发送前导零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn more about RxJava in general on the &lt;a href="https://github.com/ReactiveX/RxJava/wiki"&gt;Wiki Home&lt;/a&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065616Z" creationid="pingfangx" creationdate="20190617T065616Z">
        <seg>有关 RxJava 的更多信息可参阅 &lt;a href="https://github.com/ReactiveX/RxJava/wiki"&gt;Wiki Home&lt;/a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like Observables, Singles can be manipulated by means of a variety of operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073856Z" creationid="pingfangx" creationdate="20190620T073856Z">
        <seg>像 Observables 一样，Singles 可以通过各种操作符进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134429Z" creationid="pingfangx" creationdate="20190831T134429Z">
        <seg>与安全的定义一样，幂等属性仅适用于用户请求的内容；服务器可以单独记录每个请求，保留修订控制历史记录，或为每个幂等请求实现其他非幂等副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111305Z" creationid="pingfangx" creationdate="20190831T111305Z">
        <seg>同样，如果客户端打算为后续请求重用相同的连接，则它必须读取整个响应消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134147Z" creationid="pingfangx" creationdate="20190831T134147Z">
        <seg>同样，通过在 Web 上选择广告而发起的安全请求通常具有向广告账户收费的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by checking the target resource revision(s) after a failed connection, reverting or fixing any changes that were partially applied, and then automatically retrying the requests that failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111518Z" creationid="pingfangx" creationdate="20190831T111518Z">
        <seg>同样，专门设计用于版本控制存储库的用户代理可能能够通过在连接失败后检查目标资源修订，恢复或修复部分应用的任何更改，然后自动从部分失败条件中恢复重试失败的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, abstract concepts can be resources, such as the operators and operands of a mathematical equation, the types of a relationship (e.g., "parent" or "employee"), or numeric values (e.g., zero, one, and infinity).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060641Z" creationid="pingfangx" creationdate="20190902T060641Z">
        <seg>同样，抽象概念可以是资源，例如数学方程的操作符和操作数，关系的类型(例如，“父”或“雇员”)，或数值(例如，零，一和无穷大)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, any server may act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081406Z" creationid="pingfangx" creationdate="20190828T081406Z">
        <seg>同样，任何服务器都可以充当源服务器，代理，网关或隧道，基于每个请求的性质来切换行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, common HTTP origin servers include home automation units, configurable networking components, office machines, autonomous robots, news feeds, traffic cameras, ad selectors, and video-delivery platforms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100630Z" creationid="pingfangx" creationdate="20190830T100630Z">
        <seg>同样，常见的 HTTP 源服务器包括家庭自动化单元，可配置网络组件，办公机器，自动机器人，新闻源，交通摄像头，广告选择器和视频传送平台。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, later requests might be sent through a different path of connections, often based on dynamic configuration for load balancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101148Z" creationid="pingfangx" creationdate="20190830T101148Z">
        <seg>同样，以后的请求可能通过不同的连接路径发送，通常基于负载平衡的动态配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, protocols and data formats that make use of URI references can refer to this specification as a definition for the range of syntax allowed for all URIs, including those schemes that have yet to be defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061940Z" creationid="pingfangx" creationdate="20190902T061940Z">
        <seg>同样，使用 URI 引用的协议和数据格式可以将此规范称为所有 URI 允许的语法范围的定义，包括那些尚未定义的方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134051Z" creationid="pingfangx" creationdate="20190831T134051Z">
        <seg>同样，合理使用安全方法预计不会对原始服务器造成任何伤害，财产损失或异常负担。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, requirements that an automated action be confirmed by the user before proceeding might be met via advance configuration choices, run-time options, or simple avoidance of the unsafe action; confirmation does not imply any specific user interface or interruption of normal processing if the user has already made that choice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100750Z" creationid="pingfangx" creationdate="20190830T100750Z">
        <seg>同样，可以通过提前配置选择，运行时选项或简单避免不安全操作来满足用户在继续之前确认自动操作的要求；如果用户已经做出该选择，则确认不暗示任何特定用户界面或正常处理的中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, servers do not need to be aware of each client's purpose: an HTTP request can be considered in isolation rather than being associated with a specific type of client or a predetermined sequence of application steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094231Z" creationid="pingfangx" creationdate="20190830T094231Z">
        <seg>同样，服务器不需要知道每个客户端的目的：可以单独考虑 HTTP 请求，而不是与特定类型的客户端或预定的应用程序步骤序列相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the "one" resource identified might not be singular in nature (e.g., a resource might be a named set or a mapping that varies over time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061007Z" creationid="pingfangx" creationdate="20190902T060957Z">
        <seg>同样，所识别的“一个”资源本质上可能不是单一的(例如，资源可能是命名集或随时间变化的映射)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the presence of such whitespace in a response might be ignored by some clients or cause others to cease parsing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T063659Z" creationid="pingfangx" creationdate="20190831T063659Z">
        <seg>同样，响应中存在这样的空格可能会被某些客户端忽略或导致其他客户端停止解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line folding in chunk extensions is disallowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092048Z" creationid="pingfangx" creationdate="20190830T092048Z">
        <seg>不允许在块扩展中折叠行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Linear white space (LWS) MUST NOT be used between the type and subtype, nor between an attribute and its value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T145034Z" creationid="pingfangx" creationdate="20190828T145034Z">
        <seg>线性空白(LWS)不能在类型和子类型之间使用，也不能在属性和它的值之间使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Location Headers and Spoofing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074409Z" creationid="pingfangx" creationdate="20190828T074409Z">
        <seg>位置首部和欺骗</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking to the right towards the subscriber/consumer, is called the **downstream**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070953Z" creationid="pingfangx" creationdate="20190617T070908Z">
        <seg>向右侧的订阅者/消费者看，称为 **downstream**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MHTML and Line Length Limitations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074628Z" creationid="pingfangx" creationdate="20190828T074628Z">
        <seg>MHTML 和行长限制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MIME provides for a number of "multipart" types -- encapsulations of one or more entities within a single message-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152007Z" creationid="pingfangx" creationdate="20190828T152007Z">
        <seg>MIME 提供了许多“multipart”类型 - 单个消息体内的一个或多个实体的封装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Major Differences from TLS 1.2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121636Z" creationid="pingfangx" creationdate="20190901T121636Z">
        <seg>与 TLS 1.2 的主要区别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many HTTP/1.1 header field values consist of words separated by LWS or special characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101211Z" creationid="pingfangx" creationdate="20190828T101211Z">
        <seg>许多 HTTP/1.1 首部字段值由 LWS 或特殊字符分隔的单词组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many URI schemes include a hierarchical element for a naming authority so that governance of the name space defined by the remainder of the URI is delegated to that authority (which may, in turn, delegate it further).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072907Z" creationid="pingfangx" creationdate="20190902T072907Z">
        <seg>许多 URI 方案包括命名权限的分层元素，以便将由 URI 的其余部分定义的名称空间的治理委托给该权限(进而可以进一步委托它)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many frequently used operator has overloads that can deal with the other types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100658Z" creationid="pingfangx" creationdate="20190617T100658Z">
        <seg>许多经常使用的运算符具有可以处理其他类型的重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many implementations depend on HTTP's stateless design in order to reuse proxied connections or dynamically load balance requests across multiple servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101901Z" creationid="pingfangx" creationdate="20190830T101901Z">
        <seg>许多实现依赖于 HTTP 的无状态设计，以便重用代理连接或跨多个服务器动态地负载平衡请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators that expect the user to provide some function returning a reactive type can't be overloaded because the type erasure around a `Function&lt;T, X&gt;` turns such method signatures into duplicates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102139Z" creationid="pingfangx" creationdate="20190617T102139Z">
        <seg>许多期望用户提供返回反应类型的函数的运算符不能被重载，因为围绕 `Function&lt;T, X&gt;` 的类型擦除将这样的方法签名变成重复的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many value generation can be expressed in a form of a state-machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020256Z" creationid="pingfangx" creationdate="20190624T020256Z">
        <seg>许多值生成可以以状态机的形式表达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching is performed using the matching rules specified by [RFC2459].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T104437Z" creationid="pingfangx" creationdate="20190901T104437Z">
        <seg>使用 [RFC2459] 指定的匹配规则执行匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mathematical and Aggregate Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072016Z" creationid="pingfangx" creationdate="20190620T072016Z">
        <seg>数学和集合操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Media Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072135Z" creationid="pingfangx" creationdate="20190828T072135Z">
        <seg>媒体类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Media-type values are registered with the Internet Assigned Number Authority (IANA [19]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T150130Z" creationid="pingfangx" creationdate="20190828T150130Z">
        <seg>媒体类型值已在 Internet Assigned Number Authority(IANA [19])中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Body</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T083710Z" creationid="pingfangx" creationdate="20190828T072243Z">
        <seg>消息主体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Body Length</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090758Z" creationid="pingfangx" creationdate="20190830T090758Z">
        <seg>消息主体长度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Confidentiality</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091210Z" creationid="pingfangx" creationdate="20190830T091210Z">
        <seg>消息机密性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Format</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090706Z" creationid="pingfangx" creationdate="20190830T090706Z">
        <seg>消息格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Forwarding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090948Z" creationid="pingfangx" creationdate="20190830T090948Z">
        <seg>消息转发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072721Z" creationid="pingfangx" creationdate="20190828T072227Z">
        <seg>消息首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Integrity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091208Z" creationid="pingfangx" creationdate="20190830T091208Z">
        <seg>消息完整性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Length</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072247Z" creationid="pingfangx" creationdate="20190828T072247Z">
        <seg>消息长度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Parsing Robustness</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090816Z" creationid="pingfangx" creationdate="20190830T090816Z">
        <seg>消息解析健状性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Routing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090921Z" creationid="pingfangx" creationdate="20190830T090921Z">
        <seg>消息路由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Transmission Requirements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073009Z" creationid="pingfangx" creationdate="20190828T073009Z">
        <seg>消息传输要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072217Z" creationid="pingfangx" creationdate="20190828T072217Z">
        <seg>消息类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T090421Z" creationid="pingfangx" creationdate="20190829T090421Z">
        <seg>消息不能同时包含 Content-Length 首部字段和非标识传输编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages are parsed using a generic algorithm, independent of the individual header field names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083244Z" creationid="pingfangx" creationdate="20190831T083244Z">
        <seg>使用通用算法解析消息，独立于各个首部字段名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages are passed in a format similar to that used by Internet mail [9] as defined by the Multipurpose Internet Mail Extensions (MIME) [7].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080039Z" creationid="pingfangx" creationdate="20190828T080039Z">
        <seg>消息的传递格式类似于多用途 Internet 邮件扩展(MIME)[7] 定义的 Internet 邮件 [9] 所使用的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages are passed in a format similar to that used by Internet mail [RFC5322] and the Multipurpose Internet Mail Extensions (MIME) [RFC2045] (see Appendix A of [RFC7231] for the differences between HTTP and MIME messages).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095922Z" creationid="pingfangx" creationdate="20190830T095922Z">
        <seg>消息的传递格式类似于互联网邮件 [RFC5322] 和多用途互联网邮件扩展(MIME)[RFC2045] 所使用的格式(有关 HTTP 和 MIME 邮件之间的差异，请参阅 [RFC7231] 的附录 A)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072307Z" creationid="pingfangx" creationdate="20190828T072307Z">
        <seg>方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method Definitions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073050Z" creationid="pingfangx" creationdate="20190828T073050Z">
        <seg>方法定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method Registry</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115933Z" creationid="pingfangx" creationdate="20190831T115933Z">
        <seg>方法注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T032611Z" creationid="pingfangx" creationdate="20190830T032611Z">
        <seg>方法也可以具有“幂等”的属性(除了错误或到期问题) N&gt;0 个相同请求的副作用与单个请求相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minimum supported sizes for various protocol elements have been suggested, to improve interoperability.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091750Z" creationid="pingfangx" creationdate="20190830T091750Z">
        <seg>已提出各种协议元素的最小支持大小，以提高互操作性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minor 2.x increments (such as 2.1, 2.2, etc) will occur when non-trivial new functionality is added or significant enhancements or bug fixes occur that may have behavioral changes that may affect some edge cases (such as dependence on behavior resulting from a bug).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104949Z" creationid="pingfangx" creationdate="20190617T104949Z">
        <seg>当添加非平凡的新功能或重大增强或发生可能影响某些边缘情况的行为变化（例如，对错误导致的行为的依赖）的错误修复时，将发生次要 2.x 升级（例如 2.1,2.2 等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122032Z" creationid="pingfangx" creationdate="20190901T122032Z">
        <seg>杂项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Missing Charset</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072118Z" creationid="pingfangx" creationdate="20190828T072118Z">
        <seg>丢失的字符集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Model of Operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071223Z" creationid="pingfangx" creationdate="20190828T071223Z">
        <seg>操作模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Connections for Error Status Messages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073021Z" creationid="pingfangx" creationdate="20190828T073021Z">
        <seg>监视错误状态消息的连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, it provides a `Scheduler` that schedules on the main thread or any given `Looper`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T030026Z" creationid="pingfangx" creationdate="20190624T030026Z">
        <seg>更具体地说，它提供了一个 `Scheduler`，它在主线程或任何给定的 `Looper` 上进行调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More than one response message per request only occurs when one or more informational responses (1xx, see Section 6.2 of [RFC7231]) precede a final response to the same request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132228Z" creationid="pingfangx" creationdate="20190831T132228Z">
        <seg>当一个或多个信息响应(1xx，参见 [RFC7231] 的第 6.2 节)在对同一请求的最终响应之前时，每个请求只发生一条响应消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most HTTP communication consists of a retrieval request (GET) for a representation of some resource identified by a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095945Z" creationid="pingfangx" creationdate="20190830T095945Z">
        <seg>大多数 HTTP 通信包括用于表示由 URI 标识的某些资源的检索请求(GET)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085232Z" creationid="pingfangx" creationdate="20190828T085232Z">
        <seg>大多数 HTTP 通信由用户代理启动，并且包含要应用于某个源服务器上的资源的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most HTTP header field values are defined using common syntax components (token, quoted-string, and comment) separated by whitespace or specific delimiting characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085620Z" creationid="pingfangx" creationdate="20190831T085620Z">
        <seg>大多数 HTTP 首部字段值是使用由空格或特定分隔字符分隔的通用语法组件(标记，引用字符串和注释)定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most asynchronous operator use this as their default `Scheduler`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073243Z" creationid="pingfangx" creationdate="20190617T073243Z">
        <seg>大多数异步操作符使用它作为它们的默认 `Scheduler`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most backpressure-sensitive operators in the recent versions of RxJava now allow programmers to specify the size of their internal buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090433Z" creationid="pingfangx" creationdate="20190621T090433Z">
        <seg>最近版本的 RxJava 中的大多数背压敏感操作符现在允许程序员指定其内部缓冲区的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most clients maintain multiple connections in parallel, including more than one connection per server endpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110142Z" creationid="pingfangx" creationdate="20190831T110142Z">
        <seg>大多数客户端并行维护多个连接，包括每个服务器端点多个连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most developers encounter backpressure when their application fails with `MissingBackpressureException` and the exception usually points to the `observeOn` operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T085845Z" creationid="pingfangx" creationdate="20190621T085845Z">
        <seg>大多数开发人员在应用程序因 `MissingBackpressureException` 而失败时都会遇到背压，而该异常通常指向 `observeOn` 操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most fields using product tokens also allow sub-products which form a significant part of the application to be listed, separated by white space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152940Z" creationid="pingfangx" creationdate="20190828T152940Z">
        <seg>使用产品标记的大多数字段还允许列出构成应用程序重要部分的子产品，由空格分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators are still there in 2.x and practically all of them have the same behavior as they had in 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T110949Z" creationid="pingfangx" creationdate="20190618T110949Z">
        <seg>大多数操作符仍然在 2.x 中，并且几乎所有操作符都具有与 1.x 中相同的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators operate on an Observable and return an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072320Z" creationid="pingfangx" creationdate="20190620T072320Z">
        <seg>大多数操作符都在 Observable 上操作并返回一个 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110203Z" creationid="pingfangx" creationdate="20190831T110203Z">
        <seg>大多数服务器旨在维护数千个并发连接，同时控制请求队列以实现合理使用并检测拒绝服务攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Motivation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071157Z" creationid="pingfangx" creationdate="20190828T071157Z">
        <seg>动机</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Much of that architecture is reflected in the terminology and syntax productions used to define HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094947Z" creationid="pingfangx" creationdate="20190830T094947Z">
        <seg>大部分体系结构都反映在用于定义 HTTP 的术语和语法产品中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple connections are typically used to avoid the "head-of-line blocking" problem, wherein a request that takes significant server-side processing and/or has a large payload blocks subsequent requests on the same connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112203Z" creationid="pingfangx" creationdate="20190831T112203Z">
        <seg>通常使用多个连接来避免“行头阻塞”问题，其中进行大量服务器端处理和/或具有大的有效载荷的请求阻止对同一连接的后续请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T081442Z" creationid="pingfangx" creationdate="20190829T081442Z">
        <seg>当且仅当该首部字段的整个字段值被定义为以逗号分隔的列表 [ 即，#(values)] 时，具有相同字段名的多个消息首部字段可以存在于消息中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Must be zero.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105328Z" creationid="pingfangx" creationdate="20190827T105328Z">
        <seg>必须为零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NOTE BENE:  this diagram is only a summary and must not be taken as the total specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T113245Z" creationid="pingfangx" creationdate="20190827T113245Z">
        <seg>注：此图只是一个概要，不能作为总规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming in programming is one of the hardest things as names are expected to be not long, expressive, capturing and easily memorable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101332Z" creationid="pingfangx" creationdate="20190617T101332Z">
        <seg>编程中的命名是最困难的事情之一，因为名称不宜太长，表达清楚，容易捕捉且容易记忆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, `fromCallable` also properly supports backpressure and won't emit the computed value unless requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020008Z" creationid="pingfangx" creationdate="20190624T020008Z">
        <seg>当然，`fromCallable` 也能正确支持背压，除非有要求，否则不会发射计算值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T032409Z" creationid="pingfangx" creationdate="20190830T032409Z">
        <seg>当然，不可能确保服务器不会因执行 GET 请求而产生副作用；实际上，一些动态资源会考虑这个功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151005Z" creationid="pingfangx" creationdate="20190829T151005Z">
        <seg>协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network intermediaries are indistinguishable (at a protocol level) from a man-in-the-middle attack, often introducing security flaws or interoperability problems due to mistakenly violating HTTP semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101757Z" creationid="pingfangx" creationdate="20190830T101757Z">
        <seg>网络中介与中间人攻击无法区分(在协议级别)，由于错误地违反 HTTP 语义而经常引入安全漏洞或互操作性问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nevertheless, nothing in this specification prevents an application from limiting itself to particular types of resources, or to a subset of URIs that maintains characteristics desired by that application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061235Z" creationid="pingfangx" creationdate="20190902T061235Z">
        <seg>然而，本说明书中没有任何内容阻止应用程序将其自身限制于特定类型的资源，或者限制维护该应用程序所需特性的 URI 的子集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New content-coding value tokens SHOULD be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed to implement a new value SHOULD be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141411Z" creationid="pingfangx" creationdate="20190828T141411Z">
        <seg>新的内容编码值标记应该注册；为了实现客户端和服务器之间的互操作性，实现新值所需的内容编码算法的规范应该是公开可用的，并且足以独立实现，并且符合本节中定义的内容编码的目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New functionality marked with an [`@Beta`][beta source link] or [`@Experimental`][experimental source link] annotation can also be added in patch releases to allow rapid exploration and iteration of unstable new functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105214Z" creationid="pingfangx" creationdate="20190617T105214Z">
        <seg>标记有 [`@Beta`][beta source link] 或 [`@Experimental`][experimental source link] 注释的新功能也可以添加到补丁版本中，以便快速探索和迭代不稳定的新功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New header fields can be defined such that, when they are understood by a recipient, they might override or enhance the interpretation of previously defined header fields, define preconditions on request evaluation, or refine the meaning of responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082040Z" creationid="pingfangx" creationdate="20190831T082040Z">
        <seg>可以定义新的首部字段，使得当接收者理解它们时，它们可以覆盖或增强对先前定义的首部字段的解释，定义请求评估的前提条件，或者细化响应的含义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New header fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103446Z" creationid="pingfangx" creationdate="20190830T103446Z">
        <seg>如果定义的语义允许它们被不识别它们的接收者安全地忽略，则可以在不更改协议版本的情况下引入新的首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New instances of a connection will be referred to as incarnations of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023152Z" creationid="pingfangx" creationdate="20190828T023152Z">
        <seg>连接的新实例将被称为连接的化身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061022Z" creationid="pingfangx" creationdate="20190619T061022Z">
        <seg>新返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New transfer-coding value tokens SHOULD be registered in the same way as new content-coding value tokens (section 3.5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143415Z" creationid="pingfangx" creationdate="20190828T143415Z">
        <seg>新的传输编码值标记应该以与新的内容编码值标记相同的方式注册(第 3.5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Newly defined header fields SHOULD limit their field values to US-ASCII octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T084957Z" creationid="pingfangx" creationdate="20190831T084957Z">
        <seg>新定义的首部字段应该将其字段值限制为 US-ASCII 八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next is a “decision tree” that may help you choose the operator that is most appropriate to your use case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094107Z" creationid="pingfangx" creationdate="20190620T094107Z">
        <seg>接下来是一个“决策树”，可以帮助您选择最适合您的用例的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No CR or LF is allowed except in the final CRLF sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T093632Z" creationid="pingfangx" creationdate="20190829T093632Z">
        <seg>除最终的 CRLF 序列外，不允许使用 CR 或 LF。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No Content-Transfer-Encoding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074616Z" creationid="pingfangx" creationdate="20190828T074616Z">
        <seg>无内容传输编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No change is made to the version number for the addition of message components which do not affect communication behavior or which only add to extensible field values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103113Z" creationid="pingfangx" creationdate="20190828T103113Z">
        <seg>添加不影响通信行为或仅添加到可扩展字段值的消息组件的版本号没有变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further SENDs from the user will be accepted by the TCP, and it enters the FIN-WAIT-1 state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063418Z" creationid="pingfangx" creationdate="20190828T063418Z">
        <seg>TCP 不接受用户的进一步 SEND，并进入 FIN-WAIT-1 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further development, support, maintenance, PRs and updates will happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065638Z" creationid="pingfangx" creationdate="20190617T065638Z">
        <seg>不会进一步开发，支持，维护，PR 和更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No longer wraps all consumer types (i.e., `Observer`) with a safety wrapper, (just like the 1.x `unsafeSubscribe` no longer available).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053805Z" creationid="pingfangx" creationdate="20190619T053805Z">
        <seg>不再用安全包装器包装所有消费者类型(即 `Observer`)(就像 1.x 中的 `unsafeSubscribe` 不再可用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No whitespace is allowed between the header field-name and colon.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083426Z" creationid="pingfangx" creationdate="20190831T083426Z">
        <seg>首部字段名称和冒号之间不允许有空格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-ASCII characters must first be encoded according to UTF-8 [STD63], and then each octet of the corresponding UTF-8 sequence must be percent-encoded to be represented as URI characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T080020Z" creationid="pingfangx" creationdate="20190902T080020Z">
        <seg>非 ASCII 字符必须首先根据 UTF-8[std63] 进行编码，然后相应的 UTF-8 序列的每个八位字节必须进行百分比编码，以表示为 URI 字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-US-ASCII content in header fields and the reason phrase has been obsoleted and made opaque (the TEXT rule was removed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091914Z" creationid="pingfangx" creationdate="20190830T091914Z">
        <seg>首部字段中的非 US-ASCII 内容和原因短语已被废弃并变为不透明(删除了 TEXT 规则)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-idempotent methods or sequences MUST NOT be automatically retried, although user agents MAY offer a human operator the choice of retrying the request(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152321Z" creationid="pingfangx" creationdate="20190829T152321Z">
        <seg>非幂等方法或序列不得自动重试，尽管用户代理可以为人类操作符提供重试请求的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-modifiable Headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074009Z" creationid="pingfangx" creationdate="20190828T074009Z">
        <seg>不可修改的首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-validating Conditionals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073941Z" creationid="pingfangx" creationdate="20190828T073941Z">
        <seg>非验证条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-validating parsers (those that merely separate a URI reference into its major components) will often ignore the subcomponent structure of authority, treating it as an opaque string from the double-slash to the first terminating delimiter, until such time as the URI is dereferenced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073454Z" creationid="pingfangx" creationdate="20190902T073454Z">
        <seg>非验证解析器(仅将 URI 引用分隔到其主要组件中的解析器)通常会忽略权限的子组件结构，将其视为从双斜杠到第一个终止分隔符的不透明字符串，直到取消对 URI 的引用为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor should it be assumed that a system using URIs will access the resource identified: in many cases, URIs are used to denote resources without any intention that they be accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060934Z" creationid="pingfangx" creationdate="20190902T060934Z">
        <seg>也不应该假设使用 URI 的系统将访问所识别的资源：在许多情况下，URI 用于表示资源而无意访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal Close Sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063956Z" creationid="pingfangx" creationdate="20190828T063956Z">
        <seg>正常关闭序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal HTTP behavior, including retained connections should be followed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091523Z" creationid="pingfangx" creationdate="20190901T091523Z">
        <seg>应遵循正常的 HTTP 行为，包括持久连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normalization and Comparison</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042951Z" creationid="pingfangx" creationdate="20190902T042951Z">
        <seg>规范化和比较</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normalization may increase the set of same-document references, which may be of benefit to some caching applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090038Z" creationid="pingfangx" creationdate="20190902T090038Z">
        <seg>规范化可能会增加同一文档引用的集合，这可能对某些缓存应用程序有益。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normalization of the base and target URIs prior to their comparison, as described in Sections 6.2.2 and 6.2.3, is allowed but rarely performed in practice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085941Z" creationid="pingfangx" creationdate="20190902T085941Z">
        <seg>如第 6.2.2 和 6.2.3 节所述，在比较之前对基本 URI 和目标 URI 进行标准化是允许的，但在实践中很少执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a “PublishSubject” here is known simply as a “Subject”):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083851Z" creationid="pingfangx" creationdate="20190620T083851Z">
        <seg>并非所有这些种类都在所有实现中可用，并且一些实现使用其他命名约定(例如，在 RxScala 中，在这里简称为“Subject”的被称为的“PublishSubject”)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all resources are network "retrievable"; e.g., human beings, corporations, and bound books in a library can also be considered resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040214Z" creationid="pingfangx" creationdate="20190902T040214Z">
        <seg>并非所有资源都是网络“可检索的”;例如，人，公司和图书馆中的装订书籍也可以被视为资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all responses are usefully cacheable, and some requests may contain modifiers which place special requirements on cache behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T091146Z" creationid="pingfangx" creationdate="20190828T091146Z">
        <seg>并非所有响应都可以缓存，并且某些请求可能包含对缓存行为提出特殊要求的修饰符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notational Conventions and Generic Grammar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072022Z" creationid="pingfangx" creationdate="20190828T072022Z">
        <seg>符号约定和通用语法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that due to Reactive-Streams compatibility, the method `onCompleted` has been renamed to `onComplete` without the trailing `d`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070522Z" creationid="pingfangx" creationdate="20190618T070522Z">
        <seg>另请注意，由于 Reactive-Streams 兼容性，方法 `onCompleted` 已重命名为 `onComplete` 而没有尾随的 `d`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also the `Files.readLines(name)` invoked without try-catch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064342Z" creationid="pingfangx" creationdate="20190618T064342Z">
        <seg>另请注意，在没有 try-catch 的情况下调用 `Files.readLines(name)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note hovewer that these operators only reduce the rate of value reception by the downstream and thus they may still lead to `MissingBackpressureException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091703Z" creationid="pingfangx" creationdate="20190621T091703Z">
        <seg>但请注意，这些操作符仅降低了下游的值接收速率，因此它们仍可能导致 `MissingBackpressureException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that `onBackpressureBuffer` consumes its source in an unbounded manner, that is, without applying any backpressure to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092853Z" creationid="pingfangx" creationdate="20190621T092853Z">
        <seg>但请注意，`onBackpressureBuffer` 以无限制的方式消耗其来源，即不对其施加任何背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that generally, this may be only a temporary fix as the overflow can still happen if the source overproduces the predicted buffer size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091109Z" creationid="pingfangx" creationdate="20190621T091109Z">
        <seg>但请注意，通常情况下，这可能只是一个临时修复，因为如果源过量生产超出预测的缓冲区大小，仍可能发生溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that the computation does happen anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020014Z" creationid="pingfangx" creationdate="20190624T020014Z">
        <seg>但请注意，无论如何计算确实会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a &lt;c0&gt;PublishSubject&lt;/c0&gt; may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084738Z" creationid="pingfangx" creationdate="20190620T084738Z">
        <seg>请注意，&lt;c0&gt;PublishSubject&lt;/c0&gt; 可能会在创建后立即开始发射项目(除非您已采取措施防止此情况)，因此在创建 Subject 和观察者订阅它之间的时间段内，可能会丢失一个或多个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a TCP receiving a FIN will ACK but not send its own FIN until its user has CLOSED the connection also.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063636Z" creationid="pingfangx" creationdate="20190828T063636Z">
        <seg>请注意，接收 FIN 的 TCP 将确认但不发送自己的 FIN，直到其用户也已 CLOSED 连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a premature close does not call into question the security of the data already received, but simply indicates that subsequent data might have been truncated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T092316Z" creationid="pingfangx" creationdate="20190901T092316Z">
        <seg>请注意，过早关闭不会对已收到的数据的安全性产生疑问，而只是表明后续数据可能已被截断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112246Z" creationid="pingfangx" creationdate="20190831T112246Z">
        <seg>请注意，服务器可能会拒绝其认为具有滥用或拒绝服务攻击特征的流量，例如来自单个客户端的过多打开连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that an implementation which does this MAY choose to reuse the session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091851Z" creationid="pingfangx" creationdate="20190901T091851Z">
        <seg>请注意，执行此操作的实现可以选择重用会话。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that due to how request management works, calling `request(n)` from `Subscriber.onSubscribe` or `ResourceSubscriber.onStart` may trigger calls to `onNext` immediately before the `request()` call itself returns to the `onSubscribe`/`onStart` method of yours:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072258Z" creationid="pingfangx" creationdate="20190618T071233Z">
        <seg>请注意，由于请求管理的工作方式，从 `Subscriber.onSubscribe` 或 `ResourceSubscriber.onStart` 调用 `request(n)` 可能会立即触发对 `onNext` 的调用，该调用在 `request()` 调用本身返回 `onSubscribe`/`onStart` 方法之前：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if a TCP is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024451Z" creationid="pingfangx" creationdate="20190828T024451Z">
        <seg>请注意，如果 TCP 在某种意义上重新初始化，但仍然保留其使用的序列号的内存，那么它根本不需要等待；它必须只能确保使用大于最近使用的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in many cases the URI itself comes from an untrusted source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111612Z" creationid="pingfangx" creationdate="20190901T111612Z">
        <seg>请注意，在许多情况下，URI 本身来自不受信任的来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it currently doesn't support additional parameters to those backpressure modes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022104Z" creationid="pingfangx" creationdate="20190624T022104Z">
        <seg>请注意，它目前不支持那些背压模式的附加参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that one tick mark represents one bit position.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104850Z" creationid="pingfangx" creationdate="20190827T104850Z">
        <seg>请注意，一个刻度标记表示一位位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that other forms of dotted notation may be interpreted on some platforms, as described in Section 7.4, but only the dotted-decimal form of four octets is allowed by this grammar.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075056Z" creationid="pingfangx" creationdate="20190902T075056Z">
        <seg>请注意，其他形式的点分表示法可能会在某些平台上解释，如第 7.4 节所述，但此语法只允许四个八位字节的点分十进制形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that some older HTTP applications do not recognize media type parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T145859Z" creationid="pingfangx" creationdate="20190828T145859Z">
        <seg>请注意，某些较旧的 HTTP 应用程序无法识别媒体类型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the "https" URI scheme depends on both TLS and TCP for establishing authority.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060648Z" creationid="pingfangx" creationdate="20190831T060648Z">
        <seg>请注意，“https”URI 方案依赖于 TLS 和 TCP 来建立权限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the absolute path cannot be empty; if none is present in the original URI, it MUST be given as "/" (the server root).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101212Z" creationid="pingfangx" creationdate="20190829T101212Z">
        <seg>注意绝对路径不能为空；如果原始 URI 中不存在，则必须以“/”(服务器根)的形式给出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the last two strategies cause discontinuity in the stream as they drop out elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014649Z" creationid="pingfangx" creationdate="20190624T014649Z">
        <seg>请注意，最后两个策略会导致流不连续，因为它们会删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the list of options may be shorter than the data offset field might imply.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110921Z" creationid="pingfangx" creationdate="20190827T110921Z">
        <seg>请注意，选项列表可能比数据偏移字段可能暗示的要短。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103556Z" creationid="pingfangx" creationdate="20190828T103556Z">
        <seg>请注意，主要和次要数字必须被视为单独的整数，并且每个数字可以增加到高于一位数字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the presence of a URI with a given authority component does not imply that there is always an HTTP server listening for connections on that host and port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044317Z" creationid="pingfangx" creationdate="20190831T044317Z">
        <seg>请注意，具有给定权限组件的 URI 的存在并不意味着始终有 HTTP 服务器侦听该主机和端口上的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the proxy MAY forward the request on to another proxy or directly to the server specified by the absoluteURI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100649Z" creationid="pingfangx" creationdate="20190829T100649Z">
        <seg>请注意，代理可以将请求转发到另一个代理或直接转发到 absoluteURI 指定的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the sequence number of the segment in line 5 is the same as in line 4 because the ACK does not occupy sequence number space (if it did, we would wind up ACKing ACK's!).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041825Z" creationid="pingfangx" creationdate="20190828T041825Z">
        <seg>请注意，第 5 行中的报文段的序列号与第 4 行中的相同，因为 ACK 不占用序列号空间(如果确实如此，我们将结束 ACK 确认！)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this list is not exhaustive -- it does not include extension status codes defined in other specifications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144737Z" creationid="pingfangx" creationdate="20190831T144737Z">
        <seg>请注意，此列表并非详尽无遗 - 它不包括其他规范中定义的扩展状态代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that unconditional conversion in the other direction is not required, in that not all characters may be available in a given character set and a character set may provide more than one sequence of octets to represent a particular character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114925Z" creationid="pingfangx" creationdate="20190828T114925Z">
        <seg>注意，不需要在另一个方向上的无条件转换，因为并非所有字符都可以在给定字符集中可用，并且字符集可以提供多于一个八位字节序列来表示特定字符​​。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when the receive window is zero no segments should be acceptable except ACK segments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022420Z" creationid="pingfangx" creationdate="20190828T022420Z">
        <seg>请注意，当接收窗口为零时，除了 ACK 报文段之外，不应接受任何报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of the `LATEST` backpressure mode; if we know there will be only a single value, we don't need the `BUFFER` strategy as it allocates a default 128 element long buffer (that grows as necessary) that is never going to be fully utilized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T023107Z" creationid="pingfangx" creationdate="20190624T023107Z">
        <seg>注意使用 `LATEST` 背压模式；如果我们知道只有一个值，我们不需要 `BUFFER` 策略，因为它分配一个永远不会被充分利用的默认 128 元素长缓冲区(必要时增长)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that `flatMap` doesn't guarantee any order and the end result from the inner flows may end up interleaved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083110Z" creationid="pingfangx" creationdate="20190617T083110Z">
        <seg>但请注意，`flatMap` 不保证任何顺序，内部流的最终结果可能会交错出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that some received protocol elements might not be parsed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102705Z" creationid="pingfangx" creationdate="20190830T102705Z">
        <seg>但请注意，某些收到的协议元素可能无法解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: Converting between versions of HTTP may involve modification of header fields required or forbidden by the versions involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104209Z" creationid="pingfangx" creationdate="20190828T104201Z">
        <seg>注意：在 HTTP 版本之间进行转换可能涉及修改所涉及版本所需或禁止的首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: HTTP requirements for the date/time stamp format apply only to their usage within the protocol stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114355Z" creationid="pingfangx" creationdate="20190828T114355Z">
        <seg>注意：日期/时间戳格式的 HTTP 要求仅适用于它们在协议流中的使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: HTTP's use of Content-Length for message framing differs significantly from the same field's use in MIME, where it is an optional field used only within the "message/external-body" media-type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101126Z" creationid="pingfangx" creationdate="20190831T101126Z">
        <seg>注意：HTTP 对消息框架的 Content-Length 的使用与 MIME 中相同字段的使用显着不同，在 MIME 中，它是仅在“message/external-body”媒体类型中使用的可选字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: In practice, the "Set-Cookie" header field ([RFC6265]) often appears multiple times in a response message and does not use the list syntax, violating the above requirements on multiple header fields with the same name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082555Z" creationid="pingfangx" creationdate="20190831T082555Z">
        <seg>注意：实际上，“Set-Cookie”首部字段([RFC6265])经常在响应消息中多次出现，并且不使用列表语法，违反了对具有相同名称的多个首部字段的上述要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: Recipients of date values are encouraged to be robust in accepting date values that may have been sent by non-HTTP applications, as is sometimes the case when retrieving or posting messages via proxies/gateways to SMTP or NNTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113817Z" creationid="pingfangx" creationdate="20190828T113817Z">
        <seg>注意：鼓励日期值的接收者在接受非 HTTP 应用程序可能发送的日期值时非常健壮，有时在通过代理/网关检索或发布消息到 SMTP 或 NNTP 时也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations might not properly support these lengths.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T110809Z" creationid="pingfangx" creationdate="20190828T110809Z">
        <seg>注意：服务器应该谨慎依赖于长度超过 255 个字节的 URI，因为某些较旧的客户端或代理实现可能无法正确支持这些长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: The "multipart/form-data" type has been specifically defined for carrying form data suitable for processing via the POST request method, as described in RFC 1867 [15].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152823Z" creationid="pingfangx" creationdate="20190828T152823Z">
        <seg>注意：“multipart/form-data”类型已经专门定义用于携带适合通过 POST 请求方法处理的表单数据，如 RFC 1867 [15] 中所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: The "no rewrite" rule prevents the proxy from changing the meaning of the request when the origin server is improperly using a non-reserved URI character for a reserved purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101429Z" creationid="pingfangx" creationdate="20190829T101429Z">
        <seg>注意：“无重写”规则可防止代理在原始服务器不正确地使用非保留 URI 字符用于保留目的时更改请求的含义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: This use of the term "character set" is more commonly referred to as a "character encoding." However, since HTTP and MIME share the same registry, it is important that the terminology also be shared.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115040Z" creationid="pingfangx" creationdate="20190828T115040Z">
        <seg>注意：术语“字符集”的这种使用通常被称为“字符编码”。但是，由于 HTTP 和 MIME 共享相同的注册表，因此共享术语也很重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now suppose, at this instant, the host crashes, recovers, and establishes a new incarnation of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025655Z" creationid="pingfangx" creationdate="20190828T025655Z">
        <seg>现在假设，在这一瞬间，主机崩溃，恢复并建立连接的新化身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can directly block for some results by invoking a `blockingX` operation directly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095232Z" creationid="pingfangx" creationdate="20190618T095232Z">
        <seg>现在，您可以通过直接调用 `blockingX` 操作直接阻塞某些结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbering of octets within a segment is that the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021236Z" creationid="pingfangx" creationdate="20190828T021122Z">
        <seg>报文段内八位字节的编号是紧跟在首部之后的第一个数据八位字节，其编号最小的，并且后面的八位字节是连续编号的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OCTET          = &lt;any 8-bit sequence of data&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094534Z" creationid="pingfangx" creationdate="20190828T094534Z">
        <seg>OCTET          = &lt;任何 8 位数据序列&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects of the &lt;c0&gt;Worker&lt;/c0&gt; class implement &lt;a1&gt;the &lt;c2&gt;Subscription&lt;/c2&gt; interface&lt;/a1&gt;, with its &lt;a3&gt;&lt;c4&gt;isUnsubscribed&lt;/c4&gt;&lt;/a3&gt; and &lt;a5&gt;&lt;c6&gt;unsubscribe&lt;/c6&gt;&lt;/a5&gt; methods, so you can stop work when a subscription is cancelled, or you can cancel the subscription from within the scheduled task:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092237Z" creationid="pingfangx" creationdate="20190620T092237Z">
        <seg>&lt;c0&gt;Worker&lt;/c0&gt; 类的对象实现 &lt;a1&gt;&lt;c2&gt;Subscription&lt;/c2&gt; 接口&lt;/a1&gt;，使用他的 &lt;a3&gt;&lt;c4&gt;isUnsubscribed&lt;/c4&gt;&lt;/a3&gt; 和 &lt;a5&gt;&lt;c6&gt;unsubscribe&lt;/c6&gt;&lt;/a5&gt; 方法，因此你可以在取消订阅时停止工作，也可以从计划任务中取消订阅：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observable Utility Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101858Z" creationid="pingfangx" creationdate="20190620T101858Z">
        <seg>Observable 辅助操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Composable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034539Z" creationid="pingfangx" creationdate="20190620T034517Z">
        <seg>Observables 是可组合的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Flexible</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034528Z" creationid="pingfangx" creationdate="20190620T034528Z">
        <seg>Observables 是灵活的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Less Opinionated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034607Z" creationid="pingfangx" creationdate="20190620T034607Z">
        <seg>Observables 是无偏见的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables and observers are only the start of ReactiveX.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071352Z" creationid="pingfangx" creationdate="20190620T070226Z">
        <seg>对于 ReactiveX 来说，Observable 和观察者仅仅是个开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables can be implemented using thread-pools, event loops, non-blocking I/O, actors (such as from Akka), or whatever implementation suits your needs, your style, or your expertise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040404Z" creationid="pingfangx" creationdate="20190620T040312Z">
        <seg>可以用任何方式来实现 Observable，使用线程池，事件循环，非阻塞 I/O，actor(例如来自 Akka)或任何适合您的需求，风格或专业知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables fill the gap by being the ideal way to access asynchronous sequences of multiple items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033647Z" creationid="pingfangx" creationdate="20190620T033647Z">
        <seg>Observable 通过理想方式访问多个项的异步序列来填补空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, even where a user selects to "wait," this is not necessary after the host has been "up" for at least MSL seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025902Z" creationid="pingfangx" creationdate="20190828T025902Z">
        <seg>显然，即使用户选择“等待”，在主机已经“启动”至少 MSL 秒之后也不需要这样做。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, suffixes of various kinds may appear together:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103554Z" creationid="pingfangx" creationdate="20190617T103554Z">
        <seg>当然，各种后缀可能会一起出现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, the arrival of an old duplicate "SYN" segment can potentially make it appear, to the recipient, that a simultaneous connection initiation is in progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031550Z" creationid="pingfangx" creationdate="20190828T031550Z">
        <seg>当然，旧的重复“SYN”报文段的到来可能使得向接收者显示同时连接启动正在进行中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, we can imitate other typical sources, such as an unbounded range with it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021515Z" creationid="pingfangx" creationdate="20190624T021515Z">
        <seg>当然，我们可以模仿其他典型的来源，例如无限范围：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134417Z" creationid="pingfangx" creationdate="20190831T134417Z">
        <seg>在本规范定义的请求方法中，PUT，DELETE 和安全请求方法是幂等的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134153Z" creationid="pingfangx" creationdate="20190831T134153Z">
        <seg>在本规范定义的请求方法中，GET，HEAD，OPTIONS 和 TRACE 方法被定义为安全的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often though there is a way that is somewhat more expressive (and also lower overhead) by using `Completable` as the mediator and its operator `andThen` to resume with something else:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091925Z" creationid="pingfangx" creationdate="20190617T091925Z">
        <seg>通常有一种方式更具表现力(也更低开销)，使用 `Completable` 作为调解器及其运算符 `andThen` 继续使用其他内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old Duplicate SYN Initiates a Reset on two Passive Sockets</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060417Z" creationid="pingfangx" creationdate="20190828T060417Z">
        <seg>旧的重复 SYN 在两个无源套接字上启动重置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061019Z" creationid="pingfangx" creationdate="20190619T061019Z">
        <seg>旧返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103237Z" creationid="pingfangx" creationdate="20190831T103237Z">
        <seg>较早的 HTTP/1.0 用户代理实现可能会在 POST 请求之后发送额外的 CRLF，作为某些早期服务器应用程序的解决方法，这些应用程序无法读取未通过行结束终止的消息正文内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On desktop Java, this latter handler does nothing on an `ExecutorService` backed `Scheduler` and the application can keep running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090323Z" creationid="pingfangx" creationdate="20190618T090323Z">
        <seg>在桌面 Java 上，后一个处理程序对 `ExecutorService` 支持的 `Scheduler` 什么都不做，应用程序可以继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a close has been signaled, the client MUST NOT send any more requests on that connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150352Z" creationid="pingfangx" creationdate="20190829T150352Z">
        <seg>一旦发出关闭信号，客户端就不能再在该连接上发送任何请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a connection is established this is always sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105237Z" creationid="pingfangx" creationdate="20190827T105237Z">
        <seg>建立连接后，始终会发送此字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel may have been initiated by an HTTP request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081643Z" creationid="pingfangx" creationdate="20190828T081643Z">
        <seg>一旦激活，隧道不被视为 HTTP 通信的一方，尽管隧道可能已由 HTTP 请求启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel might have been initiated by an HTTP request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101614Z" creationid="pingfangx" creationdate="20190830T101614Z">
        <seg>一旦激活，隧道就不被视为 HTTP 通信的一方，尽管隧道可能是由 HTTP 请求发起的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once an inbound connection is obtained, the client sends an HTTP request message (Section 3) with a request-target derived from the target URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123811Z" creationid="pingfangx" creationdate="20190831T123811Z">
        <seg>获得入站连接后，客户端将发送一条 HTTP 请求消息(第 3 节)，其中包含从目标 URI 派生的请求目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133650Z" creationid="pingfangx" creationdate="20190831T133650Z">
        <seg>一旦定义，标准化方法在应用于任何资源时应该具有相同的语义，尽管每个资源自己确定是否实现或允许这些语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the `compute(int)` finishes, the another value is then requested from `range`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082132Z" creationid="pingfangx" creationdate="20190621T082132Z">
        <seg>一旦 `compute(int)` 完成，就会从 `range` 请求另一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data is ready, you can make sure they get processed on the foreground or GUI thread via `observeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072853Z" creationid="pingfangx" creationdate="20190617T072853Z">
        <seg>数据准备好后，您可以确保通过 `observeOn` 在前台或 GUI 线程上处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the effective request URI has been constructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132012Z" creationid="pingfangx" creationdate="20190831T132012Z">
        <seg>一旦构建了有效请求 URI，源服务器就需要决定是否通过接收请求的连接为该 URI 提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the scheme is determined, further scheme-specific parsing can be performed on the components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T062014Z" creationid="pingfangx" creationdate="20190902T062014Z">
        <seg>一旦确定了方案，就可以对组件执行进一步的特定于方案的解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the target URI is determined, a client needs to decide whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123535Z" creationid="pingfangx" creationdate="20190831T123535Z">
        <seg>一旦确定了目标 URI，客户端就需要决定是否需要网络请求来完成所需的语义，如果需要，则需要确定该请求的定向位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can think of it as a 0 capacity `onBackpressureBuffer` with strategy `ON_OVERFLOW_DROP_LATEST`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014750Z" creationid="pingfangx" creationdate="20190624T014750Z">
        <seg>可以将其视为具有策略 `ON_OVERFLOW_DROP_LATEST` 的 0 容量 `onBackpressureBuffer`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can think of this as a variant of the `onBackpressureBuffer` with a capacity of 1 and strategy of `ON_OVERFLOW_DROP_OLDEST`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015135Z" creationid="pingfangx" creationdate="20190624T015135Z">
        <seg>可以将其视为 `onBackpressureBuffer` 的变体，其容量为 1，策略为 `ON_OVERFLOW_DROP_OLDEST`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One consequence of this flexibility is that the protocol cannot be defined in terms of what occurs behind the interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094309Z" creationid="pingfangx" creationdate="20190830T094309Z">
        <seg>这种灵活性的一个结果是协议不能根据接口背后的内容来定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One could, of course, turn that into an `Iterable` but when such sources are associated with resources, we may leak those resources if the downstream unsubscribes the sequence before it would end.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021000Z" creationid="pingfangx" creationdate="20190624T021000Z">
        <seg>当然，可以将其转换为 `Iterable`，但是当这些源与资源相关联时，如果下游在序列结束之前取消订阅序列，我们可能会泄漏这些资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One design goal of HTTP is to separate resource identification from request semantics, which is made possible by vesting the request semantics in the request method (Section 4) and a few request-modifying header fields (Section 5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122921Z" creationid="pingfangx" creationdate="20190831T122921Z">
        <seg>HTTP 的一个设计目标是将资源标识与请求语义分开，这可以通过将请求语义归入请求方法(第 4 节)和一些请求修改首部字段(第 5 节)来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example would be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100129Z" creationid="pingfangx" creationdate="20190829T100129Z">
        <seg>一个例子是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important design requirement for 2.x is that no `Throwable` errors should be swallowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085938Z" creationid="pingfangx" creationdate="20190618T085938Z">
        <seg>2.x 的一个重要设计要求是不应忽略任何 `Throwable` 的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One main point of difference is that functional reactive programming operates on values that change &lt;e0&gt;continuously&lt;/e0&gt; over time, while ReactiveX operates on &lt;e1&gt;discrete&lt;/e1&gt; values that are emitted over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034024Z" creationid="pingfangx" creationdate="20190620T034024Z">
        <seg>一个主要的不同点是函数性响应式编程对随时间变化的 &lt;e0&gt;continuously (连续)&lt;/e0&gt; 值进行操作，而 ReactiveX 对随时间发射的 &lt;e1&gt;discrete (离散)&lt;/e1&gt; 值进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One notable difference is that all our functional interfaces now define `throws Exception`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064131Z" creationid="pingfangx" creationdate="20190618T064131Z">
        <seg>一个值得注意的区别是我们所有的函数接口现在都定义了 `throws Exception`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the benefits is that changing `Flowable` to `Observable` here the test code part doesn't have to change at all due to the implicit type change of the `TestSubscriber` to `TestObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101614Z" creationid="pingfangx" creationdate="20190618T101614Z">
        <seg>其中一个好处是将 `Flowable` 改为 `Observable`，测试代码部分根本不需要改变，因为 `TestSubscriber` 隐式改为 `TestObserver`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the common use cases for RxJava is to run some computation, network request on a background thread and show the results (or error) on the UI thread:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072246Z" creationid="pingfangx" creationdate="20190617T072246Z">
        <seg>RxJava 的一个常见用例是在后台线程上运行一些计算，网络请求并在 UI 线程上显示结果(或错误)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the design flaws of RxJava 1.x was the exposure of the `rx.Observable.create()` method that while powerful, not the typical operator you want to use to enter the reactive world.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094300Z" creationid="pingfangx" creationdate="20190618T094300Z">
        <seg>RxJava 1.x 的一个设计缺陷是 `rx.Observable.create()` 方法的曝光，虽然功能强大，但不是您想要用来进入响应世界的典型操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One version allows you to set this time out by means of a number of specified time units:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075647Z" creationid="pingfangx" creationdate="20190620T075647Z">
        <seg>一个版本允许您通过许多指定的时间单位设置此时间：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One version of merge takes a Single that emits a second Single and converts it into a Single that emits the item emitted by that second Single:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075522Z" creationid="pingfangx" creationdate="20190620T075522Z">
        <seg>一个合并的版本，需要一个 Single 发射第二个 Single 并将其转换为 Single，它发射第二个 Single 发射的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the "quite time" specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025829Z" creationid="pingfangx" creationdate="20190828T025829Z">
        <seg>解决这个问题的一种方法是在从崩溃恢复后故意延迟一个 MSL 的发射报文段 - 这是“quite time”的规范。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One would be inclined to write such continuations as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092156Z" creationid="pingfangx" creationdate="20190617T092156Z">
        <seg>人们倾向于写下如下的延续：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the most common subcomponents are defined by this specification; other subcomponents may be defined by a URI scheme's specification, or by the implementation-specific syntax of a URI's dereferencing algorithm, provided that such subcomponents are delimited by characters in the reserved set allowed within that component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070954Z" creationid="pingfangx" creationdate="20190902T070954Z">
        <seg>本规范仅定义了最常见的子组件；其他子组件可以由 URI 方案的规范定义，或者由 URI 的解除引用算法的特定于实现的语法定义，前提是这些子组件由该组件内允许的保留集中的字符分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071214Z" creationid="pingfangx" creationdate="20190828T071214Z">
        <seg>操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators By Category</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094354Z" creationid="pingfangx" creationdate="20190620T094354Z">
        <seg>操作符分类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators marked as `@Beta` or `@Experimental` in 1.x are promoted to standard.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111329Z" creationid="pingfangx" creationdate="20190618T111329Z">
        <seg>在 1.x 中标记为 `@Beta` 或 `@Experimental` 的操作符将升级为标准操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators of the new `Flowable` base reactive type now consider downstream request amounts properly, however, this doesn't mean `MissingBackpressureException` is gone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073550Z" creationid="pingfangx" creationdate="20190618T073550Z">
        <seg>新的 `Flowable` 基本响应类型的运算符现在正确考虑下游请求数量，但是，这并不意味着 `MissingBackpressureException` 消失了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that evaluate one or more Observables or items emitted by Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102521Z" creationid="pingfangx" creationdate="20190620T102521Z">
        <seg>计算一个或多个 Observables 或 Observable 发射的项目的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that help to recover from error notifications from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101819Z" creationid="pingfangx" creationdate="20190620T101819Z">
        <seg>有助于从 Observable 发出的错误通知中恢复的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that operate on the entire sequence of items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102846Z" creationid="pingfangx" creationdate="20190620T102846Z">
        <seg>操作 Observable 发射的整个项目序列的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that originate new Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094459Z" creationid="pingfangx" creationdate="20190620T094459Z">
        <seg>创建新 Observables 的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that selectively emit items from a source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100037Z" creationid="pingfangx" creationdate="20190620T100037Z">
        <seg>有选择地从源 Observable 中发射项的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that transform items that are emitted by an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095438Z" creationid="pingfangx" creationdate="20190620T095438Z">
        <seg>转换 Observable 发射的数据项的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that work with multiple source Observables to create a single Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101232Z" creationid="pingfangx" creationdate="20190620T101232Z">
        <seg>使用多个源 Observable 创建单个 Observable 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators to Convert Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103717Z" creationid="pingfangx" creationdate="20190620T103717Z">
        <seg>转换 Observables 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally, the least-significant two pieces may instead be represented in IPv4 address textual format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074741Z" creationid="pingfangx" creationdate="20190902T074741Z">
        <seg>可选地，最不重要的两个部分可以替代地以 IPv4 地址文本格式表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110808Z" creationid="pingfangx" creationdate="20190827T110808Z">
        <seg>选项可能占用 TCP 首部末尾的空间，并且长度为 8 位的倍数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or, something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053036Z" creationid="pingfangx" creationdate="20190620T053036Z">
        <seg>或者，像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other URI schemes make the hierarchy explicit and visible to generic parsing algorithms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064613Z" creationid="pingfangx" creationdate="20190902T064613Z">
        <seg>其他 URI 方案使层次结构对于通用解析算法显而易见且可见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other fields such as window, addresses, lengths, and text have been left out in the interest of clarity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034713Z" creationid="pingfangx" creationdate="20190828T034713Z">
        <seg>为了清楚起见，省略了诸如窗口，地址，长度和文本之类的其他字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other pages show how you use &lt;a0&gt;the variety of Observable operators&lt;/a0&gt; to link Observables together and change their behaviors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044205Z" creationid="pingfangx" creationdate="20190620T044205Z">
        <seg>其他页面显示了如何使用 &lt;a0&gt;各种 Observable 运算符&lt;/a0&gt; 将 Observable 链接在一起并更改其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other protocols might also be used to provide access to "http" identified resources -- it is only the authoritative interface that is specific to TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T055030Z" creationid="pingfangx" creationdate="20190831T055030Z">
        <seg>其他协议也可用于提供对“http”标识资源的访问 - 它只是特定于 TCP 的权威接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other recipients SHOULD ignore unrecognized header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082105Z" creationid="pingfangx" creationdate="20190831T082105Z">
        <seg>其他接收者应该忽略无法识别的首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others are used for access control or to filter content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132326Z" creationid="pingfangx" creationdate="20190831T132326Z">
        <seg>其他用于访问控制或过滤内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others do not operate on any particular Scheduler, or operate on a particular default Scheduler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091415Z" creationid="pingfangx" creationdate="20190620T091415Z">
        <seg>其他人不在任何特定的调度器上运行，或在特定的默认调度器上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, a premature termination of the transport connection could lead to indeterminate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151534Z" creationid="pingfangx" creationdate="20190829T151534Z">
        <seg>否则，过早终止传输连接可能导致不确定的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the request is received over a TLS-secured TCP connection, the effective request URI's scheme is "https"; if not, the scheme is "http".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131528Z" creationid="pingfangx" creationdate="20190831T130942Z">
        <seg>否则，如果是通过 TLS 安全的 TCP 连接接收到请求，则有效请求 URI 的方案是“https”;如果没有，该方案是“http”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the (most specific) Common Name field in the Subject field of the certificate MUST be used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103926Z" creationid="pingfangx" creationdate="20190901T103926Z">
        <seg>否则，必须使用证书的 Subject 字段中的(最具体的)Common Name 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the authority component is assigned the default name configured for the server and, if the connection's incoming TCP port number differs from the default port for the effective request URI's scheme, then a colon (":") and the incoming port number (in decimal form) are appended to the authority component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131109Z" creationid="pingfangx" creationdate="20190831T131109Z">
        <seg>否则，为权限组件分配为服务器配置的默认名称，如果连接的传入 TCP 端口号与有效请求 URI 的方案的默认端口不同，则冒号(“:”)和传入端口号(在十进制格式)附加到权限组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the client might not reliably receive the response message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025557Z" creationid="pingfangx" creationdate="20190830T025557Z">
        <seg>否则，客户端可能无法可靠地接收响应消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the combined path and query component is the same as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131839Z" creationid="pingfangx" creationdate="20190831T131331Z">
        <seg>否则，组合 path 和 query 组件与请求目标相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the effective request URI is constructed as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130707Z" creationid="pingfangx" creationdate="20190831T130707Z">
        <seg>否则，有效请求 URI 构造如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102256Z" creationid="pingfangx" creationdate="20190831T102256Z">
        <seg>否则，这是没有声明的消息体长度的响应消息，因此消息体长度由服务器关闭连接之前接收的八位字节数确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our goal is to define all of the mechanisms necessary for HTTP message handling that are independent of message semantics, thereby defining the complete set of requirements for message parsers and message-forwarding intermediaries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094451Z" creationid="pingfangx" creationdate="20190830T094451Z">
        <seg>我们的目标是定义独立于消息语义的 HTTP 消息处理所需的所有机制，从而为消息解析器和消息转发中介定义完整的需求集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our use of the terms "identify" and "identifying" refer to this purpose of distinguishing one resource from all other resources, regardless of how that purpose is accomplished (e.g., by name, address, or context).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060818Z" creationid="pingfangx" creationdate="20190902T060818Z">
        <seg>我们对术语“identify”和“identifying”的使用指的是将一种资源与所有其他资源区分开的目的，而不管如何实现该目的(例如，通过名称，地址或上下文)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overall Operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072012Z" creationid="pingfangx" creationdate="20190828T072012Z">
        <seg>整体运作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115745Z" creationid="pingfangx" creationdate="20190831T115745Z">
        <seg>概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overview of Status Codes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115841Z" creationid="pingfangx" creationdate="20190831T115841Z">
        <seg>状态代码概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overview of URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035922Z" creationid="pingfangx" creationdate="20190902T035922Z">
        <seg>URI 概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overview of URIs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042546Z" creationid="pingfangx" creationdate="20190902T042546Z">
        <seg>URI 概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PHILOSOPHY</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071216Z" creationid="pingfangx" creationdate="20190828T071216Z">
        <seg>哲学</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POST is designed to allow a uniform method to cover the following functions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064111Z" creationid="pingfangx" creationdate="20190830T064111Z">
        <seg>POST 旨在允许统一的方法来涵盖以下功能：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POST requests MUST obey the message transmission requirements set out in section 8.2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064739Z" creationid="pingfangx" creationdate="20190830T064739Z">
        <seg>POST 请求必须遵守 8.2 节中规定的消息传输要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PREFACE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071150Z" creationid="pingfangx" creationdate="20190828T071150Z">
        <seg>前言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PSH:  Push Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105413Z" creationid="pingfangx" creationdate="20190827T105413Z">
        <seg>PSH：推送功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PUT requests MUST obey the message transmission requirements set out in section 8.2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T071553Z" creationid="pingfangx" creationdate="20190830T071553Z">
        <seg>PUT 请求必须遵守 8.2 节中规定的消息传输要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter types may be defined by scheme-specific semantics, but in most cases the syntax of a parameter is specific to the implementation of the URI's dereferencing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083026Z" creationid="pingfangx" creationdate="20190902T083026Z">
        <seg>参数类型可以由特定于方案的语义定义，但在大多数情况下，参数的语法特定于 URI 的解除引用算法的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T145020Z" creationid="pingfangx" creationdate="20190828T145020Z">
        <seg>参数值可能是也可能不区分大小写，具体取决于参数名称的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters MAY follow the type/subtype in the form of attribute/value pairs (as defined in section 3.6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144956Z" creationid="pingfangx" creationdate="20190828T144956Z">
        <seg>参数可以以属性/值对的形式遵循类型/子类型(如第 3.6 节中所定义)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters are in  the form of attribute/value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142355Z" creationid="pingfangx" creationdate="20190828T142355Z">
        <seg>参数采用属性/值对的形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T062821Z" creationid="pingfangx" creationdate="20190831T062821Z">
        <seg>将 HTTP 消息解析为 Unicode 字符流，而不考虑特定的编码，会由于字符串处理库处理包含八位字节 LF (%x0A) 的无效多字节字符序列的方式不同而造成安全漏洞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patch 2.x.y increments (such as 2.0.0 -&gt; 2.0.1, 2.3.1 -&gt; 2.3.2, etc) will occur for bug fixes and trivial functionality (like adding a method overload).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105139Z" creationid="pingfangx" creationdate="20190617T105139Z">
        <seg>补丁 2.x.y 增量(如 2.0.0-&gt;2.0.1、2.3.1-&gt;2.3.2 等)将出现在 bug 修复和琐碎功能(如添加方法重载)上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Payload Semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115719Z" creationid="pingfangx" creationdate="20190831T115719Z">
        <seg>有效载荷语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Payload header fields are defined in other parts of this specification, due to their impact on message parsing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025849Z" creationid="pingfangx" creationdate="20190902T025849Z">
        <seg>Payload 首部字段在本规范的其他部分中定义，因为它们对消息解析有影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Percent-Encoding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042755Z" creationid="pingfangx" creationdate="20190902T042755Z">
        <seg>百分号编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Percent-encoding a reserved character, or decoding a percent-encoded octet that corresponds to a reserved character, will change how the URI is interpreted by most applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070710Z" creationid="pingfangx" creationdate="20190902T070710Z">
        <seg>对保留字符进行百分比编码，或解码与保留字符对应的百分比编码八位字节，将改变大多数应用程序解释 URI 的方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091014Z" creationid="pingfangx" creationdate="20190830T091014Z">
        <seg>持久</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent Connections</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072954Z" creationid="pingfangx" creationdate="20190828T072954Z">
        <seg>持久连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent Connections and Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073012Z" creationid="pingfangx" creationdate="20190828T073012Z">
        <seg>持久连接和流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent HTTP connections have a number of advantages:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144156Z" creationid="pingfangx" creationdate="20190829T144156Z">
        <seg>持久 HTTP 连接有许多优点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150319Z" creationid="pingfangx" creationdate="20190829T150319Z">
        <seg>持久连接提供了一种机制，通过该机制，客户端和服务器可以发出 TCP 连接关闭的信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Personal Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074316Z" creationid="pingfangx" creationdate="20190828T074316Z">
        <seg>个人信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pipelining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151021Z" creationid="pingfangx" creationdate="20190829T151021Z">
        <seg>流水线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144938Z" creationid="pingfangx" creationdate="20190829T144938Z">
        <seg>流水线技术允许客户端在不等待每个响应的情况下发出多个请求，从而允许更有效地使用单个 TCP 连接，并且使用时间更短。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please refer to the current edition of the "Internet Official Protocol Standards" (STD 1) for the standardization state and status of this protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070905Z" creationid="pingfangx" creationdate="20190828T070905Z">
        <seg>有关本协议的标准化状态和状态，请参阅当前版本的“互联网官方协议标准”(STD 1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Port Number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090521Z" creationid="pingfangx" creationdate="20190901T090521Z">
        <seg>端口号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical Considerations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073005Z" creationid="pingfangx" creationdate="20190828T073005Z">
        <seg>实际考虑因素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical information systems require more functionality than simple retrieval, including search, front-end update, and annotation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075551Z" creationid="pingfangx" creationdate="20190828T075551Z">
        <seg>实用信息系统需要比简单检索更多的函数，包括搜索，前端更新和注释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, parallelism in RxJava means running independent flows and merging their results back into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075816Z" creationid="pingfangx" creationdate="20190617T075816Z">
        <seg>实际上，RxJava 中的并行性意味着运行独立流并将其结果合并回单个流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, the 1.x `fromEmitter` (formerly `fromAsync`) has been renamed to `Flowable.create`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094844Z" creationid="pingfangx" creationdate="20190618T094844Z">
        <seg>实际上，1.x 的 `fromEmitter`(以前称为 fromAsync`)已被重命名为 `Flowable.create`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, this is when the body of the given example above executes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072207Z" creationid="pingfangx" creationdate="20190617T072207Z">
        <seg>实际上，这是在上面给出的示例的主体执行时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence and Security</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071253Z" creationid="pingfangx" creationdate="20190828T071253Z">
        <seg>优先级和安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Presentation Language</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121752Z" creationid="pingfangx" creationdate="20190901T121752Z">
        <seg>表示语言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112122Z" creationid="pingfangx" creationdate="20190831T112122Z">
        <seg>HTTP 的先前版本提供了特定数量的连接作为上限，但发现这对许多应用程序来说是不切实际的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prior to persistent connections, a separate TCP connection was established to fetch each URL, increasing the load on HTTP servers and causing congestion on the Internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T143007Z" creationid="pingfangx" creationdate="20190829T143007Z">
        <seg>在持久连接之前，建立了单独的 TCP 连接以获取每个 URL，从而增加了 HTTP 服务器上的负载并导致互联网上的拥塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Privacy Issues Connected to Accept Headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074357Z" creationid="pingfangx" creationdate="20190828T074357Z">
        <seg>连接到 Accept 首部的隐私问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Privacy of Server Log Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091216Z" creationid="pingfangx" creationdate="20190830T091216Z">
        <seg>服务器日志信息的隐私</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proactive Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115730Z" creationid="pingfangx" creationdate="20190831T115730Z">
        <seg>主动协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Representation Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115700Z" creationid="pingfangx" creationdate="20190831T115700Z">
        <seg>处理表示数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing the numbers 1 to 10 in parallel is a bit more involved:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075758Z" creationid="pingfangx" creationdate="20190617T075758Z">
        <seg>并行处理数字 1 到 10 涉及更多：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Product Tokens</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T153529Z" creationid="pingfangx" creationdate="20190828T153529Z">
        <seg>产品标记</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Product tokens SHOULD be short and to the point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T153131Z" creationid="pingfangx" creationdate="20190828T153131Z">
        <seg>产品标记应该简短而切题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Product tokens are used to allow communicating applications to identify themselves by software name and version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152916Z" creationid="pingfangx" creationdate="20190828T152916Z">
        <seg>产品标记用于允许通信应用程序通过软件名称和版本来标识自己。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proper use of "reset" segments can disambiguate these cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031556Z" creationid="pingfangx" creationdate="20190828T031556Z">
        <seg>正确使用“重置”报文段可以消除这些情况的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121649Z" creationid="pingfangx" creationdate="20190901T121649Z">
        <seg>协议概述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Parameters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072033Z" creationid="pingfangx" creationdate="20190828T072033Z">
        <seg>协议参数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Versioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090647Z" creationid="pingfangx" creationdate="20190830T090647Z">
        <seg>协议版本控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxies and Caching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074418Z" creationid="pingfangx" creationdate="20190828T074418Z">
        <seg>代理和缓存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxies are often used to group an organization's HTTP requests through a common intermediary for the sake of security, annotation services, or shared caching.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101418Z" creationid="pingfangx" creationdate="20190830T101418Z">
        <seg>代理通常用于通过公共中介对组织的 HTTP 请求进行分组，以实现安全性、注释服务或共享缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxies that support CONNECT SHOULD restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143343Z" creationid="pingfangx" creationdate="20190831T143343Z">
        <seg>支持 CONNECT 的代理应该将其使用限制在一组有限的已知端口或安全请求目标的可配置白名单中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy Servers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073000Z" creationid="pingfangx" creationdate="20190828T073000Z">
        <seg>代理服务器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy and gateway applications need to be careful when forwarding messages in protocol versions different from that of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104015Z" creationid="pingfangx" creationdate="20190828T104015Z">
        <seg>在转发与应用程序不同的协议版本的消息时，代理和网关应用程序需要小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy authentication might be used to establish the authority to create a tunnel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143246Z" creationid="pingfangx" creationdate="20190831T143246Z">
        <seg>代理身份验证可用于建立创建隧道的权限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an "http" or "https" URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123645Z" creationid="pingfangx" creationdate="20190831T123645Z">
        <seg>代理配置依赖于实现，但通常基于 URI 前缀匹配，选择性权限匹配或两者，并且代理本身通常由“http”或“https”URI 标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112332Z" creationid="pingfangx" creationdate="20190831T112332Z">
        <seg>代理服务器可能会使此值更高，因为客户端可能会通过同一代理服务器建立更多连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152121Z" creationid="pingfangx" creationdate="20190829T152121Z">
        <seg>代理服务器可能会使此值更高，因为客户端可能会通过同一服务器建立更多连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Purpose</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071920Z" creationid="pingfangx" creationdate="20190828T071920Z">
        <seg>目的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quotation marks surround literal text.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092725Z" creationid="pingfangx" creationdate="20190828T092725Z">
        <seg>引号围绕文字文本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RC3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061550Z" creationid="pingfangx" creationdate="20190619T061550Z">
        <seg>RC3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.NXT - receive next</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111754Z" creationid="pingfangx" creationdate="20190827T111754Z">
        <seg>RCV.NXT - 接收下一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022217Z" creationid="pingfangx" creationdate="20190828T022217Z">
        <seg>RCV.NXT =传入报文段上预期的下一个序列号，是接收窗口的左下边缘</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022231Z" creationid="pingfangx" creationdate="20190828T022231Z">
        <seg>RCV.NXT+RCV.WND-1 =传入报文段上预期的最后序列号，是接收窗口的右边缘或上边缘</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.UP  - receive urgent pointer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111805Z" creationid="pingfangx" creationdate="20190827T111805Z">
        <seg>RCV.UP  - 接收紧急指针</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RCV.WND - receive window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111800Z" creationid="pingfangx" creationdate="20190827T111800Z">
        <seg>RCV.WND - 接收窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RECEIVEs are allowed in this state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063508Z" creationid="pingfangx" creationdate="20190828T063508Z">
        <seg>在这种状态下允许 RECEIVE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REFERENCES</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071311Z" creationid="pingfangx" creationdate="20190828T071311Z">
        <seg>参考文献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RFC 2616 permits an HTTP client to close the connection at any time, and requires servers to recover gracefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T102546Z" creationid="pingfangx" creationdate="20190901T102546Z">
        <seg>RFC 2616 允许 HTTP 客户端随时关闭连接，并要求服务器正常恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RST:  Reset the connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105420Z" creationid="pingfangx" creationdate="20190827T105420Z">
        <seg>RST：重置连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Range Units</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072213Z" creationid="pingfangx" creationdate="20190828T072213Z">
        <seg>范围单位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reactive Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115739Z" creationid="pingfangx" creationdate="20190831T115739Z">
        <seg>响应性协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reactive Programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041620Z" creationid="pingfangx" creationdate="20190620T041620Z">
        <seg>响应式编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Is a Polyglot Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034622Z" creationid="pingfangx" creationdate="20190620T034622Z">
        <seg>ReactiveX 是一种多语言实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Observables support not just the emission of single scalar values (as Futures do), but also of sequences of values or even infinite streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035551Z" creationid="pingfangx" creationdate="20190620T035545Z">
        <seg>ReactiveX Observables 不仅支持单个标量值的发射(如 Futures 那样)，还支持值序列甚至无限流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Observables, on the other hand, are &lt;e0&gt;intended&lt;/e0&gt; for &lt;a1&gt;composing flows and sequences of asynchronous data&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035425Z" creationid="pingfangx" creationdate="20190620T035425Z">
        <seg>另一方面，ReactiveX Observables &lt;e0&gt;旨在&lt;/e0&gt; 用于 &lt;a1&gt;组合异步数据流和序列&lt;/a1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T025919Z" creationid="pingfangx" creationdate="20190620T025919Z">
        <seg>ReactiveX 是一个库，通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is currently implemented in a variety of languages, in ways that respect those languages’ idioms, and more languages are being added at a rapid clip.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041309Z" creationid="pingfangx" creationdate="20190620T041309Z">
        <seg>ReactiveX 在大量的编程语言中都有实现，并尊重实现语言的风格，而且更多的实现正在飞速增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is not biased toward some particular source of concurrency or asynchronicity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040233Z" creationid="pingfangx" creationdate="20190620T040233Z">
        <seg>ReactiveX 不偏向某些特定的并发或异步性源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX may be functional, and it may be reactive, but “functional reactive programming” is a different animal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033853Z" creationid="pingfangx" creationdate="20190620T033853Z">
        <seg>ReactiveX 可能是函数式的，它可能是响应式的，但“函数响应式编程”是一种不同的动物。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX provides &lt;a0&gt;a collection of operators&lt;/a0&gt; with which you can filter, select, transform, combine, and compose Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041826Z" creationid="pingfangx" creationdate="20190620T041826Z">
        <seg>ReactiveX 提供了 &lt;a0&gt;一系列操作符&lt;/a0&gt;，你可以使用它们来过滤(filter)，选择(select)，转换(transform)，结合(combine)和组合(compose) Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Readers familiar with regular expressions should see Appendix B for an example of a non-validating URI-reference parser that will take any given string and extract the URI components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084449Z" creationid="pingfangx" creationdate="20190902T084449Z">
        <seg>熟悉正则表达式的读者应该参阅附录 B，了解一个非验证 URI 引用解析器的示例，它将获取任何给定的字符串并提取 URI 组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receive Sequence Space</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111923Z" creationid="pingfangx" creationdate="20190827T111923Z">
        <seg>接收序列空间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receive Sequence Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111748Z" creationid="pingfangx" creationdate="20190827T111748Z">
        <seg>接收序列变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recipients of an HTTP/1.0 request that lacks a Host header field MAY attempt to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to determine what exact resource is being requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102200Z" creationid="pingfangx" creationdate="20190829T102200Z">
        <seg>缺少 Host 首部字段的 HTTP/1.0 请求的接收者可以尝试使用启发法(例如，检查 URI 路径以查找特定主机特有的内容)，以便确定正在请求什么样的确切资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recipients of an HTTP/1.0 request that lacks a Host header field might need to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to guess the effective request URI's authority component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132001Z" creationid="pingfangx" creationdate="20190831T132001Z">
        <seg>缺少主机首部字段的 HTTP/1.0 请求的接收者可能需要使用启发式方法(例如，检查特定主机特有的 URI 路径)以便猜测有效请求 URI 的权限组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070716Z" creationid="pingfangx" creationdate="20190831T070716Z">
        <seg>无效请求行的接收者应该响应 400(错误请求)错误或 301(移动永久)重定向，并且请求目标正确编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085756Z" creationid="pingfangx" creationdate="20190831T085756Z">
        <seg>处理带引号的字符串的值的接收者必须处理一个引用对，就好像它被反斜杠后面的八位字节替换一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recipients typically parse the request-line into its component parts by splitting on whitespace (see Section 3.5), since no whitespace is allowed in the three components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070607Z" creationid="pingfangx" creationdate="20190831T070607Z">
        <seg>接收者通常通过拆分空格来将请求行解析为其组成部分(参见第 3.5 节)，因为这三个组件中不允许有空格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Record Layer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122145Z" creationid="pingfangx" creationdate="20190901T122145Z">
        <seg>记录层</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Record Payload Protection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190901T122148Z">
        <seg>记录有效载荷保护</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Record Protocol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122142Z" creationid="pingfangx" creationdate="20190901T122142Z">
        <seg>记录协议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovery from Old Duplicate SYN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042815Z" creationid="pingfangx" creationdate="20190828T042815Z">
        <seg>从旧的重复 SYN 恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursive Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092103Z" creationid="pingfangx" creationdate="20190620T092103Z">
        <seg>递归调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reference Resolution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090620Z" creationid="pingfangx" creationdate="20190902T090620Z">
        <seg>引用解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>References</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074444Z" creationid="pingfangx" creationdate="20190828T074444Z">
        <seg>参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless, only the origin server needs to know how each of its resource identifiers corresponds to an implementation and how each implementation manages to select and send a current representation of the target resource in a response to GET.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135553Z" creationid="pingfangx" creationdate="20190831T135553Z">
        <seg>无论如何，只有源服务器需要知道其每个资源标识符如何对应于实现以及每个实现如何在对 GET 的响应中设置选择和发送目标资源的当前表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Registration of Transfer Codings now requires IETF Review (Section 8.4)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092340Z" creationid="pingfangx" creationdate="20190830T092340Z">
        <seg>转让密码的注册现在要求 IETF 审查(第 8.4 节)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Relation to Other Protocols</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071230Z" creationid="pingfangx" creationdate="20190828T071230Z">
        <seg>与其他协议的关系</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Relative Reference</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042841Z" creationid="pingfangx" creationdate="20190902T042841Z">
        <seg>相对引用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reliable Communication</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071233Z" creationid="pingfangx" creationdate="20190828T071233Z">
        <seg>可靠的通信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061028Z" creationid="pingfangx" creationdate="20190619T061028Z">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data in the segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025239Z" creationid="pingfangx" creationdate="20190828T025239Z">
        <seg>请记住，每个报文段都绑定了与报文段中数据的八位字节一样多的连续序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed as the Reactive Streams specification mandates the `onXXX` methods don't crash and therefore the default is to not have a safety net in `subscribe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054131Z" creationid="pingfangx" creationdate="20190619T054131Z">
        <seg>在 Reactive Streams 规范要求删除 `onXXX` 方法不会崩溃，因此默认是在 `subscribe` 中没有安全网。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed in version</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061536Z" creationid="pingfangx" creationdate="20190619T061536Z">
        <seg>在版本移除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Representation Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115716Z" creationid="pingfangx" creationdate="20190831T115716Z">
        <seg>表示数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Representation Metadata</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115653Z" creationid="pingfangx" creationdate="20190831T115653Z">
        <seg>表示元数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Representation header fields provide metadata about the representation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T024934Z" creationid="pingfangx" creationdate="20190902T024934Z">
        <seg>表示首部字段提供有关表示的元数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Representations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115657Z" creationid="pingfangx" creationdate="20190831T115657Z">
        <seg>表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072304Z" creationid="pingfangx" creationdate="20190828T072304Z">
        <seg>请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request (section 5) and Response (section 6) messages use the generic message format of RFC 822 [9] for transferring entities (the payload of the message).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T073230Z" creationid="pingfangx" creationdate="20190829T073230Z">
        <seg>请求(第 5 节)和响应(第 6 节)消息使用 RFC 822 [9] 的通用消息格式来传输实体(消息的有效载荷)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request Context</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115834Z" creationid="pingfangx" creationdate="20190831T115834Z">
        <seg>请求上下文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request Header Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072734Z" creationid="pingfangx" creationdate="20190828T072336Z">
        <seg>请求首部字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request Line</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090713Z" creationid="pingfangx" creationdate="20190830T090713Z">
        <seg>请求行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115742Z" creationid="pingfangx" creationdate="20190831T115742Z">
        <seg>请求方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request Smuggling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091206Z" creationid="pingfangx" creationdate="20190830T091206Z">
        <seg>请求走私</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request Target</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090937Z" creationid="pingfangx" creationdate="20190830T090937Z">
        <seg>请求目标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request and Response messages MAY transfer an entity if not otherwise restricted by the request method or response status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T111701Z" creationid="pingfangx" creationdate="20190829T111701Z">
        <seg>请求和响应消息如果没有请求方法或响应状态代码的限制，可以传输实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request message framing is independent of method semantics, even if the method does not define any use for a message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T020003Z" creationid="pingfangx" creationdate="20190831T090219Z">
        <seg>请求消息帧独立于方法语义，即使该方法没有为消息主体定义任何用途。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134035Z" creationid="pingfangx" creationdate="20190831T134035Z">
        <seg>如果请求方法的定义语义基本上是只读的，则被认为是“安全的”;即，作为对目标资源应用安全方法的结果，客户端不请求并且不期望源服务器上的任何状态改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request methods can be defined as "cacheable" to indicate that responses to them are allowed to be stored for future reuse; for specific requirements see [RFC7234].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134516Z" creationid="pingfangx" creationdate="20190831T134516Z">
        <seg>请求方法可以定义为“可缓存”，以指示允许存储对它们的响应以供将来重用；有关具体要求，请参阅 [RFC7234]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request-Line</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072306Z" creationid="pingfangx" creationdate="20190828T072306Z">
        <seg>请求行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request-URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072310Z" creationid="pingfangx" creationdate="20190828T072310Z">
        <seg>请求 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request-header field names can be extended reliably only in combination with a change in the protocol version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102325Z" creationid="pingfangx" creationdate="20190829T102325Z">
        <seg>请求首部字段名称只能与协议版本的更改一起可靠地扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests are serviced internally or by passing them on, with possible translation, to other servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081456Z" creationid="pingfangx" creationdate="20190828T081456Z">
        <seg>请求在内部提供服务，或者通过可能的转换将其传递给其他服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072006Z" creationid="pingfangx" creationdate="20190828T072006Z">
        <seg>要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements Notation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090603Z" creationid="pingfangx" creationdate="20190830T090603Z">
        <seg>需求符号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements Terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090440Z" creationid="pingfangx" creationdate="20190901T090440Z">
        <seg>要求术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements for HTTP/1.1 clients:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024432Z" creationid="pingfangx" creationdate="20190830T024432Z">
        <seg>HTTP/1.1 客户端的要求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements for HTTP/1.1 origin servers:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024707Z" creationid="pingfangx" creationdate="20190830T024707Z">
        <seg>HTTP/1.1 源服务器的要求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements for HTTP/1.1 proxies:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025632Z" creationid="pingfangx" creationdate="20190830T025632Z">
        <seg>HTTP/1.1 代理的要求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements on such "forwarding" of messages are defined in Section 5.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124601Z" creationid="pingfangx" creationdate="20190831T124601Z">
        <seg>第 5.7 节中定义了对这种“转发”消息的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reserved Characters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042759Z" creationid="pingfangx" creationdate="20190902T042759Z">
        <seg>保留字符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reserved for future use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105325Z" creationid="pingfangx" creationdate="20190827T105325Z">
        <seg>保留供将来使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset Generation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060500Z" creationid="pingfangx" creationdate="20190828T060500Z">
        <seg>重置生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061707Z" creationid="pingfangx" creationdate="20190828T061707Z">
        <seg>重置处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115640Z" creationid="pingfangx" creationdate="20190831T115640Z">
        <seg>资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resources made available via the "https" scheme have no shared identity with the "http" scheme even if their resource identifiers indicate the same authority (the same host listening to the same TCP port).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060712Z" creationid="pingfangx" creationdate="20190831T060712Z">
        <seg>通过“https”方案提供的资源与“http”方案没有共享标识，即使它们的资源标识符指示相同的权限(同一主机侦听相同的 TCP 端口)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resources may be available in multiple representations (e.g. multiple languages, data formats, size, and resolutions) or vary in other ways.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080956Z" creationid="pingfangx" creationdate="20190828T080956Z">
        <seg>资源可以以多种表示形式(例如，多种语言，数据格式，大小和分辨率)获得，或者以其他方式变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072340Z" creationid="pingfangx" creationdate="20190828T072340Z">
        <seg>响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Cacheability</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073944Z" creationid="pingfangx" creationdate="20190828T073944Z">
        <seg>响应可缓存性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Context</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115918Z" creationid="pingfangx" creationdate="20190831T115918Z">
        <seg>响应背景</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Header Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072737Z" creationid="pingfangx" creationdate="20190828T072606Z">
        <seg>响应首部字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Splitting</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091202Z" creationid="pingfangx" creationdate="20190830T091202Z">
        <seg>响应分解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Status Codes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115837Z" creationid="pingfangx" creationdate="20190831T115837Z">
        <seg>响应状态代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190902T025833Z">
        <seg>具有错误状态代码的响应消息通常包含表示错误条件的有效载荷，以便它描述错误状态以及建议用于解决它的后续步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response-header field names can be extended reliably only in combination with a change in the protocol version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110917Z" creationid="pingfangx" creationdate="20190829T110917Z">
        <seg>只有在协议版本发生变化的情况下，才能可靠地扩展响应首部字段名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [RFC7234]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141722Z" creationid="pingfangx" creationdate="20190831T141722Z">
        <seg>POST 请求的响应只有在包含显式新鲜度信息时才可缓存(参见 [RFC7234] 的第 4.2.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to the CONNECT method are not cacheable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143413Z" creationid="pingfangx" creationdate="20190831T143413Z">
        <seg>对 CONNECT 方法的响应不可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to the HEAD request method (Section 4.3.2 of [RFC7231]) never include a message body because the associated response header fields (e.g., Transfer-Encoding, Content-Length, etc.), if present, indicate only what their values would have been if the request method had been GET (Section 4.3.1 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090408Z" creationid="pingfangx" creationdate="20190831T090408Z">
        <seg>对 HEAD 请求方法的响应（[RFC7231] 的第 4.3.2 节）从不包含消息体，因为相关的响应首部字段（例如，Transfer-Encoding, Content-Length等）（如果存在）仅在请求方法是 GET 时指示它们的值（[RFC7231] 的第 4.3.1 节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to the OPTIONS method are not cacheable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143826Z" creationid="pingfangx" creationdate="20190831T143826Z">
        <seg>对 OPTIONS 方法的响应不可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to the TRACE method are not cacheable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144145Z" creationid="pingfangx" creationdate="20190831T144145Z">
        <seg>对 TRACE 方法的响应不可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to this method MUST NOT be cached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074422Z" creationid="pingfangx" creationdate="20190830T074422Z">
        <seg>不得缓存对此方法的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064704Z" creationid="pingfangx" creationdate="20190830T064704Z">
        <seg>除非响应包含适当的 Cache-Control 或 Expires 首部字段，否则对此方法的响应不可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to this method are not cacheable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041645Z" creationid="pingfangx" creationdate="20190830T041645Z">
        <seg>对此方法的响应不可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses with status codes that are defined as cacheable by default (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in this specification) can be reused by a cache with heuristic expiration unless otherwise indicated by the method definition or explicit cache controls [RFC7234]; all other status codes are not cacheable by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144720Z" creationid="pingfangx" creationdate="20190831T144720Z">
        <seg>默认情况下定义为可缓存的状态代码的响应(例如，本规范中的 200,203,204,206,300,301,404,405,410,414 和 501)可以由具有启发式到期的缓存重用，除非否则由方法定义或显式缓存控制 [RFC7234] 指示；默认情况下，所有其他状态代码都不可缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumption and Pre-Shared Key (PSK)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121748Z" creationid="pingfangx" creationdate="20190901T121748Z">
        <seg>恢复和预共享密钥(PSK)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrying Requests</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091016Z" creationid="pingfangx" creationdate="20190830T091016Z">
        <seg>重试请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Right arrows (--&gt;) indicate departure of a TCP segment from TCP A to TCP B, or arrival of a segment at B from A.  Left arrows (&lt;--), indicate the reverse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034516Z" creationid="pingfangx" creationdate="20190828T034516Z">
        <seg>右箭头(--&gt;)表示 TCP 报文段从 TCP A 到 TCP B 的离开，或者从 A 到达 B 的报文段的到达。左箭头(&lt;--)表示相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Risks of Intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091149Z" creationid="pingfangx" creationdate="20190830T091149Z">
        <seg>中介的风险</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Robustness Principle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071302Z" creationid="pingfangx" creationdate="20190828T071302Z">
        <seg>稳健性原则</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rules about implicit linear whitespace between certain grammar productions have been removed; now whitespace is only allowed where specifically defined in the ABNF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091826Z" creationid="pingfangx" creationdate="20190830T091826Z">
        <seg>关于某些语法产生之间的隐式线性空白的规则已被删除；现在只允许在 ABNF 中明确定义的空格。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rules for When to Use Entity Tags and Last-Modified Dates.89</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073937Z" creationid="pingfangx" creationdate="20190828T073937Z">
        <seg>何时使用实体标签和最后修改日期的规则.89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava (and its derivatives like RxGroovy &amp; RxScala) has developed an &lt;a0&gt;Observable&lt;/a0&gt; variant called “Single.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073327Z" creationid="pingfangx" creationdate="20190620T073327Z">
        <seg>RxJava(及其衍生品，如 RxGroovy 和 RxScala)开发了一种名为“Single”的 &lt;a0&gt;Observable&lt;/a0&gt; 变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2 features several base classes you can discover operators on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065936Z" creationid="pingfangx" creationdate="20190617T065936Z">
        <seg>RxJava 2 具有几个可以发现运算符的基类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2 features several standard schedulers accessible via `Schedulers` utility class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073108Z" creationid="pingfangx" creationdate="20190617T073108Z">
        <seg>RxJava 2 具有几个可通过 `Schedulers` 实用程序类访问的标准调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2's design was heavily influenced by the [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams) specification, therefore, the library features a class and an interface per each reactive type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103741Z" creationid="pingfangx" creationdate="20190617T103741Z">
        <seg>RxJava 2 的设计深受 [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams) 规范的影响，因此，该库为每种反应类型提供了一个类和一个接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.0 has been completely rewritten from scratch on top of the Reactive-Streams specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T015500Z" creationid="pingfangx" creationdate="20190618T015500Z">
        <seg>RxJava 2.0 已经根据 Reactive-Streams 规范从头开始完全重写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.0.0-RC2 introduced a new base reactive type called `Maybe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060309Z" creationid="pingfangx" creationdate="20190618T060309Z">
        <seg>RxJava 2.0.0-RC2 引入了一个名为 `Maybe` 的新的基本响应类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.x no longer accepts `null` values and the following will yield `NullPointerException` immediately or as a signal to downstream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052728Z" creationid="pingfangx" creationdate="20190618T052728Z">
        <seg>RxJava 2.x 不再接受 `null` 值，以下将立即产生 `NullPointerException` 或作为下游的信号：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava chose to name such operators by appending the type as suffix as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102150Z" creationid="pingfangx" creationdate="20190617T102150Z">
        <seg>RxJava 选择通过将类型附加为后缀来命名此类运算符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is a Java VM implementation of [Reactive Extensions](http://reactivex.io): a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064503Z" creationid="pingfangx" creationdate="20190617T064503Z">
        <seg>RxJava 是 [Reactive Extensions](http://reactivex.io) 的 Java VM 实现：其用于通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is a Java VM implementation of [ReactiveX (Reactive Extensions)](https://reactivex.io): a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113439Z" creationid="pingfangx" creationdate="20190617T113439Z">
        <seg>RxJava 是 [ReactiveX(Reactive Extensions)](https://reactivex.io) 的 Java VM 实现：其通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is meant for a more polyglot environment than just Java/Scala, and it is being designed to respect the idioms of each JVM-based language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113631Z" creationid="pingfangx" creationdate="20190617T113631Z">
        <seg>RxJava 用于比 Java/Scala 更多的多语言环境，它被设计为尊重每种基于 JVM 的语言的习语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava operators don't work with `Thread`s or `ExecutorService`s directly but with so called `Scheduler`s that abstract away sources of concurrency behind a uniform API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073048Z" creationid="pingfangx" creationdate="20190617T073048Z">
        <seg>RxJava 运算符不能直接使用 `Thread` 或 `ExecutorService`，而是使用所谓的 `Scheduler` 来抽象统一 API 背后的并发源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava supports Java 6 or higher and JVM-based languages such as [Groovy](https://github.com/ReactiveX/RxGroovy), [Clojure](https://github.com/ReactiveX/RxClojure), [JRuby](https://github.com/ReactiveX/RxJRuby), [Kotlin](https://github.com/ReactiveX/RxKotlin) and [Scala](https://github.com/ReactiveX/RxScala).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113556Z" creationid="pingfangx" creationdate="20190617T113556Z">
        <seg>RxJava 支持 Java 6 或更高版本以及基于 JVM 的语言，如 [Groovy](https://github.com/ReactiveX/RxGroovy)，[Clojure](https://github.com/ReactiveX/RxClojure)，[JRuby] (https://github.com/ReactiveX/RxJRuby)，[Kotlin](https://github.com/ReactiveX/RxKotlin) 和 [Scala](https://github.com/ReactiveX/RxScala)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava tries to be very lightweight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113503Z" creationid="pingfangx" creationdate="20190617T113503Z">
        <seg>RxJava 试图非常轻量级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S1 = ISN(t) -- last used sequence number on old incarnation of connection!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025715Z" creationid="pingfangx" creationdate="20190828T025715Z">
        <seg>S1 = ISN(t) - 旧的连接化身上最后使用的序列号！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.ACK - segment acknowledgment number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112007Z" creationid="pingfangx" creationdate="20190827T112007Z">
        <seg>SEG.ACK - 报文段确认号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.ACK = acknowledgment from the receiving TCP (next sequence number expected by the receiving TCP)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022012Z" creationid="pingfangx" creationdate="20190828T022012Z">
        <seg>SEG.ACK =来自接收 TCP 的确认号(接收 TCP 预期的下一个序列号)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.LEN - segment length</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112012Z" creationid="pingfangx" creationdate="20190827T112012Z">
        <seg>SEG.LEN - 报文段长度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022025Z" creationid="pingfangx" creationdate="20190828T022025Z">
        <seg>SEG.LEN =报文段中数据占用的八位字节数(计算 SYN 和 FIN)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.PRC - segment precedence value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112028Z" creationid="pingfangx" creationdate="20190827T112028Z">
        <seg>SEG.PRC - 报文段优先值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ - segment sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112002Z" creationid="pingfangx" creationdate="20190827T112002Z">
        <seg>SEG.SEQ - 报文段序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ = first sequence number occupied by the incoming segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022235Z" creationid="pingfangx" creationdate="20190828T022235Z">
        <seg>SEG.SEQ =传入报文段占用的第一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ = first sequence number of a segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022017Z" creationid="pingfangx" creationdate="20190828T022017Z">
        <seg>SEG.SEQ =报文段的第一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022245Z" creationid="pingfangx" creationdate="20190828T022245Z">
        <seg>SEG.SEQ+SEG.LEN-1 =传入报文段占用的最后一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.SEQ+SEG.LEN-1 = last sequence number of a segment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022047Z" creationid="pingfangx" creationdate="20190828T022047Z">
        <seg>SEG.SEQ+SEG.LEN-1 = 报文段的最后序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.UP  - segment urgent pointer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112023Z" creationid="pingfangx" creationdate="20190827T112023Z">
        <seg>SEG.UP  - 报文段紧急指针</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SEG.WND - segment window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112019Z" creationid="pingfangx" creationdate="20190827T112019Z">
        <seg>SEG.AND - 报文段窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.NXT - send next</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111654Z" creationid="pingfangx" creationdate="20190827T111654Z">
        <seg>SND.NXT - 发送下一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.NXT = next sequence number to be sent</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021952Z" creationid="pingfangx" creationdate="20190828T021952Z">
        <seg>SND.NXT =要发送的下一个序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.UNA - send unacknowledged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111647Z" creationid="pingfangx" creationdate="20190827T111647Z">
        <seg>SND.UNA  - 发送未确认的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.UNA = oldest unacknowledged sequence number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021949Z" creationid="pingfangx" creationdate="20190828T021949Z">
        <seg>SND.UNA =最早的未确认序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.UP  - send urgent pointer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111710Z" creationid="pingfangx" creationdate="20190827T111710Z">
        <seg>SND.UP  - 发送紧急指针</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.WL1 - segment sequence number used for last window update</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111726Z" creationid="pingfangx" creationdate="20190827T111726Z">
        <seg>SND.WL1 - 用于最后一次窗口更新的报文段序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.WL2 - segment acknowledgment number used for last window update</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111734Z" creationid="pingfangx" creationdate="20190827T111734Z">
        <seg>SND.WL2 - 用于最后一次窗口更新的报文段确认号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SND.WND - send window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111659Z" creationid="pingfangx" creationdate="20190827T111659Z">
        <seg>SND.WND - 发送窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SP             = &lt;US-ASCII SP, space (32)&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095340Z" creationid="pingfangx" creationdate="20190828T095340Z">
        <seg>SP             = &lt;US-ASCII SP, 空格 (32)&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSL, and its successor TLS [RFC2246] were designed to provide channel-oriented security.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091107Z" creationid="pingfangx" creationdate="20190901T091107Z">
        <seg>SSL 及其后继 TLS [RFC2246] 旨在提供面向通道的安全性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112646Z" creationid="pingfangx" creationdate="20190827T112646Z">
        <seg>SYN-RECEIVED - 表示在收到并发送连接请求后等待确认连接请求确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYN-SENT - represents waiting for a matching connection request after having sent a connection request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112624Z" creationid="pingfangx" creationdate="20190827T112624Z">
        <seg>SYN-SENT - 表示在发送连接请求后等待匹配的连接请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SYN:  Synchronize sequence numbers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105424Z" creationid="pingfangx" creationdate="20190827T105424Z">
        <seg>SYN：同步序列号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safe Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073057Z" creationid="pingfangx" creationdate="20190828T073057Z">
        <seg>安全方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safe and Idempotent Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073055Z" creationid="pingfangx" creationdate="20190828T073055Z">
        <seg>安全和幂等方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Same-Document Reference</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042849Z" creationid="pingfangx" creationdate="20190902T042849Z">
        <seg>同一文档引用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheme names consist of a sequence of characters beginning with a letter and followed by any combination of letters, digits, plus ("+"), period ("."), or hyphen ("-").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072432Z" creationid="pingfangx" creationdate="20190902T072432Z">
        <seg>方案名称由一系列以字母开头的字符组成，后跟字母，数字，加号(“+”)，句号(“.”)或连字符(“ - ”)的任意组合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheme specifications will not define fragment identifier syntax or usage, regardless of its applicability to resources identifiable via that scheme, as fragment identification is orthogonal to scheme definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085508Z" creationid="pingfangx" creationdate="20190902T085508Z">
        <seg>方案规范将不定义片段标识符语法或用法，而不管其对通过该方案可识别的资源的适用性，因为片段标识与方案定义正交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071200Z" creationid="pingfangx" creationdate="20190828T071200Z">
        <seg>范围</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Section 2.4 describes when percent-encoding and decoding is applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065601Z" creationid="pingfangx" creationdate="20190902T065601Z">
        <seg>第 2.4 节描述了何时应用百分比编码和解码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Section 4.4 defines how the transfer-length of a message-body is determined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121508Z" creationid="pingfangx" creationdate="20190829T121508Z">
        <seg>第 4.4 节定义了如何确定消息体的传输长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Considerations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074313Z" creationid="pingfangx" creationdate="20190828T074313Z">
        <seg>安全考虑因素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044335Z" creationid="pingfangx" creationdate="20190620T044335Z">
        <seg>相关参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Appendix A.1.2 for more information on backwards compatibility with HTTP/1.0 clients.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111326Z" creationid="pingfangx" creationdate="20190831T111326Z">
        <seg>有关向后兼容 HTTP/1.0 客户端的更多信息，请参阅附录 A.1.2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Appendix E for a more complete statement of the relevant security properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T123739Z" creationid="pingfangx" creationdate="20190901T123739Z">
        <seg>有关相关安全属性的更完整声明，请参阅附录 E。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See RFC 2145 [36] for a fuller explanation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103159Z" creationid="pingfangx" creationdate="20190828T103159Z">
        <seg>有关更全面的解释，请参阅 RFC 2145 [36]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Section 6 of [RFC7231] for information about the semantics of status codes, including the classes of status code (indicated by the first digit), the status codes defined by this specification, considerations for the definition of new status codes, and the IANA registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081202Z" creationid="pingfangx" creationdate="20190831T081202Z">
        <seg>有关状态代码语义的信息，请参见 [RFC7231] 的第 6 节，包括状态代码类(由第一个数字表示)，本规范定义的状态代码，新状态代码定义的注意事项以及 IANA 中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Section 9 for security considerations regarding message routing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132142Z" creationid="pingfangx" creationdate="20190831T132142Z">
        <seg>有关消息路由的安全注意事项，请参见第 9 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Section 9.1 for security considerations related to establishing authority.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044424Z" creationid="pingfangx" creationdate="20190831T044424Z">
        <seg>有关建立权限的安全性考虑，请参见第 9.1 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See section 15.1.3 for security considerations when used for forms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063016Z" creationid="pingfangx" creationdate="20190830T063016Z">
        <seg>有关用于表单的安全注意事项，请参见第 15.1.3 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See section 15.1.3 for security considerations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064742Z" creationid="pingfangx" creationdate="20190830T064742Z">
        <seg>有关安全性的考虑，请参见第 15.1.3 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See section 19.3 for further information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113722Z" creationid="pingfangx" creationdate="20190828T113722Z">
        <seg>有关详细信息，请参见第 19.3 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See section 19.6.2 for more information on backward compatibility with HTTP/1.0 clients.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150921Z" creationid="pingfangx" creationdate="20190829T150921Z">
        <seg>有关与 HTTP/1.0 客户端向后兼容的更多信息，请参见第 19.6.2 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See section 3.4.1 for compatibility problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151747Z" creationid="pingfangx" creationdate="20190828T151747Z">
        <seg>有关兼容性问题，请参见第 3.4.1 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the differences between version 1.x and 2.x in the wiki article [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065542Z" creationid="pingfangx" creationdate="20190617T065542Z">
        <seg>请参阅 wiki 文章中的版本 1.x 和 2.x 之间的差异 [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Segment contents are shown in abbreviated form, with sequence number, control flags, and ACK field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034700Z" creationid="pingfangx" creationdate="20190828T034700Z">
        <seg>报文段内容以缩写形式显示，具有序列号，控制标志和 ACK 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Send Sequence Space</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111904Z" creationid="pingfangx" creationdate="20190827T111904Z">
        <seg>发送序列空间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Send Sequence Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111553Z" creationid="pingfangx" creationdate="20190827T111553Z">
        <seg>发送序列变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Senders wishing to defeat this behavior MAY include a charset parameter even when the charset is ISO-8859-1 and SHOULD do so when it is known that it will not confuse the recipient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190828T115609Z">
        <seg>希望打败此行为的可能包含 charset 参数，即使字符集是 ISO-8859-1，并且应该知道它不会混淆接收者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separating Identification from Interaction .</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060429Z" creationid="pingfangx" creationdate="20190902T060429Z">
        <seg>将识别与交互分离</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>September 1981</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041848Z" creationid="pingfangx" creationdate="20190828T041848Z">
        <seg>September 1981</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sequence Numbers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T020911Z" creationid="pingfangx" creationdate="20190828T020911Z">
        <seg>序号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090513Z" creationid="pingfangx" creationdate="20190901T090513Z">
        <seg>服务器行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server Identity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090550Z" creationid="pingfangx" creationdate="20190901T090550Z">
        <seg>服务器标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server response:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100448Z" creationid="pingfangx" creationdate="20190830T100448Z">
        <seg>服务器响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server-Specified Expiration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073259Z" creationid="pingfangx" creationdate="20190828T073259Z">
        <seg>服务器指定的过期时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server-driven Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150449Z" creationid="pingfangx" creationdate="20190828T073219Z">
        <seg>服务器驱动的协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103113Z" creationid="pingfangx" creationdate="20190901T103113Z">
        <seg>服务器可以在发送关闭警报后关闭连接，从而在客户端生成不完整的关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103102Z" creationid="pingfangx" creationdate="20190901T103102Z">
        <seg>在关闭连接之前，服务器必须尝试与客户端交换关闭警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T110649Z" creationid="pingfangx" creationdate="20190828T110649Z">
        <seg>服务器必须能够处理它们所服务的任何资源的 URI，并且如果它们提供可以生成这种 URI 的基于 GET 的表单，它应该能够处理无限长度的 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers SHOULD NOT close a connection in the middle of transmitting a response, unless a network or client failure is suspected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152551Z" creationid="pingfangx" creationdate="20190829T152551Z">
        <seg>除非怀疑网络或客户端故障，否则服务器不应在传输响应的过程中关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers SHOULD always respond to at least one request per connection, if at all possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152541Z" creationid="pingfangx" creationdate="20190829T152541Z">
        <seg>如果可能的话，服务器应该总是响应每个连接至少一个请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers SHOULD respond to invalid Request-URIs with an appropriate status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101326Z" creationid="pingfangx" creationdate="20190829T101326Z">
        <seg>服务器应该使用适当的状态代码响应无效的 Request-URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers will usually have some time-out value beyond which they will no longer maintain an inactive connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152109Z" creationid="pingfangx" creationdate="20190829T152109Z">
        <seg>服务器通常会有一些超时值，超过这个值就不再保持非活动连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112323Z" creationid="pingfangx" creationdate="20190831T112323Z">
        <seg>服务器通常会有一些超时值，超过这个值就不再保持非活动连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several examples of connection initiation follow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031601Z" creationid="pingfangx" creationdate="20190828T031601Z">
        <seg>下面是几个连接启动的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shared and Non-Shared Caches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074033Z" creationid="pingfangx" creationdate="20190828T074033Z">
        <seg>共享和非共享缓存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Side Effects of GET and HEAD</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074046Z" creationid="pingfangx" creationdate="20190828T074046Z">
        <seg>GET 和 HEAD 的副作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to how error-handling became a first-class citizen and received operators to deal with it (via `onErrorXXX` operators), backpressure is another property of dataflows that the programmer has to think about and handle (via `onBackpressureXXX` operators).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T073237Z" creationid="pingfangx" creationdate="20190621T073237Z">
        <seg>类似于错误处理成为一等公民并接受操作符处理它(通过 `onErrorXXX` 操作符)，背压是数据流的另一个属性，程序员必须考虑和处理(通过 `onBackpressureXXX` 操作符)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the naming changes, `rx.Completable.CompletableSubscriber` has become `io.reactivex.CompletableObserver` with `onSubscribe(Disposable)`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060056Z" creationid="pingfangx" creationdate="20190618T060056Z">
        <seg>与命名更改类似，`rx.Completable.CompletableSubscriber` 已变为 `io.reactivex.CompletableObserver`，带有 `onSubscribe(Disposable)`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simply use HTTP over TLS precisely as you would use HTTP over TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091223Z" creationid="pingfangx" creationdate="20190901T091223Z">
        <seg>简单地使用 HTTP over TLS 就像使用 HTTP over TCP 一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simultaneous Close Sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063958Z" creationid="pingfangx" creationdate="20190828T063958Z">
        <seg>同时关闭序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simultaneous Connection Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042446Z" creationid="pingfangx" creationdate="20190828T042446Z">
        <seg>同时连接同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simultaneous initiation is only slightly more complex, as is shown in figure 8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041917Z" creationid="pingfangx" creationdate="20190828T041917Z">
        <seg>同时启动只是稍微复杂一些，如图 8 所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since 1.x `Observable.subscribe(Subscriber)` returned `Subscription`, users often added the `Subscription` to a `CompositeSubscription` for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070549Z" creationid="pingfangx" creationdate="20190618T070549Z">
        <seg>由于 1.x `Observable.subscribe(Subscriber)` 返回 `Subscription`，用户经常将 `Subscription` 添加到 `CompositeSubscription` 中，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since 2.x is a fresh start, we won't make that mistake again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094650Z" creationid="pingfangx" creationdate="20190618T094650Z">
        <seg>由于 2.x 是一个新的开始，我们不会再犯这个错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041855Z" creationid="pingfangx" creationdate="20190830T041855Z">
        <seg>由于服务器的通信选项通常取决于资源，因此“*”请求仅用作“ping”或“no-op”类型的方法；除了允许客户端测试服务器的功能之外，它什么都不做。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132355Z" creationid="pingfangx" creationdate="20190831T132355Z">
        <seg>由于 HTTP 流具有与管道和过滤器架构类似的特性，因此中间件可以增强(或干扰)流的任一方向的程度没有固有的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since data length in this situation is signalled by connection close a premature close generated by the server cannot be distinguished from a spurious close generated by an attacker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093625Z" creationid="pingfangx" creationdate="20190901T093625Z">
        <seg>由于在这种情况下的数据长度通过连接关闭发出信号，因此服务器生成的过早关闭不能与攻击者生成的虚假关闭区分开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since every octet is sequenced, each of them can be acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T020941Z" creationid="pingfangx" creationdate="20190828T020941Z">
        <seg>由于每个八位字节都是有序的，因此每个八位字节都可以被确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it cannot be combined into a single field-value, recipients ought to handle "Set-Cookie" as a special case while processing header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082607Z" creationid="pingfangx" creationdate="20190831T082607Z">
        <seg>由于它不能组合成单个字段值，因此接收者应该在处理首部字段时将“Set-Cookie”作为特殊情况处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since many of the existing code targeting 1.x do such things, the method `safeSubscribe` has been introduced that does handle these non-conforming consumers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095633Z" creationid="pingfangx" creationdate="20190618T095633Z">
        <seg>由于许多针对 1.x 的现有代码都是这样做的，因此引入了 `safeSubscribe` 方法来处理这些不符合要求的消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since not all sources need all these features, the static methods of `Flowable.generate` let's one create instances without them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021428Z" creationid="pingfangx" creationdate="20190624T021428Z">
        <seg>由于并非所有源都需要所有这些功能，因此 `Flowable.generate` 的静态方法可以创建没有它们的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the "http" and "https" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in Section 6 of [RFC3986], using the defaults described above for each scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060910Z" creationid="pingfangx" creationdate="20190831T060910Z">
        <seg>由于“http”和“https”方案符合 URI 通用语法，因此根据 [RFC3986] 第 6 节中定义的算法对这些 URI 进行归一化和比较，使用上述每个方案的默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Host field-value is critical information for handling a request, a user agent SHOULD generate Host as the first header field following the request-line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125603Z" creationid="pingfangx" creationdate="20190831T125603Z">
        <seg>由于 Host 字段值是处理请求的关键信息，因此用户代理应该生成 Host 作为请求行之后的第一个首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Host header field acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130127Z" creationid="pingfangx" creationdate="20190831T130127Z">
        <seg>由于 Host 首部字段充当应用程序级路由机制，因此它常常是恶意软件试图中毒共享缓存或将请求重定向到非预期服务器的目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Java convention is to have a lowercase letter start a method name, this would have been `return(T)` which is a keyword in Java and thus not available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101634Z" creationid="pingfangx" creationdate="20190617T101634Z">
        <seg>由于 Java 约定是以小写字母开始一个方法名称，这将是 `return(T)`，它是 Java 中的关键字，因此不可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to l0's of megabits/sec.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025430Z" creationid="pingfangx" creationdate="20190828T025430Z">
        <seg>由于网络中的最大报文段寿命不可能超过几十秒，因此即使数据速率上升到 10 兆字节/秒，也可以认为这对可预见的网络提供了充足的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the protocol version indicates the protocol capability of the sender, a proxy/gateway MUST NOT send a message with a version indicator which is greater than its actual version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104059Z" creationid="pingfangx" creationdate="20190828T104059Z">
        <seg>由于协议版本指示发送方的协议能力，因此代理/网关不得发送带有的版本版本指示符大于其实际版本的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the request-target often contains only part of the user agent's target URI, a server reconstructs the intended target as an "effective request URI" to properly service the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130556Z" creationid="pingfangx" creationdate="20190831T130556Z">
        <seg>由于请求目标通常仅包含用户代理的目标 URI 的一部分，因此服务器将预期目标重建为“有效请求 URI”以正确地为请求提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2**32.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021312Z" creationid="pingfangx" creationdate="20190828T021312Z">
        <seg>由于空间是有限的，所有处理序列号的算术必须以 2 ** 32 为模进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 9.3).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T100810Z">
        <seg>由于对有效载荷的长度没有预定义的限制，因此接收方必须预期可能存在大的十进制数字，并防止由于整数转换溢出而导致的解析错误(第 9.3 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is no way to distinguish a successfully completed, close-delimited message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102316Z" creationid="pingfangx" creationdate="20190831T102316Z">
        <seg>由于无法区分成功完成的，近距离分隔的消息和因网络故障而中断的部分接收消息，因此服务器应尽可能生成编码或长度分隔的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we assume that segments will stay in the network no more than the Maximum Segment Lifetime (MSL) and that the MSL is less than 4.55 hours we can reasonably assume that ISN's will be unique.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023417Z" creationid="pingfangx" creationdate="20190828T023417Z">
        <seg>由于我们假设网报文段将在网络中停留不超过最大网报文段生命周期(MSL)并且 MSL 小于 4.55 小时，我们可以合理地假设 ISN 将是唯一的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we build an `Flowable` out of it, we can express our will to consume only the first 5 of it and then stop requesting anything.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020557Z" creationid="pingfangx" creationdate="20190624T020557Z">
        <seg>由于我们构建了一个 `Flowable`，我们可以表达我们的意愿，只消耗它的前 5 个，然后停止请求任何东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we explicitly don't request in `onStart`, this will not print anything.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015652Z" creationid="pingfangx" creationdate="20190624T015652Z">
        <seg>由于我们明确地不在 `onStart` 中请求，因此不会打印任何内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sleeping for some time in this example situations lets you see the output of the flow on the console with time to spare.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T074030Z" creationid="pingfangx" creationdate="20190617T074030Z">
        <seg>在此示例情况下休眠一段时间，使您可以在留出的时间在控制台上查看流的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Snapshots are available via https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105550Z" creationid="pingfangx" creationdate="20190617T105550Z">
        <seg>可通过 https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/ 获取快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some HTTP communication options might apply only to the connection with the nearest, non-tunnel neighbor, only to the endpoints of the chain, or to all connections along the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101102Z" creationid="pingfangx" creationdate="20190830T101102Z">
        <seg>某些 HTTP 通信选项可能仅适用于与最近的非隧道邻居的连接，仅适用于链的端点或链中的所有连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some HTTP header fields allow a time value to be specified as an integer number of seconds, represented in decimal, after the time that the message was received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114718Z" creationid="pingfangx" creationdate="20190828T114718Z">
        <seg>某些 HTTP 首部字段允许指定整数秒数的时间值，表示十进制的在收到消息之后经过的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some HTTP messages transfer a complete or partial representation as the message "payload".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025211Z" creationid="pingfangx" creationdate="20190902T025211Z">
        <seg>某些 HTTP 消息将完整或部分表示作为消息“payload”传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some HTTP/1.0 software has interpreted a Content-Type header without charset parameter incorrectly to mean "recipient should guess."</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115517Z" creationid="pingfangx" creationdate="20190828T115517Z">
        <seg>某些 HTTP/1.0 软件将 Content-Type 首部解释为没有 charset 参数错误地表示“收件人应该猜测”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Notes on Naming Conventions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064512Z" creationid="pingfangx" creationdate="20190620T064512Z">
        <seg>关于命名约定的一些注释</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091407Z" creationid="pingfangx" creationdate="20190620T091407Z">
        <seg>RxGroovy 中的一些 Observable 操作符具有替代形式，允许您设置操作符将用于(至少某些部分)其操作的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091921Z" creationid="pingfangx" creationdate="20190620T091921Z">
        <seg>RxJava 中的一些 Observable 操作符具有替代形式，允许您设置操作符将用于(至少某些部分)其操作的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085701Z" creationid="pingfangx" creationdate="20190620T085701Z">
        <seg>一些 ReactiveX Observable 操作符具有将 Scheduler 作为参数的变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some implementations make use of the userinfo component for internal configuration of authentication information, such as within command invocation options, configuration files, or bookmark lists, even though such usage might expose a user identifier or password.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T055131Z" creationid="pingfangx" creationdate="20190831T055131Z">
        <seg>一些实现利用 userinfo 组件来进行认证信息的内部配置，例如在命令调用选项，配置文件或书签列表中，即使这样的使用可能暴露用户标识符或密码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some intermediaries are used to improve performance or availability.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132323Z" creationid="pingfangx" creationdate="20190831T132323Z">
        <seg>一些中介用于提高性能或可用性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some libraries offer some help, such as Google Guava's `AbstractIterable` and IxJava's `Ix.generate()` and `Ix.forloop()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020434Z" creationid="pingfangx" creationdate="20190624T020434Z">
        <seg>一些库提供了一些帮助，例如 Google Guava 的 `AbstractIterable` 和 IxJava 的 `Ix.generate()` 和 `Ix.forloop()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some non-standard HTTP extensions (e.g., [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101937Z" creationid="pingfangx" creationdate="20190830T101937Z">
        <seg>已知一些非标准 HTTP 扩展(例如，[RFC4559])违反了该要求，导致安全性和互操作性问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the functionality described is not applicable to all URI schemes, and some operations are only possible when certain media types are retrieved using the URI, regardless of the scheme used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035419Z" creationid="pingfangx" creationdate="20190902T035419Z">
        <seg>所描述的某些功能不适用于所有 URI 方案，并且某些操作仅在使用 URI 检索某些媒体类型时才可能，无论使用何种方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of this metainformation is OPTIONAL; some might be REQUIRED by portions of this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T120452Z" creationid="pingfangx" creationdate="20190829T120452Z">
        <seg>这些元信息中的一些是可选的；有些可能是本规范的部分内容所必需的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operator overloads have been renamed with a postfix, such as `fromArray`, `fromIterable` etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111237Z" creationid="pingfangx" creationdate="20190618T111140Z">
        <seg>一些操作符重载已使用后缀重命名，例如 `fromArray`，`fromIterable` 等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators also allow for an interface between the Observable world and the Single world so that you can mix the two varieties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073958Z" creationid="pingfangx" creationdate="20190620T073958Z">
        <seg>一些操作符还允许 Obse​​rvable 世界和 Single 世界之间的接口，以便您可以混合两种变体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators that produced exactly one value or an error now return `Single` in 2.x (or `Maybe` if an empty source is allowed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060131Z" creationid="pingfangx" creationdate="20190619T060131Z">
        <seg>一些只生成一个值或错误的操作符现在在 2.x 中返回 `Single`(如果允许空源，则返回 `Maybe`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some protocol elements allow only the absolute form of a URI without a fragment identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085322Z" creationid="pingfangx" creationdate="20190902T085322Z">
        <seg>某些协议元素仅允许没有片段标识符的 URI 的绝对形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some proxies are designed to apply transformations to selected messages or payloads while they are being forwarded, as described in Section 5.7.2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190830T101436Z">
        <seg>某些代理设计用于在转发时将转换应用于选定的消息或有效载荷，如第 5.7.2 节中所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some schemes do not allow the userinfo and/or port subcomponents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073348Z" creationid="pingfangx" creationdate="20190902T073348Z">
        <seg>某些方案不允许 userinfo 和/或端口子组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some sources block or start emitting items right away in this state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072007Z" creationid="pingfangx" creationdate="20190617T072007Z">
        <seg>某些来源在此状态下会立即阻止或开始发射项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some translations are minimal, such as for proxy requests for "http" URIs, whereas other requests might require translation to and from entirely different application-level protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101400Z" creationid="pingfangx" creationdate="20190830T101400Z">
        <seg>某些转换是最小的，例如对于“http”URI 的代理请求，而其他请求可能需要从完全不同的应用程序级协议进行转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes such overflows happen due to bursty sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090237Z" creationid="pingfangx" creationdate="20190621T090237Z">
        <seg>有时这种溢出是由于突发源而发生的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes though, multiple sources may fail at which point there is a choice whether or not wait for all of them to complete or fail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103451Z" creationid="pingfangx" creationdate="20190617T103451Z">
        <seg>但有时候，多个来源可能会失败，此时可以选择是否等待所有来源完成或失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, a source or service returns a different type than the flow that is supposed to work with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092728Z" creationid="pingfangx" creationdate="20190617T092728Z">
        <seg>有时，源或服务返回的类型与应该使用它的流不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, a suffix is added to avoid logical ambiguities that may compile but produce the wrong type in a flow:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103058Z" creationid="pingfangx" creationdate="20190617T103058Z">
        <seg>有时，会添加一个后缀以避免可能编译但在流中产生错误类型的逻辑歧义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, the data source to be converted into the reactive world itself is synchronous (blocking) and pull-like, that is, we have to call some `get` or `read` method to get the next piece of data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020722Z" creationid="pingfangx" creationdate="20190624T020722Z">
        <seg>有时，要转换为响应世界本身的数据源是同步的(阻塞)和拉式的，也就是说，我们必须调用一些 `get` 或 `read` 方法来获取下一个数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, the source to be wrapped into an `Flowable` is already hot (such as mouse moves) or cold but not backpressurable in its API (such as an asynchronous network callback).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021709Z" creationid="pingfangx" creationdate="20190624T021709Z">
        <seg>有时，被包装成 `Flowable` 的源已经是热源(例如鼠标移动)或是冷源但在其 API 中不能背压(例如异步网络回调)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, there is an implicit data dependency between the previous sequence and the new sequence that, for some reason, was not flowing through the "regular channels".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092144Z" creationid="pingfangx" creationdate="20190617T092144Z">
        <seg>有时，前一个序列和新序列之间存在隐含的数据依赖性，由于某种原因，它不会流经“常规通道”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, when an item has become available, one would like to perform some dependent computations on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083533Z" creationid="pingfangx" creationdate="20190617T083533Z">
        <seg>有时，当项目可用时，人们希望对其执行一些依赖计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specialty Observables that have more precisely-controlled subscription dynamics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103546Z" creationid="pingfangx" creationdate="20190620T103546Z">
        <seg>具有更精确控制的订阅动态的特殊 Observables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specific repetition: "&lt;n&gt;(element)" is equivalent to "&lt;n&gt;*&lt;n&gt;(element)"; that is, exactly &lt;n&gt; occurrences of (element).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093649Z" creationid="pingfangx" creationdate="20190828T093649Z">
        <seg>具体重复：“&lt;n&gt;(element)”相当于“&lt;n&gt;*&lt;n&gt;(element)”;也就是说，&lt;element&gt; 恰好是 &lt;n&gt; 次出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, the secure channel should provide the following properties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122431Z" creationid="pingfangx" creationdate="20190901T122431Z">
        <seg>具体而言，安全通道应提供以下属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spiders, for example, are typically given a start URI and configured to follow certain behavior while crawling the Web as a hypertext graph.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100703Z" creationid="pingfangx" creationdate="20190830T100703Z">
        <seg>例如，蜘蛛通常被赋予一个起始 URI，并被配置为在将 Web 作为超文本图形爬行时遵循某些行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Square brackets enclose optional elements; "[foo bar]" is equivalent to "*1(foo bar)".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093519Z" creationid="pingfangx" creationdate="20190828T093519Z">
        <seg>方括号包含可选元素；“[foo bar]”相当于“*1(foo bar)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start Line</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090710Z" creationid="pingfangx" creationdate="20190830T090710Z">
        <seg>起始行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status Code Definitions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073124Z" creationid="pingfangx" creationdate="20190828T073124Z">
        <seg>状态码定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status Code Registry</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115938Z" creationid="pingfangx" creationdate="20190831T115938Z">
        <seg>状态代码注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status Code and Reason Phrase</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072559Z" creationid="pingfangx" creationdate="20190828T072559Z">
        <seg>状态代码和原因短语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status Line</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090716Z" creationid="pingfangx" creationdate="20190830T090716Z">
        <seg>状态行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status of This Memo</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090417Z" creationid="pingfangx" creationdate="20190830T090417Z">
        <seg>本备忘录的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status of this Memo</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070818Z" creationid="pingfangx" creationdate="20190828T070818Z">
        <seg>本备忘录的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status-Line</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072556Z" creationid="pingfangx" creationdate="20190828T072556Z">
        <seg>状态行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Store the return value from that method in a variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053011Z" creationid="pingfangx" creationdate="20190620T053011Z">
        <seg>将该方法的返回值存储在变量中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field-value after message parsing has delineated the individual fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T063203Z" creationid="pingfangx" creationdate="20190831T063203Z">
        <seg>在从消息中提取元素之后，只能在协议元素内安全地使用基于字符串的解析器，例如在消息解析描述了各个字段之后的首部字段值内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a message indicates to the site B TCP that something is wrong, and it is expected to abort the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055639Z" creationid="pingfangx" creationdate="20190828T055639Z">
        <seg>这样的消息向站点 B TCP 指示出现了问题，并且预计会中止连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101934Z" creationid="pingfangx" creationdate="20190831T101934Z">
        <seg>这样的消息可能表示尝试执行请求走私(第 9.5 节)或响应拆分(第 9.4 节)，并且应该作为错误处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a name consists of a sequence of domain labels separated by ".", each domain label starting and ending with an alphanumeric character and possibly also containing "-" characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075319Z" creationid="pingfangx" creationdate="20190902T075319Z">
        <seg>这样的名称由一系列以“.”分隔的域标签组成，每个域标签以字母数字字符开头和结尾，可能还包含“ - ”字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a segment must be preceded by a dot-segment (e.g., "./this:that") to make a relative-path reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085237Z" creationid="pingfangx" creationdate="20190902T085237Z">
        <seg>这样的片段必须以点片段开头(例如，“./this:that”)以进行相对路径引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such an Observable does not begin emitting items until its &lt;a0&gt;&lt;s1&gt;Connect&lt;/s1&gt;&lt;/a0&gt; method is called, whether or not any observers have subscribed to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070147Z" creationid="pingfangx" creationdate="20190620T070147Z">
        <seg>这样的 Observable 在调用 &lt;a0&gt;&lt;s1&gt;Connect&lt;/s1&gt;&lt;/a0&gt; 方法之前不会开始发射项目，无论是否有任何观察者订阅了它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such connections will automatically become reset if an attempt is made to send data in either direction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043538Z" creationid="pingfangx" creationdate="20190828T043538Z">
        <seg>如果尝试向任一方向发送数据，则此类连接将自动重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such errors are routed to the `RxJavaPlugins.onError` handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090058Z" creationid="pingfangx" creationdate="20190618T090058Z">
        <seg>这些错误被路由到 `RxJavaPlugins.onError` 处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such leading or trailing LWS MAY be removed without changing the semantics of the field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T083126Z" creationid="pingfangx" creationdate="20190829T081240Z">
        <seg>这样的前导或尾随 LWS 可以在不改变字段值语义的情况下删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103925Z" creationid="pingfangx" creationdate="20190830T103925Z">
        <seg>除非由特定客户端属性触发，例如当一个或多个请求首部字段(例如，用户代理)唯一地匹配由已知错误的客户端发送的值时，否则不应执行这样的协议降级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such references are primarily intended for human interpretation rather than for machines, with the assumption that context-based heuristics are sufficient to complete the URI (e.g., most registered names beginning with "www" are likely to have a URI prefix of "http://").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090412Z" creationid="pingfangx" creationdate="20190902T090412Z">
        <seg>这些引用主要用于人工解释而不是机器，假设基于上下文的启发式方法足以完成 URI(例如，以“www”开头的大多数注册名称可能具有 URI 前缀“http://“)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such rendering will assist the user in cases where the userinfo has been misleadingly crafted to look like a trusted domain name (Section 7.6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073732Z" creationid="pingfangx" creationdate="20190902T073732Z">
        <seg>在 userinfo 被误导性地制作成看起来像可信域名的情况下，此类呈现将帮助用户(第 7.6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suddenly, the user taps the screen too quickly and `observeOn`'s default 16-element internal buffer on Android overflows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090257Z" creationid="pingfangx" creationdate="20190621T090257Z">
        <seg>突然，用户太快地点击了屏幕，Android 上的 `observeOn` 的默认 16 元素内部缓冲区溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suffix Reference</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042853Z" creationid="pingfangx" creationdate="20190902T042853Z">
        <seg>后缀引用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose, for example, that a connection is opened starting with sequence number S.  Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025646Z" creationid="pingfangx" creationdate="20190828T025646Z">
        <seg>例如，假设从序列号 S 开始打开连接。假设此连接使用不多，并且最终初始序列号函数(ISN(t))采用等于序列号的值，例如 S1，此 TCP 在特定连接上发送的最后一个报文段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Surprising to some, this prints 1 twice instead of printing 1 and 2 respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015800Z" creationid="pingfangx" creationdate="20190624T015800Z">
        <seg>令某些人感到惊讶的是，这打印 1 次，而不是分别打印 1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactically, the two types of message differ only in the start-line, which is either a request-line (for requests) or a status-line (for responses), and in the algorithm for determining the length of the message body (Section 3.3).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T065502Z" creationid="pingfangx" creationdate="20190831T065502Z">
        <seg>从语法上讲，这两种类型的消息只在起始行上以及在确定消息体长度的算法中( 3.3)有所不同，起始行是请求行(对于请求)或状态行(对于响应)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax Components</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042827Z" creationid="pingfangx" creationdate="20190902T042827Z">
        <seg>语法组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax Notation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090608Z" creationid="pingfangx" creationdate="20190830T090608Z">
        <seg>语法符号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TABLE OF CONTENTS</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071147Z" creationid="pingfangx" creationdate="20190828T071147Z">
        <seg>目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP A detects that the ACK field is incorrect and returns a RST (reset) with its SEQ field selected to make the segment believable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043058Z" creationid="pingfangx" creationdate="20190828T043058Z">
        <seg>TCP A 检测到 ACK 字报文段不正确并返回 RST(重置)，并选择其 SEQ 字段以使该报文段可信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP A sees that this segment does not acknowledge anything it sent and, being unsynchronized, sends a reset (RST) because it has detected a half-open connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060135Z" creationid="pingfangx" creationdate="20190828T060135Z">
        <seg>TCP A 看到此报文段未确认它发送的任何内容，因此不同步，所以会发送重置(RST)因为它已检测到半开连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP A will continue to try to establish the connection; the problem is now reduced to the basic 3-way handshake of figure 7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060158Z" creationid="pingfangx" creationdate="20190828T060158Z">
        <seg>TCP A 将继续尝试建立连接；问题现在减少到图 7 的基本三次握手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B aborts at line 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060145Z" creationid="pingfangx" creationdate="20190828T060145Z">
        <seg>TCP B 在第 5 行中止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B accepts the reset and returns to its passive LISTEN state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060408Z" creationid="pingfangx" creationdate="20190828T060408Z">
        <seg>TCP B 接受重置并返回其被动 LISTEN 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B, in the meantime, thinks the connection is open.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055851Z" creationid="pingfangx" creationdate="20190828T055844Z">
        <seg>在此期间，TCP B 认为连接是打开的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP B, on receiving the RST, returns to the LISTEN state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043257Z" creationid="pingfangx" creationdate="20190828T043257Z">
        <seg>接收到 RST 后，TCP B 返回到 LISTEN 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP Header Format</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104755Z" creationid="pingfangx" creationdate="20190827T104755Z">
        <seg>TCP 首部格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP implementors may violate the "quiet time" restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024916Z" creationid="pingfangx" creationdate="20190828T024916Z">
        <seg>TCP 实现者可能违反“安静时间”限制，但仅有可能导致某些旧数据被接受为新的或新的数据被拒绝，因为互联网系统中的某些接收器复制旧数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP segments are sent as internet datagrams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T100659Z" creationid="pingfangx" creationdate="20190827T100659Z">
        <seg>TCP 报文段作为 Internet 数据报发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP states represent the state AFTER the departure or arrival of the segment (whose contents are shown in the center of each line).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T034622Z" creationid="pingfangx" creationdate="20190828T034622Z">
        <seg>TCP 状态表示报文段的离开或到达之后的状态(其内容显示在每条线的中心)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCPs consume sequence number space each time a segment is formed and entered into the network output queue at a source host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025014Z" creationid="pingfangx" creationdate="20190828T025014Z">
        <seg>每次形成一个报文段并将其输入到源主机的网络输出队列中时，TCP 会消耗序列号空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TEXT           = &lt;any OCTET except CTLs, but including LWS&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100046Z" creationid="pingfangx" creationdate="20190828T100046Z">
        <seg>TEXT           = &lt;除 CTL 之外的任何 OCTET，但包括 LWS&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112924Z" creationid="pingfangx" creationdate="20190827T112924Z">
        <seg>TIME-WAIT - 表示等待足够的时间以确保远程 TCP 收到其连接终止请求的确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121356Z" creationid="pingfangx" creationdate="20190901T121356Z">
        <seg>TLS 允许客户端/服务器应用程序在互联网上通过旨在防止窃听，篡改和消息伪造的方式进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TLS consists of two primary components:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T124313Z" creationid="pingfangx" creationdate="20190901T124313Z">
        <seg>TLS 包含两个主要组件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TLS does not hide the length of the data it transmits, though endpoints are able to pad TLS records in order to obscure lengths and improve protection against traffic analysis techniques.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T123159Z" creationid="pingfangx" creationdate="20190901T123159Z">
        <seg>TLS 不会隐藏它传输的数据的长度，尽管端点能够填充 TLS 记录以掩盖长度并改进对流量分析技术的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TLS implementations MUST initiate an exchange of closure alerts before closing a connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091802Z" creationid="pingfangx" creationdate="20190901T091802Z">
        <seg>TLS 实现必须在关闭连接之前启动关闭警报的交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TLS only presumes a reliable connection-oriented data stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103316Z" creationid="pingfangx" creationdate="20190901T103316Z">
        <seg>TLS 仅假定可靠的面向连接的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TLS provides a facility for secure connection closure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091629Z" creationid="pingfangx" creationdate="20190901T091629Z">
        <seg>TLS 提供安全连接关闭的工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074307Z" creationid="pingfangx" creationdate="20190830T074307Z">
        <seg>TRACE 允许客户端查看请求链另一端收到的内容，并将该数据用于测试或诊断信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TRANSMISSION CONTROL PROTOCOL</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025942Z" creationid="pingfangx" creationdate="20190828T024814Z">
        <seg>TRANSMISSION CONTROL PROTOCOL
输输控制协议
没有完全翻译，并且有部分内容不太理解，可能只是单纯的机器翻译，没加修饰。
应该需要多读几遍才行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T144636Z" creationid="pingfangx" creationdate="20190830T144636Z">
        <seg>目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tear-down</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091027Z" creationid="pingfangx" creationdate="20190830T091027Z">
        <seg>拆除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Techniques like &lt;a0&gt;Java Futures&lt;/a0&gt; are straightforward to use for &lt;a1&gt;a single level of asynchronous execution&lt;/a1&gt; but they start to add &lt;a2&gt;non-trivial complexity&lt;/a2&gt; when they’re nested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034736Z" creationid="pingfangx" creationdate="20190620T034736Z">
        <seg>诸如 &lt;a0&gt;Java Futures&lt;/a0&gt; 之类的技术可以直接用于 &lt;a1&gt;单层的异步操作&lt;/a1&gt;，但是当它们嵌套时，它们开始变得 &lt;a2&gt;异常的复杂&lt;/a2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111055Z" creationid="pingfangx" creationdate="20190827T111055Z">
        <seg>术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test developers are now encouraged to simply `new TestScheduler()` in their code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093750Z" creationid="pingfangx" creationdate="20190618T093750Z">
        <seg>现在鼓励测试开发人员在他们的代码中简单地使用 `new TestScheduler()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing RxJava 2.x works the same way as it does in 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095744Z" creationid="pingfangx" creationdate="20190618T095744Z">
        <seg>测试 RxJava 2.x 的工作方式与 1.x 相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests that want to override the schedulers and the lifecycle of the base reactive types can do it on a case-by-case basis through callback functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085756Z" creationid="pingfangx" creationdate="20190618T085756Z">
        <seg>想要覆盖调度器和基本响应类型生命周期的测试可以通过回调函数逐个进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That abstraction is called a representation [REST].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T132834Z" creationid="pingfangx" creationdate="20190831T132834Z">
        <seg>这种抽象称为表示 (representation) [REST]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is not the case in practice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100531Z" creationid="pingfangx" creationdate="20190830T100531Z">
        <seg>实际情况并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, "(element), , (element) " is permitted, but counts as only two elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094050Z" creationid="pingfangx" creationdate="20190828T094050Z">
        <seg>也就是说，“(element), , (element) ”是允许的，但只计为两个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, unless otherwise indicated, the client SHOULD assume that the server will maintain a persistent connection, even after error responses from the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150307Z" creationid="pingfangx" creationdate="20190829T150307Z">
        <seg>也就是说，除非另有说明，客户端应该假设服务器将保持持久连接，即使在服务器的错误响应之后也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T065128Z" creationid="pingfangx" creationdate="20190830T065128Z">
        <seg>该资源可能是数据接受过程，某些其他协议的网关或接受注释的单独实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "Connection" header field allows the sender to indicate desired control options for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110219Z" creationid="pingfangx" creationdate="20190831T110219Z">
        <seg>“Connection”首部字段允许发送方指示当前连接的所需控制选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "Host" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125351Z" creationid="pingfangx" creationdate="20190831T125351Z">
        <seg>请求中的“Host”首部字段提供来自目标 URI 的主机和端口信息，使原始服务器能够在为单个 IP 地址上的多个主机名的请求提供服务时区分资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113020Z" creationid="pingfangx" creationdate="20190831T113020Z">
        <seg>“Upgrade”首部字段旨在提供一种简单的机制，用于在同一连接上从 HTTP/1.1 转换到某些其他协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "charset" parameter is used with some media types to define the character set (section 3.4) of the data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151634Z" creationid="pingfangx" creationdate="20190828T151634Z">
        <seg>“charset”参数与某些媒体类型一起用于定义数据的字符集(第 3.4 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "chunked" transfer-coding MUST NOT be applied more than once to a message-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142754Z" creationid="pingfangx" creationdate="20190828T142754Z">
        <seg>“分块”传输编码不得多次应用于消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "close" connection option is defined for a sender to signal that this connection will be closed after completion of the response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110846Z" creationid="pingfangx" creationdate="20190831T110846Z">
        <seg>为发送方定义“close”连接选项，以表示在完成响应后将关闭此连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "close" connection option is used to signal that a connection will not persist after the current request/response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110947Z" creationid="pingfangx" creationdate="20190831T110947Z">
        <seg>“close”连接选项用于表示在当前请求/响应之后连接不会持久存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "http" URI scheme is hereby defined for the purpose of minting identifiers according to their association with the hierarchical namespace governed by a potential HTTP origin server listening for TCP ([RFC0793]) connections on a given port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T043716Z" creationid="pingfangx" creationdate="20190831T043716Z">
        <seg>“http”URI 方案的定义是为了根据标识符与层次命名空间的关联来生成标识符，层次命名空间由监听给定端口上 TCP([RFC0793])连接的潜在 HTTP 源服务器控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "http" scheme is used to locate network resources via the HTTP protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T111609Z" creationid="pingfangx" creationdate="20190828T111609Z">
        <seg>“http”方案用于通过 HTTP 协议定位网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "https" URI scheme is hereby defined for the purpose of minting identifiers according to their association with the hierarchical namespace governed by a potential HTTP origin server listening to a given TCP port for TLS-secured connections ([RFC5246]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060125Z" creationid="pingfangx" creationdate="20190831T055751Z">
        <seg>“https”URI 方案的定义是为了根据标识符与层次命名空间的关联来生成标识符，该层次命名空间由潜在的 HTTP 源服务器控制，该服务器监听给定的 TCP 端口以进行 TLS 安全连接([RFC5246])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "identity" transfer coding token has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092034Z" creationid="pingfangx" creationdate="20190830T092034Z">
        <seg>已删除“identity”传输编码标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "three-way handshake" is the procedure used to establish a connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030650Z" creationid="pingfangx" creationdate="20190828T030650Z">
        <seg>“三次握手”是用于建立连接的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "zlib" format defined in RFC 1950 [31] in combination with the "deflate" compression mechanism described in RFC 1951 [29].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141218Z" creationid="pingfangx" creationdate="20190828T141218Z">
        <seg>RFC 1950 [31] 中定义的“zlib”格式与 RFC 1951 [29] 中描述的“deflate”压缩机制相结合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 1.x `TestSubject` has been dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063524Z" creationid="pingfangx" creationdate="20190618T063524Z">
        <seg>1.x 的 `TestSubject` 已被删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x API still supports the main default scheduler types: `computation`, `io`, `newThread` and `trampoline`, accessible through `io.reactivex.schedulers.Schedulers` utility class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093502Z" creationid="pingfangx" creationdate="20190618T093502Z">
        <seg>2.x API 仍支持主要的默认调度器类型：`calculate`，`io`，`newThread` 和 `trampoline`，可通过 `io.reactivex.schedulers.Schedulers` 实用程序类访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x `Single` reactive base type, which can emit a single `onSuccess` or `onError` has been redesigned from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055616Z" creationid="pingfangx" creationdate="20190618T055616Z">
        <seg>2.x 重新设计的 `Single` 响应基类型，它可以发出单个 `onSuccess` 或 `onError` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x redesigned the `RxJavaPlugins` class which now supports changing the hooks at runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085718Z" creationid="pingfangx" creationdate="20190618T085718Z">
        <seg>2.x 重新设计了 `RxJavaPlugins` 类，它现在支持在运行时更改钩子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Worker&lt;/c0&gt; is also a &lt;c1&gt;Subscription&lt;/c1&gt; and so you can (and should, eventually) call its &lt;c2&gt;unsubscribe&lt;/c2&gt; method to signal that it can halt work and release resources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092316Z" creationid="pingfangx" creationdate="20190620T092316Z">
        <seg>&lt;c0&gt;Worker&lt;/c0&gt; 也是 &lt;c1&gt;Subscription&lt;/c1&gt;，因此您可以(通常也应该)调用其 &lt;c2&gt;unsubscribe&lt;/c2&gt; 方法来表示它可以停止工作和释放资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;onError&lt;/c2&gt; method takes as its parameter an indication of what caused the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060342Z" creationid="pingfangx" creationdate="20190620T060342Z">
        <seg>&lt;c2&gt;onError&lt;/c2&gt; 方法将导致错误的原因作为其参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;major&gt; number is incremented when the format of a message within the protocol is changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103152Z" creationid="pingfangx" creationdate="20190828T103152Z">
        <seg>当协议内的消息格式发生变化时，&lt;major&gt; 号会递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;minor&gt; number is incremented when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may add to the message semantics and imply additional capabilities of the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103143Z" creationid="pingfangx" creationdate="20190828T103143Z">
        <seg>当对协议所做的更改添加不改变一般消息解析算法但可能添加到消息语义并暗示发送方的附加功能的特征时，&lt;minor&gt; 数字会递增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;s1&gt;SubscribeOn&lt;/s1&gt; operator changes this behavior by specifying a different Scheduler on which the Observable should operate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085953Z" creationid="pingfangx" creationdate="20190620T085953Z">
        <seg>&lt;s1&gt;SubscribeOn&lt;/s1&gt; 操作符通过指定 Observable 应在其上运行的其他 Scheduler 来更改此行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;s2&gt;ObserveOn&lt;/s2&gt; operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090251Z" creationid="pingfangx" creationdate="20190620T090251Z">
        <seg>&lt;s2&gt;ObserveOn&lt;/s2&gt; 操作符指定 Observable 将用于向其观察者发送通知的另一个 Scheduler。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ABNF notation defines its terminal values to be non-negative integers (codepoints) based on the US-ASCII coded character set [ASCII].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065035Z" creationid="pingfangx" creationdate="20190902T065035Z">
        <seg>ABNF 表示法根据 US-ASCII 编码字符集 [ASCII] 将其终值定义为非负整数(代码点)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ABNF of URI-reference, along with the "first-match-wins" disambiguation rule, is sufficient to define a validating parser for the generic syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084422Z" creationid="pingfangx" creationdate="20190902T084422Z">
        <seg>URI-reference 的 ABNF 以及“first-match-wins”消歧规则足以为通用语法定义验证解析器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ABNF productions defining header fields now only list the field value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091813Z" creationid="pingfangx" creationdate="20190830T091813Z">
        <seg>现在，定义首部字段的 ABNF 产品仅列出字段值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ABNF provided here is a translation of the text definition of an IPv6 literal address provided in [RFC3513].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074638Z" creationid="pingfangx" creationdate="20190902T074638Z">
        <seg>这里提供的 ABNF 是 [RFC3513] 中提供的 IPv6 文字地址的文本定义的翻译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ABNF requires five separate rules to disambiguate these cases, only one of which will match the path substring within a given URI reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081734Z" creationid="pingfangx" creationdate="20190902T081734Z">
        <seg>ABNF 需要五个单独的规则来消除这些情况的歧义，其中只有一个与给定 URI 引用中的路径子字符串匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BWS rule is used where the grammar allows optional whitespace only for historical reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082800Z" creationid="pingfangx" creationdate="20190831T082800Z">
        <seg>BWS 规则用于语法仅出于历史原因允许可选空格的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142907Z" creationid="pingfangx" creationdate="20190831T142907Z">
        <seg>CONNECT 方法请求接收方建立到由请求目标标识的目标源服务器的隧道，并且如果成功，则此后将其行为限制为在两个方向上盲转发分组，直到隧道关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Connection header field (Section 6.1) provides a "close" connection option that a sender SHOULD send when it wishes to close the connection after the current request/response pair.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112608Z" creationid="pingfangx" creationdate="20190831T112608Z">
        <seg>Connection 首部字段(第 6.1 节)提供了一个“close”连接选项，发送者在希望在当前请求/响应对之后关闭连接时应该发送该选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Connection header field's value has the following grammar:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110328Z" creationid="pingfangx" creationdate="20190831T110328Z">
        <seg>Connection 首部字段的值具有以下语法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T085240Z" creationid="pingfangx" creationdate="20190829T085240Z">
        <seg>如果这两个长度不同(即，如果存在 Transfer-Encoding 首部字段)，则不得发送 Content-Length 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DELETE method requests that the origin server delete the resource identified by the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T073203Z" creationid="pingfangx" creationdate="20190830T073203Z">
        <seg>DELETE 方法请求源服务器删除 Request-URI 标识的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DELETE method requests that the origin server remove the association between the target resource and its current functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142536Z" creationid="pingfangx" creationdate="20190831T142536Z">
        <seg>DELETE 方法请求源服务器删除目标资源与其当前功能之间的关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062101Z" creationid="pingfangx" creationdate="20190830T062101Z">
        <seg>GET 方法意味着检索由 Request-URI 标识的任何信息(以实体的形式)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GET method requests transfer of a current selected representation for the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135203Z" creationid="pingfangx" creationdate="20190831T135203Z">
        <seg>GET 方法请求传输目标资源的当前所选表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063258Z" creationid="pingfangx" creationdate="20190830T063258Z">
        <seg>HEAD 方法与 GET 相同，只是服务器不能在响应中返回消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HEAD method is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header section).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T140001Z" creationid="pingfangx" creationdate="20190831T140001Z">
        <seg>HEAD 方法与 GET 相同，除了服务器不得在响应中发送消息体(即响应终止于首部的末尾)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135410Z" creationid="pingfangx" creationdate="20190831T135410Z">
        <seg>资源的 HTTP 接口很可能实现为内容对象树，各种数据库记录的编程视图或其他信息系统的网关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP protocol does not place any a priori limit on the length of a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T110552Z" creationid="pingfangx" creationdate="20190828T110552Z">
        <seg>HTTP 协议不对 URI 的长度设置任何先验限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP protocol is a request/response protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T084804Z" creationid="pingfangx" creationdate="20190828T084804Z">
        <seg>HTTP 协议是请求/响应协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP version number consists of two decimal digits separated by a "." (period or decimal point).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103237Z" creationid="pingfangx" creationdate="20190830T103237Z">
        <seg>HTTP 版本号由两个以“.”分隔的十进制数字组成。(句号或小数点)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP version of an application is the highest HTTP version for which the application is at least conditionally compliant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104004Z" creationid="pingfangx" creationdate="20190828T104004Z">
        <seg>应用程序的 HTTP 版本是应用程序至少有条件兼容的最高 HTTP 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP-version ABNF production has been clarified to be case-sensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091611Z" creationid="pingfangx" creationdate="20190830T091611Z">
        <seg>HTTP 版本的 ABNF 生产已被阐明为区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTPS URI scheme is now defined by this specification; previously, it was done in Section 2.4 of [RFC2818].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091718Z" creationid="pingfangx" creationdate="20190830T091718Z">
        <seg>HTTPS URI 方案现在由此规范定义；以前，它是在 [RFC2818] 的第 2.4 节中完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Host Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071226Z" creationid="pingfangx" creationdate="20190828T071226Z">
        <seg>主机环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Host request-header field (section 14.23) MUST accompany all HTTP/1.1 requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T031758Z" creationid="pingfangx" creationdate="20190830T031758Z">
        <seg>主机请求首部字段(第 14.23 节)必须伴随所有 HTTP/1.1 请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090344Z" creationid="pingfangx" creationdate="20190830T090344Z">
        <seg>超文本传输​​协议(HTTP)是用于分布式、协作性、超文本信息系统的无状态应用程序级协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190830T093332Z">
        <seg>超文本传输​​协议(HTTP)是一种无状态应用程序级请求/响应协议，它使用可扩展语义和自描述消息有效载荷来与基于网络的超文本信息系统进行灵活交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071006Z" creationid="pingfangx" creationdate="20190828T071006Z">
        <seg>超文本传输协议(HTTP)是一种用于分布式、协作性、超媒体信息系统的应用级协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Internet Assigned Numbers Authority (IANA) acts as a registry for content-coding value tokens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140205Z" creationid="pingfangx" creationdate="20190828T140205Z">
        <seg>互联网号码分配机构(IANA)充当内容编码值标记的注册机构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143232Z" creationid="pingfangx" creationdate="20190828T143232Z">
        <seg>互联网号码分配机构(IANA)充当传输编码值标记的注册机构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Internet Protocol header carries several information fields, including the source and destination host addresses [2].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T103155Z" creationid="pingfangx" creationdate="20190827T103155Z">
        <seg>Internet 协议首部包含多个信息字段，包括源地址和目标主机地址 [2]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MIME header fields within each body-part of a multipart message- body do not have any significance to HTTP beyond that defined by their MIME semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152736Z" creationid="pingfangx" creationdate="20190828T152736Z">
        <seg>多部分消息体的每个主体部分中的 MIME 首部字段对于超出其 MIME 语义定义的 HTTP 没有任何重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042243Z" creationid="pingfangx" creationdate="20190830T042243Z">
        <seg>Max-Forwards 请求首部字段可用于定位请求链中的特定代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Method  token indicates the method to be performed on the resource identified by the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094040Z" creationid="pingfangx" creationdate="20190829T094040Z">
        <seg>Method 标记指示要对 Request-URI 标识的资源执行的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The NUL octet is no longer allowed in comment and quoted-string text, and handling of backslash-escaping in them has been clarified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091847Z" creationid="pingfangx" creationdate="20190830T091847Z">
        <seg>注释和带引号的文本中不再允许使用 NUL 八位字节，并且已经澄清了对它们进行反斜杠转义的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041612Z" creationid="pingfangx" creationdate="20190830T041612Z">
        <seg>OPTIONS 方法表示一个信息请求，请求的信息是有关 Request-URI 标识的请求/响应链上可用的通信选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143427Z" creationid="pingfangx" creationdate="20190831T143427Z">
        <seg>OPTIONS 方法在源服务器或中间中介处请求有关目标资源可用的通信选项的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OWS rule is used where zero or more linear whitespace octets might appear.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082653Z" creationid="pingfangx" creationdate="20190831T082653Z">
        <seg>OWS 规则用于可能出现零个或多个线性空白八位字节的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Observable type adds two missing semantics to &lt;a0&gt;the Gang of Four’s Observer pattern&lt;/a0&gt;, to match those that are available in the Iterable type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042308Z" creationid="pingfangx" creationdate="20190620T042308Z">
        <seg>Observable 类型为 &lt;a0&gt;Gang of Four 的观察者模式&lt;/a0&gt; 添加了两个缺少的语义，以匹配 Iterable 类型中可用的语义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Operators of ReactiveX</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094002Z" creationid="pingfangx" creationdate="20190620T094002Z">
        <seg>ReactiveX 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063942Z" creationid="pingfangx" creationdate="20190830T063942Z">
        <seg>POST 方法用于请求源服务器接受请求中包含的实体作为 Request-Line 中 Request-URI 标识的资源的新下级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T140533Z" creationid="pingfangx" creationdate="20190831T140533Z">
        <seg>POST 方法请求目标资源根据资源自身的特定语义处理请求中包含的表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PUT method requests that the enclosed entity be stored under the supplied Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064831Z" creationid="pingfangx" creationdate="20190830T064831Z">
        <seg>PUT 方法请求将所包含的实体存储在提供的 Request-URI 下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142403Z" creationid="pingfangx" creationdate="20190831T142403Z">
        <seg>PUT 方法请求创建或替换目标资源的状态，该状态由请求消息负载中包含的表示定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RST is acceptable so TCP B processes it and aborts the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060254Z" creationid="pingfangx" creationdate="20190828T060254Z">
        <seg>RST 是可接受的，因此 TCP B 处理它并中止连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RWS rule is used when at least one linear whitespace octet is required to separate field tokens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082750Z" creationid="pingfangx" creationdate="20190831T082750Z">
        <seg>当需要至少一个线性空白八位字节来分隔字段标记时，使用 RWS 规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification has its own Subscriber as an interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065304Z" creationid="pingfangx" creationdate="20190618T065304Z">
        <seg>Reactive-Streams 规范有自己的订阅者作为接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification mandates operators supporting backpressure, specifically via the guarantee that they don't overflow their consumers when those don't request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073359Z" creationid="pingfangx" creationdate="20190618T073359Z">
        <seg>Reactive-Streams 规范要求操作符支持背压，特别是通过保证在没有请求时它们不会溢出消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification took this name for specifying an interaction point between a source and a consumer: `org.reactivestreams.Subscription` allows requesting a positive amount from the upstream and allows cancelling the sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072735Z" creationid="pingfangx" creationdate="20190618T072735Z">
        <seg>Reactive-Streams 规范使用此名称来指定源和消费者之间的交互点：`org.reactivestreams.Subscription` 允许从上游请求正数量并允许取消序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034410Z" creationid="pingfangx" creationdate="20190620T034410Z">
        <seg>ReactiveX Observable 模型允许您使用简单，可组合的操作来处理异步事件流，就像用于数据项集合(如数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reason-Phrase is intended to give a short textual description of the Status-Code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105438Z" creationid="pingfangx" creationdate="20190829T105438Z">
        <seg>Reason-Phrase 旨在提供 Status-Code 的简短文本描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Request-Line begins with a method token, followed by the Request-URI and the protocol version, and ending with CRLF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105229Z" creationid="pingfangx" creationdate="20190829T093619Z">
        <seg>请求行(Request-Line)以方法标记开头，后跟 Request-URI 和协议版本，以 CRLF 结尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Request-URI is a Uniform Resource Identifier (section 3.2) and identifies the resource upon which to apply the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T095106Z" creationid="pingfangx" creationdate="20190829T095104Z">
        <seg>Request-URI 是统一资源标识符(第 3.2 节)，用于标识应用请求的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Request-URI is transmitted in the format specified in section 3.2.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101254Z" creationid="pingfangx" creationdate="20190829T101254Z">
        <seg>Request-URI 以 3.2.1 节中指定的格式传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022716Z" creationid="pingfangx" creationdate="20190828T022716Z">
        <seg>SYN 和 FIN 是唯一需要此保护的控制位，这些控制位仅用于连接打开和关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Status-Code element is a 3-digit integer result code of the attempt to understand and satisfy the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105427Z" creationid="pingfangx" creationdate="20190829T105427Z">
        <seg>Status-Code 元素是尝试理解和满足请求的 3 位整数结果代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Status-Code is intended for use by automata and the Reason-Phrase is intended for the human user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105522Z" creationid="pingfangx" creationdate="20190829T105522Z">
        <seg>Status-Code 旨在供自动机使用，Reason-Phrase 适用于人类用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP Length is the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity, but is computed), and it does not count the 12 octets of the pseudo header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110544Z" creationid="pingfangx" creationdate="20190827T110544Z">
        <seg>TCP 长度是 TCP 报头长度加上八位字节的数据长度(这不是显式发送的数量，而是计算的)，并且它不计算伪首部的 12 个八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP Quiet Time Concept</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024503Z" creationid="pingfangx" creationdate="20190828T024503Z">
        <seg>TCP 安静的时间概念</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP header (even one including options) is an integral number of 32 bits long.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105322Z" creationid="pingfangx" creationdate="20190827T105322Z">
        <seg>TCP 首部(甚至包括选项)是 32 位长的整数倍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111049Z" creationid="pingfangx" creationdate="20190827T111049Z">
        <seg>TCP 首部填充用于确保 TCP 首部结束和数据开始在 32 位边界上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TCP then waits until its own FIN is acknowledged whereupon it deletes the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063742Z" creationid="pingfangx" creationdate="20190828T063742Z">
        <seg>然后 TCP 等待，直到它自己的 FIN 被确认，然后删除连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TEXT rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095925Z" creationid="pingfangx" creationdate="20190828T095925Z">
        <seg>TEXT 规则仅用于描述性字段内容和不打算由消息解析器解释的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TRACE method is used to invoke a remote, application-layer loop- back of the request message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T073935Z" creationid="pingfangx" creationdate="20190830T073935Z">
        <seg>TRACE 方法用于调用请求消息的远程应用层环回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TRACE method requests a remote, application-level loop-back of the request message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143840Z" creationid="pingfangx" creationdate="20190831T143840Z">
        <seg>TRACE 方法请求请求消息的远程应用程序级环回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Trailer header field can be used to indicate which header fields are included in a trailer (see section 14.40).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144042Z" creationid="pingfangx" creationdate="20190828T144042Z">
        <seg>Trailer 首部字段可用于指示 trailer 中包含哪些首部字段(请参阅第 14.40 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090625Z" creationid="pingfangx" creationdate="20190831T090625Z">
        <seg>Transfer-Encoding 首部字段列出了与已经(或将要)应用于有效载荷主体以形成消息主体的传输编码序列相对应的传输编码名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI characters are, in turn, frequently encoded as octets for transport or presentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064902Z" creationid="pingfangx" creationdate="20190902T064902Z">
        <seg>反过来，URI 字符经常被编码为用于传输或呈现的八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI generic syntax for authority also includes a deprecated userinfo subcomponent ([RFC3986], Section 3.2.1) for including user authentication information in the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T055050Z" creationid="pingfangx" creationdate="20190831T055050Z">
        <seg>权限的 URI 通用语法还包括不推荐使用的 userinfo 子组件([RFC3986]，第 3.2.1 节)，用于在 URI 中包含用户身份验证信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI in a POST request identifies the resource that will handle the enclosed entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T065112Z" creationid="pingfangx" creationdate="20190830T065112Z">
        <seg>POST 请求中的 URI 标识将处理所包含实体的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI referred to by a relative reference, also known as the target URI, is obtained by applying the reference resolution algorithm of Section 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084943Z" creationid="pingfangx" creationdate="20190902T084943Z">
        <seg>相对引用所引用的 URI(也称为目标 URI)是通过应用第 5 节的引用解析算法获得的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042521Z" creationid="pingfangx" creationdate="20190902T042521Z">
        <seg>URI 语法定义了一个语法，该语法是所有有效 URI 的超集，允许实现解析 URI 引用的公共组件，而不需要知道每个可能标识符的特定于方案的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI syntax is designed for unambiguous reference to resources and extensibility via the URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090203Z" creationid="pingfangx" creationdate="20190902T090203Z">
        <seg>URI 语法旨在通过 URI 方案明确引用资源和可扩展性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI syntax is organized hierarchically, with components listed in order of decreasing significance from left to right.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064516Z" creationid="pingfangx" creationdate="20190902T064516Z">
        <seg>URI 语法按层次结构组织，组件按从左到右的重要性递减顺序列出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URI syntax provides a method of encoding data, presumably for the sake of identifying a resource, as a sequence of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064842Z" creationid="pingfangx" creationdate="20190902T064842Z">
        <seg>URI 语法提供了一种将数据编码的方法，可能是为了识别资源，作为字符序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The US-ASCII coded character set is defined by ANSI X3.4-1986 [21].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094506Z" creationid="pingfangx" creationdate="20190828T094506Z">
        <seg>US-ASCII 编码字符集由 ANSI X3.4-1986 [21] 定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113829Z" creationid="pingfangx" creationdate="20190831T113829Z">
        <seg>Upgrade 首部字段仅适用于现有连接之上的切换协议；它不能用于切换底层连接(传输)协议，也不能用于将现有通信切换到不同的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `BackpressureOverflow.Strategy` is an interface actually but the class `BackpressureOverflow` offers 4 static fields with implementations of it representing typical actions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014454Z" creationid="pingfangx" creationdate="20190624T014454Z">
        <seg>`BackpressureOverflow.Strategy` 实际上是一个接口，但是 `BackpressureOverflow` 类提供了 4 个静态字段，其实现代表了典型的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `BehaviorProcessor` and `PublishProcessor` don't coordinate requests (use `Flowable.publish()` for that) of their downstream subscribers and will signal them `MissingBackpressureException` if the downstream can't keep up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063040Z" creationid="pingfangx" creationdate="20190618T063040Z">
        <seg>`BehaviorProcessor` 和 `PublishProcessor` 不协调下游订阅者的请求(如果需要则使用 `Flowable.publish()`)，如果下游无法跟上，则会发出 `MissingBackpressureException` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Completable` type remains largely the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055938Z" creationid="pingfangx" creationdate="20190618T055938Z">
        <seg>`Completable` 类型基本保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Emitter` is relatively straightforward to use; one can call `onNext`, `onError` and `onComplete` on it and the operator handles backpressure and unsubscription management on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022550Z" creationid="pingfangx" creationdate="20190624T022550Z">
        <seg>`Emitter` 的使用相对简单；可以在其上调用 `onNext`，`onError` 和 `onComplete`，操作符可以自己处理背压和取消订阅管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `FuncN` is replaced by the `Function&lt;Object[], R&gt;` type declaration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065013Z" creationid="pingfangx" creationdate="20190618T065013Z">
        <seg>`FuncN` 被 `Function&lt;Object[], R&gt;` 类型声明所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Maybe` class is accompanied by `MaybeSource` as its base interface type, `MaybeObserver&lt;T&gt;` as its signal-receiving interface and follows the protocol `onSubscribe (onSuccess | onError | onComplete)?`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060616Z" creationid="pingfangx" creationdate="20190618T060616Z">
        <seg>`Maybe` 类伴随着 `MaybeSource` 作为其基本接口类型，`MaybeObserver&lt;T&gt;` 作为其信号接收接口，并遵循协议 `onSubscribe (onSuccess | onError | onComplete)?`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Schedulers.test()` has been removed as well to avoid the conceptional difference with the rest of the default schedulers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093658Z" creationid="pingfangx" creationdate="20190618T093658Z">
        <seg>`Schedulers.test()` 也已被移除，以避免与其他默认调度器的概念差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `SerializedSubject` is no longer a public class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063614Z" creationid="pingfangx" creationdate="20190618T063614Z">
        <seg>`SerializedSubject` 不再是公共类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Thread.sleep(2000);` at the end is no accident.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073846Z" creationid="pingfangx" creationdate="20190617T073846Z">
        <seg>最后的 `Thread.sleep(2000);`  不是偶然的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `computeValue` is called as part of the main routine and not in response to the subscribers subscribing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015849Z" creationid="pingfangx" creationdate="20190624T015849Z">
        <seg>`computeValue` 作为主程序的一部分被调用，而不是响应订阅者的订阅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `fromIterable` also gives an interesting opportunity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020241Z" creationid="pingfangx" creationdate="20190624T020241Z">
        <seg>`fromIterable` 也提供了一个有趣的机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `immediate` scheduler is not present in 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093540Z" creationid="pingfangx" creationdate="20190618T093540Z">
        <seg>`immediate` 调度器不存在于 2.x 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.Scheduler` abstract base class now supports scheduling tasks directly without the need to create and then destroy a `Worker` (which is often forgotten):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093812Z" creationid="pingfangx" creationdate="20190618T093812Z">
        <seg>`io.reactivex.Scheduler` 抽象基类现在支持直接调度任务，而不需要创建然后销毁 `Worker`(经常被遗忘)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.processors.AsyncProcessor`, `io.reactivex.processors.BehaviorProcessor`, `io.reactivex.processors.PublishProcessor`, `io.reactivex.processors.ReplayProcessor` and `io.reactivex.processors.UnicastProcessor` are backpressure-aware.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062905Z" creationid="pingfangx" creationdate="20190618T062905Z">
        <seg>`io.reactivex.processors.AsyncProcessor`，`io.reactivex.processors.BehaviorProcessor`，`io.reactivex.processors.PublishProcessor`，`io.reactivex.processors.ReplayProcessor` 和 `io.reactivex.processors.UnicastProcessor` 是背压感知的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.subjects.AsyncSubject`, `io.reactivex.subjects.BehaviorSubject`, `io.reactivex.subjects.PublishSubject`, `io.reactivex.subjects.ReplaySubject` and `io.reactivex.subjects.UnicastSubject` in 2.x don't support backpressure (as part of the 2.x `Observable` family).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062846Z" creationid="pingfangx" creationdate="20190618T062846Z">
        <seg>`io.reactivex.subjects.AsyncSubject`，`io.reactivex.subjects.BehaviorSubject`，`io.reactivex.subjects.PublishSubject`，`io.reactivex.subjects.ReplaySubject` 和 `io.reactivex.subjects.UnicastSubject` 在 2.x 中不支持背压(作为 2.x `Observable` 系列的一部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `rx.observables.ConnectableObservable` is now `io.reactivex.observables.ConnectableObservable&lt;T&gt;` and `io.reactivex.flowables.ConnectableFlowable&lt;T&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063659Z" creationid="pingfangx" creationdate="20190618T063659Z">
        <seg>`rx.observables.ConnectableObservable` 现在是 `io.reactivex.observables.ConnectableObservable&lt;T&gt;` 和 `io.reactivex.flowables.ConnectableFlowable&lt;T&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `rx.observables.GroupedObservable` is now `io.reactivex.observables.GroupedObservable&lt;T&gt;` and `io.reactivex.flowables.GroupedFlowable&lt;T&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063807Z" creationid="pingfangx" creationdate="20190618T063807Z">
        <seg>`rx.observables.GroupedObservable` 现在是 `io.reactivex.observables.GroupedObservable&lt;T&gt;` 和 `io.reactivex.flowables.GroupedFlowable&lt;T&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `set()` method disposes the old value and `replace()` method does not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073205Z" creationid="pingfangx" creationdate="20190618T073205Z">
        <seg>`set()` 方法处理旧值，而 'replace()` 方法则不处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `test()` method on `TestObserver` has a `test(boolean cancel)` overload which cancels/disposes the `TestSubscriber`/`TestObserver` before it even gets subscribed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101725Z" creationid="pingfangx" creationdate="20190618T101725Z">
        <seg>`TestObserver` 上的 `test()` 方法有一个 `test(boolean cancel)` 重载，在它被订阅之前取消/释放 `TestSubscriber`/`TestObserver`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above categories for intermediary only consider those acting as participants in the HTTP communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101719Z" creationid="pingfangx" creationdate="20190830T101719Z">
        <seg>上述中间类别仅考虑那些充当 HTTP 通信参与者的类别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above-described check provides no protection against attacks where this source is compromised.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111635Z" creationid="pingfangx" creationdate="20190901T111635Z">
        <seg>上述检查不提供针对源受损的攻击的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The absoluteURI form is REQUIRED when the request is being made to a proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100144Z" creationid="pingfangx" creationdate="20190829T100144Z">
        <seg>在向代理发出请求时，必须使用 absoluteURI 形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021046Z" creationid="pingfangx" creationdate="20190828T021046Z">
        <seg>所采用的确认机制是累积的，因此序列号 X 的确认表明已经接收到所有八位字节但不包括 X。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The action performed by the POST method might not result in a resource that can be identified by a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064356Z" creationid="pingfangx" creationdate="20190830T064356Z">
        <seg>POST 方法执行的操作可能不会生成可由 URI 标识的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual cause is usually the non-backpressured use of `PublishProcessor`, `timer()` or `interval()` or custom operators created via `create()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090210Z" creationid="pingfangx" creationdate="20190621T090210Z">
        <seg>实际原因通常是使用 `PublishProcessor`，`timer()` 或 `interval()` 或通过 `create()` 创建的自定义操作符的非背压使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064254Z" creationid="pingfangx" creationdate="20190830T064254Z">
        <seg>POST 方法执行的实际功能由服务器确定，通常依赖于 Request-URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The age of a response is the time since it was sent by, or successfully validated with, the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T082041Z" creationid="pingfangx" creationdate="20190828T081949Z">
        <seg>响应的年龄是自原始服务器发送或成功验证以来的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The agent acting as the HTTP client should also act as the TLS client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091308Z" creationid="pingfangx" creationdate="20190901T091308Z">
        <seg>充当 HTTP 客户端的代理也应充当 TLS 客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The algorithm for determining the message body length has been clarified to indicate all of the special cases (e.g., driven by methods or status codes) that affect it, and that new protocol elements cannot define such special cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092010Z" creationid="pingfangx" creationdate="20190830T092010Z">
        <seg>已经阐明了用于确定消息体长度的算法以指示影响它的所有特殊情况(例如，由方法或状态代码驱动)，并且新协议元素不能定义这种特殊情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asterisk "*" means that the request does not apply to a particular resource, but to the server itself, and is only allowed when the method used does not necessarily apply to a resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T095940Z" creationid="pingfangx" creationdate="20190829T095940Z">
        <seg>星号“*”表示请求不适用于特定资源，而是适用于服务器本身，并且仅在使用的方法不一定适用于资源时才允许。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asterisk-form of request-target is only used for a server-wide OPTIONS request (Section 4.3.7 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125038Z" creationid="pingfangx" creationdate="20190831T125038Z">
        <seg>请求目标的星号形式仅用于服务器范围的 OPTIONS 请求([RFC7231] 的第 4.3.7 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asterisk-form of the request-target is only allowed with the OPTIONS method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092117Z" creationid="pingfangx" creationdate="20190830T092117Z">
        <seg>请求目标的星号形式仅允许使用 OPTIONS 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The augmented BNF includes the following constructs:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092509Z" creationid="pingfangx" creationdate="20190828T092509Z">
        <seg>增强的 BNF 包括以下结构：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The authority component is preceded by a double slash ("//") and is terminated by the next slash ("/"), question mark ("?"), or number sign ("#") character, or by the end of the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081605Z" creationid="pingfangx" creationdate="20190902T073238Z">
        <seg>权限组件前面有一个双斜杠(“//”)，并由下一个斜杠(“/”)，问号(“?”)或数字符号(“#”)字符终止，或者由 URI 的结束终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The authority form is only used by the CONNECT method (section 9.9).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100917Z" creationid="pingfangx" creationdate="20190829T100908Z">
        <seg>authority 形式仅由 CONNECT 方法使用(第 9.9 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The authority-form of request-target is only used for CONNECT requests (Section 4.3.6 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124903Z" creationid="pingfangx" creationdate="20190831T124903Z">
        <seg>请求目标的权限形式仅用于 CONNECT 请求([RFC7231] 的第 4.3.6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The automatic retry SHOULD NOT be repeated if the second sequence of requests fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152530Z" creationid="pingfangx" creationdate="20190829T152530Z">
        <seg>如果第二个请求序列失败，则不应重复自动重试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The backslash character ("\") MAY be used as a single-character quoting mechanism only within quoted-string and comment constructs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101718Z" creationid="pingfangx" creationdate="20190828T101718Z">
        <seg>反斜杠字符(“\”)只能在带引号的字符串和注释结构中用作单字符引用机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The backslash octet ("\") can be used as a single-octet quoting mechanism within quoted-string and comment constructs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085738Z" creationid="pingfangx" creationdate="20190831T085738Z">
        <seg>反斜杠八位字节(“\”)可以用作引号字符串和注释结构中的单八位字节引用机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bad news is that one should be careful when performing 'organize imports' as it may select the non-backpressured `io.reactivex.Observable` unintended.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053501Z" creationid="pingfangx" creationdate="20190618T053501Z">
        <seg>坏消息是，在执行“组织导入”时应该小心，因为它可能会无意中选择非背压的 `io.reactivex.Observable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base classes can be considered heavy due to the sheer number of static and instance methods on them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103625Z" creationid="pingfangx" creationdate="20190617T103625Z">
        <seg>由于基类的静态和实例方法数量庞大，因此可以认为基类很重。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP does not have any memory of the sequence numbers it last used on a given connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025512Z" creationid="pingfangx" creationdate="20190828T025512Z">
        <seg>但是，如果源 TCP 没有最后在给定连接上使用的序列号的任何内存，则可以取消 TCP 中的基本重复检测和排序算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic unit of HTTP communication, consisting of a structured sequence of octets matching the syntax defined in section 4 and transmitted via the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080919Z" creationid="pingfangx" creationdate="20190828T080919Z">
        <seg>HTTP 通信的基本单元，由与第 4 节中定义的语法匹配并通过连接传输的结构化八位字节序列组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113309Z" creationid="pingfangx" creationdate="20190831T113309Z">
        <seg>协议更改后应用程序级通信的功能和性质完全取决于所选的新协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character "*" preceding an element indicates repetition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093229Z" creationid="pingfangx" creationdate="20190828T093229Z">
        <seg>元素前面的字符“*”表示重复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters slash ("/") and question mark ("?") are allowed to represent data within the fragment identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083911Z" creationid="pingfangx" creationdate="20190902T083911Z">
        <seg>字符斜杠(“/”)和问号(“?”)允许表示片段标识符内的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters slash ("/") and question mark ("?") may represent data within the query component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083214Z" creationid="pingfangx" creationdate="20190902T083214Z">
        <seg>字符斜杠(“/”)和问号(“/”)可以表示查询组件中的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checksum also covers a 96 bit pseudo header conceptually</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110032Z" creationid="pingfangx" creationdate="20190827T110032Z">
        <seg>校验和还在 TCP 首部之前，概念性地涵盖了 96 位伪首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105814Z" creationid="pingfangx" creationdate="20190827T105814Z">
        <seg>校验和字段是首部和文本中所有 16 位字的反码求和的 16 位反码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chunk-size field is a string of hex digits indicating the size of the chunk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143924Z" creationid="pingfangx" creationdate="20190828T143924Z">
        <seg>chunk-size 字段是一个十六进制数字字符串，表示块的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chunked encoding is ended by any chunk whose size is zero, followed by the trailer, which is terminated by an empty line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144002Z" creationid="pingfangx" creationdate="20190828T144002Z">
        <seg>分块编码由任何大小为零的块结束，后跟 trailer，后者由空行终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing entity-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143737Z" creationid="pingfangx" creationdate="20190828T143737Z">
        <seg>分块编码修改消息正文，以便将其作为一系列块进行传输，每个块都有自己的大小指示器，后跟一个包含实体首部字段的可选尾部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class-based `RxJavaObservableHook` and friends are now gone and `RxJavaHooks` functionality is incorporated into `RxJavaPlugins`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085830Z" creationid="pingfangx" creationdate="20190618T085830Z">
        <seg>基于类 `RxJavaObservableHook` 和朋友现在已经不在了，`RxJavaHooks` 函数被整合到 `RxJavaPlugins` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classic case of the need for backpressure is when the producer is a hot source:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T071555Z" creationid="pingfangx" creationdate="20190621T071555Z">
        <seg>需要背压的经典案例是当生产者是热源时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T073646Z" creationid="pingfangx" creationdate="20190830T073646Z">
        <seg>即使从源服务器返回的状态代码指示操作已成功完成，也无法保证客户端已执行该操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client is not required to examine or display the Reason-Phrase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105530Z" creationid="pingfangx" creationdate="20190829T105530Z">
        <seg>客户端不需要检查或显示 Reason-Phrase。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client may then initiate the first HTTP request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091456Z" creationid="pingfangx" creationdate="20190901T091456Z">
        <seg>然后，客户端可以发起第一个 HTTP 请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client which initiates a request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081304Z" creationid="pingfangx" creationdate="20190828T081304Z">
        <seg>发起请求的客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102323Z" creationid="pingfangx" creationdate="20190831T102323Z">
        <seg>close-delimiting 功能主要用于向后兼容 HTTP/1.0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The comma (",") reserved character is often used for similar purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082913Z" creationid="pingfangx" creationdate="20190902T082913Z">
        <seg>逗号(“,”)保留字符通常用于类似目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete URI syntax is collected in Appendix A.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064825Z" creationid="pingfangx" creationdate="20190902T064825Z">
        <seg>完整的 URI 语法收集在附录 A 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete list of status codes is maintained by IANA.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144741Z" creationid="pingfangx" creationdate="20190831T144741Z">
        <seg>完整的状态代码列表由 IANA 维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete set of tokens is defined by the IANA Character Set registry [19].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115130Z" creationid="pingfangx" creationdate="20190828T115130Z">
        <seg>完整的标记集由 IANA 字符集注册表 [19] 定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The components of the effective request URI, once determined as above, can be combined into absolute-URI form by concatenating the scheme, "://", authority, and combined path and query component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131857Z" creationid="pingfangx" creationdate="20190831T131409Z">
        <seg>一旦如上确定，有效请求 URI 的组件可以通过连接方案“://”，权限以及组合 path 和 query 组件而组合成绝对 URI 形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062519Z" creationid="pingfangx" creationdate="20190830T062519Z">
        <seg>条件 GET 方法旨在减少不必要的网络使用，通过允许刷新缓存的实体而不需要多个请求或传输客户端已经拥有的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection options do not always correspond to a header field present in the message, since a connection-specific header field might not be needed if there are no parameters associated with a connection option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110750Z" creationid="pingfangx" creationdate="20190831T110750Z">
        <seg>连接选项并不总是对应于消息中存在的首部字段，因为如果没有与连接选项关联的参数，则可能不需要特定于连接的首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection remains in the CLOSED state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060702Z" creationid="pingfangx" creationdate="20190828T060702Z">
        <seg>连接仍处于 CLOSED 状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection remains in the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061030Z" creationid="pingfangx" creationdate="20190828T061030Z">
        <seg>连接保持相同状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The content of the header beyond the End-of-Option option must be header padding (i.e., zero).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110945Z" creationid="pingfangx" creationdate="20190827T110945Z">
        <seg>超出选项结束选项的首部的内容必须是首部填充(即，零)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents within a given field value are not parsed until a later stage of message interpretation (usually after the message's entire header section has been processed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083301Z" creationid="pingfangx" creationdate="20190831T083301Z">
        <seg>直到消息解释的后期阶段(通常在处理消息的整个首部部分之后)，才解析给定字段值内的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding response routing follows the same connection chain back to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123048Z" creationid="pingfangx" creationdate="20190831T123048Z">
        <seg>相应的响应路由遵循相同的连接链返回客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data type of the representation data is determined via the header fields Content-Type and Content-Encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025130Z" creationid="pingfangx" creationdate="20190902T025130Z">
        <seg>表示数据的数据类型通过首部字段 Content-Type 和 Content-Encoding 确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dataflows in RxJava consist of a source, zero or more intermediate steps followed by a data consumer or combinator step (where the step is responsible to consume the dataflow by some means):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070925Z" creationid="pingfangx" creationdate="20190617T070735Z">
        <seg>RxJava 中的数据流由源，零个或多个中间步骤，后跟数据消费者或组合器步骤(其中步骤负责通过某种方式消费数据流)组成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default (identity) encoding; the use of no transformation whatsoever.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141228Z" creationid="pingfangx" creationdate="20190828T141228Z">
        <seg>默认(标识)编码；没有任何转变的使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default port is TCP 80 [19], but other ports can be used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092031Z" creationid="pingfangx" creationdate="20190828T092031Z">
        <seg>默认端口是 TCP 80 [19]，但可以使用其他端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition of how they are used and compared as cache validators is in section 13.3.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155647Z" creationid="pingfangx" creationdate="20190828T155647Z">
        <seg>它们如何被使用和比较为缓存验证器的定义见第 13.3.3 节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of "URI-reference", "absolute-URI", "relative-part", "scheme", "authority", "port", "host", "path-abempty", "segment", "query", and "fragment" are adopted from the URI generic syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104824Z" creationid="pingfangx" creationdate="20190830T104824Z">
        <seg>从 URI 通用语法中采用 "URI-reference", "absolute-URI", "relative-part", "scheme", "authority", "port", "host", "path-abempty", "segment", "query" 和 "fragment" 的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The delegated nature of registered names and IP addresses creates a federated namespace, based on control over the indicated host and port, whether or not an HTTP server is present.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044419Z" creationid="pingfangx" creationdate="20190831T044419Z">
        <seg>注册名称和 IP 地址的委派性质基于对指示的主机和端口的控制，无论是否存在 HTTP 服务器，都会创建联合命名空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The destination port number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104937Z" creationid="pingfangx" creationdate="20190827T104937Z">
        <seg>目的端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation of each operator has a description about its backpressure behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080246Z" creationid="pingfangx" creationdate="20190621T080246Z">
        <seg>每个操作符的文档都有关于其背压行为的描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2**32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have "drained" from the internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025040Z" creationid="pingfangx" creationdate="20190828T025040Z">
        <seg>TCP 协议中的重复检测和排序算法依赖于报文段数据与序列空间的唯一绑定，以使序列号在绑定到那些序列号的报文段数据之前不会循环通过所有 2 ** 32 值并且接收方承认并且所有报文段的重复副本已从互联网“耗尽”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090341Z" creationid="pingfangx" creationdate="20190828T090341Z">
        <seg>缓存的效果是，如果链中的一个参与者具有适用于该请求的缓存响应，则缩短请求/响应链。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The eight encoded pieces are given most-significant first, separated by colon characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074734Z" creationid="pingfangx" creationdate="20190902T074734Z">
        <seg>八个编码的片段首先被赋予最重要的，由冒号字符分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements are separated by SP characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T093624Z" creationid="pingfangx" creationdate="20190829T093624Z">
        <seg>元素由 SP 字符分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The encoding format produced by the common UNIX file compression program "compress".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140956Z" creationid="pingfangx" creationdate="20190828T140956Z">
        <seg>通用 UNIX 文件压缩程序“compress”产生的编码格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end-of-line marker within an entity-body is defined by its associated media type, as described in section 3.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T095602Z" creationid="pingfangx" creationdate="20190828T095602Z">
        <seg>实体主体中的行尾标记由其关联的媒体类型定义，如 3.7 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entity-body (if any) sent with an HTTP request or response is in a format and encoding defined by the entity-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T120749Z" creationid="pingfangx" creationdate="20190829T120749Z">
        <seg>使用 HTTP 发送的请求或响应实体主体(如果有)采用实体首部字段定义的格式和编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entity-body is obtained from the message-body by decoding any Transfer-Encoding that might have been applied to ensure safe and proper transfer of the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121016Z" creationid="pingfangx" creationdate="20190829T121016Z">
        <seg>通过解码可能已经应用的确保安全和正确的消息传输的任何 Transfer-Encoding，从消息体获得实体主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entity-length of a message is the length of the message-body before any transfer-codings have been applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121500Z" creationid="pingfangx" creationdate="20190829T121500Z">
        <seg>消息的实体长度是在应用任何传输编码之前消息体的长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101625Z" creationid="pingfangx" creationdate="20190829T101625Z">
        <seg>通过检查 Request-URI 和 Host 首部字段来确定 Internet 请求标识的确切资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception is still there but this time, the operator that can't signal more `onNext` will signal this exception instead (allowing better identification of who is not properly backpressured).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073650Z" creationid="pingfangx" creationdate="20190618T073650Z">
        <seg>例外情况仍然存在，但这一次，无法发出更多 `onNext` 信号的操作符将发出异常信号(允许更好地识别谁没有正确背压)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expectation to support HTTP/0.9 requests has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092400Z" creationid="pingfangx" creationdate="20190830T092400Z">
        <seg>已删除支持 HTTP/0.9 请求的期望。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extension-header mechanism allows additional entity-header fields to be defined without changing the protocol, but these fields cannot be assumed to be recognizable by the recipient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T120547Z" creationid="pingfangx" creationdate="20190829T120547Z">
        <seg>扩展首部机制允许在不更改协议的情况下定义其他实体首部字段，但不能假定这些字段可由接收者识别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The field value MAY be preceded by any amount of LWS, though a single SP is preferred.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T082935Z" creationid="pingfangx" creationdate="20190829T080918Z">
        <seg>字段值前面可以有任意数量的 LWS，但最好是只有单个 SP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The field value does not include any leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field value or after the last non-whitespace octet of the field value ought to be excluded by parsers when extracting the field value from a header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083731Z" creationid="pingfangx" creationdate="20190831T083731Z">
        <seg>字段值不包括任何前导或尾随空格：在字段值的第一个非空白八位字节之前或在字段值的最后一个非空白八位字节之后出现的 OWS 应该在从首部字段中提取字段值时被解析器排除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The field-content does not include any leading or trailing LWS: linear white space occurring before the first non-whitespace character of the field-value or after the last non-whitespace character of the field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T081231Z" creationid="pingfangx" creationdate="20190829T081231Z">
        <seg>字段内容不包括任何前导或尾随 LWS：线性空白区域出现在字段值的第一个非空白字符之前或字段值的最后一个非空白字符之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The field-name token labels the corresponding field-value as having the semantics defined by that header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081844Z" creationid="pingfangx" creationdate="20190831T081844Z">
        <seg>字段名标记将相应的字段值标记为具有由该首部字段定义的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure above shows three intermediaries (A, B, and C) between the user agent and origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090050Z" creationid="pingfangx" creationdate="20190828T090050Z">
        <seg>上图显示了用户代理和源服务器之间的三个中介(A，B 和 C)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figures should be interpreted in the following way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033919Z" creationid="pingfangx" creationdate="20190828T033900Z">
        <seg>该图应按以下方式解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final callback gets invoked when the downstream unsubscribes (closing the inputstream) or when the previous callback called the terminal methods; it allows freeing up resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021408Z" creationid="pingfangx" creationdate="20190624T021408Z">
        <seg>当下游取消​​订阅(关闭输入流)或前一个回调调用终端方法时，将调用最终的回调；它允许释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final operator keeps only the latest value and practically overwrites older, undelivered values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015125Z" creationid="pingfangx" creationdate="20190624T015125Z">
        <seg>最后一个操作符只保留最新的值，实际上覆盖了旧的、未传递的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final recipient is either the origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074142Z" creationid="pingfangx" creationdate="20190830T074142Z">
        <seg>最终接收者是原始服务器或第一个代理或网关，其在请求中接收 Max-Forwards 值为零(0)(请参阅第 14.31 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 5.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144003Z" creationid="pingfangx" creationdate="20190831T144003Z">
        <seg>最终接收者是源服务器或第一个在请求中接收 Max-Forwards 值为零(0)的服务器(第 5.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final recipient of the request SHOULD exclude any request header fields that are likely to contain sensitive data when that recipient generates the response body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144127Z" creationid="pingfangx" creationdate="20190831T144127Z">
        <seg>请求的最终接收者应该排除在接收者生成响应正文时可能包含敏感数据的任何请求首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074042Z" creationid="pingfangx" creationdate="20190830T074042Z">
        <seg>请求的最终接收者应该将收到的消息反映回客户端作为 200(OK)响应的实体主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a Content-Type of "message/http" (Section 8.3.1 of [RFC7230]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143946Z" creationid="pingfangx" creationdate="20190831T143946Z">
        <seg>请求的最终接收者应将接收到的消息（不包括下面描述的某些字段）作为内容类型为“message/http”的 200（OK）响应的消息正文（见 [RFC7230] 第 8.3.1 节）反射回客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first callbacks allows one to create a per-subscriber state, such as the `FileInputStream` in the example; the file will be opened independently to each individual subscriber.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021149Z" creationid="pingfangx" creationdate="20190624T021149Z">
        <seg>第一个回调允许创建一个每个订阅者独立的状态，例如示例中的 `FileInputStream`;该文件将为每个订阅者独立打开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first data that a TLS server (and hence an HTTP/TLS server) expects to receive is the ClientHello.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103233Z" creationid="pingfangx" creationdate="20190901T103233Z">
        <seg>TLS 服务器(以及 HTTP/TLS 服务器)期望接收的第一个数据是 ClientHello。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first data that an HTTP server expects to receive from the client is the Request-Line production.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103156Z" creationid="pingfangx" creationdate="20190901T103156Z">
        <seg>HTTP 服务器期望从客户端接收的第一个数据是请求行产品。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first digit ("major version") indicates the HTTP messaging syntax, whereas the second digit ("minor version") indicates the highest minor version within that major version to which the sender is conformant and able to understand for future communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103257Z" creationid="pingfangx" creationdate="20190830T103257Z">
        <seg>第一个数字(“主要版本”)表示 HTTP 消息传递语法，而第二个数字(“次要版本”)表示该主要版本中的最高次要版本，发送者符合并且能够理解以用于将来的通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first digit of the Status-Code defines the class of response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105613Z" creationid="pingfangx" creationdate="20190829T105613Z">
        <seg>Status-Code 的第一个数字定义了响应类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first digit of the status-code defines the class of response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144444Z" creationid="pingfangx" creationdate="20190831T144444Z">
        <seg>状态代码的第一个数字定义了响应类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first format is preferred as an Internet standard and represents a fixed-length subset of that defined by RFC 1123 [8] (an update to RFC 822 [9]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113438Z" creationid="pingfangx" creationdate="20190828T113438Z">
        <seg>第一种格式是互联网标准的首选格式，它代表 RFC 1123 [8](RFC 822 [9] 的更新)定义的固定长度子集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first line of a Response message is the Status-Line, consisting of the protocol version followed by a numeric status code and its associated textual phrase, with each element separated by SP characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105153Z" creationid="pingfangx" creationdate="20190829T105118Z">
        <seg>响应消息的第一行是状态行(Status-Line)，由协议版本后跟数字状态代码及其关联的文本短语组成，每个元素由 SP 字符分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, another space, a possibly empty textual phrase describing the status code, and ending with CRLF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081057Z" creationid="pingfangx" creationdate="20190831T081057Z">
        <seg>响应消息的第一行是状态行，包括协议版本，空格(SP)，状态代码，另一个空格，可能为空的描述状态代码的文本短语，然后以 CRLF 结尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022401Z" creationid="pingfangx" creationdate="20190828T022401Z">
        <seg>该测试的第一部分检查该报文段的开头是否落入窗口，测试的第二部分检查该报文段的末端是否落入窗口；如果报文段通过测试的任何一部分，则它包含窗口中的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first step is to include RxJava 2 into your project, for example, as a Gradle compile dependency:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065845Z" creationid="pingfangx" creationdate="20190617T065845Z">
        <seg>第一步是将 RxJava 2 包含到您的项目中，例如，作为 Gradle 编译依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first typical case for its use when one wants to interact with a push-based source, such as GUI events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022214Z" creationid="pingfangx" creationdate="20190624T022214Z">
        <seg>当人们想要与基于推的源（例如 GUI 事件）交互时使用的第一个典型案例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first version of HTTP, referred to as HTTP/0.9, was a simple protocol for raw data transfer across the Internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075414Z" creationid="pingfangx" creationdate="20190828T075414Z">
        <seg>HTTP 的第一个版本，称为 HTTP/0.9，是一个简单的协议，用于通过 Internet 进行原始数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are two example URIs and their component parts:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072316Z" creationid="pingfangx" creationdate="20190902T072316Z">
        <seg>以下是两个示例 URI 及其组成部分：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following comparisons are needed to process the acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021803Z" creationid="pingfangx" creationdate="20190828T021803Z">
        <seg>处理确认需要进行以下比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094903Z" creationid="pingfangx" creationdate="20190830T094903Z">
        <seg>以下核心规则通过引用包含在内，如 [RFC5234]，附录 B.1 中所定义的：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控制），DIGIT（十进制 0-9），DQUOTE（双引号），HEXDIG（十六进制 0-9/A-F/a-f），HTAB（水平制表符），LF（换行），OCTET（任何 8 位数据序列），SP（空格）和 VCHAR（任何可见的 [USASCII] 字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following diagrams may help to relate some of these variables to the sequence space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111858Z" creationid="pingfangx" creationdate="20190827T111858Z">
        <seg>以下图表可能有助于将这些变量中的一些与序列空间相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example URIs illustrate several URI schemes and variations in their common syntax components:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061535Z" creationid="pingfangx" creationdate="20190902T061535Z">
        <seg>以下示例 URI 说明了几种 URI 方案及其常见语法组件的变体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates a typical message exchange for a GET request (Section 4.3.1 of [RFC7231]) on the URI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100352Z" creationid="pingfangx" creationdate="20190830T100352Z">
        <seg>以下示例说明了 URI 上 GET 请求([RFC7231] 的第 4.3.1 节)的典型消息交换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates a typical message exchange for a GET request (Section 4.3.1 of [RFC7231]) on the URI "http://www.example.com/hello.txt":</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T144733Z" creationid="pingfangx" creationdate="20190830T144733Z">
        <seg>以下示例说明 URI“http://www.example.com/hello.txt”上的 GET 请求([RFC7231] 的第 4.3.1 节)的典型消息交换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example schedules &lt;c2&gt;someAction&lt;/c2&gt; to be performed on &lt;c3&gt;someScheduler&lt;/c3&gt; after 500ms have passed according to that Scheduler’s clock:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092445Z" creationid="pingfangx" creationdate="20190620T092445Z">
        <seg>以下示例根据调度器的时钟调度 500ms 后，在 &lt;c3&gt;someScheduler&lt;/c3&gt; 上调度 &lt;c2&gt;someAction&lt;/c2&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example schedules &lt;c2&gt;someAction&lt;/c2&gt; to be performed on &lt;c3&gt;someScheduler&lt;/c3&gt; after 500ms have passed, and then every 250ms thereafter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092640Z" creationid="pingfangx" creationdate="20190620T092640Z">
        <seg>以下示例调度在经过 500ms 后在 &lt;c3&gt;someScheduler&lt;/c3&gt; 上执行 &lt;c2&gt;someAction&lt;/c2&gt;，然后每隔 250ms 执行一次：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses &lt;a0&gt;the &lt;c1&gt;schedule&lt;/c1&gt; method&lt;/a0&gt; of &lt;a2&gt;the &lt;c3&gt;Scheduler.Worker&lt;/c3&gt; class&lt;/a2&gt; to schedule work on the &lt;c4&gt;newThread&lt;/c4&gt; Scheduler:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092100Z" creationid="pingfangx" creationdate="20190620T092100Z">
        <seg>以下示例使用&lt;a2&gt;&lt;c3&gt;Scheduler.Worker&lt;/c3&gt; 类&lt;/a2&gt; 的 &lt;a0&gt;&lt;c1&gt;schedule&lt;/c1&gt; 方法&lt;/a0&gt; 来安排 &lt;c4&gt;newThread&lt;/c4&gt; 调度器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following external libraries can work with RxJava:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113641Z" creationid="pingfangx" creationdate="20190617T113641Z">
        <seg>以下外部库可以与 RxJava 一起使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following header fields convey representation metadata:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025015Z" creationid="pingfangx" creationdate="20190902T025015Z">
        <seg>以下首部字段传达表示元数据：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request that has not been cached by UA or A.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102257Z" creationid="pingfangx" creationdate="20190830T102257Z">
        <seg>下面说明了当 B 具有来自 O(通过 C)的早期响应的缓存副本时的结果链，该响应是未被 UA 或 A 缓存的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T091032Z" creationid="pingfangx" creationdate="20190828T090506Z">
        <seg>下面说明了当 B 具有来自 O(通过 C)的早期响应的缓存副本时的结果链，该响应是未被 UA 或 A 缓存的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a hypothetical example sent by a client:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113242Z" creationid="pingfangx" creationdate="20190831T113242Z">
        <seg>以下是客户发送的假设示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is an example response to the above hypothetical request:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113516Z" creationid="pingfangx" creationdate="20190831T113516Z">
        <seg>以下是对上述假设请求的示例响应：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following matrix shows the available conversion options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T093040Z" creationid="pingfangx" creationdate="20190617T093040Z">
        <seg>以下矩阵显示了可用的转换选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following rules are used throughout this specification to describe basic parsing constructs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094455Z" creationid="pingfangx" creationdate="20190828T094455Z">
        <seg>在整个说明书中使用以下规则来描述基本的解析构造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following sections of this page will give marble diagrams that explain these operators schematically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074923Z" creationid="pingfangx" creationdate="20190620T074923Z">
        <seg>本页的以下部分将给出 marble 图，可以示意性地解释这些操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following subsections list each base reactive type and the difference between 1.x and 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111012Z" creationid="pingfangx" creationdate="20190618T111012Z">
        <seg>以下小节列出了每个基本响应类型以及 1.x 和 2.x 之间的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090950Z" creationid="pingfangx" creationdate="20190620T090950Z">
        <seg>下表显示了在 RxGroovy 中通过这些方法可用的调度器的种类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091905Z" creationid="pingfangx" creationdate="20190620T091905Z">
        <seg>下表显示了在 RxJava 中通过这些方法可用的 Scheduler 的种类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042201Z" creationid="pingfangx" creationdate="20190830T042201Z">
        <seg>此规范未定义此类主体的格式，但可能由未来的 HTTP 扩展定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The four options for Request-URI are dependent on the nature of the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T095817Z" creationid="pingfangx" creationdate="20190829T095817Z">
        <seg>Request-URI 的四个选项取决于请求的性质。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fragment identifier component of a URI allows indirect identification of a secondary resource by reference to a primary resource and additional identifying information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083433Z" creationid="pingfangx" creationdate="20190902T083433Z">
        <seg>URI 的片段标识符组件允许通过引用主要资源和附加标识信息来间接标识辅助资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fragment's format and resolution is therefore dependent on the media type [RFC2046] of a potentially retrieved representation, even though such a retrieval is only performed if the URI is dereferenced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083620Z" creationid="pingfangx" creationdate="20190902T083620Z">
        <seg>因此，片段的格式和解析取决于可能检索的表示的媒体类型 [RFC2046]，即使仅在取消引用 URI 时也执行此类检索。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The full form is "&lt;n&gt;#&lt;m&gt;element" indicating at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by one or more commas (",") and OPTIONAL linear white space (LWS).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093858Z" creationid="pingfangx" creationdate="20190828T093822Z">
        <seg>完整形式是“&lt;n&gt;#&lt;m&gt;element”，表示最少 &lt;n&gt; 和最多 &lt;m&gt; 个元素，每个元素由一个或多个逗号(“,”)和可选线性白色空间(LWS)分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The full form is "&lt;n&gt;*&lt;m&gt;element" indicating at least &lt;n&gt; and at most</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093322Z" creationid="pingfangx" creationdate="20190828T093322Z">
        <seg>完整形式是“&lt;n&gt;*&lt;m&gt;element”，表示至少 &lt;n&gt; 和至多</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T065104Z" creationid="pingfangx" creationdate="20190830T065104Z">
        <seg>POST 和 PUT 请求之间的根本区别体现在 Request-URI 的不同含义上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023337Z" creationid="pingfangx" creationdate="20190828T023337Z">
        <seg>生成器绑定到(可能是虚构的)32 位时钟，其低位比特大约每 4 微秒递增一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072059Z" creationid="pingfangx" creationdate="20190902T072059Z">
        <seg>通用 URI 语法由分层的组件序列组成，称为方案(scheme)，权限(authority)，路径(path)，查询(query)和片段(fragment)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic syntax provides a common means for distinguishing an authority based on a registered name or server address, along with optional port and user information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072957Z" creationid="pingfangx" creationdate="20190902T072957Z">
        <seg>通用语法提供了用于基于注册名称或服务器地址，以及可选的端口和用户信息来区分权限的常用手段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic syntax uses the slash ("/"), question mark ("?"), and number sign ("#") characters to delimit components that are significant to the generic parser's hierarchical interpretation of an identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064657Z" creationid="pingfangx" creationdate="20190902T064657Z">
        <seg>通用语法使用斜杠(“/”)，问号(“?”)和数字符号(“#”)来划分对于通用解析器的标识符层次解释很重要的组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal of HTTP/1.1 is to support the wide diversity of configurations already deployed while introducing protocol constructs that meet the needs of those who build web applications that require high reliability and, failing that, at least reliable indications of failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092022Z" creationid="pingfangx" creationdate="20190828T092022Z">
        <seg>HTTP/1.1 的目标是支持已经部署的各种配置，同时引入协议构造，以满足那些构建需要高可靠性的 Web 应用程序的需求，并且失败，至少可靠的失败指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The good news is that operator names remain (mostly) the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053420Z" creationid="pingfangx" creationdate="20190618T053420Z">
        <seg>好消息是操作符名称(大多数)保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grammar described by this specification is word-based.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094239Z" creationid="pingfangx" creationdate="20190828T094239Z">
        <seg>本说明书描述的语法是基于单词的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The heuristics noted above will change over time, particularly when a new URI scheme becomes popular, and are often incorrect when used out of context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090521Z" creationid="pingfangx" creationdate="20190902T090521Z">
        <seg>上面提到的启发式方法将随着时间的推移而改变，特别是当新的 URI 方案变得流行时，并且当在上下文之外使用时通常是不正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hierarchical path component and optional query component serve as an identifier for a potential target resource within that origin server's name space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044124Z" creationid="pingfangx" creationdate="20190831T044124Z">
        <seg>层次的 path 组件和可选的 query 组件用作该源服务器的名称空间内的潜在目标资源的标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The host subcomponent is case-insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073811Z" creationid="pingfangx" creationdate="20190902T073811Z">
        <seg>主机子组件不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The host subcomponent of authority is identified by an IP literal encapsulated within square brackets, an IPv4 address in dotted-decimal form, or a registered name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073808Z" creationid="pingfangx" creationdate="20190902T073808Z">
        <seg>权限的主机子组件由封装在方括号内的 IP 文字，点分十进制形式的 IPv4 地址或注册名称标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identified secondary resource may be some portion or subset of the primary resource, some view on representations of the primary resource, or some other resource defined or described by those representations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083455Z" creationid="pingfangx" creationdate="20190902T083455Z">
        <seg>所标识的辅助资源可以是主要资源的一些部分或子集，关于主要资源的表示的一些视图，或者由那些表示定义或描述的一些其他资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation diversity of HTTP means that not all user agents can make interactive suggestions to their user or provide adequate warning for security or privacy concerns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100719Z" creationid="pingfangx" creationdate="20190830T100719Z">
        <seg>HTTP 的实现多样性意味着并非所有用户代理都可以向其用户提供交互式建议，或者为安全性或隐私问题提供足够的警告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T032437Z" creationid="pingfangx" creationdate="20190830T032437Z">
        <seg>这里的重要区别是，用户没有要求副作用，因此不能追究他们的责任。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The individual values of the numeric status codes defined for HTTP/1.1, and an example set of corresponding Reason-Phrase's, are presented below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105817Z" creationid="pingfangx" creationdate="20190829T105817Z">
        <seg>为 HTTP/1.1 定义的数字状态代码的各个值以及相应的 Reason-Phrase 的示例集如下所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The information transferred as the payload of a request or response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190828T081012Z">
        <seg>作为请求或响应的有效载荷传输的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial send sequence number (ISS) is chosen by the data sending TCP, and the initial receive sequence number (IRS) is learned during the connection establishing procedure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023455Z" creationid="pingfangx" creationdate="20190828T023455Z">
        <seg>初始发送序列号(ISS)由数据发送 TCP 选择，并且在连接建立过程期间学习初始接收序列号(IRS)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial sequence number chosen is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025710Z" creationid="pingfangx" creationdate="20190828T025710Z">
        <seg>选择的初始序列号是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intention of HTTP's versioning design is that the major number will only be incremented if an incompatible message syntax is introduced, and that the minor number will only be incremented when changes made to the protocol have the effect of adding to the message semantics or implying additional capabilities of the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104017Z" creationid="pingfangx" creationdate="20190830T104017Z">
        <seg>HTTP 的版本控制设计的目的是，只有在引入不兼容的消息语法时才会增加主要编号，并且只有当对协议进行的更改具有添加到消息语义或暗示附加的发送者的能力时，次要编号才会增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpretation of a header field does not change between minor versions of the same major HTTP version, though the default behavior of a recipient in the absence of such a field can change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103417Z" creationid="pingfangx" creationdate="20190830T103417Z">
        <seg>首部字段的解释在相同主要 HTTP 版本的次要版本之间不会改变，但是在没有这样的字段的情况下接收者的默认行为可以改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094522Z" creationid="pingfangx" creationdate="20190830T094522Z">
        <seg>本文件中的关键词 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", 和 "OPTIONAL" 按照 [RFC2119] 中的描述进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last two digits do not have any categorization role.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105619Z" creationid="pingfangx" creationdate="20190829T105619Z">
        <seg>最后两位数字没有任何分类角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter technique can exacerbate network congestion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024206Z" creationid="pingfangx" creationdate="20190830T024206Z">
        <seg>后一种技术可能会加剧网络拥塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of a message body is determined by one of the following (in order of precedence):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T101221Z" creationid="pingfangx" creationdate="20190831T101221Z">
        <seg>消息主体的长度由以下之一确定(按优先顺序排列)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of time between the generation of a response and its expiration time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081959Z" creationid="pingfangx" creationdate="20190828T081959Z">
        <seg>生成响应与其到期时间之间的时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The limit of two connections per server has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092200Z" creationid="pingfangx" creationdate="20190830T092200Z">
        <seg>已删除每个服务器的两个连接的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list of methods allowed by a resource can be specified in an Allow header field (section 14.7).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094318Z" creationid="pingfangx" creationdate="20190829T094318Z">
        <seg>可以在 Allow 首部字段中指定资源允许的方法列表(第 14.7 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main issue with backpressure is that many hot sources, such as UI events, can't be reasonably backpressured and cause unexpected `MissingBackpressureException` (i.e., beginners don't expect them).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053209Z" creationid="pingfangx" creationdate="20190618T053209Z">
        <seg>背压的主要问题是许多热源，例如 UI 事件，不能合理地背压并导致意外的 `MissingBackpressureException`(即，初学者不期望它们)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main purpose is to avoid the tracking overhead of the `Worker`s for typically one-shot tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093953Z" creationid="pingfangx" creationdate="20190618T093953Z">
        <seg>主要目的是避免通常一次性任务的 `Worker` 的跟踪开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maintenance of a TCP connection requires the remembering of several variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111259Z" creationid="pingfangx" creationdate="20190827T111259Z">
        <seg>维护 TCP 连接需要记住几个变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110019Z" creationid="pingfangx" creationdate="20190831T110019Z">
        <seg>HTTP 请求和响应结构到底层传输协议的数据单元的映射超出了本规范的范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of the "deflate" content coding has been clarified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092055Z" creationid="pingfangx" creationdate="20190830T092055Z">
        <seg>“deflate”内容编码的含义已经阐明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism for selecting the appropriate representation when servicing a request, as described in section 12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081208Z" creationid="pingfangx" creationdate="20190828T081208Z">
        <seg>在服务请求时选择适当表示的机制，如第 12 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The media type registration process is outlined in RFC 1590 [17].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T150136Z" creationid="pingfangx" creationdate="20190828T150136Z">
        <seg>RFC 1590 [17] 概述了媒体类型注册过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message body (if any) of an HTTP message is used to carry the payload body of that request or response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T085935Z">
        <seg>HTTP 消息的消息体(如果有的话)用于携带该请求或响应的有效载荷主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message body is identical to the payload body unless a transfer coding has been applied, as described in Section 3.3.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T085953Z">
        <seg>除非已应用传输编码，否则消息主体与有效载荷主体相同，如第 3.3.1 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message body is itself a protocol element and MUST therefore use only CRLF to represent line breaks between body-parts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152331Z" creationid="pingfangx" creationdate="20190828T152331Z">
        <seg>消息体本身就是一个协议元素，因此必须只使用 CRLF 来表示正文部分之间的换行符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T080751Z" creationid="pingfangx" creationdate="20190829T083726Z">
        <seg>HTTP 消息的消息主体(如果有的话)用于携带与请求或响应相关联的实体主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message-body differs from the entity-body only when a transfer-coding has been applied, as indicated by the Transfer-Encoding header field (section 14.41).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084114Z" creationid="pingfangx" creationdate="20190829T084114Z">
        <seg>只有当应用了传输编码时，消息主体才与实体主体不同，如 Transfer-Encoding 首部字段所示(第 14.41 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063426Z" creationid="pingfangx" creationdate="20190830T063426Z">
        <seg>响应 HEAD 请求的 HTTP 首部中包含的元信息应该与响应 GET 请求时发送的信息相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method is case-sensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094049Z" creationid="pingfangx" creationdate="20190829T094049Z">
        <seg>该方法区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method that returns the scheduler's own notion of current time, `now()` has been changed to accept a `TimeUnit` to indicate the unit of measure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094029Z" creationid="pingfangx" creationdate="20190618T094029Z">
        <seg>返回调度器自己的当前时间概念 `now()` 的方法已被更改为接受 `TimeUnit` 来指示度量单位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method token indicates the request method to be performed on the target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070454Z" creationid="pingfangx" creationdate="20190831T070454Z">
        <seg>方法标记指示要对目标资源执行的请求方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133527Z" creationid="pingfangx" creationdate="20190831T133527Z">
        <seg>方法标记区分大小写，因为它可能用作具有区分大小写方法名称的基于对象的系统的网关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods GET and HEAD MUST be supported by all general-purpose servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094500Z" creationid="pingfangx" creationdate="20190829T094500Z">
        <seg>所有通用服务器都必须支持 GET 和 HEAD 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods GET, HEAD, PUT and DELETE share this property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T040521Z" creationid="pingfangx" creationdate="20190830T040521Z">
        <seg>方法 GET，HEAD，PUT 和 DELETE 共享此属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods have a default implementation that reuses `createWorker` properly but can be overridden with more efficient implementations if necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094015Z" creationid="pingfangx" creationdate="20190618T094015Z">
        <seg>这些方法有一个默认实现，可以正确地重用 `createWorker`，但如果需要可以用更高效的实现覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minor version advertises the sender's communication capabilities even when the sender is only using a backwards-compatible subset of the protocol, thereby letting the recipient know that more advanced features can be used in response (by servers) or in future requests (by clients).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190830T103322Z">
        <seg>即使仅使用协议的向后兼容子集，次要版本也会通告发送者的通信功能，从而让接收者知道可以使用更高级的功能(通过服务器)或将来的请求(通过客户端)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most basic backpressure aware source is created via `just`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015628Z" creationid="pingfangx" creationdate="20190624T015628Z">
        <seg>最基本的背压感知源是通过 `just` 创建的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most common form of Request-URI is that used to identify a resource on an origin server or gateway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100929Z" creationid="pingfangx" creationdate="20190829T100929Z">
        <seg>Request-URI 的最常见形式是用于标识源服务器或网关上的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most common form of request-target is the origin-form.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123845Z" creationid="pingfangx" creationdate="20190831T123845Z">
        <seg>最常见的请求目标形式是原始形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most common name registry mechanism is the Domain Name System (DNS).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075216Z" creationid="pingfangx" creationdate="20190902T075216Z">
        <seg>最常见的名称注册机制是域名系统(DNS)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most frequent examples of same-document references are relative references that are empty or include only the number sign ("#") separator followed by a fragment identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085736Z" creationid="pingfangx" creationdate="20190902T085736Z">
        <seg>相同文档引用的最常见示例是相对引用，它们是空的或仅包含数字符号(“#”)分隔符，后跟片段标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most typical scenario is to given a value, invoke another service, await and continue with its result:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083633Z" creationid="pingfangx" creationdate="20190617T083633Z">
        <seg>最典型的情况是给出一个值，调用另一个服务，等待其结果并继续：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a rule is simply the name itself (without any enclosing "&lt;" and "&gt;") and is separated from its definition by the equal "=" character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092612Z" creationid="pingfangx" creationdate="20190828T092612Z">
        <seg>规则的名称只是名称本身(没有任何括号“&lt;”和“&gt;”)，并且通过等号“=”字符与其定义分开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name space of language tags is administered by the IANA.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154911Z" creationid="pingfangx" creationdate="20190828T154911Z">
        <seg>语言标签的名称空间由 IANA 管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new `safeSubscribe` method was introduced to explicitly add the safety wrapper around a consumer type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054140Z" creationid="pingfangx" creationdate="20190619T054140Z">
        <seg>引入了新的 `safeSubscribe` 方法，以明确地在消费者类型周围添加安全包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new interface is **constrained to RxJava 2** and represents a consumer to `Flowable` that is able to work in a mode that relaxes the Reactive-Streams version 1.0.0 specification in rules §1.3, §2.3, §2.12 and §3.9:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084021Z" creationid="pingfangx" creationdate="20190618T074005Z">
        <seg>新接口被 **约束为 RxJava 2** 并且将消费者表示为 `Flowable`，它能够在 Reactive-Streams 版本 1.0.0 规范的规则 §1.3，§2.3，§2.12 和 §3.9 的宽松模式中工作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The no argument `Action0` is replaced by the `io.reactivex.functions.Action` for the operators and `java.lang.Runnable` for the `Scheduler` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064830Z" creationid="pingfangx" creationdate="20190618T064830Z">
        <seg>无参数 `Action0` 被替换为用于运算符的 `io.reactivex.functions.Action` 和用于 `Scheduler` 方法的 `java.lang.Runnable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The normal procedure for parsing an HTTP message is to read the start-line into a structure, read each header field into a hash table by field name until the empty line, and then use the parsed data to determine if a message body is expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T062618Z" creationid="pingfangx" creationdate="20190831T062618Z">
        <seg>解析 HTTP 消息的正常过程是将起始行读入结构，按字段名称将每个首部字段读取到散列表中直到空行，然后使用解析的数据来确定是否需要消息体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The normal state for the data transfer phase of the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112713Z" creationid="pingfangx" creationdate="20190827T112713Z">
        <seg>连接的数据传输阶段的正常状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of 32 bit words in the TCP Header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105241Z" creationid="pingfangx" creationdate="20190827T105241Z">
        <seg>TCP 首部中 32 位字的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105729Z" creationid="pingfangx" creationdate="20190827T105729Z">
        <seg>该报文段的发送方愿意接受的数据八位字节数，从确认字段中指示的数据八位字节数开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The official Javadoc pages for 2.x is hosted at http://reactivex.io/RxJava/2.x/javadoc/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052658Z" creationid="pingfangx" creationdate="20190618T052658Z">
        <seg>2.x 的官方 Javadoc 页面托管在 http://reactivex.io/RxJava/2.x/javadoc/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The one exception is the "multipart/byteranges" type (appendix 19.2) when it appears in a 206 (Partial Content) response, which will be interpreted by some HTTP caching mechanisms as described in sections 13.5.4 and 14.16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152646Z" creationid="pingfangx" creationdate="20190828T152646Z">
        <seg>当它出现在 206(部分内容)响应中时，一个例外是“multipart/byteranges”类型(附录 19.2)，它将由 13.5.4 和 14.16 节中描述的某些 HTTP 缓存机制解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only dependency between the `sourceObservable` and the `someSingleSource` is that the former should complete normally in order for the latter to be consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091956Z" creationid="pingfangx" creationdate="20190617T091956Z">
        <seg>`sourceObservable` 和 `someSingleSource` 之间唯一的依赖关系是前者应该正常完成，以便后者被消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference between them is the direction in which the data flows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042457Z" creationid="pingfangx" creationdate="20190620T042457Z">
        <seg>它们之间的唯一区别是数据流动的方向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only range unit defined by HTTP/1.1 is "bytes".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160440Z" creationid="pingfangx" creationdate="20190828T160440Z">
        <seg>HTTP/1.1 定义的唯一范围单位是“bytes”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator `flatMap` does this by first mapping each number from 1 to 10 into its own individual `Flowable`, runs them and merges the computed squares.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083001Z" creationid="pingfangx" creationdate="20190617T083001Z">
        <seg>运算符 `flatMap` 通过首先将 1 到 10 中的每个数字映射到它自己的 `Flowable` 中，运行它们并合并计算出的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator `range` sends a callback, in the form of an implementation of the `org.reactivestreams.Subscription` interface, to the `observeOn` by calling its (inner `Subscriber`'s) `onSubscribe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081157Z" creationid="pingfangx" creationdate="20190621T081157Z">
        <seg>操作符 `range` 以 `org.reactivestreams.Subscription` 接口的实现形式，通过调用其(内部 `Subscriber` 的) `onSubscribe` 向 `observeOn` 发送一个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The option-length counts the two octets of option-kind and option-length as well as the option-data octets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110913Z" creationid="pingfangx" creationdate="20190827T110913Z">
        <seg>option-length 计算 option-kind 和 option-length 的两个八位字节以及 option-data 八位字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional fragment component allows for indirect identification of a secondary resource, independent of the URI scheme, as defined in Section 3.5 of [RFC3986].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044148Z" creationid="pingfangx" creationdate="20190831T044148Z">
        <seg>可选的 fragment 组件允许间接识别辅助资源，独立于 URI 方案，如 [RFC3986] 的第 3.5 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which header fields with differing field names are received is not significant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T081316Z" creationid="pingfangx" creationdate="20190829T081316Z">
        <seg>接收到具有不同字段名称的首部字段的顺序并不重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which header fields with the same field name are received is therefore significant to the interpretation of the combined field value; a proxy MUST NOT change the order of these field values when forwarding a message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082535Z" creationid="pingfangx" creationdate="20190831T082535Z">
        <seg>因此，接收具有相同字段名称的首部字段的顺序对于组合字段值的解释是重要的；代理不得在转发消息时更改这些字段值的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T081625Z" creationid="pingfangx" creationdate="20190829T081625Z">
        <seg>因此，接收具有相同字段名称的首部字段的顺序对于组合字段值的解释是重要的，因此代理不能在转发消息时改变这些字段值的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The origin server MUST NOT wait for the request body before sending the 100 (Continue) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024824Z" creationid="pingfangx" creationdate="20190830T024824Z">
        <seg>在发送 100(继续)响应之前，源服务器不得等待请求主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The origin server for an "http" URI is identified by the authority component, which includes a host identifier and optional TCP port ([RFC3986], Section 3.2.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T043907Z" creationid="pingfangx" creationdate="20190831T043907Z">
        <seg>“http”URI 的原始服务器由 authority 组件标识，该组件包括主机标识符和可选的 TCP 端口([RFC3986]，第 3.2.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original `Subscription` container types have been renamed and updated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073136Z" creationid="pingfangx" creationdate="20190618T073136Z">
        <seg>原始的 `Subscription` 容器类型已重命名和更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other `XProcessor` types honor backpressure of their downstream subscribers but otherwise, when subscribed to a source (optional), they consume it in an unbounded manner (requesting `Long.MAX_VALUE`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063226Z" creationid="pingfangx" creationdate="20190618T063226Z">
        <seg>其他 `XProcessor` 类型支持其下游订阅者的背压，但是当订阅源(可选)时，它们以无限制的方式消费它(请求 `Long.MAX_VALUE`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other base reactive types also follow this signature with their respective subscriber types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072930Z" creationid="pingfangx" creationdate="20190618T072930Z">
        <seg>其他基本响应类型也遵循此签名及其各自的订阅者类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other base reactive types have similar `create` methods (minus the backpressure strategy).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094904Z" creationid="pingfangx" creationdate="20190618T094904Z">
        <seg>其他基础响应类型具有类似的 `create` 方法(减去背压策略)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other overloads of `subscribe` now return `Disposable` in 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072939Z" creationid="pingfangx" creationdate="20190618T072939Z">
        <seg>`subscribe` 的其他重载现在在 2.x 中返回 `Disposable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other types, `Single`, `Maybe` and `Completable` don't support backpressure nor should they; there is always room to store one item temporarily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071515Z" creationid="pingfangx" creationdate="20190617T071515Z">
        <seg>其他类型，`Single`，`Maybe`和`Completable`不支持背压，也不应该支持背压；它们只是暂时存放单个项目的空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pad is not transmitted as part of the segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110012Z" creationid="pingfangx" creationdate="20190827T110012Z">
        <seg>填充不作为报文段的传输部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The padding is composed of zeros.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111053Z" creationid="pingfangx" creationdate="20190827T111053Z">
        <seg>填充由零组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062842Z" creationid="pingfangx" creationdate="20190830T062842Z">
        <seg>部分 GET 方法旨在通过允许完成部分检索的实体而不传输客户端已经拥有的数据来减少不必要的网络使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The passing of authentication information in clear text has proven to be a security risk in almost every case where it has been used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073712Z" creationid="pingfangx" creationdate="20190902T073712Z">
        <seg>以明文形式传递身份验证信息几乎在所有使用过的情况下都被证明是一种安全风险。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path component contains data, usually organized in hierarchical form, that, along with data in the non-hierarchical query component (Section 3.4), serves to identify a resource within the scope of the URI's scheme and naming authority (if any).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081518Z" creationid="pingfangx" creationdate="20190902T081518Z">
        <seg>路径组件包含通常以分层形式组织的数据，该数据与非分层查询组件(第 3.4 节)中的数据一起用于标识 URI 方案和命名权限(如果有)范围内的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path is terminated by the first question mark ("?") or number sign ("#") character, or by the end of the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081549Z" creationid="pingfangx" creationdate="20190902T081549Z">
        <seg>路径由第一个问号(“?”)或数字符号(“#”)字符终止，或者由 URI 的末尾终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path segments "." and "..", also known as dot-segments, are defined for relative reference within the path name hierarchy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082352Z" creationid="pingfangx" creationdate="20190902T082352Z">
        <seg>路径段“.”和“..”，也称为点段，被定义为路径名称层次结构内的相对引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The port subcomponent of authority is designated by an optional port number in decimal following the host and delimited from it by a single colon (":") character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081318Z" creationid="pingfangx" creationdate="20190902T081318Z">
        <seg>权限的端口子组件由主机后面的十进制可选端口号指定，并由单个冒号(“:”)字符分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T064329Z" creationid="pingfangx" creationdate="20190830T064329Z">
        <seg>发布的实体从属于该 URI，其方式与文件从属于包含它的目录相同，新闻文章从属于发布它的新闻组，或者记录从属于数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preparation of dataflows by applying various intermediate operators happens in the so-called **assembly time**:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071711Z" creationid="pingfangx" creationdate="20190617T071711Z">
        <seg>通过应用各种中间运算符来准备数据流发生在所谓的 **assembly time** 中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The presence of a host subcomponent within a URI does not imply that the scheme requires access to the given host on the Internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073847Z" creationid="pingfangx" creationdate="20190902T073847Z">
        <seg>URI 中的主机子组件的存在并不意味着该方案需要访问互联网上的给定主机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090117Z" creationid="pingfangx" creationdate="20190831T090117Z">
        <seg>请求中存在消息主体由 Content-Length 或 Transfer-Encoding 首部字段指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The presence of a message body in a response depends on both the request method to which it is responding and the response status code (Section 3.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090246Z" creationid="pingfangx" creationdate="20190831T090246Z">
        <seg>响应中存在消息主体取决于它响应的请求方法和响应状态代码(第 3.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The presence of a message-body in a request is signaled by the inclusion of a Content-Length or Transfer-Encoding header field in the request's message-headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T080343Z" creationid="pingfangx" creationdate="20190829T084354Z">
        <seg>在请求的消息首部中包含 Content-Length 或 Transfer-Encoding 首部字段，可以指示请求中存在消息主体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The presence of such whitespace in a request might be an attempt to trick a server into ignoring that field or processing the line after it as a new request, either of which might result in a security vulnerability if other implementations within the request chain interpret the same message differently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T063646Z" creationid="pingfangx" creationdate="20190831T063521Z">
        <seg>请求中存在这样的空格可能是试图欺骗服务器忽略该字段或将其后的行作为新请求处理，如果请求链中的其他实现未相同地解释消息，则可能导致安全漏洞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T145207Z" creationid="pingfangx" creationdate="20190828T145207Z">
        <seg>参数的存在或不存在对于媒体类型的处理可能是重要的，这取决于媒体类型注册表中的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The primary goal of TLS is to provide a secure channel between two communicating peers; the only requirement from the underlying transport is a reliable, in-order data stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T122426Z" creationid="pingfangx" creationdate="20190901T122426Z">
        <seg>TLS 的主要目标是在两个通信对等体之间提供安全通道；底层传输的唯一要求是可靠的有序数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042455Z" creationid="pingfangx" creationdate="20190828T042455Z">
        <seg>三次握手的主要原因是防止旧的重复连接启动引起混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem comes when one does some initialization in `onSubscribe`/`onStart` after calling `request` there and `onNext` may or may not see the effects of the initialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071801Z" creationid="pingfangx" creationdate="20190618T071801Z">
        <seg>在调用 `request` 之后在 `onSubscribe`/`onStart` 中进行初始化时会出现问题，因为 `onNext` 可能看到或可能看不到初始化的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that the recovering host may not know for how long it crashed nor does it know whether there are still old duplicates in the system from earlier connection incarnations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025808Z" creationid="pingfangx" creationdate="20190828T025808Z">
        <seg>问题是恢复的主机可能不知道它崩溃了多长时间，也不知道系统中是否还存在来自早期连接化身的旧重复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem starts when there are, for example, 1 billion elements or the same 1 million sequence appears 1000 times in a program, leading to `OutOfMemoryError` and generally slowdowns due to excessive GC overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072930Z" creationid="pingfangx" creationdate="20190621T072930Z">
        <seg>例如，当一个程序中有 10 亿个元素或相同的 100 万个序列出现 1000 次时会出现这个问题，导致 `OutOfMemoryError`，并且通常由于过多的 GC 开销而导致变慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem that arises from this is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023158Z" creationid="pingfangx" creationdate="20190828T023158Z">
        <seg>由此产生的问题是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The procedure also works if two TCP simultaneously initiate the procedure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030812Z" creationid="pingfangx" creationdate="20190828T030812Z">
        <seg>如果两个 TCP 同时启动该过程，则该过程也有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process for authoritative access to an "https" identified resource is defined in [RFC2818].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060805Z" creationid="pingfangx" creationdate="20190831T060805Z">
        <seg>在 [RFC2818] 中定义了对“https”标识资源进行权威访问的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process for registration of new URI schemes is defined separately by [BCP35].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T055438Z" creationid="pingfangx" creationdate="20190902T055438Z">
        <seg>注册新 URI 方案的过程由 [BCP35] 单独定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol places no restriction on a particular connection being used over and over again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023132Z" creationid="pingfangx" creationdate="20190828T023132Z">
        <seg>该协议对一次又一次使用的特定连接没有限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol version as a whole indicates the sender's conformance with the set of requirements laid out in that version's corresponding specification of HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103142Z" creationid="pingfangx" creationdate="20190830T103142Z">
        <seg>协议版本作为一个整体表示发送者与该版本的相应 HTTP 规范中规定的一组要求的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further HTTP communication, rather than the features obtained via that communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103058Z" creationid="pingfangx" creationdate="20190828T103058Z">
        <seg>协议版本控制策略旨在允许发送方指示消息的格式及其理解进一步 HTTP 通信的能力，而不是通过该通信获得的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf to either the next inbound proxy server or directly to the origin server indicated by the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124556Z" creationid="pingfangx" creationdate="20190831T124556Z">
        <seg>如果可能，请求代理从有效缓存服务该请求，或者代表客户端向下一个入站代理服务器或直接向请求目标指示的源服务器发出相同的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proxy is requested to forward the request or service it from a valid cache, and return the response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100637Z" creationid="pingfangx" creationdate="20190829T100637Z">
        <seg>请求的代理转发请求或从有效缓存中为其提供服务，并返回响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proxy server MUST signal persistent connections separately with its clients and the origin servers (or other proxy servers) that it connects to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T151842Z" creationid="pingfangx" creationdate="20190829T151842Z">
        <seg>代理服务器必须分别与其客户端和它连接的源服务器(或其他代理服务器)发信号通知持久连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proxy/gateway's response to that request MUST be in the same major version as the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T104153Z" creationid="pingfangx" creationdate="20190828T104153Z">
        <seg>代理/网关对该请求的响应必须与请求处于相同的主要版本中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose is a combination of request semantics, which are defined in [RFC7231], and a target resource upon which to apply those semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123231Z" creationid="pingfangx" creationdate="20190831T123231Z">
        <seg>目的是在 [RFC7231] 中定义的请求语义和应用这些语义的目标资源的组合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of a payload in a request is defined by the method semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190902T025320Z">
        <seg>请求中的有效载荷的目的由方法语义定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134207Z" creationid="pingfangx" creationdate="20190831T134207Z">
        <seg>区分安全和不安全方法的目的是允许自动检索过程(蜘蛛)和缓存性能优化(预取)工作而不用担心造成伤害。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of reserved characters is to provide a set of delimiting characters that are distinguishable from other data within a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070545Z" creationid="pingfangx" creationdate="20190902T070545Z">
        <seg>保留字符的目的是提供一组可与 URI 中的其他数据区分开的分隔字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of the 100 (Continue) status (see section 10.1.1) is to allow a client that is sending a request message with a request body to determine if the origin server is willing to accept the request (based on the request headers) before the client sends the request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024413Z" creationid="pingfangx" creationdate="20190830T024413Z">
        <seg>100(继续)状态(参见第 10.1.1 节)的目的是允许正在向请求主体发送请求消息的客户端确定源服务器是否愿意接受请求(基于请求首部)在客户端发送请求主体之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The query component contains non-hierarchical data that, along with data in the path component (Section 3.3), serves to identify a resource within the scope of the URI's scheme and naming authority (if any).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083133Z" creationid="pingfangx" creationdate="20190902T083133Z">
        <seg>查询组件包含非分层数据，与路径组件(第 3.3 节)中的数据一起用于标识 URI 方案和命名权限(如果有)范围内的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The query component is indicated by the first question mark ("?") character and terminated by a number sign ("#") character or by the end of the URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083202Z" creationid="pingfangx" creationdate="20190902T083202Z">
        <seg>查询组件由第一个问号(“?”)字符表示，并以数字符号(“#”)字符或 URI 的末尾结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The quoted-pair rule no longer allows escaping control characters other than HTAB.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091858Z" creationid="pingfangx" creationdate="20190830T091858Z">
        <seg>引用对规则不再允许转义除 HTAB 之外的控制字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The real power comes with the “reactive extensions” (hence “ReactiveX”) — operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071557Z" creationid="pingfangx" creationdate="20190620T071557Z">
        <seg>“响应式扩展 (reactive extensions)”(这也是为什么称之为 “ReactiveX”) 真正强大的地方是 - 允许您转换，组合，操作和处理 Observable 发射的项目序列的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is that many source operators can "generate" values on demand and thus the operator `observeOn` can tell the `range` generate at most so many values the `observeOn` buffer can hold at once without overflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080646Z" creationid="pingfangx" creationdate="20190621T080512Z">
        <seg>原因是许多源操作符可以按需“生成”值，因此操作符 `observeOn` 可以告诉 `range`，最多生成 `observeOn` 缓冲区可以立即保存而不会溢出的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is that when the library is compiled with Java 8, the javac often can't disambiguate between functional interface types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111255Z" creationid="pingfangx" creationdate="20190618T111255Z">
        <seg>原因是当使用 Java 8 编译库时，javac 通常无法消除函数接口类型之间的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason phrases listed here are only recommendations -- they MAY be replaced by local equivalents without affecting the protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105946Z" creationid="pingfangx" creationdate="20190829T105946Z">
        <seg>这里列出的短语只是建议 - 它们可以被本地等价物替换，而不会影响协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason phrases listed here are only recommendations -- they can be replaced by local equivalents without affecting the protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144649Z" creationid="pingfangx" creationdate="20190831T144649Z">
        <seg>此处列出的原因仅是建议 - 它们可以由本地等效项替换，而不会影响协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason these operators have a suffix instead of simply having the same name with different signature is type erasure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100728Z" creationid="pingfangx" creationdate="20190617T100728Z">
        <seg>这些运算符具有后缀而不是简单地具有不同签名的相同名称的原因是类型擦除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081249Z" creationid="pingfangx" creationdate="20190831T081249Z">
        <seg>原因 - 短语元素的唯一目的是提供与数字状态代码相关联的文本描述，主要是出于对交互式文本客户端更频繁使用的早期互联网应用程序协议的尊重。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receive window is the portion of the sequence space labeled 2 in figure 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111933Z" creationid="pingfangx" creationdate="20190827T111933Z">
        <seg>接收窗口是图 5 中标记为 2 的序列空间的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver of a RST first validates it, then changes state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061754Z" creationid="pingfangx" creationdate="20190828T061754Z">
        <seg>RST 的接收者首先验证它，然后改变状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024312Z" creationid="pingfangx" creationdate="20190828T024312Z">
        <seg>第一个 SYN 的接收者无法知道该报文段是否是旧的延迟报文段，除非它记住连接上使用的最后一个序列号(这并不总是可能)，因此它必须要求发送方验证这个 SYN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T065030Z" creationid="pingfangx" creationdate="20190830T065030Z">
        <seg>实体的接收者绝不能忽略它不理解或未实现的任何 Content-*(例如 Content-Range)首部，并且在这种情况下必须返回 501(Not Implemented)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recipient proxy can establish a tunnel either by directly connecting to the request-target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143121Z" creationid="pingfangx" creationdate="20190831T143121Z">
        <seg>接收者代理可以通过直接连接到请求目标来建立隧道，或者，如果配置为使用另一个代理，则通过将 CONNECT 请求转发到下一个入站代理来建立隧道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reg-name syntax allows percent-encoded octets in order to represent non-ASCII registered names in a uniform way that is independent of the underlying name resolution technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T080004Z" creationid="pingfangx" creationdate="20190902T080004Z">
        <seg>reg-name 语法允许百分比编码的八位字节，以便以统一的方式表示非 ASCII 注册名称，独立于基础名称解析技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relationship between HTTP and MIME is described in appendix 19.4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085125Z" creationid="pingfangx" creationdate="20190828T085125Z">
        <seg>HTTP 和 MIME 之间的关系在附录 19.4 中描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevance of this operator is decreasing as more and more operators now allow setting their buffer sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093239Z" creationid="pingfangx" creationdate="20190621T093239Z">
        <seg>随着越来越多的操作符现在允许设置其缓冲区大小，此操作符的相关性正在下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevant parameters are usually called `bufferSize`, `prefetch` or `capacityHint`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090454Z" creationid="pingfangx" creationdate="20190621T090454Z">
        <seg>相关参数通常称为 `bufferSize`，`prefetch` 或 `capacityHint`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining action interfaces were named according to the Java 8 functional types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064541Z" creationid="pingfangx" creationdate="20190618T064541Z">
        <seg>其余的操作接口根据 Java 8 函数类型命名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote TCP initiates by sending a FIN control signal</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063204Z" creationid="pingfangx" creationdate="20190828T063204Z">
        <seg>远程 TCP 通过发送 FIN 控制信号启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the effective request URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025111Z" creationid="pingfangx" creationdate="20190902T025111Z">
        <seg>与 HTTP 消息相关联的表示数据或者作为消息的有效载荷主体提供，或者由消息语义和有效请求 URI 引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The representation data is in a format and encoding defined by the representation metadata header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T025119Z" creationid="pingfangx" creationdate="20190902T025119Z">
        <seg>表示数据采用由表示元数据首部字段定义的格式和编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The representation of entities in any response can be negotiated (including error responses).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081217Z" creationid="pingfangx" creationdate="20190828T081217Z">
        <seg>可以协商任何响应中的实体表示(包括错误响应)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request method is case-sensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070500Z" creationid="pingfangx" creationdate="20190831T070500Z">
        <seg>请求方法区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133233Z" creationid="pingfangx" creationdate="20190831T133233Z">
        <seg>请求方法标记是请求语义的主要来源；它表示客户提出此请求的目的以及客户期望的成功结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133512Z" creationid="pingfangx" creationdate="20190831T133512Z">
        <seg>请求方法被设想为将语义应用于目标资源，其方式与在已识别的将应用语义的对象上调用已定义方法的方式非常相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request method's semantics might be further specialized by the semantics of some header fields when present in a request (Section 5) if those additional semantics do not conflict with the method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133257Z" creationid="pingfangx" creationdate="20190831T133257Z">
        <seg>如果某些首部字段存在于请求(第 5 节)中，如果这些附加语义不与该方法冲突，那么请求方法的语义可能会进一步专门化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request methods defined by this specification can be found in Section 4 of [RFC7231], along with information regarding the HTTP method registry and considerations for defining new methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070530Z" creationid="pingfangx" creationdate="20190831T070530Z">
        <seg>本规范定义的请求方法可以在 [RFC7231] 的第 4 节中找到，以及有关 HTTP 方法注册的信息和定义新方法的注意事项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request-header fields allow the client to pass additional information about the request, and about the client itself, to the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102304Z" creationid="pingfangx" creationdate="20190829T102236Z">
        <seg>请求首部字段允许客户端将有关请求以及客户端本身的其他信息传递给服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request-target identifies the target resource upon which to apply the request, as defined in Section 5.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070541Z" creationid="pingfangx" creationdate="20190831T070541Z">
        <seg>请求目标标识应用请求的目标资源，如第 5.3 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The requirement to retry requests under certain circumstances when the server prematurely closes the connection has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092213Z" creationid="pingfangx" creationdate="20190830T092213Z">
        <seg>已删除在服务器过早关闭连接的某些情况下重试请求的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reset takes its sequence number from the ACK field of the incoming segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T061702Z" creationid="pingfangx" creationdate="20190828T061702Z">
        <seg>重置从传入报文段的 ACK 字段获取其序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resource is the conceptual mapping to an entity or set of entities, not necessarily the entity which corresponds to that mapping at any particular instance in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040234Z" creationid="pingfangx" creationdate="20190902T040234Z">
        <seg>资源是到实体或实体集的概念映射，不一定是在任何特定时刻对应于该映射的实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response body, if any, SHOULD also include information about the communication options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042049Z" creationid="pingfangx" creationdate="20190830T042049Z">
        <seg>响应主体(如果有)还应包括有关通信选项的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response header fields allow the server to pass additional information about the response beyond what is placed in the status-line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144824Z" creationid="pingfangx" creationdate="20190831T144824Z">
        <seg>响应首部字段允许服务器传递有关响应的附加信息，这些信息超出了放置在状态行中的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response message will usually contain a representation that explains the status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144427Z" creationid="pingfangx" creationdate="20190831T144427Z">
        <seg>响应消息通常包含解释状态的表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response payload, if any, might also describe the communication options in a machine or human-readable representation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143621Z" creationid="pingfangx" creationdate="20190831T143621Z">
        <seg>响应有效载荷(如果有的话)也可以描述机器中的通信选项或人类可读的表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in section 13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062929Z" creationid="pingfangx" creationdate="20190830T062929Z">
        <seg>当且仅当它满足第 13 节中描述的 HTTP 缓存要求时，对 GET 请求的响应才是可缓存的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response to a GET request is cacheable; a cache MAY use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [RFC7234]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T135720Z" creationid="pingfangx" creationdate="20190831T135720Z">
        <seg>对 GET 请求的响应是可缓存的；缓存可以使用它来满足后续的 GET 和 HEAD 请求，除非 Cache-Control 首部字段另有说明([RFC7234] 的第 5.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063717Z" creationid="pingfangx" creationdate="20190830T063717Z">
        <seg>对于 HEAD 请求的响应可以是可缓存的，因为响应中包含的信息可以用于从该资源更新先前缓存的实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response to a HEAD request is cacheable; a cache MAY use it to satisfy subsequent HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [RFC7234]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T140324Z" creationid="pingfangx" creationdate="20190831T140324Z">
        <seg>对 HEAD 请求的响应是可缓存的；缓存可以使用它来满足后续的 HEAD 请求，除非 Cache-Control 首部字段另有说明([RFC7234] 的第 5.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response-header fields allow the server to pass additional information about the response which cannot be placed in the Status-Line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110818Z" creationid="pingfangx" creationdate="20190829T110818Z">
        <seg>响应首部字段允许服务器传递有关响应而无法放入状态行的其他信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the response message is to be interpreted in light of the semantics defined for that status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081129Z" creationid="pingfangx" creationdate="20190831T081129Z">
        <seg>响应消息的其余部分将根据为该状态代码定义的语义进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a protocol that can be used effectively in many different contexts and for which implementations can evolve independently over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094238Z" creationid="pingfangx" creationdate="20190830T094238Z">
        <seg>结果是一种协议，可以在许多不同的上下文中有效地使用，并且实现可以随着时间的推移独立发展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T062007Z" creationid="pingfangx" creationdate="20190620T061944Z">
        <seg>取消订阅的结果将通过应用于该观察者所订阅的 Observable 的操作符链级联，这将导致链中的每个链接停止发射项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T094336Z" creationid="pingfangx" creationdate="20190829T094336Z">
        <seg>响应的返回代码始终通知客户端当前是否允许在资源上使用方法，因为允许的方法集可以动态更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rightmost domain label of a fully qualified domain name in DNS may be followed by a single "." and should be if it is necessary to distinguish between the complete domain name and some local domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075421Z" creationid="pingfangx" creationdate="20190902T075421Z">
        <seg>DNS 中完全限定域名的最右边的域名标签后面可以跟一个“.”，如果需要区分完整域名和某些本地域，则应该跟一个“.”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for determining the cacheability of HTTP responses are defined in section 13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081806Z" creationid="pingfangx" creationdate="20190828T081806Z">
        <seg>确定 HTTP 响应的可缓存性的规则在第 13 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for when a message body is allowed in a message differ for requests and responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090026Z" creationid="pingfangx" creationdate="20190831T090026Z">
        <seg>消息中允许消息主体的规则因请求和响应而异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for when a message-body is allowed in a message differ for requests and responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T080253Z" creationid="pingfangx" creationdate="20190829T084300Z">
        <seg>消息中允许消息主体的规则因请求和响应而异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same applies to `Observer`, `SingleObserver`, `MaybeObserver` and `CompletableObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095612Z" creationid="pingfangx" creationdate="20190618T095612Z">
        <seg>这同样适用于 `Observer`，`SingleObserver`，`MaybeObserver` 和 `CompletableObserver`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same limitation exists for the operator `Switch`, which had to be named `switchOnNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101839Z" creationid="pingfangx" creationdate="20190617T101839Z">
        <seg>运算符 `Switch` 也存在同样的限制，它必须命名为 `switchOnNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same program might act as a client on some connections and a server on others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095556Z" creationid="pingfangx" creationdate="20190830T095556Z">
        <seg>同一程序可能在某些连接上充当客户端，在其他连接上充当服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scheme and host are case-insensitive and normally provided in lowercase; all other components are compared in a case-sensitive manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T061014Z" creationid="pingfangx" creationdate="20190831T061014Z">
        <seg>方案和主机不区分大小写，通常以小写形式提供；所有其他组件都以区分大小写的方式进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scheme and path components are required, though the path may be empty (no characters).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072217Z" creationid="pingfangx" creationdate="20190902T072217Z">
        <seg>方案和路径组件是必需的，但路径可能为空(无字符)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scheme registry maintains the mapping between scheme names and their specifications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072557Z" creationid="pingfangx" creationdate="20190902T072557Z">
        <seg>方案注册表维护方案名称与其规范之间的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second callback takes this state object and provides an output `Observer` whose `onXXX` methods can be called to emit values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021221Z" creationid="pingfangx" creationdate="20190624T021221Z">
        <seg>第二个回调接受这个状态对象，并提供一个输出 `Observer`，可以调用其 `onXXX` 方法来发射值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second convenience is that most `TestSubscriber`/`TestObserver` methods return the instance itself allowing chaining the various `assertX` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095918Z" creationid="pingfangx" creationdate="20190618T095918Z">
        <seg>第二个方便是大多数 `TestSubscriber`/`TestObserver` 方法返回实例本身，允许链式调用各种 `assertX` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second format is in common use, but is based on the obsolete RFC 850 [12] date format and lacks a four-digit year.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113638Z" creationid="pingfangx" creationdate="20190828T113638Z">
        <seg>第二种格式是常用的，但基于过时的 RFC 850 [12] 日期格式，缺少四位数年份。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second is to write the **Hello World** program:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065858Z" creationid="pingfangx" creationdate="20190617T065858Z">
        <seg>第二个是编写 ** Hello World ** 程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second scenario usually involves some asynchronous, callback-based API that has to be converted into an `Flowable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022924Z" creationid="pingfangx" creationdate="20190624T022924Z">
        <seg>第二种情况通常涉及一些异步的，基于回调的 API，必须将其转换为 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The segment + query components of RFC 3986 have been used to define the request-target, instead of abs_path from RFC 1808.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092107Z" creationid="pingfangx" creationdate="20190830T092107Z">
        <seg>RFC 3986 的段+查询组件已用于定义请求目标，而不是 RFC 1808 中的 abs_path。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The segment length (SEG.LEN) includes both data and sequence space occupying controls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022829Z" creationid="pingfangx" creationdate="20190828T022829Z">
        <seg>报文段长度(SEG.LEN)包括数据和控制位占用的序列空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics are that the identified resource is located at the server listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path (section 5.1.2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112517Z" creationid="pingfangx" creationdate="20190828T112517Z">
        <seg>语义是标识的资源位于服务器上，监听该主机端口上的 TCP 连接，资源的 Request-URI 是 abs_path(第 5.1.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of a fragment identifier are defined by the set of representations that might result from a retrieval action on the primary resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083542Z" creationid="pingfangx" creationdate="20190902T083542Z">
        <seg>片段标识符的语义由可能由主资源上的检索操作产生的表示集定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of the GET method change to a "conditional GET" if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062650Z" creationid="pingfangx" creationdate="20190830T062326Z">
        <seg>如果请求消息包括 If-Modified-Since，If-Unmodified-Since，If-Match，If-None-Match 或 If-Range 首部字段，则 GET 方法的语义变为“条件 GET (conditional GET)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of the GET method change to a "partial GET" if the request message includes a Range header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T062658Z" creationid="pingfangx" creationdate="20190830T062636Z">
        <seg>如果请求消息包括 Range 首部字段，则 GET 方法的语义变为“部分 GET (partial GET)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of the Upgrade header field is now defined in responses other than 101 (this was incorporated from [RFC2817]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092228Z" creationid="pingfangx" creationdate="20190830T092228Z">
        <seg>现在，在不是 101 的响应中定义了升级首部字段的语义(这是从 [RFC2817] 中加入的)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence number of the first data octet in this segment (except when SYN is present).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105012Z" creationid="pingfangx" creationdate="20190827T105012Z">
        <seg>此报文段中第一个数据八位字节的序列号(存在 SYN 时除外)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST NOT process any further requests received on that connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112702Z" creationid="pingfangx" creationdate="20190831T112702Z">
        <seg>服务器不得处理在该连接上收到的任何进一步请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server SHOULD send a "close" connection option in its final response on that connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112658Z" creationid="pingfangx" creationdate="20190831T112658Z">
        <seg>服务器应该在该连接的最终响应中发送“close”连接选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields (Section 3.3) MAY be omitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T140126Z">
        <seg>服务器在响应 HEAD 请求时，应该发送当请求是 GET 时它将发送的相同的首部字段，除了可以省略有效载荷首部字段(第 3.3 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server on which a given resource resides or is to be created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081417Z" creationid="pingfangx" creationdate="20190828T081417Z">
        <seg>要在其上创建或将要创建给定资源的服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server responds with a status line, including the message's protocol version and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible entity-body content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085034Z" creationid="pingfangx" creationdate="20190828T085034Z">
        <seg>服务器响应，有一行状态行包括消息的协议版本和成功或错误代码，然后是包含服务器信息，实体元信息和可能的实体主体内容的类似 MIME 的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server then continues to read from the connection until it receives a corresponding close by the client, or until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112931Z" creationid="pingfangx" creationdate="20190831T112931Z">
        <seg>然后，服务器继续从连接读取，直到它收到客户端的相应关闭，或者直到服务器合理地确定其自己的 TCP 堆栈已经收到客户端对包含服务器最后响应的数据包的确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The set of common methods for HTTP/1.1 is defined below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T031649Z" creationid="pingfangx" creationdate="20190830T031649Z">
        <seg>HTTP/1.1 的常用方法集定义如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The set of methods allowed by a target resource can be listed in an Allow header field (Section 7.4.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133930Z" creationid="pingfangx" creationdate="20190831T133930Z">
        <seg>目标资源允许的方法集可以列在 Allow 首部字段中(第 7.4.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest three-way handshake is shown in figure 7 below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T033648Z" creationid="pingfangx" creationdate="20190828T033648Z">
        <seg>最简单的三次握手如下图 7 所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source port number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104852Z" creationid="pingfangx" creationdate="20190827T104852Z">
        <seg>源端口号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specification itself has evolved out of RxJava 1.x and provides a common baseline for reactive systems and libraries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051835Z" creationid="pingfangx" creationdate="20190618T051835Z">
        <seg>规范本身已经从 RxJava 1.x 发展而来，并为响应式系统和库提供了一个共同的基线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specification of URI is designed to meet the recommendations laid out in "Functional Recommendations for Internet Resource Locators" [RFC1736] and "Functional Requirements for Uniform Resource Names" [RFC1737].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035822Z" creationid="pingfangx" creationdate="20190902T035822Z">
        <seg>URI 的规范旨在满足“互联网资源定位器的功能建议”[RFC1736] 和“统一资源名称的功能要求”[RFC1737] 中列出的建议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state diagram in figure 6 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T113155Z" creationid="pingfangx" creationdate="20190827T113155Z">
        <seg>图 6 中的状态图仅说明状态变化以及导致事件和结果动作，但既不解决错误条件也不解决与状态变化无关的动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The states are:  LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, and the fictional state CLOSED.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T112450Z" creationid="pingfangx" creationdate="20190827T112450Z">
        <seg>状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, 和虚构状态 CLOSED.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status codes listed below are defined in this specification, Section 4 of [RFC7232], Section 4 of [RFC7233], and Section 3 of [RFC7235].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144641Z" creationid="pingfangx" creationdate="20190831T144641Z">
        <seg>下面列出的状态代码在本规范，[RFC7232] 的第 4 节，[RFC7233] 的第 4 节和 [RFC7235] 的第 3 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T081119Z" creationid="pingfangx" creationdate="20190831T081119Z">
        <seg>status-code 元素是一个 3 位整数代码，用于描述服务器尝试理解和满足客户端相应请求的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status-code element is a three-digit integer code giving the result of the attempt to understand and satisfy the request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144338Z" creationid="pingfangx" creationdate="20190831T144338Z">
        <seg>状态代码元素是一个三位整数代码，给出了试图理解和满足请求的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The symbol "=&lt;" means "less than or equal" (modulo 2**32).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021556Z" creationid="pingfangx" creationdate="20190828T021556Z">
        <seg>符号 "=&lt;" 表示“小于或等于”(模 2**32)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The synchronization requires each side to send it's own initial sequence number and to receive a confirmation of it in acknowledgment from the other side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023812Z" creationid="pingfangx" creationdate="20190828T023812Z">
        <seg>同步要求每一方发送它自己的初始序列号，并从另一方接收确认信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax and registry of HTTP language tags is the same as that defined by RFC 1766 [1].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154650Z" creationid="pingfangx" creationdate="20190828T154650Z">
        <seg>HTTP 语言标记的语法和注册与 RFC 1766 [1] 定义的相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax is designed to meet the recommendations laid out in "Functional Recommendations for Internet Resource Locators" [RFC1736] and "Functional Requirements for Uniform Resource Names" [RFC1737].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T043058Z" creationid="pingfangx" creationdate="20190902T043058Z">
        <seg>该语法旨在满足“互联网资源定位器的功能建议”[RFC1736] 和“统一资源名称的功能要求”[RFC1737] 中列出的建议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax rule for host is ambiguous because it does not completely distinguish between an IPv4address and a reg-name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074224Z" creationid="pingfangx" creationdate="20190902T074224Z">
        <seg>主机的语法规则不明确，因为它不能完全区分 IPv4 地址和注册名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing ([RFC3986], Section 3.5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123453Z" creationid="pingfangx" creationdate="20190831T123453Z">
        <seg>目标 URI 排除了引用的片段组件（如果有），因为片段标识符是为客户端处理保留的（[RFC3986]，第 3.5 节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The target of an HTTP request is called a "resource".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122248Z" creationid="pingfangx" creationdate="20190831T122248Z">
        <seg>HTTP 请求的目标称为“资源”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "Effective Request URI" has been introduced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092123Z" creationid="pingfangx" creationdate="20190830T092123Z">
        <seg>已引入术语“有效请求 URI”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "Uniform Resource Locator" (URL) refers to the subset of URIs that, in addition to identifying a resource, provide a means of locating the resource by describing its primary access mechanism (e.g., its network "location").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T063912Z" creationid="pingfangx" creationdate="20190902T063912Z">
        <seg>术语“统一资源定位符”(URL)指的是 URI 的子集，其除了标识资源之外，还通过描述其主要访问机制(例如，其网络“位置”)来提供定位资源的手段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "Uniform Resource Name" (URN) has been used historically to refer to both URIs under the "urn" scheme [RFC2141], which are required to remain globally unique and persistent even when the resource ceases to exist or becomes unavailable, and to any other URI with the properties of a name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064241Z" creationid="pingfangx" creationdate="20190902T064011Z">
        <seg>历史上使用术语“统一资源名称”(URN)来指代“urn”方案 [RFC2141] 下的两个 URI 及具有名称属性的任何其他 URI，即使资源不再存在或变得不可用，它们仍然是全局唯一且持久的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "character set" is used in this document to refer to a method used with one or more tables to convert a sequence of octets into a sequence of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114854Z" creationid="pingfangx" creationdate="20190828T114854Z">
        <seg>在本文档中使用术语“字符集”来指代与一个或多个表一起使用以将八位字节序列转换为字符序列的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "origin server" refers to the program that can originate authoritative responses for a given target resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095819Z" creationid="pingfangx" creationdate="20190830T095819Z">
        <seg>术语“源服务器”指的是可以为给定目标资源发起权威响应的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "user agent" does not imply that there is a human user directly interacting with the software agent at the time of a request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100639Z" creationid="pingfangx" creationdate="20190830T100639Z">
        <seg>术语“用户代理”并不意味着在请求时存在直接与软件代理交互的人类用户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The term "user agent" refers to any of the various client programs that initiate a request, including (but not limited to) browsers, spiders (web-based robots), command-line tools, custom applications, and mobile apps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095805Z" creationid="pingfangx" creationdate="20190830T095805Z">
        <seg>术语“用户代理”是指发起请求的各种客户端程序中的任何一个，包括(但不限于)浏览器，蜘蛛(基于 web 的机器人)，命令行工具，自定义应用程序和移动应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terms "client" and "server" refer only to the roles that these programs perform for a particular connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095546Z" creationid="pingfangx" creationdate="20190830T095546Z">
        <seg>术语“客户端”和“服务器”仅指这些程序为特定连接执行的角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terms "inbound" and "outbound" are used to describe directional requirements in relation to the request route: "inbound" means toward the origin server and "outbound" means toward the user agent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101209Z" creationid="pingfangx" creationdate="20190830T101209Z">
        <seg>术语“入站”和“出站”用于描述与请求路由相关的方向要求：“入站”表示朝向源服务器，“出站”表示朝向用户代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terms "sender" and "recipient" refer to any implementation that sends or receives a given message, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T095837Z" creationid="pingfangx" creationdate="20190830T095837Z">
        <seg>术语“发送者”和“接收者”分别指代发送或接收给定消息的任何实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terms "upstream" and "downstream" are used to describe directional requirements in relation to the message flow: all messages flow from upstream to downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101202Z" creationid="pingfangx" creationdate="20190830T101202Z">
        <seg>术语“上游”和“下游”用于描述与消息流相关的方向要求：所有消息从上游流向下游。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third convenience is that you can now fluently test your sources without the need to create or introduce `TestSubscriber`/`TestObserver` instance in your code:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100013Z" creationid="pingfangx" creationdate="20190618T100013Z">
        <seg>第三个方便是您现在可以流畅地测试您的源，而无需在代码中创建或引入 `TestSubscriber`/`TestObserver` 实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024325Z" creationid="pingfangx" creationdate="20190828T024325Z">
        <seg>在 [3] 中讨论了三次握手和时钟驱动方案的优点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three-way handshake reduces the possibility of false connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T032510Z" creationid="pingfangx" creationdate="20190828T032510Z">
        <seg>三次握手减少了错误连接的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The time at which the origin server intends that an entity should no longer be returned by a cache without further validation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081910Z" creationid="pingfangx" creationdate="20190828T081910Z">
        <seg>原始服务器打算在没有进一步验证的情况下不再由缓存返回实体的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trailer allows the sender to include additional HTTP header fields at the end of the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190828T144020Z">
        <seg>trailer 允许在邮件末尾包含其他 HTTP 首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transfer-length of a message is the length of the message-body as it appears in the message; that is, after any transfer-codings have been applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084910Z" creationid="pingfangx" creationdate="20190829T084910Z">
        <seg>消息的传输长度是消息中出现的消息体的长度；也就是说，在应用任何传输编码之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tunnel ceases to exist when both ends of the relayed connections are closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081651Z" creationid="pingfangx" creationdate="20190828T081651Z">
        <seg>当中继连接的两端都闭合时，隧道不再存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T105858Z" creationid="pingfangx" creationdate="20190828T105848Z">
        <seg>这两种形式的区别在于绝对 URI 始终以 scheme 名称开头后跟冒号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of port designated by the port number (e.g., TCP, UDP, SCTP) is defined by the URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081345Z" creationid="pingfangx" creationdate="20190902T081345Z">
        <seg>由端口号指定的端口类型(例如，TCP，UDP，SCTP)由 URI 方案定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type, subtype, and parameter attribute names are case- insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T145005Z" creationid="pingfangx" creationdate="20190828T145005Z">
        <seg>type，subtype 和 parameter 属性名称不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The typical kinds of sequence number comparisons which the TCP must perform include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021605Z" creationid="pingfangx" creationdate="20190828T021605Z">
        <seg>TCP 必须执行的典型序列号比较包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The uppercase hexadecimal digits 'A' through 'F' are equivalent to the lowercase digits 'a' through 'f', respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065628Z" creationid="pingfangx" creationdate="20190902T065628Z">
        <seg>大写十六进制数字 'A' 到 'F' 分别相当于小写数字 'a' 到 'f'。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The urgent pointer points to the sequence number of the octet following the urgent data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110719Z" creationid="pingfangx" creationdate="20190827T110719Z">
        <seg>紧急指针指向紧急数据之后的八位字节的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of IP addresses in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112532Z" creationid="pingfangx" creationdate="20190828T112532Z">
        <seg>应尽可能避免在 URL 中使用 IP 地址(参见 RFC 1900 [24])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of `onBackpressureDrop` in this case would lead to a situation where the very last click gets dropped and leaves the user wondering why the business logic wasn't executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015341Z" creationid="pingfangx" creationdate="20190624T015341Z">
        <seg>在这种情况下使用 `onBackpressureDrop` 会导致最后一次点击被删除，并会使用户疑惑为什么没有执行业务逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of inline images and other associated data often require a client to make multiple requests of the same server in a short amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T143028Z" creationid="pingfangx" creationdate="20190829T143028Z">
        <seg>内联图像和其他相关数据的使用通常要求客户端在短时间内对同一服务器发出多个请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of persistent connections places no requirements on the length (or existence) of this time-out for either the client or the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152136Z" creationid="pingfangx" creationdate="20190829T152136Z">
        <seg>持久连接的使用对客户端或服务器的超时长度(或存在)没有要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112401Z" creationid="pingfangx" creationdate="20190831T112401Z">
        <seg>持久连接的使用对客户端或服务器的超时长度(或存在)没有要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of the same entity tag value in conjunction with entities obtained by requests on different URIs does not imply the equivalence of those entities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T160036Z" creationid="pingfangx" creationdate="20190828T160036Z">
        <seg>将相同实体标签值与通过不同 URI 上的请求获得的实体结合使用并不意味着这些实体的等同性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user in such situations probably wanted to defer some computation until the `someSource` has completed, thus the correct</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102855Z" creationid="pingfangx" creationdate="20190617T102855Z">
        <seg>在这种情况下的用户可能想要推迟一些计算，直到 `someSource` 完成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user information, if present, is followed by a commercial at-sign ("@") that delimits it from the host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073539Z" creationid="pingfangx" creationdate="20190902T073539Z">
        <seg>用户信息（如果存在）之后是商业 at 符号（“@”），用于将其与主机分隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user initiates by telling the TCP to CLOSE the connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063155Z" creationid="pingfangx" creationdate="20190828T063155Z">
        <seg>用户通过告知 TCP 关闭连接来启动</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user who CLOSEs may continue to RECEIVE until he is told that the other side has CLOSED also.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T065845Z" creationid="pingfangx" creationdate="20190828T062634Z">
        <seg>CLOSE 的用户会继续 RECEIVE，直到他被告知另一方也已 CLOSED。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user will respond with a CLOSE, upon which the TCP can send a FIN to the other TCP after sending any remaining data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063732Z" creationid="pingfangx" creationdate="20190828T063732Z">
        <seg>用户将以 CLOSE 响应，TCP 可以在发送任何剩余数据后将 FIN 发送到另一个 TCP。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The userinfo subcomponent may consist of a user name and, optionally, scheme-specific information about how to gain authorization to access the resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073512Z" creationid="pingfangx" creationdate="20190902T073512Z">
        <seg>userinfo 子组件可以包括用户名，以及可选的，关于如何获得访问资源的授权的特定于方案的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the Via header field (Section 5.7.1 of [RFC7230]) is of particular interest, since it acts as a trace of the request chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144136Z" creationid="pingfangx" creationdate="20190831T144136Z">
        <seg>Via 首部字段的值([RFC7230] 的第 5.7.1 节)特别令人感兴趣，因为它充当请求链的跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the Via header field (section 14.45) is of particular interest, since it acts as a trace of the request chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074340Z" creationid="pingfangx" creationdate="20190830T074340Z">
        <seg>Via 首部字段(第 14.45 节)的值特别令人感兴趣，因为它充当请求链的跟踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The verb "generate" is used instead of "send" where a requirement differentiates between creating a protocol element and merely forwarding a received element downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102534Z" creationid="pingfangx" creationdate="20190830T102534Z">
        <seg>使用动词“generate”代替“send”，其中需求区分创建协议元素和仅仅向下游转发接收的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version flag does not indicate the IP version; rather, it indicates future versions of the literal format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074524Z" creationid="pingfangx" creationdate="20190902T074524Z">
        <seg>版本标志不表示 IP 版本；相反，它表示文字格式的未来版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version of an HTTP message is indicated by an HTTP-Version field in the first line of the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103317Z" creationid="pingfangx" creationdate="20190828T103317Z">
        <seg>HTTP 消息的版本由消息第一行中的 HTTP-Version 字段指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version of an HTTP message is indicated by an HTTP-version field in the first line of the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103150Z" creationid="pingfangx" creationdate="20190830T103150Z">
        <seg>HTTP 消息的版本由消息第一行中的 HTTP 版本字段指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their use here is representative of historical practice, not good design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141139Z" creationid="pingfangx" creationdate="20190828T141139Z">
        <seg>它们在这里的使用代表了历史实践，而不是良好的设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then that observer reacts to whatever item or sequence of items the Observable &lt;d3&gt;emits&lt;/d3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043345Z" creationid="pingfangx" creationdate="20190620T043345Z">
        <seg>然后该观察者对 Observable &lt;d3&gt;emits (发射)&lt;/d3&gt;的数据或数据序列作出响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, each component is parsed for its subparts and their validation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084410Z" creationid="pingfangx" creationdate="20190902T084410Z">
        <seg>然后，解析每个组件的子部件及其验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are 4 additional overloads of `onBackpressureBuffer`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093033Z" creationid="pingfangx" creationdate="20190621T093033Z">
        <seg>`onBackpressureBuffer` 还有 4 个额外的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are 5 values for the first digit:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105623Z" creationid="pingfangx" creationdate="20190829T105623Z">
        <seg>第一个数字有 5 个值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few header fields which have general applicability for both request and response messages, but which do not apply to the entity being transferred.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T091807Z" creationid="pingfangx" creationdate="20190829T091807Z">
        <seg>有一些首部字段对请求和响应消息具有一般适用性，但不适用于正在传输的实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also intermediaries that can act on lower layers of the network protocol stack, filtering or redirecting HTTP traffic without the knowledge or permission of message senders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101731Z" creationid="pingfangx" creationdate="20190830T101731Z">
        <seg>还有一些中介可以在网络协议栈的较低层上起作用，在没有消息发送者知情或许可的情况下过滤或重定向 HTTP 流量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also some variables used frequently in the discussion that take their values from the fields of the current segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111945Z" creationid="pingfangx" creationdate="20190827T111945Z">
        <seg>在讨论中还经常使用一些变量，这些变量从当前报文段的字报文段中获取它们的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also versions of &lt;c0&gt;ReplaySubject&lt;/c0&gt; that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085024Z" creationid="pingfangx" creationdate="20190620T085024Z">
        <seg>还有一些 &lt;c0&gt;ReplaySubject&lt;/c0&gt; 的版本，一旦重放缓冲区超过一定大小，或者自项目最初发射以来已经过了指定的时间跨度，它们将丢弃旧项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are alternative operators:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083144Z" creationid="pingfangx" creationdate="20190617T083144Z">
        <seg>还有其他可选运算符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are essentially three cases:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063148Z" creationid="pingfangx" creationdate="20190828T063148Z">
        <seg>基本上有三种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123833Z" creationid="pingfangx" creationdate="20190831T123833Z">
        <seg>请求目标有四种不同的格式，具体取决于请求的方法和请求是否是代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four varieties of &lt;c0&gt;Subject&lt;/c0&gt; that are designed for particular use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083734Z" creationid="pingfangx" creationdate="20190620T083734Z">
        <seg>有四种 &lt;c0&gt;Subject&lt;/c0&gt; 专为特定用例而设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many terms used to describe this model of asynchronous programming and design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045654Z" creationid="pingfangx" creationdate="20190620T045654Z">
        <seg>有许多术语用于描述这种异步编程和设计模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072833Z" creationid="pingfangx" creationdate="20190620T072833Z">
        <seg>还有其他模式，如 Builder 模式，其中特定类的各种方法对同一类的项进行操作，通过方法的操作修改该项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several strategies available (such as buffering, dropping, keeping the latest) via the `BackpressureStrategy` parameter or via standard `Flowable` operators such as `onBackpressureBuffer`, `onBackpressureDrop`, `onBackpressureLatest` which also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100520Z" creationid="pingfangx" creationdate="20190617T100520Z">
        <seg>有几种策略可用(例如缓冲，丢弃，保持最新)通过 `BackpressureStrategy` 参数或通过标准的 `Flowable` 操作符，如 `onBackpressureBuffer`，`onBackpressureDrop`，`onBackpressureLatest` 它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several ways of dealing with such situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090224Z" creationid="pingfangx" creationdate="20190621T090224Z">
        <seg>有几种方法可以处理这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143315Z" creationid="pingfangx" creationdate="20190831T143315Z">
        <seg>建立到任意服务器的隧道存在很大的风险，特别是当目标是一个众所周知的或保留的 TCP 端口而非用于 Web 流量时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021509Z" creationid="pingfangx" creationdate="20190828T021509Z">
        <seg>计算机模运算有一些细微之处，因此在对这些值的比较进行编程时应该非常小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three common forms of HTTP intermediary: proxy, gateway, and tunnel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101040Z" creationid="pingfangx" creationdate="20190830T101040Z">
        <seg>HTTP 中介有三种常见形式：代理，网关和隧道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three common forms of intermediary: proxy, gateway, and tunnel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T085523Z" creationid="pingfangx" creationdate="20190828T085523Z">
        <seg>中介有三种常见形式：代理，网关和隧道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three groups of states:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060544Z" creationid="pingfangx" creationdate="20190828T060544Z">
        <seg>有三组状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two cases for the format of an option:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110817Z" creationid="pingfangx" creationdate="20190827T110817Z">
        <seg>选项格式有两种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There exist one overload of this operator: `onBackpressureDrop(Consumer&lt;? super T&gt; onDrop)`  where the (shared) action is called with the value being dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015000Z" creationid="pingfangx" creationdate="20190624T015000Z">
        <seg>这个操作符有一个重载：`onBackpressureDrop(Consumer&lt;? super T&gt; onDrop)`，其中调用(共享)动作并删除该值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a wide variety of architectures and configurations of caches deployed across the World Wide Web and inside large organizations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102349Z" creationid="pingfangx" creationdate="20190830T102349Z">
        <seg>在万维网和大型组织内部署了各种各样的缓存架构和配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a variety that takes a &lt;a0&gt;Scheduler&lt;/a0&gt; as an argument:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075402Z" creationid="pingfangx" creationdate="20190620T075402Z">
        <seg>还有一个变种采用 &lt;a0&gt;Scheduler&lt;/a0&gt; 作为参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a version of this operator that allows you to perform the delay on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075341Z" creationid="pingfangx" creationdate="20190620T075341Z">
        <seg>还有一个此操作符的版本，允许您对特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 执行延迟：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also an instance version of this operator:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075313Z" creationid="pingfangx" creationdate="20190620T075313Z">
        <seg>还有这个操作符的实例版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is an exception to this rule: for compatibility with RFC 2068, a server MAY send a 100 (Continue) status in response to an HTTP/1.1 PUT or POST request that does not include an Expect request-header field with the "100- continue" expectation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025228Z" creationid="pingfangx" creationdate="20190830T025228Z">
        <seg>此规则有一个例外：为了与 RFC 2068 兼容，服务器可以发送 100(继续)状态以响应 HTTP/1.1 PUT 或 POST 请求，该请求不包含具有“100- continue”期待的 Expect 请求首部字段继续。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no `FlowableSource` since `Publisher` is provided by the Reactive Streams library (and subtyping it wouldn't have helped with interoperation either).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104518Z" creationid="pingfangx" creationdate="20190617T104518Z">
        <seg>没有 `FlowableSource`，因为 `Publisher` 是由 Reactive Streams 库提供的(子类型化也不会有助于互操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no canonical naming standard, though there are many commonalities between implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064538Z" creationid="pingfangx" creationdate="20190620T064538Z">
        <seg>虽然实现之间存在许多共性，但没有规范的命名标准。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no default encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121318Z" creationid="pingfangx" creationdate="20190829T121318Z">
        <seg>没有默认编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no error and everything runs smoothly with small memory usage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080515Z" creationid="pingfangx" creationdate="20190621T080432Z">
        <seg>这将没有错误，一切运行顺畅，内存使用量很少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one exception to the above rule.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093716Z" creationid="pingfangx" creationdate="20190901T093716Z">
        <seg>上述规则有一个例外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may exist multiple representations associated with a particular response status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081148Z" creationid="pingfangx" creationdate="20190828T081148Z">
        <seg>可能存在与特定响应状态相关联的多个表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, 2.0.6 introduces specific exception wrappers to help distinguish and track down what was happening the time of the error:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091015Z" creationid="pingfangx" creationdate="20190618T091015Z">
        <seg>因此，2.0.6 引入了特定的异常包装器，以帮助区分和跟踪错误发生时的情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, RxJava chose to name this operator `just(T)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101822Z" creationid="pingfangx" creationdate="20190617T101822Z">
        <seg>因此，RxJava 选择将此运算符命名为 `just(T)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if the two are swapped, the example still works the same:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082820Z" creationid="pingfangx" creationdate="20190621T082820Z">
        <seg>因此，如果两者交换，示例仍然正常工作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, many operators that required some reactive base type from the user now accept `Publisher` and `XSource`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061451Z" creationid="pingfangx" creationdate="20190618T061451Z">
        <seg>因此，许多需要用户使用某种响应基类型的运算符现在接受 `Publisher` 和 `XSource`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, one should do all field initialization in `onStart` or even before that and call `request()` last.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083947Z" creationid="pingfangx" creationdate="20190621T083947Z">
        <seg>因此，应该在 `onStart` 中甚至在此之前进行所有字段初始化，并最后调用 `request()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the following sequence won't call `doOnCancel`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115027Z" creationid="pingfangx" creationdate="20190618T115027Z">
        <seg>因此，以下序列不会调用 `doOnCancel`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the integer values used by the ABNF must be mapped back to their corresponding characters via US-ASCII in order to complete the syntax rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065058Z" creationid="pingfangx" creationdate="20190902T065058Z">
        <seg>因此，必须通过 US-ASCII 将 ABNF 使用的整数值映射回其对应的字符，以便完成语法规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, when a client sends this header field to an origin server (possibly via a proxy) from which it has never seen a 100 (Continue) status, the client SHOULD NOT wait for an indefinite period before sending the request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T024704Z" creationid="pingfangx" creationdate="20190830T024704Z">
        <seg>因此，当客户端将此首部字段发送到原始服务器(可能通过代理)时，它从未看到过 100(继续)状态，客户端不应该在发送请求主体之前无限期等待。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, where at least one element is required, at least one non-null element MUST be present.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094058Z" creationid="pingfangx" creationdate="20190828T094058Z">
        <seg>因此，在需要至少一个元素的情况下，必须存在至少一个非空元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071736Z" creationid="pingfangx" creationdate="20190620T071736Z">
        <seg>这些 Rx 操作符允许您以声明方式组合异步序列，它具有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are available on all JVM platforms but some specific platforms, such as Android, have their own typical `Scheduler`s defined: `AndroidSchedulers.mainThread()`, `SwingScheduler.instance()` or `JavaFXSchedulers.gui()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073609Z" creationid="pingfangx" creationdate="20190617T073609Z">
        <seg>这些在所有 JVM 平台上都可用，但某些特定平台（如 Android）有自己典型的 `Scheduler`：`AndroidSchedulers.mainThread()`，`SwingScheduler.instance()` 或 `JavaFXSchedulers.gui()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are by themselves worthy of a full series so let's see some very basic `Iterable` source that repeats some constant value indefinitely:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020455Z" creationid="pingfangx" creationdate="20190624T020455Z">
        <seg>这些本身就值得一个完整的系列，所以让我们看一些非常基本的 `Iterable` 源，它无限地重复一些常量值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are often browsers, editors, spiders (web-traversing robots), or other end user tools.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081317Z" creationid="pingfangx" creationdate="20190828T081317Z">
        <seg>这些通常是浏览器，编辑器，蜘蛛(网络遍历机器人)或其他最终用户工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are usually named with the suffix of the target type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100713Z" creationid="pingfangx" creationdate="20190617T100713Z">
        <seg>这些通常以目标类型的后缀命名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These characters are called "reserved" because they may (or may not) be defined as delimiters by the generic syntax, by each scheme-specific syntax, or by the implementation-specific syntax of a URI's dereferencing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070056Z" creationid="pingfangx" creationdate="20190902T070056Z">
        <seg>这些字符称为“保留(reserved)”，因为它们可能(或可能不)通过通用语法，每种特定于方案的语法或 URI 的解除引用算法的特定于实现的语法定义为分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These codes are fully defined in section 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T105431Z" creationid="pingfangx" creationdate="20190829T105431Z">
        <seg>这些代码在第 10 节中有详细说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These define a two-layer, ordered encoding model:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121234Z" creationid="pingfangx" creationdate="20190829T121234Z">
        <seg>这些定义了一个两层有序编码模型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These fields act as request modifiers, similar to the parameters on a programming language method invocation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144230Z" creationid="pingfangx" creationdate="20190831T144230Z">
        <seg>这些字段充当请求修饰符，类似于编程语言方法调用的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These fields act as request modifiers, with semantics equivalent to the parameters on a programming language method invocation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T102255Z" creationid="pingfangx" creationdate="20190829T102255Z">
        <seg>这些字段充当请求修饰符，其语义等同于编程语言方法调用的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These guidelines are intended to improve HTTP response times and avoid congestion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152632Z" creationid="pingfangx" creationdate="20190829T152632Z">
        <seg>这些准则旨在改善 HTTP 响应时间并避免拥塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These header fields apply only to the message being transmitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T091824Z" creationid="pingfangx" creationdate="20190829T091824Z">
        <seg>这些首部字段仅适用于正在传输的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These header fields give information about the server and about further access to the resource identified by the Request-URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T110841Z" creationid="pingfangx" creationdate="20190829T110841Z">
        <seg>这些首部字段提供有关服务器的信息以及有关 Request-URI 标识的资源的进一步访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These header fields give information about the server, about further access to the target resource, or about related resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T144830Z" creationid="pingfangx" creationdate="20190831T144830Z">
        <seg>这些首部字段提供有关服务器，有关对目标资源的进一步访问或相关资源的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include national hierarchies of proxy caches to save transoceanic bandwidth, collaborative systems that broadcast or multicast cache entries, archives of pre-fetched cache entries for use in off-line or high-latency environments, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102413Z" creationid="pingfangx" creationdate="20190830T102413Z">
        <seg>这些包括用于保存跨洋带宽的代理高速缓存的国家层次结构，用于广播或多播高速缓存条目的协作系统，用于离线或高延迟环境的预取高速缓存条目的存档等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include uppercase and lowercase letters, decimal digits, hyphen, period, underscore, and tilde.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071237Z" creationid="pingfangx" creationdate="20190902T071237Z">
        <seg>这些包括大写和小写字母，十进制数字，连字符，句点，下划线和波浪号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These instruct the operator to do some or all of its work on a particular Scheduler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085827Z" creationid="pingfangx" creationdate="20190620T085827Z">
        <seg>这会指示操作符在特定的调度器上完成部分或全部工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These interfaces are, however, not standard in the sense of the Reactive Streams specification and are currently RxJava specific only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104540Z" creationid="pingfangx" creationdate="20190617T104540Z">
        <seg>但是，这些接口在 Reactive Streams 规范的意义上并不是标准的，并且目前仅针对 RxJava。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET “SelectMany” operator links to the documentation of the &lt;s0&gt;FlatMap&lt;/s0&gt; ReactiveX operator, of which “SelectMany” is the Rx.NET implementation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094320Z" creationid="pingfangx" creationdate="20190620T094320Z">
        <seg>这些链接到记录核心操作符的页面，该核心操作符最类似于特定于语言的操作符（例如，Rx.NET “SelectMany” 操作符链接到 &lt;s0&gt;FlatMap&lt;/s0&gt; ReactiveX 操作符的文档，其中“SelectMany”是 Rx.NET 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods allow only a single resource to be associated with the emitter at a time and setting a new one unsubscribes the old one automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022745Z" creationid="pingfangx" creationdate="20190624T022745Z">
        <seg>这些方法一次只允许一个源与 emitter 相关联，并且设置一个新资源会自动取消订阅旧资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods ought to be considered "safe".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T032316Z" creationid="pingfangx" creationdate="20190830T032316Z">
        <seg>这些方法应该被认为是“安全的 (safe)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072226Z" creationid="pingfangx" creationdate="20190620T072226Z">
        <seg>这些页面包含的一些操作符的信息，这些操作符不属于 ReactiveX 的核心，而是在一个或多个特定于语言的实现和/或可选模块中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These patterns also allow you to chain the methods in a similar way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072842Z" creationid="pingfangx" creationdate="20190620T072842Z">
        <seg>这些模式也允许您以类似的方式链接方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties should be true even in the face of an attacker who has complete control of the network, as described in [RFC3552].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T123726Z" creationid="pingfangx" creationdate="20190901T123726Z">
        <seg>即使面对完全控制网络的攻击者，这些属性也应该是正确的，如 [RFC3552] 中所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements allow HTTP's functionality to be enhanced without requiring prior update of deployed intermediaries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082120Z" creationid="pingfangx" creationdate="20190831T082120Z">
        <seg>这些要求允许增强 HTTP 的功能，而无需事先更新已部署的中介。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These restrictions exist in order to preserve the self-delimiting nature of a multipart message- body, wherein the "end" of the message-body is indicated by the ending multipart boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152549Z" creationid="pingfangx" creationdate="20190828T152549Z">
        <seg>存在这些限制是为了保持多部分消息体的自定界性质，其中消息体的“结束”由结束的多部分边界指示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These restrictions result in five different ABNF rules for a path (Section 3.3), only one of which will match any given URI reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072311Z" creationid="pingfangx" creationdate="20190902T072311Z">
        <seg>这些限制导致路径的五个不同的 ABNF 规则(第 3.3 节)，其中只有一个匹配任何给定的 URI 引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules allow the recipient to determine the transfer-length of the message (section 4.4).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142828Z" creationid="pingfangx" creationdate="20190828T142828Z">
        <seg>这些规则允许收件人确定邮件的传输长度(第 4.4 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These special characters MUST be in a quoted string to be used within a parameter value (as defined in section 3.6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T101700Z" creationid="pingfangx" creationdate="20190828T101700Z">
        <seg>这些特殊字符必须位于引用的字符串中，以便在参数值中使用(如第 3.6 节中所定义)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems include national hierarchies of proxy caches to save transoceanic bandwidth, systems that broadcast or multicast cache entries, organizations that distribute subsets of cached data via CD-ROM, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T144827Z" creationid="pingfangx" creationdate="20190828T091326Z">
        <seg>这些系统包括用于保存跨洋带宽的代理缓存的国家层次结构，用于广播或多播缓存条目的系统，通过 CD-ROM 分发缓存数据子集的组织等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These terms should not be mistaken as an assumption that an identifier defines or embodies the identity of what is referenced, though that may be the case for some identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060910Z" creationid="pingfangx" creationdate="20190902T060910Z">
        <seg>这些术语不应该被误认为是标识符定义或体现所引用内容的标识的假设，尽管某些标识符可能就是这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They MUST NOT be used for advertising or other non-essential information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T153147Z" creationid="pingfangx" creationdate="20190828T153147Z">
        <seg>它们不得用于广告或其他非必要信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are distinct namespaces and are considered to be distinct origin servers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060731Z" creationid="pingfangx" creationdate="20190831T060731Z">
        <seg>它们是不同的名称空间，被认为是不同的源服务器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are intended for use at the beginning of a relative-path reference (Section 4.2) to indicate relative position within the hierarchical tree of names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082415Z" creationid="pingfangx" creationdate="20190902T082415Z">
        <seg>它们旨在用于相对路径引用(第 4.2 节)的开头，以指示名称的分层树中的相对位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are naturally efficient because they execute when the response is ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041028Z" creationid="pingfangx" creationdate="20190620T041028Z">
        <seg>它们自然有效，因为它们在响应准备就绪时执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are purely to allow broad testing and feedback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105331Z" creationid="pingfangx" creationdate="20190617T105331Z">
        <seg>它们纯粹是为了进行广泛的测试和反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be modified in any way, or even removed, at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105240Z" creationid="pingfangx" creationdate="20190617T105240Z">
        <seg>它们可以随时以任何方式进行修改，甚至可以删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They will have different group ids (`io.reactivex.rxjava2` vs `io.reactivex`) and namespaces (`io.reactivex` vs `rx`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065528Z" creationid="pingfangx" creationdate="20190617T065528Z">
        <seg>他们将拥有不同的组 ID (`io.reactivex.rxjava2` vs `io.reactivex`) 和名称空间 (`io.reactivex` vs `rx`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This "selected representation" is used to provide the data and metadata for evaluating conditional requests [RFC7232] and constructing the payload for 200 (OK) and 304 (Not Modified) responses to GET (Section 4.3.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133042Z" creationid="pingfangx" creationdate="20190831T133042Z">
        <seg>这个“选定表示”用于提供数据和元数据，用于评估条件请求 [RFC7232] 和构建 200(OK)和 304(未修改)对 GET 响应的有效载荷(第 4.3.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;a1&gt;can be done&lt;/a1&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;c2&gt;Future.get()&lt;/c2&gt;, which eliminates the benefit of asynchronous execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035327Z" creationid="pingfangx" creationdate="20190620T035327Z">
        <seg>当然，这 &lt;a1&gt;可以实现&lt;/a1&gt;，但它很快变得复杂(因而容易出错)或者过早地阻塞了 &lt;c2&gt;Future.get()&lt;/c2&gt;，这消除了异步执行的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This HTTP/1.1 specification obsoletes RFC 2616 and RFC 2145 (on HTTP versioning).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094115Z" creationid="pingfangx" creationdate="20190830T094115Z">
        <seg>此 HTTP/1.1 规范废弃了 RFC 2616 和 RFC 2145(关于 HTTP 版本控制)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This SHOULD only be done when the application knows (typically through detecting HTTP message boundaries) that it has received all the message data that it cares about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T092139Z" creationid="pingfangx" creationdate="20190901T092139Z">
        <seg>只有当应用程序知道(通常通过检测 HTTP 消息边界)它已经接收到它关心的所有消息数据时，才应该这样做。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This Scheduler has three additional methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091825Z" creationid="pingfangx" creationdate="20190620T091825Z">
        <seg>此调度器还有三种方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113448Z" creationid="pingfangx" creationdate="20190831T113448Z">
        <seg>这允许将连接升级到具有与 HTTP 相同语义的协议，而无需额外往返的延迟成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows constraining the memory usage of the dataflows in situations where there is generally no way for a step to know how many items the upstream will send to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071409Z" creationid="pingfangx" creationdate="20190617T071409Z">
        <seg>这允许在通常无法知道上游将向其发送多少项的步骤的情况下约束数据流的存储器使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows creating stream consumers with less internal state than the quite heavy `rx.Subscriber` of 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065453Z" creationid="pingfangx" creationdate="20190618T065453Z">
        <seg>这允许创建具有比 1.x 的非常重​​的 `rx.Subscriber` 更少的内部状态的流消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows dynamically produced content to be transferred along with the information necessary for the recipient to verify that it has received the full message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T143806Z" creationid="pingfangx" creationdate="20190828T143806Z">
        <seg>这允许动态生成的内容与接收方验证其已收到完整消息所需的信息一起传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows for efficient execution and composition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041859Z" creationid="pingfangx" creationdate="20190620T041859Z">
        <seg>这些操作符让执行和复合变得非常高效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T032343Z" creationid="pingfangx" creationdate="20190830T032343Z">
        <seg>这允许用户代理以特殊方式表示其他方法，例如 POST，PUT 和 DELETE，以便使用户意识到正在请求可能不安全的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to apply these operators one after the other, in a chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072332Z" creationid="pingfangx" creationdate="20190620T072332Z">
        <seg>这允许您在链中一个接一个地应用这些操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025324Z" creationid="pingfangx" creationdate="20190828T025324Z">
        <seg>仅这一点并不能保证从网络中排出旧的重复数据，因此序列空间已经非常大，以减少流浪复制品在到达时会造成麻烦的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is more flexible, because values can arrive synchronously or asynchronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042157Z" creationid="pingfangx" creationdate="20190620T042157Z">
        <seg>这种方法更灵活，因为值可以同步或异步到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior differs from 1.x where a `request` call went through a deferred logic that accumulated requests until an upstream `Producer` arrived at some time (This nature adds overhead to all operators and consumers in 1.x.) In 2.x, there is always a `Subscription` coming down first and 90% of the time there is no need to defer requesting.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072117Z" creationid="pingfangx" creationdate="20190618T072117Z">
        <seg>这种行为不同于 1.x，其中 `request` 调用通过延迟逻辑累积请求，直到上游 `Producer` 在某个时间到达(这种性质增加了 1.x 中所有运算符和消费者的开销)。在 2.x 中，总是有一个 `Subscription` 首先出现，90% 的时间不需要延迟请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This callback is executed as many times as the downstream requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021228Z" creationid="pingfangx" creationdate="20190624T021228Z">
        <seg>此回调的执行次数与下游请求的次数相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be achieved by moving the outer `flatMap` into the inner parts of the previous `flatMap` for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083752Z" creationid="pingfangx" creationdate="20190617T083752Z">
        <seg>这可以通过将外部 `flatMap` 移动到前一个 `flatMap` 的内部部分来实现，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be used, for example, to have a larger but still fixed pool of threads (unlike `computation()` and `io()` respectively).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073827Z" creationid="pingfangx" creationdate="20190617T073827Z">
        <seg>例如，这可用于拥有更大但仍然固定的线程池(分别与 `calculation()` 和 `io()` 不同)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful for testing interactions that depend on precise arrangements of actions in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091822Z" creationid="pingfangx" creationdate="20190620T091822Z">
        <seg>这对于测试依赖于及时精确的动作安排的交互是有用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful in some telemetry-like situations where the data may come in some bursty pattern but only the very latest is interesting for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015225Z" creationid="pingfangx" creationdate="20190624T015225Z">
        <seg>这在类似遥测的情况下非常有用，在这种情况下，数据可能会以某种突发模式出现，但只有最新的数据才会对处理感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can get also ambiguous when functional interface types get involved as the type argument `T`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103113Z" creationid="pingfangx" creationdate="20190617T103113Z">
        <seg>当函数接口类型作为类型参数 `T` 参与时，这也会变得有歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can have the effect of making the resulting Subject a “hot” Observable variant of the original “cold” Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083654Z" creationid="pingfangx" creationdate="20190620T083654Z">
        <seg>这可以使得到的 Subject 成为原始“冷” Observable 的“热” Observable 变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This content-coding is used only in the Accept-Encoding header, and SHOULD NOT be used in the Content-Encoding header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141306Z" creationid="pingfangx" creationdate="20190828T141306Z">
        <seg>此内容编码仅在 Accept-Encoding 首部中使用，并且不应在 Content-Encoding 首部中使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This decouples the evolution of identification schemes from the evolution of protocols, data formats, and implementations that make use of URIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061955Z" creationid="pingfangx" creationdate="20190902T061955Z">
        <seg>这使得识别方案的演变与使用 URI 的协议，数据格式和实现的演变分离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition is intended to allow various kinds of character encoding, from simple single-table mappings such as US-ASCII to complex table switching methods such as those that use ISO-2022's techniques.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T114946Z" creationid="pingfangx" creationdate="20190828T114946Z">
        <seg>此定义旨在允许各种字符编码，从简单的单表映射(如 US-ASCII)到复杂的表切换方法(如使用 ISO-2022 技术的那些)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134109Z" creationid="pingfangx" creationdate="20190831T134109Z">
        <seg>安全方法的这种定义并不妨碍实现包含可能有害的行为，不完全是只读的行为，或者在调用安全方法时导致副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This diagram explains how Singles are represented in marble diagrams:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075156Z" creationid="pingfangx" creationdate="20190620T075156Z">
        <seg>此图解释了 Single 如何在 marble 图中表示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This differs from a content coding in that the transfer-coding is a property of the message, not of the original entity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142124Z" creationid="pingfangx" creationdate="20190828T142124Z">
        <seg>这与内容编码的不同之处在于，传输编码是消息的属性，而不是原始实体的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction is important because some HTTP communication options may apply only to the connection with the nearest, non-tunnel neighbor, only to the end-points of the chain, or to all connections along the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T090200Z" creationid="pingfangx" creationdate="20190828T090200Z">
        <seg>这种区别很重要，因为某些 HTTP 通信选项可能仅适用于与最近的非隧道邻居的连接，仅适用于链的端点或链中的所有连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This division allows for the existence of host level protocols other than TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T104752Z" creationid="pingfangx" creationdate="20190827T104752Z">
        <seg>这种划分允许存在除 TCP 之外的主机级协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document also defines representation metadata that describe how a payload is intended to be interpreted by a recipient, the request header fields that might influence content selection, and the various selection algorithms that are collectively referred to as "content negotiation" (Section 3.4).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121755Z" creationid="pingfangx" creationdate="20190831T121755Z">
        <seg>本文档还定义了表示元数据，描述了接收者如何解释有效载荷，可能影响内容选择的请求首部字段，以及统称为“内容协商”的各种选择算法(第 3.4 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document also specifies new requirements for TLS 1.2 implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121407Z" creationid="pingfangx" creationdate="20190901T121407Z">
        <seg>本文档还规定了 TLS 1.2 实现的新要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document defines HTTP/1.1 request and response semantics in terms of the architecture defined in [RFC7230].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T121640Z" creationid="pingfangx" creationdate="20190831T121640Z">
        <seg>本文档根据 [RFC7230] 中定义的体系结构定义 HTTP/1.1 请求和响应语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document defines a grammar that is a superset of all valid URI, such that an implementation can parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035516Z" creationid="pingfangx" creationdate="20190902T035516Z">
        <seg>本文档定义了一个语法，它是所有有效 URI 的超集，因此实现可以解析 URI 引用的公共组件，而无需了解每种可能的标识符类型的特定于方案的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document defines the generic syntax of URI, including both absolute and relative forms, and guidelines for their use; it revises and replaces the generic definitions in RFC 1738 and RFC 1808.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035503Z" creationid="pingfangx" creationdate="20190902T035503Z">
        <seg>本文档定义了 URI 的通用语法，包括绝对和相对形式，以及它们的使用指南；它修改并替换了 RFC 1738 和 RFC 1808 中的通用定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T115518Z">
        <seg>本文档定义了 HTTP/1.1 消息的语义，如请求方法，请求首部字段，响应状态代码和响应首部字段，以及消息的有效载荷(元数据和正文内容)以及内容协商机制所表示的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes how to use HTTP over TLS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091124Z" creationid="pingfangx" creationdate="20190901T091124Z">
        <seg>本文档介绍如何使用 HTTP over TLS。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes the architectural elements that are used or referred to in HTTP, defines the "http" and "https" URI schemes, describes overall network operation and connection management, and defines HTTP message framing and forwarding requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094430Z" creationid="pingfangx" creationdate="20190830T094430Z">
        <seg>本文档描述了在 HTTP 中使用或引用的体系结构元素，定义了“http”和“https”URI 方案，描述了整体网络操作和连接管理，并定义了 HTTP 消息成帧和转发要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document documents that practice using TLS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T085651Z" creationid="pingfangx" creationdate="20190901T085651Z">
        <seg>本文档记录了使用 TLS 的练习。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document does not define a generative grammar for URI; that task will be performed by the individual specifications of each URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035523Z" creationid="pingfangx" creationdate="20190902T035523Z">
        <seg>本文档没有定义 URI 的生成语法；该任务将由每个 URI 方案的各个规范执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document does not discuss the issues and recommendation for dealing with characters outside of the US-ASCII character set [ASCII]; those recommendations are discussed in a separate document.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035909Z" creationid="pingfangx" creationdate="20190902T035909Z">
        <seg>本文档不讨论处理 US-ASCII 字符集 [ASCII] 之外的字符的问题和建议；这些建议将在另一份文件中讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is a product of the Internet Engineering Task Force (IETF).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090442Z" creationid="pingfangx" creationdate="20190830T090442Z">
        <seg>本文档是互联网工程任务组(IETF)的产品。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is the first in a series of documents that collectively form the HTTP/1.1 specification:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T093338Z" creationid="pingfangx" creationdate="20190830T093338Z">
        <seg>本文档是一系列文档中的第一个，它们共同构成了 HTTP/1.1 规范：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document obsoletes [RFC2396], which merged "Uniform Resource Locators" [RFC1738] and "Relative Uniform Resource Locators" [RFC1808] in order to define a single, generic syntax for all URIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T043106Z" creationid="pingfangx" creationdate="20190902T043106Z">
        <seg>本文档废弃 [RFC2396]，它合并了“统一资源定位符”[RFC1738] 和“相对统一资源定位符”[RFC1808]，以便为所有 URI 定义单个通用语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090410Z" creationid="pingfangx" creationdate="20190830T090410Z">
        <seg>本文档概述了 HTTP 体系结构及其相关术语，定义了“http”和“https”统一资源标识符(URI)方案，定义了 HTTP/1.1 消息语法和解析要求，并描述了实现的相关安全性问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T070847Z" creationid="pingfangx" creationdate="20190828T070847Z">
        <seg>本文档为互联网社区指定了互联网标准跟踪协议，并请求讨论和改进建议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121305Z" creationid="pingfangx" creationdate="20190901T121305Z">
        <seg>本文档规定了传输层安全性(TLS)协议的 1.3 版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121403Z" creationid="pingfangx" creationdate="20190901T121403Z">
        <seg>本文档更新了 RFC 5705 和 6066，并废弃了 RFC 5077,5246 和 6961。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document updates and merges "Uniform Resource Locators" [RFC1738] and "Relative Uniform Resource Locators" [RFC1808] in order to define a single, generic syntax for all URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035841Z" creationid="pingfangx" creationdate="20190902T035841Z">
        <seg>本文档更新并合并“统一资源定位符”[RFC1738] 和“相对统一资源定位符”[RFC1808]，以便为所有 URI 定义单个通用语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document will use the following terms: An &lt;d0&gt;observer&lt;/d0&gt; &lt;d1&gt;subscribes&lt;/d1&gt; to an &lt;d2&gt;Observable&lt;/d2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045732Z" creationid="pingfangx" creationdate="20190620T045732Z">
        <seg>本文档将使用以下术语：&lt;d0&gt;observer (观察者)&lt;/d0&gt; &lt;d1&gt;subscribes (订阅)&lt;/d1&gt; 到 &lt;d2&gt;Observable (可观察对象)&lt;/d2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation accompanies its explanations with “marble diagrams.” Here is how marble diagrams represent Observables and transformations of Observables:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044318Z" creationid="pingfangx" creationdate="20190620T044318Z">
        <seg>本文档的说明会带有“marble 图”。以下是 marble 图如何表示 Observables 的 Observables 的转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation groups information about &lt;a0&gt;the various operators&lt;/a0&gt; and examples of their usage into the following pages:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071815Z" creationid="pingfangx" creationdate="20190620T071815Z">
        <seg>本文档将有关 &lt;a0&gt;各种操作符&lt;/a0&gt; 的信息及其用法示例分组到以下页面中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092120Z" creationid="pingfangx" creationdate="20190828T092120Z">
        <seg>这并不妨碍 HTTP 在 Internet 上或其他网络上的任何其他协议之上实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not preclude HTTP/TLS from being run over another transport.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103306Z" creationid="pingfangx" creationdate="20190901T103306Z">
        <seg>这并不妨碍 HTTP/TLS 在另一个传输上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example flow squares the numbers from 1 to 10 on the **computation** `Scheduler` and consumes the results on the "main" thread (more precisely, the caller thread of `blockingSubscribe`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075535Z" creationid="pingfangx" creationdate="20190617T075535Z">
        <seg>这个示例流在 **computation** `Scheduler` 上将数字 1 到 10 计算平方，并在 "main" 线程上消费结果(更确切地说，是 `blockingSubscribe` 的调用者线程)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This exception, the purpose of which is to minimize any client processing delays associated with an undeclared wait for 100 (Continue) status, applies only to HTTP/1.1 requests, and not to requests with any other HTTP- version value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025304Z" creationid="pingfangx" creationdate="20190830T025304Z">
        <seg>此异常的目的是最小化与未声明等待 100(继续)状态相关联的任何客户端处理延迟，仅适用于 HTTP/1.1 请求，而不适用于具有任何其他 HTTP 版本值的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110702Z" creationid="pingfangx" creationdate="20190827T110702Z">
        <seg>该字段将紧急指针的当前值传递为该报文段中序列号的正偏移量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This field is only be interpreted in segments with the URG control bit set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110733Z" creationid="pingfangx" creationdate="20190827T110733Z">
        <seg>该字段仅在设置了 URG 控制位的报文段中进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This flexibility regarding line breaks applies only to text media in the entity-body; a bare CR or LF MUST NOT be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151608Z" creationid="pingfangx" creationdate="20190828T151608Z">
        <seg>关于换行的这种灵活性仅适用于实体主体中的文本媒体；在任何 HTTP 控制结构(例如首部字段和多部分边界)内，绝不能用 CR 或 LF 代替 CRLF。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This format is a Lempel-Ziv coding (LZ77) with a 32 bit CRC.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T140943Z" creationid="pingfangx" creationdate="20190828T140943Z">
        <seg>该格式是具有 32 位 CRC 的 Lempel-Ziv 编码(LZ77)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This format is an adaptive Lempel-Ziv-Welch coding (LZW).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141007Z" creationid="pingfangx" creationdate="20190828T141007Z">
        <seg>该格式是自适应 Lempel-Ziv-Welch 编码(LZW)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the TCP protection against misrouted segments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110215Z" creationid="pingfangx" creationdate="20190827T110215Z">
        <seg>这为 TCP 提供了针对错误路由的报文段的保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This handler can be overridden with the method `RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090229Z" creationid="pingfangx" creationdate="20190618T090229Z">
        <seg>可以使用方法 `RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)` 覆盖此处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T142247Z" creationid="pingfangx" creationdate="20190831T142247Z">
        <seg>这具有以下优点：向用户代理提供资源标识符并通过更适合于共享缓存的方法来传送表示，但是如果用户代理尚未具有缓存的表示，则以额外请求为代价。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the consequence that even a backpressure-supporting source such as `range` will be completely realized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093127Z" creationid="pingfangx" creationdate="20190621T093030Z">
        <seg>这样的结果是，即使是一个支持背压的源，如 `range` ，也将完全 realized。（译注：不知道怎么译）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This indicates where the data begins.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105250Z" creationid="pingfangx" creationdate="20190827T105250Z">
        <seg>这表示数据的起始位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092716Z" creationid="pingfangx" creationdate="20190831T092716Z">
        <seg>但是，此指示不是必需的，因为响应链上的任何接收者(包括源服务器)都可以在不需要时删除传输编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110405Z" creationid="pingfangx" creationdate="20190827T110405Z">
        <seg>此信息在 IP 协议中承载，并通过 TCP / 网络接口在 IP 上的 TCP 调用的参数或结果中传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface is lightweight and combines request management with cancellation into a single interface `org.reactivestreams.Subscription` instead of having `rx.Producer` and `rx.Subscription` separately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065405Z" creationid="pingfangx" creationdate="20190618T065405Z">
        <seg>这个接口是轻量级的，它将请求管理和取消组合到单个接口 `org.reactivestreams.Subscription` 中，而不是单独使用 `rx.Producer` 和 `rx.Subscription`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a bounded version that signals `BufferOverflowError`in case its buffer reaches the given capacity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093138Z" creationid="pingfangx" creationdate="20190621T093138Z">
        <seg>这是一个有界版本，在其缓冲区达到给定容量的情况下发出 `BufferOverflowError` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a large convenience for consumers and mappers that otherwise throw and would need `try-catch` to transform or suppress a checked exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064255Z" creationid="pingfangx" creationdate="20190618T064255Z">
        <seg>这对于消费者和映射器来说是一个很大的便利，否则会抛出并且需要 `try-catch` 来转换或抑制检查型异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a simple way of including useful notes in parallel with the specifications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094220Z" creationid="pingfangx" creationdate="20190828T094220Z">
        <seg>这是一种与规范并行包含有用注释的简单方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a temporary state when `subscribe()` is called on a flow that establishes the chain of processing steps internally:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072138Z" creationid="pingfangx" creationdate="20190617T071850Z">
        <seg>当在内部建立处理步骤链的流上调用 `subscribe()` 时，这是一个临时状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T035131Z" creationid="pingfangx" creationdate="20190828T022537Z">
        <seg>这是通过在序列空间中隐含地包括一些控制标志来实现的，这样它们可以被重传和确认而不会混淆(即，控制位的一个且仅一个副本将被作用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an Internet Standards Track document.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090430Z" creationid="pingfangx" creationdate="20190830T090430Z">
        <seg>这是一个互联网标准跟踪文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an engineering choice, and may be changed if experience indicates it is desirable to do so.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024425Z" creationid="pingfangx" creationdate="20190828T024425Z">
        <seg>这是一种工程选择，如果经验表明需要这样做，可能会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done in an exchange of connection establishing segments carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023657Z" creationid="pingfangx" creationdate="20190828T023657Z">
        <seg>这是在交换连接建立报文段间完成的，该报文段带有称为“SYN”(表示 synchronize)的控制位和初始序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is illustrated in figure 11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060215Z" creationid="pingfangx" creationdate="20190828T060215Z">
        <seg>这在图 11 中说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is indicated in the first two formats by the inclusion of "GMT" as the three-letter abbreviation for time zone, and MUST be assumed when reading the asctime format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T113935Z" creationid="pingfangx" creationdate="20190828T113935Z">
        <seg>前两种格式通过包含“GMT”作为时区的三字母缩写来表示，并且在读取 asctime 格式时必须假设。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064500Z" creationid="pingfangx" creationdate="20190620T064500Z">
        <seg>但是，这并不能保证立即发生，即使在没有观察者观察这些发射之后，Observable 也有可能在一段时间内产生并尝试发射数据项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often more apparent when each element is written on a separate line:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071017Z" creationid="pingfangx" creationdate="20190617T071017Z">
        <seg>当每个元素写在一个单独的行上时，这通常更明显：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to their role within some operating systems' file directory structures to indicate the current directory and parent directory, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082441Z" creationid="pingfangx" creationdate="20190902T082441Z">
        <seg>这类似于它们在某些操作系统的文件目录结构中的作用，分别表示当前目录和父目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is sometimes called **continuations** and, depending on what should happen and what types are involved, may involve various operators to accomplish.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083603Z" creationid="pingfangx" creationdate="20190617T083603Z">
        <seg>这有时被称为 **continuations** ，并且取决于应该发生什么以及涉及什么类型，可能涉及各种操作符来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the only place where square bracket characters are allowed in the URI syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074450Z" creationid="pingfangx" creationdate="20190902T074450Z">
        <seg>这是 URI 语法中唯一允许使用方括号字符的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the state when the flows are actively emitting items, errors or completion signals:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072024Z" creationid="pingfangx" creationdate="20190617T072024Z">
        <seg>这是流主动发出项目，错误或完成信号时的状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the true power of lazily evaluating and computing inside `Flowable`s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020651Z" creationid="pingfangx" creationdate="20190624T020651Z">
        <seg>这是 `Flowable` 内部的懒评估和计算的真正力量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is typically because such services are implemented via a gateway that requires a content-length in advance of being called and the server is unable or unwilling to buffer the entire request before processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102430Z" creationid="pingfangx" creationdate="20190831T102430Z">
        <seg>这通常是因为这样的服务是通过网关实现的，该网关在被调用之前需要内容长度并且服务器在处理之前不能或不愿意缓冲整个请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very important because now any operation you can perform on an Iterable, you can also perform on an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042520Z" creationid="pingfangx" creationdate="20190620T042520Z">
        <seg>这非常重要，因为现在您可以在 Iterable 上执行的任何操作，都可以在 Observable 上执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is when the **subscription side-effects** are triggered (see `doOnSubscribe`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072144Z" creationid="pingfangx" creationdate="20190617T071932Z">
        <seg>这是 **subscription side-effects (订阅副作用)** 的触发时机(参见 `doOnSubscribe`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means errors that can't be emitted because the downstream's lifecycle already reached its terminal state or the downstream cancelled a sequence which was about to emit an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090043Z" creationid="pingfangx" creationdate="20190618T090043Z">
        <seg>这意味着无法发出的错误，因为下游的生命周期已达到其终端状态，或者下游取消了将要发出错误的序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that `Observable&lt;Void&gt;` can no longer emit any values but only terminate normally or with an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052823Z" creationid="pingfangx" creationdate="20190618T052823Z">
        <seg>这意味着 `Observable&lt;Void&gt;` 不能再发出任何值，只能正常终止或带异常终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that an invocation of `onSubscribe(Disposable)` is potentially followed by one of the other `onXXX` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060840Z" creationid="pingfangx" creationdate="20190618T060840Z">
        <seg>这意味着 `onSubscribe(Disposable)` 的调用可能跟随其他 `onXXX` 方法之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that clients, servers, and proxies MUST be able to recover from asynchronous close events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152249Z" creationid="pingfangx" creationdate="20190829T152249Z">
        <seg>这意味着客户端，服务器和代理必须能够从异步关闭事件中恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism allows for straight-forward duplicate detection in the presence of retransmission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021057Z" creationid="pingfangx" creationdate="20190828T021057Z">
        <seg>该机制允许在存在重传的情况下进行直接重复检测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This media type UST NOT be used unless the sender knows that the recipient can arse it; the presence in a request of a Range header with ultiple byte- range specifiers from a 1.1 client implies that the lient can parse multipart/byteranges responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190829T085808Z">
        <seg>除非知道收件人可以解析，否则不得使用此媒体类型;在具有来自 1.1 客户端的多个字节范围说明符的 Range 首部的请求中的存在意味着客户端可以解析 multipart/byteranges 响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This memo describes how to use TLS to secure HTTP connections over the Internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T085617Z" creationid="pingfangx" creationdate="20190901T085617Z">
        <seg>本备忘录描述了如何使用 TLS 来保护互联网上的 HTTP 连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This memo provides information for the Internet community.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T085518Z" creationid="pingfangx" creationdate="20190901T085518Z">
        <seg>本备忘录为互联网社区提供信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method MAY be overridden by human intervention (or other means) on the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T073218Z" creationid="pingfangx" creationdate="20190830T073218Z">
        <seg>可以通过源服务器上的人为干预(或其他方式)覆盖此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143440Z" creationid="pingfangx" creationdate="20190831T143440Z">
        <seg>该方法允许客户端确定与资源相关联的选项和/或要求，或服务器的能力，而不暗示资源动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T041638Z" creationid="pingfangx" creationdate="20190830T041638Z">
        <seg>该方法允许客户端确定与资源相关联的选项和/或要求，或服务器的能力，而不暗示资源动作或启动资源检索。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method can be used for obtaining metadata about the selected representation without transferring the representation data and is often used for testing hypertext links for validity, accessibility, and recent modification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T140159Z" creationid="pingfangx" creationdate="20190831T140159Z">
        <seg>该方法可用于获得关于所选表示的元数据而不传送表示数据，并且通常用于测试超文本链接的有效性，可访问性和最近修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063442Z" creationid="pingfangx" creationdate="20190830T063442Z">
        <seg>该方法可用于获得关于请求所暗示的实体的元信息，而无需传输实体主体本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is often used for testing hypertext links for validity, accessibility, and recent modification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T063455Z" creationid="pingfangx" creationdate="20190830T063455Z">
        <seg>此方法通常用于测试超文本链接的有效性，可访问性和最近的修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method takes as a parameter the item emitted by the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060250Z" creationid="pingfangx" creationdate="20190620T060250Z">
        <seg>此方法将 Observable 发射的项作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This module adds the minimum classes to RxJava that make writing reactive components in Android applications easy and hassle-free.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T030011Z" creationid="pingfangx" creationdate="20190624T030011Z">
        <seg>该模块为 RxJava 添加了最小类，使得在 Android 应用程序中编写响应组件变得轻松无忧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This negotiation is based on the computer science concept of co-routines (I call you, you call me).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150449Z" creationid="pingfangx" creationdate="20190621T081011Z">
        <seg>这个协商是基于计算机科学的 co-routines (译注：协程？)概念(我调用你，你调用我)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator in its parameterless form reintroduces an unbounded buffer between the upstream source and the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092414Z" creationid="pingfangx" creationdate="20190621T092414Z">
        <seg>此操作符以无参数形式在上游源和下游操作符之间重新引入无边界缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator is useful when one can safely ignore values from a source (such as mouse moves or current GPS location signals) as there will be more up-to-date values later on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014819Z" creationid="pingfangx" creationdate="20190624T014819Z">
        <seg>当可以安全地忽略来自源的值(例如鼠标移动或当前 GPS 位置信号)时，此操作符非常有用，因为稍后会有更多的最新值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This overload calls a (shared) action in case an overflow happens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093437Z" creationid="pingfangx" creationdate="20190621T093437Z">
        <seg>如果发生溢出，此重载会调用(共享)操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This overload is actually more useful as it let's one define what to do in case the capacity has been reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093534Z" creationid="pingfangx" creationdate="20190621T093534Z">
        <seg>这种重载实际上更有用，因为我们可以定义在达到容量时要做什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043840Z" creationid="pingfangx" creationdate="20190620T043840Z">
        <seg>这个页面解释了什么是响应模式(reactive pattern)？以及什么是可观察对象(Observables)和观察者(observers)？(以及观察者如何订阅 Observables)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page first lists what could be considered the “core” operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094045Z" creationid="pingfangx" creationdate="20190620T094045Z">
        <seg>该页面首先列出了可以被视为 ReactiveX 中的“核心”操作符的内容，以及指向这些页面的链接，这些页面具有关于这些操作符如何工作以及特定语言特定的 ReactiveX 版本如何实现这些操作符的更深入信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T052909Z" creationid="pingfangx" creationdate="20190620T052909Z">
        <seg>此页面使用类似 Groovy 的伪代码作为示例，但在许多语言中都有 ReactiveX 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This paper describes a "superset" of operations that can be applied to URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035355Z" creationid="pingfangx" creationdate="20190902T035355Z">
        <seg>本文描述了可以应用于 URI 的操作的“超集”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043646Z" creationid="pingfangx" creationdate="20190620T043534Z">
        <seg>这种模式有利于并发操作，因为它不需要在等待 Observable 发射对象时阻塞，而是以观察者的形式创建一个哨兵，随时准备在 Observable 发射对象做出适当的反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This procedure normally is initiated by one TCP and responded to by another TCP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030758Z" creationid="pingfangx" creationdate="20190828T030758Z">
        <seg>此过程通常由一个 TCP 启动，并由另一个 TCP 响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol includes more stringent requirements than HTTP/1.0 in order to ensure reliable implementation of its features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075536Z" creationid="pingfangx" creationdate="20190828T075536Z">
        <seg>该协议包含比 HTTP/1.0 更严格的要求，以确保其功能的可靠实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110137Z" creationid="pingfangx" creationdate="20190827T110137Z">
        <seg>此伪首部包含源地址，目标地址，协议和 TCP 长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This reconstruction involves both the server's local configuration and information communicated in the request-target, Host header field, and connection context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130613Z" creationid="pingfangx" creationdate="20190831T130613Z">
        <seg>此重建涉及服务器的本地配置和在请求目标，主机首部字段和连接上下文中传递的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement overrides the general rule for forwarding of 1xx responses (see section 10.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T025925Z" creationid="pingfangx" creationdate="20190830T025925Z">
        <seg>此要求会覆盖转发 1xx 响应的一般规则(请参阅第 10.1 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement prevents an interoperability failure when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144304Z" creationid="pingfangx" creationdate="20190828T144304Z">
        <seg>当 HTTP/1.1(或更高版本)代理接收邮件并转发给 HTTP/1.0 收件人时，此要求可防止互操作性失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scenario leads to the example shown in figure 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055834Z" creationid="pingfangx" creationdate="20190828T055834Z">
        <seg>该场景导致图 10 中所示的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section defines the process of resolving a URI reference within a context that allows relative references so that the result is a string matching the &lt;URI&gt; syntax rule of Section 3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T090633Z" creationid="pingfangx" creationdate="20190902T090633Z">
        <seg>本节定义了在允许相对引用的上下文中解析 URI 引用的过程，以便结果是与第 3 节的 &lt;URI&gt; 语法规则匹配的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section defines the scheme-specific syntax and semantics for http URLs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T111623Z" creationid="pingfangx" creationdate="20190828T111623Z">
        <seg>本节定义了 http URL 的特定于方案的语法和语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be backwards compatible but does behave differently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105035Z" creationid="pingfangx" creationdate="20190617T105035Z">
        <seg>这应该是向后兼容的，但表现不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This signaling takes place using the Connection header field (section 14.10).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150331Z" creationid="pingfangx" creationdate="20190829T150331Z">
        <seg>此信号使用 Connection 首部字段进行(第 14.10 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This space ranges from 0 to 2**32 - 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021253Z" creationid="pingfangx" creationdate="20190828T021253Z">
        <seg>此空间范围为 0 到 2**32 - 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification adopts the definitions of "URI-reference", "absoluteURI", "relativeURI", "port", "host","abs_path", "rel_path", and "authority" from that specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T110543Z" creationid="pingfangx" creationdate="20190828T110530Z">
        <seg>该规范采用了那个规范中的 "URI-reference", "absoluteURI", "relativeURI", "port", "host","abs_path", "rel_path", 和 "authority" 的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification also updates the use of CONNECT to establish a tunnel, previously defined in RFC 2817, and defines the "https" URI scheme that was described informally in RFC 2818.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094131Z" creationid="pingfangx" creationdate="20190830T094131Z">
        <seg>此规范还更新了使用 CONNECT 建立隧道(先前在 RFC 2817 中定义)，并定义了 RFC 2818 中非正式描述的“https”URI 方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133659Z" creationid="pingfangx" creationdate="20190831T133659Z">
        <seg>此规范定义了 HTTP 中常用的许多标准化方法，如下表所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042506Z" creationid="pingfangx" creationdate="20190902T042506Z">
        <seg>此规范定义了通用 URI 语法和用于解析可能相对形式的 URI 引用的过程，以及在互联网上使用 URI 的准则和安全注意事项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification defines the protocol referred to as "HTTP/1.1", and is an update to RFC 2068 [33].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071630Z" creationid="pingfangx" creationdate="20190828T071630Z">
        <seg>该规范定义了称为“HTTP/1.1”的协议，并且是对 RFC 2068 [33] 的更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification defines the protocol referred to as "HTTP/1.1".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T075525Z" creationid="pingfangx" creationdate="20190828T075525Z">
        <seg>该规范定义了称为“HTTP/1.1”的协议。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification defines those elements of the URI syntax that are required of all URI schemes or are common to many URI schemes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061812Z" creationid="pingfangx" creationdate="20190902T061812Z">
        <seg>此规范定义了所有 URI 方案所需的 URI 语法元素，或者是许多 URI 方案所共有的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification defines version "1.1".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103129Z" creationid="pingfangx" creationdate="20190830T103129Z">
        <seg>该规范定义了版本“1.1”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification deprecates such line folding except within the message/http media type (Section 8.3.1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T083800Z" creationid="pingfangx" creationdate="20190831T083800Z">
        <seg>除了在 message/http 媒体类型(第 8.3.1 节)中之外，此规范不推荐使用此类折叠。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042525Z" creationid="pingfangx" creationdate="20190902T042525Z">
        <seg>该规范没有定义 URI 的生成语法；该任务由每个 URI 方案的各个规范执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification does not limit the scope of what might be a resource; rather, the term "resource" is used in a general sense for whatever might be identified by a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060505Z" creationid="pingfangx" creationdate="20190902T060505Z">
        <seg>该规范不限制可能是资源的范围；相反，术语“资源”在一般意义上用于可能由 URI 识别的任何内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification does not mandate a particular registered name lookup technology and therefore does not restrict the syntax of reg-name beyond what is necessary for interoperability.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075708Z" creationid="pingfangx" creationdate="20190902T075708Z">
        <seg>本规范不要求特定的注册名称查找技术，因此不会限制注册名称的语法超出互操作性所需的语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification does not mandate any particular character encoding for mapping between URI characters and the octets used to store or transmit those characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064920Z" creationid="pingfangx" creationdate="20190902T064920Z">
        <seg>该规范没有强制要求 URI 字符与用于存储或传输这些字符的八位字节之间的映射的任何特定字符编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification does not place any limits on the nature of a resource, the reasons why an application might seek to refer to a resource, or the kinds of systems that might use URIs for the sake of identifying resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061139Z" creationid="pingfangx" creationdate="20190902T061139Z">
        <seg>此规范不对资源的性质，应用程序可能寻求引用资源的原因或可能使用 URI 以识别资源的系统类型进行任何限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification does not require that a URI persists in identifying the same resource over time, though that is a common goal of all URI schemes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061252Z" creationid="pingfangx" creationdate="20190902T061214Z">
        <seg>尽管这是所有 URI 方案的共同目标，但此规范并不要求 URI 在一段时间内持续标识相同的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification now defines the Upgrade Token Registry, previously defined in Section 7.2 of [RFC2817].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T092356Z" creationid="pingfangx" creationdate="20190830T092356Z">
        <seg>此规范现在定义了先前在 [RFC2817] 的第 7.2 节中定义的升级标记注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification of URI syntax and semantics is derived from concepts introduced by the World Wide Web global information initiative, whose use of such objects dates from 1990 and is described in "Universal Resource Identifiers in WWW" [RFC1630].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035747Z" creationid="pingfangx" creationdate="20190902T035747Z">
        <seg>URI 语法和语义的这种规范源自万维网全球信息计划引入的概念，其对这些对象的使用可追溯到 1990 年并且在“WWW 中的统一资源标识符”[RFC1630] 中描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification of URI syntax and semantics is derived from concepts introduced by the World Wide Web global information initiative, whose use of these identifiers dates from 1990 and is described in "Universal Resource Identifiers in WWW" [RFC1630].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T043043Z" creationid="pingfangx" creationdate="20190902T043043Z">
        <seg>URI 语法和语义的这种规范源自万维网全球信息计划引入的概念，其使用这些标识符可以追溯到 1990 年并且在“WWW 中的统一资源标识符”[RFC1630] 中描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 2.6 and future updates to this specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113843Z" creationid="pingfangx" creationdate="20190831T113843Z">
        <seg>此规范仅定义协议名称“HTTP”供超文本传输​​协议族使用，如第 2.6 节的 HTTP 版本规则和本规范的未来更新所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103714Z" creationid="pingfangx" creationdate="20190830T103404Z">
        <seg>此规范对某些新功能设置了接收者版本要求，以便符合要求的仅使用兼容功能，直到通过配置或收到邮件确定接收者支持 HTTP/1.1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification provides that hosts which "crash" without retaining any knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed Maximum Segment Lifetime (MSL) in the internet system of which the host is a part.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024647Z" creationid="pingfangx" creationdate="20190828T024642Z">
        <seg>该规范规定，在不保留每个活动(即非关闭)连接上发送的最后序列号的任何知识的情况下“崩溃”的主机应至少延迟发送任何 TCP 报文段，以便至少在主机是其中的一部分的互联网系统中达成协议的最大报文段寿命(MSL)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling [44]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074446Z" creationid="pingfangx" creationdate="20190830T074446Z">
        <seg>此规范保留方法名称 CONNECT 以与可动态切换为隧道的代理一起使用(例如，SSL 隧道 [44])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification targets conformance criteria according to the role of a participant in HTTP communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102434Z" creationid="pingfangx" creationdate="20190830T102434Z">
        <seg>该规范根据 HTTP 通信中参与者的角色来确定一致性标准。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses a number of terms to refer to the roles played by participants in, and objects of, the HTTP communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T080843Z" creationid="pingfangx" creationdate="20190828T080843Z">
        <seg>本规范使用许多术语来指代 HTTP 通信中的参与者和对象所扮演的角色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC2234], including the following core ABNF syntax rules defined by that specification: ALPHA (letters), CR (carriage return),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064808Z" creationid="pingfangx" creationdate="20190902T064808Z">
        <seg>本规范使用 [RFC2234] 的 Augmented Backus-Naur Form(ABNF)表示法，包括该规范定义的以下核心 ABNF 语法规则：ALPHA(字母)，CR(回车)，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7 of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122007Z" creationid="pingfangx" creationdate="20190831T122007Z">
        <seg>本规范使用 [RFC5234] 的 Augmented Backus-Naur Form(ABNF)符号和 [RFC7230] 第 7 节中定义的列表扩展，允许使用 '#' 操作符对逗号分隔列表进行紧凑定义(类似于 '*' 操作符如何表示重复)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7, that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T094652Z" creationid="pingfangx" creationdate="20190830T094652Z">
        <seg>本规范使用 [RFC5234] 的 Augmented Backus-Naur Form(ABNF)符号和第 7 节中定义的列表扩展，允许使用 '#' 操作符紧凑定义逗号分隔列表(类似于 '*' 操作符表示重复)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses the terms "character" and "coded character set" in accordance with the definitions provided in [BCP19], and "character encoding" in place of what [BCP19] refers to as a "charset".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T055626Z" creationid="pingfangx" creationdate="20190902T055626Z">
        <seg>本说明书根据 [BCP19] 中提供的定义使用术语“字符”和“编码字符集”，并使用“字符编码”代替 [BCP19] 所称的“字符集”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses the terms "character", "character encoding scheme", "charset", and "protocol element" as they are defined in [RFC6365].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122102Z" creationid="pingfangx" creationdate="20190831T122102Z">
        <seg>本规范使用术语“character”，“character encoding scheme”，“charset”和“protocol element”，因为它们在 [RFC6365] 中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This specification uses three rules to denote the use of linear whitespace: OWS (optional whitespace), RWS (required whitespace), and BWS ("bad" whitespace).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T082643Z" creationid="pingfangx" creationdate="20190831T082643Z">
        <seg>本规范使用三个规则来表示线性空白的使用：OWS(可选空白)，RWS(需要空白)和 BWS(“坏”空白)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This style of chaining methods is called a **fluent API** which resembles the **builder pattern**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072620Z" creationid="pingfangx" creationdate="20190617T072620Z">
        <seg>这种链式方法称为 **fluent API (流式 API)**，类似于 **builder pattern (建造者模式)**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax does not support IPv6 scoped addressing zone identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074645Z" creationid="pingfangx" creationdate="20190902T074645Z">
        <seg>此语法不支持 IPv6 作用域寻址区域标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tree can help you find the ReactiveX Observable operator you’re looking for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103812Z" creationid="pingfangx" creationdate="20190620T103812Z">
        <seg>此树可以帮助你找到你正在寻找的 ReactiveX Observable 操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2**32 - 1 to 0 again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T021450Z" creationid="pingfangx" creationdate="20190828T021450Z">
        <seg>这个无符号算术保留了序列号的关系，因为它们再次从 2**32 - 1 循环到 0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variant allows cleaning up the values themselves (e.g., releasing associated resources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015008Z" creationid="pingfangx" creationdate="20190624T015008Z">
        <seg>该变体允许清除值本身(例如，释放相关资源)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was practically unnecessary and the Reactive-Streams specification states that when a terminal event arrives at a `Subscriber`, the upstream `Subscription` should be considered cancelled and thus calling `cancel()` is a no-op.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114952Z" creationid="pingfangx" creationdate="20190618T114952Z">
        <seg>这实际上是不必要的，Reactive-Streams 规范声明当终端事件到达 `Subscriber` 时，上游的 `Subscription` 应被视为取消，因此调用 `cancel()` 是无操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wiki page attempts to summarize what has changed and describes how to rewrite 1.x code into 2.x code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051858Z" creationid="pingfangx" creationdate="20190618T051858Z">
        <seg>此 Wiki 页面试图总结已更改的内容，并描述如何将 1.x 代码重写为 2.x 代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T100744Z" creationid="pingfangx" creationdate="20190831T100744Z">
        <seg>这将允许下游接收者测量传输进度，知道收到的消息何时完成，并可能重用连接以获取其他请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will print:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071625Z" creationid="pingfangx" creationdate="20190618T071625Z">
        <seg>这将打印：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This, too, has a &lt;a0&gt;Scheduler&lt;/a0&gt;-specific version:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T080543Z" creationid="pingfangx" creationdate="20190620T080543Z">
        <seg>这也有一个 &lt;a0&gt;Scheduler&lt;/a0&gt; 特定版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those APIs feature some form of `addListener`/`removeListener` calls that one can utilize:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022400Z" creationid="pingfangx" creationdate="20190624T022400Z">
        <seg>这些 API 具有某种形式的 `addListener`/`removeListener` 调用，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061715Z" creationid="pingfangx" creationdate="20190620T061715Z">
        <seg>那些 Observable 可以(如果他们没有其他感兴趣的观察者)选择停止生成要发射的新项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those return a "global" scheduler instance whereas `test()` returned always a new instance of the `TestScheduler`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093740Z" creationid="pingfangx" creationdate="20190618T093740Z">
        <seg>那些返回“全局”调度器实例，而 `test()` 总是返回 `TestScheduler` 的新实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that have a particular default Scheduler include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091455Z" creationid="pingfangx" creationdate="20190620T091455Z">
        <seg>具有特定默认调度器的包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those who are using Mockito and mocked `Observer` in 1.x has to mock the `Subscriber.onSubscribe` method to issue an initial request, otherwise, the sequence will hang or fail with hot sources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101902Z" creationid="pingfangx" creationdate="20190618T101902Z">
        <seg>那些在 1.x 中使用 Mockito 并模拟 `Observer` 的人必须模拟 `Subscriber.onSubscribe` 方法来发出初始请求，否则，序列将因热源而挂起或失败：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three alphabetic characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093707Z" creationid="pingfangx" creationdate="20190828T093707Z">
        <seg>因此，2DIGIT 是一个 2 位数字，3ALPHA 是由三个字母字符组成的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, "(elem (foo | bar) elem)" allows the token sequences "elem foo elem" and "elem bar elem".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T093137Z" creationid="pingfangx" creationdate="20190828T093137Z">
        <seg>因此，“(elem (foo | bar) elem)”允许标记序列“elem foo elem”和“elem bar elem”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is lower than HTTP/12.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T103614Z" creationid="pingfangx" creationdate="20190828T103614Z">
        <seg>因此，HTTP/2.4 是比 HTTP/2.13 更低的版本，而 HTTP/2.13 又低于 HTTP/12.3。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a program could initiate several SENDs followed by a CLOSE, and then continue to RECEIVE until signaled that a RECEIVE failed because the other side has CLOSED.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062737Z" creationid="pingfangx" creationdate="20190828T062737Z">
        <seg>因此，一个程序可以启动几个 SEND，然后是 CLOSE，然后继续 RECEIVE，直到发出 RECEIVE 失败，因为另一方已经 CLOSED。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, a resource can remain constant even when its content---the entities to which it currently corresponds---changes over time, provided that the conceptual mapping is not changed in the process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040255Z" creationid="pingfangx" creationdate="20190902T040255Z">
        <seg>因此，即使在内容 - 它当前对应的实体 - 随时间变化的情况下，资源也可以保持不变，前提是概念映射在过程中没有改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, characters in the reserved set are protected from normalization and are therefore safe to be used by scheme-specific and producer-specific algorithms for delimiting data subcomponents within a URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070757Z" creationid="pingfangx" creationdate="20190902T070757Z">
        <seg>因此，保护​​集中的字符被保护免于标准化，因此安全地被特定于方案和生成器的算法用于界定 URI 内的数据子组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, it is be possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022457Z" creationid="pingfangx" creationdate="20190828T022457Z">
        <seg>因此，TCP 可以在发送数据和接收 ACK 时保持零接收窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the ISN cycles approximately every 4.55 hours.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023344Z" creationid="pingfangx" creationdate="20190828T023344Z">
        <seg>因此，ISN 大约每 4.55 小时循环一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075639Z" creationid="pingfangx" creationdate="20190620T075639Z">
        <seg>如果订阅后某个项目在指定的时间段内未发射该项目，则超时将导致 Single 中止并发射错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T100841Z" creationid="pingfangx" creationdate="20190829T100841Z">
        <seg>为了允许在未来版本的 HTTP 中转换为所有请求中的 absoluteURI，所有 HTTP/1.1 服务器必须在请求中接受 absoluteURI 形式，即使 HTTP/1.1 客户端只在请求代理时生成它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow for transition to the absolute-form for all requests in some future version of HTTP, a server MUST accept the absolute-form in requests, even though HTTP/1.1 clients will only send them in requests to proxies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124825Z" creationid="pingfangx" creationdate="20190831T124825Z">
        <seg>为了允许在某些未来版本的 HTTP 中转换为绝对形式的所有请求，服务器必须接受请求中的绝对形式，即使 HTTP/1.1 客户端只会将请求发送给代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow having RxJava 1.x and RxJava 2.x side-by-side, RxJava 2.x is under the maven coordinates `io.reactivex.rxjava2:rxjava:2.x.y` and classes are accessible below `io.reactivex`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052632Z" creationid="pingfangx" creationdate="20190618T052632Z">
        <seg>为了允许 RxJava 1.x 和 RxJava 2.x 共存，RxJava 2.x 位于 maven 坐标 `io.reactivex.rxjava2:rxjava:2.x.y` 下，类可以在 `io.reactivex 下面访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid confusion we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023244Z" creationid="pingfangx" creationdate="20190828T023244Z">
        <seg>为了避免混淆，我们必须防止使用来自连接的一个化身的报文段，而相同的序列号可能仍然存在于早期化身的网络中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid overwhelming such steps, which usually would manifest itself as increased memory usage due to temporary buffering or the need for skipping/dropping data, a so-called backpressure is applied, which is a form of flow control where the steps can express how many items are they ready to process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071348Z" creationid="pingfangx" creationdate="20190617T071348Z">
        <seg>为了避免 overwhelming 这些步骤，通常表现为由于临时缓冲或需要跳过/丢弃数据而增加内存，所以应用所谓的背压，这是流量控制的一种形式，其中步骤可以表达多少项目准备好了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the TCP reset problem, servers typically close a connection in stages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T112859Z" creationid="pingfangx" creationdate="20190831T112859Z">
        <seg>为避免 TCP 重置问题，服务器通常会分阶段关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the name clash, the 1.x `rx.Subscription` has been renamed into `io.reactivex.Disposable` (somewhat resembling .NET's own IDisposable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072820Z" creationid="pingfangx" creationdate="20190618T072820Z">
        <seg>为避免名称冲突，1.x 的 `rx .Subscription` 已重命名为 `io .reactivex .Disposable`(有点类似于 .NET 自己的 IDisposable)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this situation, make sure you call `request` **after** all initialization have been done in `onSubscribe`/`onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071838Z" creationid="pingfangx" creationdate="20190618T071838Z">
        <seg>为了避免这种情况，请确保在 `onSubscribe`/`onStart` 中完成所有初始化 **之后** 调用 `request`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T024412Z" creationid="pingfangx" creationdate="20190828T024412Z">
        <seg>为了确保 TCP 不会创建一个带有序列号的报文段，该报文段可能被网络中剩余的旧报文段复制，TCP 必须在启动时分配任何序列号之前保持安静，以获得最大报文段寿命(MSL)。或从崩溃中恢复，其中使用的序列号的内存丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To bridge the gap we defined abstract classes `DefaultSubscriber`, `ResourceSubscriber` and `DisposableSubscriber` (plus their `XObserver` variants) for `Flowable` (and `Observable`) respectively that offers resource tracking support (of `Disposable`s) just like `rx.Subscriber` and can be cancelled/disposed externally via `dispose()`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070302Z" creationid="pingfangx" creationdate="20190618T070302Z">
        <seg>为弥合这一差距，我们分别为 `Flowable`(和 `Observable`)定义了抽象类 `DefaultSubscriber`，`ResourceSubscriber` 和 `DisposableSubscriber`(加上它们的 `XObserver` 变体)，提供了资源跟踪支持(`Disposable`)就像 `rx.Subscriber` 一样，并可以通过 `dispose()` 从外部取消/处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105603Z" creationid="pingfangx" creationdate="20190617T105603Z">
        <seg>要构建：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To deal with this, a special control message, reset, has been devised.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042505Z" creationid="pingfangx" creationdate="20190828T042505Z">
        <seg>为了解决这个问题，我们设计了一个特殊的控制消息 reset。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle such cases, RxJava has the `generate` factory method family.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021012Z" creationid="pingfangx" creationdate="20190624T021012Z">
        <seg>为了处理这种情况，RxJava 有 `generate` 工厂方法系列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle such cases, a recent version of RxJava introduced the `create(emitter)` factory method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021719Z" creationid="pingfangx" creationdate="20190624T021719Z">
        <seg>为了处理这种情况，最新版本的 RxJava 引入了 `create(emitter)` 工厂方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate, the example can be rewritten as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072726Z" creationid="pingfangx" creationdate="20190617T072726Z">
        <seg>为了说明，该示例可以重写如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate this opportunity, many operator names are suffixed with the `DelayError` words (while others feature a `delayError` or `delayErrors` boolean flag in one of their overloads):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103545Z" creationid="pingfangx" creationdate="20190617T103545Z">
        <seg>为了表明这个机会，许多运算符名称后缀为 `DelayError` (而其他运算符名称在其中一个重载中具有 `delayError` 或 `delayErrors` 布尔标志)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make sure the final API of 2.0 is clean as possible, we remove methods and other components between release candidates without deprecating them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061528Z" creationid="pingfangx" creationdate="20190619T061528Z">
        <seg>为了确保 2.0 的最终 API 尽可能干净，我们在发布候选版本之间删除方法和其他组件而不弃用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent this, operators use so-called trampolining logic that prevents such reentrant calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082411Z" creationid="pingfangx" creationdate="20190621T082411Z">
        <seg>为了防止这种情况，操作符使用所谓的 trampolining 逻辑来阻止这种可重入的调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remedy this, the method `E subscribeWith(E subscriber)` has been added to each base reactive class which returns its input subscriber/observer as is.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070729Z" creationid="pingfangx" creationdate="20190618T070729Z">
        <seg>为了解决这个问题，方法 `E subscribeWith(E subscriber)` 被添加到每个基本响应类中，该方法按原样返回其输入的订阅者/观察者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To restate what is explicitly forbidden by the BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an extra CRLF.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T073836Z" creationid="pingfangx" creationdate="20190829T073836Z">
        <seg>要重述 BNF 明确禁止的内容，HTTP/1.1 客户端不得在请求前面或后面带有额外 CRLF。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To save space and take advantage of hierarchical locality, many Internet protocol elements and media type formats allow an abbreviation of a URI, whereas others restrict the syntax to a particular form of URI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083953Z" creationid="pingfangx" creationdate="20190902T083953Z">
        <seg>为了节省空间并利用分层局部性，许多互联网协议元素和媒体类型格式允许 URI 的缩写，而其他格式将语法限制为特定形式的 URI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To schedule recursive calls, you can use &lt;c0&gt;schedule&lt;/c0&gt; and then &lt;c1&gt;schedule(this)&lt;/c1&gt; on the Worker object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092138Z" creationid="pingfangx" creationdate="20190620T092138Z">
        <seg>要调度递归调用，可以在 Worker 对象上使用 &lt;c0&gt;schedule&lt;/c0&gt; 然后 &lt;c1&gt;schedule(this)&lt;/c1&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are "busy" or "in use" until MSL seconds have passed, upon crashing a block of space-time is occupied by the octets of the last emitted segment, if a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of the last segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T030223Z" creationid="pingfangx" creationdate="20190828T030223Z">
        <seg>总结一下：发射的每个报文段都占用了序列空间中的一个或多个序列号，报文段中占用的数字是“忙”或“正在使用”，直到 MSL 秒已经过去，一旦最后一个发射报文段的八位字节位所占用空间的块崩溃了，如果新连接过早启动并使用前一个连接化身的最后一个报文段的空时足迹中的任何序列号，则存在潜在的序列号重叠区域，这可能导致在接收器端的混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support our internal testing, all base reactive types now feature `test()` methods (which is a huge convenience for us) returning `TestSubscriber` or `TestObserver`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095836Z" creationid="pingfangx" creationdate="20190618T095836Z">
        <seg>为了支持我们的内部测试，所有基本响应类型现在都有 `test()` 方法(这对我们来说非常方便)返回 `TestSubscriber` 或 `TestObserver`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To understand what is a valid URI, both the grammar and the associated description have to be studied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035405Z" creationid="pingfangx" creationdate="20190902T035405Z">
        <seg>要了解什么是有效 URI，必须研究语法和相关描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transcription</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060417Z" creationid="pingfangx" creationdate="20190902T060417Z">
        <seg>转录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer Coding Registry</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091111Z" creationid="pingfangx" creationdate="20190830T091111Z">
        <seg>传输编码注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer Codings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072127Z" creationid="pingfangx" creationdate="20190828T072127Z">
        <seg>传输编码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer codings are defined in Section 4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090655Z" creationid="pingfangx" creationdate="20190831T090655Z">
        <seg>传输编码在第 4 节中定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer of Sensitive Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074321Z" creationid="pingfangx" creationdate="20190828T074321Z">
        <seg>传递敏感信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 4.1 of [RFC7232]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092703Z" creationid="pingfangx" creationdate="20190831T092703Z">
        <seg>可以在对 HEAD 请求的响应或对 GET 请求的 304(未修改)响应([RFC7232] 的第 4.1 节)中发送 Transfer-Encoding，虽然两者都不包括消息体，以指示源服务器在请求是无条件的 GET 时，则已将传输编码应用于消息正文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-Encoding MUST be used to indicate any transfer-codings applied by an application to ensure safe and proper transfer of the message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084151Z" creationid="pingfangx" creationdate="20190829T084151Z">
        <seg>传输编码必须用于指示应用程序应用的任何传输编码，以确保安全和正确地传输消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-Encoding is a property of the message, not of the entity, and thus MAY be added or removed by any application along the request/response chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084243Z" creationid="pingfangx" creationdate="20190829T084211Z">
        <seg>传输编码是消息的属性，而不是实体的属性，因此可以由请求/响应链中的任何应用程序添加或删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T090720Z" creationid="pingfangx" creationdate="20190831T090720Z">
        <seg>Transfer-Encoding 类似于 MIME 的 Content-Transfer-Encoding 字段，旨在通过 7 位传输服务([RFC2045]，第 6 节)实现二进制数据的安全传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-Encoding was added in HTTP/1.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092742Z" creationid="pingfangx" creationdate="20190831T092742Z">
        <seg>在 HTTP/1.1 中添加了 Transfer-Encoding。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-coding values are used to indicate an encoding transformation that has been, can be, or may need to be applied to an entity-body in order to ensure "safe transport" through the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141819Z" creationid="pingfangx" creationdate="20190828T141819Z">
        <seg>传输编码值用于指示已经，可以或可能需要应用于实体主体的编码变换，以确保通过网络的“安全传输”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transfer-codings are analogous to the Content-Transfer-Encoding values of MIME [7], which were designed to enable safe transport of binary data over a 7-bit transport service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142905Z" creationid="pingfangx" creationdate="20190828T142905Z">
        <seg>传输编码类似于 MIME [7] 的 Content-Transfer-Encoding 值，旨在通过 7 位传输服务实现二进制数据的安全传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transforming Observable Items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071854Z" creationid="pingfangx" creationdate="20190620T071854Z">
        <seg>转换 Observable 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transforming Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095411Z" creationid="pingfangx" creationdate="20190620T095411Z">
        <seg>转换 Observables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transmission Control Protocol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T041849Z" creationid="pingfangx" creationdate="20190828T041849Z">
        <seg>Transmission Control Protocol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transmit the request-headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030340Z" creationid="pingfangx" creationdate="20190830T030340Z">
        <seg>传输请求首部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transparent Negotiation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150449Z" creationid="pingfangx" creationdate="20190828T073228Z">
        <seg>透明协商</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [RFC5246]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T143000Z" creationid="pingfangx" creationdate="20190831T143000Z">
        <seg>隧道通常用于通过一个或多个代理创建端到端虚拟连接，然后可以使用 TLS(传输层安全性，[RFC5246])来保护隧道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tunnels are used to extend a virtual connection through an intermediary, such as when Transport Layer Security (TLS, [RFC5246]) is used to establish confidential communication through a shared firewall proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T101712Z" creationid="pingfangx" creationdate="20190830T101712Z">
        <seg>隧道用于通过中介扩展虚拟连接，例如当使用传输层安全性(TLS，[RFC5246])通过共享防火墙代理建立机密通信时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072948Z" creationid="pingfangx" creationdate="20190828T072948Z">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, the server has no external knowledge of what the client's identity ought to be and so checks (other than that the client has a certificate chain rooted in an appropriate CA) are not possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T113143Z" creationid="pingfangx" creationdate="20190901T113143Z">
        <seg>通常，服务器不知道客户端的身份应该是什么，因此检查(除了客户端具有植根于适当 CA 的证书链之外)是不可能的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you can move computations or blocking IO to some other thread via `subscribeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072819Z" creationid="pingfangx" creationdate="20190617T072819Z">
        <seg>通常，您可以通过 `subscribeOn` 将计算或阻塞 IO 移动到其他线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UPALPHA        = &lt;any US-ASCII uppercase letter "A".."Z"&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094610Z" creationid="pingfangx" creationdate="20190828T094610Z">
        <seg>UPALPHA        = &lt;任何 US-ASCII 大写字母 "A".."Z"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URG:  Urgent Pointer field significant</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T105358Z" creationid="pingfangx" creationdate="20190827T105358Z">
        <seg>URG：指明紧急指针字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI Comparison</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072057Z" creationid="pingfangx" creationdate="20190828T072057Z">
        <seg>URI 比较</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI Format</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T090527Z" creationid="pingfangx" creationdate="20190901T090527Z">
        <seg>URI 格式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI Reference</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042835Z" creationid="pingfangx" creationdate="20190902T042835Z">
        <seg>URI 引用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI Scheme Registration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091046Z" creationid="pingfangx" creationdate="20190830T091046Z">
        <seg>URI 方案注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI are characterized by the following definitions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035926Z" creationid="pingfangx" creationdate="20190902T035926Z">
        <seg>URI 的特征在于以下定义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producers and normalizers should omit the ":" delimiter that separates host from port if the port component is empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073341Z" creationid="pingfangx" creationdate="20190902T073341Z">
        <seg>URI 生成器和规范化器应省略将主机与端口分开的“:”分隔符，如果端口组件为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producers and normalizers should omit the port component and its ":" delimiter if port is empty or if its value would be the same as that of the scheme's default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081402Z" creationid="pingfangx" creationdate="20190902T081402Z">
        <seg>如果 port 为空或者其值与方案的默认值相同，则 URI 生成器和规范化器应省略端口组件及其“:”分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producers should provide these registered names in the IDNA encoding, rather than a percent-encoding, if they wish to maximize interoperability with legacy URI resolvers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T080102Z" creationid="pingfangx" creationdate="20190902T080102Z">
        <seg>如果 URI 生成者希望最大化与传统 URI 解析器的互操作性，则应该以 IDNA 编码提供这些注册名称，而不是百分比编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producers should use names that conform to the DNS syntax, even when use of DNS is not immediately apparent, and should limit these names to no more than 255 characters in length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T075943Z" creationid="pingfangx" creationdate="20190902T075943Z">
        <seg>URI 生成器应使用符合 DNS 语法的名称，即使 DNS 的使用不明显，并且应将这些名称限制为不超过 255 个字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producing applications must not use percent-encoding in host unless it is used to represent a UTF-8 character sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T080032Z" creationid="pingfangx" creationdate="20190902T080032Z">
        <seg>URI 生成应用程序不得在主机中使用百分比编码，除非它用于表示 UTF-8 字符序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producing applications often use the reserved characters allowed in a segment to delimit scheme-specific or dereference-handler-specific subcomponents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082852Z" creationid="pingfangx" creationdate="20190902T082852Z">
        <seg>URI 生成应用程序通常使用段中允许的保留字符来分隔特定于方案或解除引用处理程序的子组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI producing applications should percent-encode data octets that correspond to characters in the reserved set unless these characters are specifically allowed by the URI scheme to represent data in that component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071015Z" creationid="pingfangx" creationdate="20190902T071015Z">
        <seg>URI 生成应用程序应对与保留集中的字符对应的数据八位字节进行百分比编码，除非 URI 方案明确允许这些字符表示该组件中的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI references are used to target requests, indicate redirects, and define relationships.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104727Z" creationid="pingfangx" creationdate="20190830T104727Z">
        <seg>URI 引用用于定位请求，指示重定向和定义关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI scheme specifications must define their own syntax so that all strings matching their scheme-specific syntax will also match the &lt;absolute-URI&gt; grammar, as described in Section 4.3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072613Z" creationid="pingfangx" creationdate="20190902T072613Z">
        <seg>URI 方案规范必须定义自己的语法，以便匹配其特定于方案的语法的所有字符串也将匹配 &lt;absolute-URI&gt; 语法，如第 4.3 节所述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI scheme specifications must define their own syntax so that all strings matching their scheme-specific syntax will also match the &lt;absolute-URI&gt; grammar.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085426Z" creationid="pingfangx" creationdate="20190902T085426Z">
        <seg>URI 方案规范必须定义自己的语法，以便匹配其特定于方案的语法的所有字符串也将匹配 &lt;absolute-URI&gt; 语法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI-reference is used to denote the most common usage of a resource identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084109Z" creationid="pingfangx" creationdate="20190902T084109Z">
        <seg>URI-reference 用于表示资源标识符的最常见用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs are characterized as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060123Z" creationid="pingfangx" creationdate="20190902T060123Z">
        <seg>URI 的特征如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs have a global scope and are interpreted consistently regardless of context, though the result of that interpretation may be in relation to the end-user's context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061330Z" creationid="pingfangx" creationdate="20190902T061330Z">
        <seg>URI 具有全局范围，并且无论上下文如何都被一致地解释，尽管该解释的结果可能与最终用户的上下文有关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs have been known by many names: WWW addresses, Universal Document Identifiers, Universal Resource Identifiers [3], and finally the combination of Uniform Resource Locators (URL) [4] and Names (URN) [20].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T105309Z" creationid="pingfangx" creationdate="20190828T105309Z">
        <seg>URI 有许多名称：WWW 地址，通用文档标识符，统一资源标识符 [3]，最后是统一资源定位符(URL)[4] 和统一资源名称(URN)[20] 的组合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs in HTTP can be represented in absolute form or relative to some known base URI [11], depending upon the context of their use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T105823Z" creationid="pingfangx" creationdate="20190828T105823Z">
        <seg>HTTP 中的 URI 可以用绝对形式或相对于某个已知的基 URI [11] 来表示，具体取决于它们的使用环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs include components and subcomponents that are delimited by characters in the "reserved" set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T065955Z" creationid="pingfangx" creationdate="20190902T065955Z">
        <seg>URI 包括由“保留”集中的字符分隔的组件和子组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs that differ in the replacement of a reserved character with its corresponding percent-encoded octet are not equivalent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T070648Z" creationid="pingfangx" creationdate="20190902T070648Z">
        <seg>将保留字符替换为其对应的百分比编码的八位字节的 URI 是不等效的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs that differ in the replacement of an unreserved character with its corresponding percent-encoded US-ASCII octet are equivalent: they identify the same resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071343Z" creationid="pingfangx" creationdate="20190902T071343Z">
        <seg>使用相应的百分比编码的 US-ASCII 八位字节替换非保留字符的 URI 是等效的：它们标识相同的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URIs that identify in relation to the end-user's local context should only be used when the context itself is a defining aspect of the resource, such as when an on-line help manual refers to a file on the end-user's file system (e.g., "file:///etc/hosts").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T061510Z" creationid="pingfangx" creationdate="20190902T061510Z">
        <seg>仅当上下文本身是资源的定义方面时才应使用与最终用户的本地上下文相关的 URI，例如当联机帮助手册引用最终用户的文件系统上的文件时(例如，，“file:///etc/hosts”)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under normal conditions, TCPs keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly using a sequence number over before its first use has been acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025301Z" creationid="pingfangx" creationdate="20190828T025301Z">
        <seg>在正常情况下，TCP 会跟踪要发射的下一个序列号和最旧的等待确认，以避免在第一次使用确认之前错误地使用序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, RxJava can't tell which of these out-of-lifecycle, undeliverable exceptions should or shouldn't crash your app.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090909Z" creationid="pingfangx" creationdate="20190618T090909Z">
        <seg>不幸的是，RxJava 无法分辨这些生命周期中的哪些，无法传递的异常应该或不应该使您的应用程序崩溃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, `just` is often mistaken for a way to compute something dynamically to be consumed by `Subscriber`s:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015754Z" creationid="pingfangx" creationdate="20190624T015722Z">
        <seg>不幸的是，`just` 经常被误认为是一种供订阅者使用的动态计算东西的方式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, many method calls across the JVM and other libraries throw checked exceptions and need to be wrapped into `try-catch`es as the functional interfaces used by this class don't allow throwing checked exceptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021458Z" creationid="pingfangx" creationdate="20190624T021458Z">
        <seg>不幸的是，JVM 和其他库中的许多方法调用抛出了检查型异常，需要将其包装到 `try-catch` 中，因为此类使用的函数接口不允许抛出检查型异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, so many depend on it that we couldn't remove or rename it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094311Z" creationid="pingfangx" creationdate="20190618T094311Z">
        <seg>不幸的是，很多人依赖它，我们无法移除或重命名它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, some older HTTP/1.0 clients did not deal properly with an explicit charset parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T115616Z" creationid="pingfangx" creationdate="20190828T115616Z">
        <seg>不幸的是，一些较旧的 HTTP/1.0 客户端没有正确处理显式字符集参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent in a request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T070639Z" creationid="pingfangx" creationdate="20190831T070639Z">
        <seg>遗憾的是，某些用户代理无法正确编码或排除在超文本引用中找到的空格，从而导致在请求目标中发送这些不允许的字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, the target language (and pre-existing conventions) may not give too much help in this regard (unusable keywords, type erasure, type ambiguities, etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101401Z" creationid="pingfangx" creationdate="20190617T101401Z">
        <seg>不幸的是，目标语言(以及预先存在的约定)在这方面可能不会提供太多帮助(不可用的关键字，类型擦除，类型歧义等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this approach doesn't work and the example does not print `2` at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102539Z" creationid="pingfangx" creationdate="20190617T102539Z">
        <seg>不幸的是，这种方法不起作用，该示例根本不打印 `2`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this prints `0` because `Single.just(count.get())` is evaluated at **assembly time** when the dataflow hasn't even run yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092426Z" creationid="pingfangx" creationdate="20190617T092324Z">
        <seg>不幸的是，这会输出 `0`，`Single.just(count.get())` 计算于 **assembly time**，数据流尚未运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, usually, these classical callback-style APIs don't support cancellation, but if they do, one can setup their cancellation just like in the previoius examples (with perhaps a more involved way though).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T023047Z" creationid="pingfangx" creationdate="20190624T023047Z">
        <seg>不幸的是，通常，这些经典的回调式 API 不支持取消，但是如果它们这样支持，就可以像在上一示例中那样设置取消(尽管可能采用更复杂的方式)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uniform Resource Identifiers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072039Z" creationid="pingfangx" creationdate="20190828T072039Z">
        <seg>统一资源标识符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uniform Resource Identifiers (URI) provide a simple and extensible means for identifying a resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T035535Z" creationid="pingfangx" creationdate="20190902T035535Z">
        <seg>统一资源标识符(URI)提供了一种简单且可扩展的方法来识别资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uniform Resource Identifiers (URIs) [RFC3986] are used throughout HTTP as the means for identifying resources (Section 2 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104710Z" creationid="pingfangx" creationdate="20190830T104710Z">
        <seg>统一资源标识符(URI)[RFC3986] 在整个 HTTP 中用作识别资源的手段([RFC7231] 的第 2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uniformity provides several benefits.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T060129Z" creationid="pingfangx" creationdate="20190902T060129Z">
        <seg>统一性提供了几个好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uniformity provides several benefits: it allows different types of resource identifiers to be used in the same context, even when the mechanisms used to access those resources may differ;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040010Z" creationid="pingfangx" creationdate="20190902T040010Z">
        <seg>统一性提供了几个好处：它允许在同一个上下文中使用不同类型的资源标识符，即使用于访问这些资源的机制可能不同；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T102354Z" creationid="pingfangx" creationdate="20190831T102354Z">
        <seg>除非已经应用了除 chunked 之外的传输编码，否则发送包含消息体的请求的客户端应该使用有效的 Content-Length 首部字段，如果事先知道消息体长度，而不是分块传输编码，因为一些已存在即使服务器理解了分块传输编码，服务也会响应具有 411(需要长度)状态代码的分块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103010Z" creationid="pingfangx" creationdate="20190830T103010Z">
        <seg>除非另有说明，否则接收方可以尝试从无效的构造中恢复可用的协议元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise indicated, URI references are parsed relative to the effective request URI (Section 5.5).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T105227Z" creationid="pingfangx" creationdate="20190830T105227Z">
        <seg>除非另有说明，否则将相对于有效请求 URI 解析 URI 引用(第 5.5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T072951Z" creationid="pingfangx" creationdate="20190830T072951Z">
        <seg>除非为特定实体首部另外指定，否则 PUT 请求中的实体首部应该应用于由 PUT 创建或修改的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless specified otherwise, header fields defined in HTTP/1.1 are defined for all versions of HTTP/1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103427Z" creationid="pingfangx" creationdate="20190830T103427Z">
        <seg>除非另有说明，否则 HTTP/1.1 中定义的首部字段是为所有版本的 HTTP/1.x 定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless stated otherwise, the text is case-insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092730Z" creationid="pingfangx" creationdate="20190828T092730Z">
        <seg>除非另有说明，否则文本不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Content-Encoding (Section 3.1.2.1 of [RFC7231]), Transfer-Encoding is a property of the message, not of the representation, and any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field-value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T092109Z" creationid="pingfangx" creationdate="20190831T092109Z">
        <seg>与内容编码（[RFC7231] 的第 3.1.2.1 节）不同，Transfer-Encoding 是消息的属性，而不是表示的属性，并且请求/响应链中的任何接收者可以解码接收的传输编码或应用假设对 Transfer-Encoding 字段值进行相应的更改，向消息体添加附加的传输编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike `Flowable`, if there is only a single value to be signalled, only `onSuccess` is called and `onComplete` is not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060927Z" creationid="pingfangx" creationdate="20190618T060927Z">
        <seg>与 `Flowable` 不同，如果只有一个值要发出信号，则只调用 `onSuccess` 而不调用 `onComplete`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike `onBackpressureDrop` there is always a value available for consumption if the downstream happened to be lagging behind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015151Z" creationid="pingfangx" creationdate="20190624T015151Z">
        <seg>与 `onBackpressureDrop` 不同，如果下游恰好落后，总有一个值可供消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a proxy, a gateway receives requests as if it were the origin server for the requested resource; the requesting client may not be aware that it is communicating with a gateway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081618Z" creationid="pingfangx" creationdate="20190828T081618Z">
        <seg>与代理不同，网关接收请求，就好像它是所请求资源的源服务器一样；请求客户端可能不知道它正在与网关通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133633Z" creationid="pingfangx" creationdate="20190831T133633Z">
        <seg>与分布式对象不同，HTTP 中的标准化请求方法不是特定于资源的，因为统一接口在基于网络的系统中提供了更好的可见性和重用 [REST]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in RFC 2046, the epilogue of any multipart message MUST be empty; HTTP applications MUST NOT transmit the epilogue (even if the original multipart contains an epilogue).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T152535Z" creationid="pingfangx" creationdate="20190828T152535Z">
        <seg>与 RFC 2046 不同，任何多部分消息的尾声必须为空；HTTP 应用程序不得传输结尾(即使原始多部分包含结尾)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unrecognized header fields SHOULD be ignored by the recipient and MUST be forwarded by transparent proxies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T120700Z" creationid="pingfangx" creationdate="20190829T120700Z">
        <seg>接收者应该忽略无法识别的首部字段，而透明代理必须转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unrecognized header fields are treated as entity-header fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T093116Z" creationid="pingfangx" creationdate="20190829T093116Z">
        <seg>无法识别的首部字段被视为实体首部字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unreserved Characters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T071055Z" creationid="pingfangx" creationdate="20190902T042804Z">
        <seg>非保留字符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsubscribing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061437Z" creationid="pingfangx" creationdate="20190620T061437Z">
        <seg>取消订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updates Affecting TLS 1.2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T121646Z" creationid="pingfangx" creationdate="20190901T121646Z">
        <seg>影响 TLS 1.2 的更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upgrade</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091030Z" creationid="pingfangx" creationdate="20190830T091030Z">
        <seg>升级</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upgrade Token Registry</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091119Z" creationid="pingfangx" creationdate="20190830T091119Z">
        <seg>升级标记注册</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon calling either method, the Single terminates and the subscription to it ends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073823Z" creationid="pingfangx" creationdate="20190620T073823Z">
        <seg>在调用任一方法时，Single 终止并且对它的订阅结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upstream and downstream describe the flow of a message: all messages flow from upstream to downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T082250Z" creationid="pingfangx" creationdate="20190828T082250Z">
        <seg>上游和下游描述了消息的流程：所有消息都从上游流向下游。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042831Z" creationid="pingfangx" creationdate="20190902T042831Z">
        <seg>用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use `Schedulers.trampoline()` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093614Z" creationid="pingfangx" creationdate="20190618T093614Z">
        <seg>请改用 `Schedulers.trampoline()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use `safeSubscribe` to get an explicit safety wrapper around a consumer type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053814Z" creationid="pingfangx" creationdate="20190619T053814Z">
        <seg>使用 `safeSubscribe` 获取消费者类型的显式安全包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of non-registered media types is discouraged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T150140Z" creationid="pingfangx" creationdate="20190828T150140Z">
        <seg>不鼓励使用未注册的媒体类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T141125Z" creationid="pingfangx" creationdate="20190828T141125Z">
        <seg>不希望使用程序名来识别编码格式，并且不鼓励将来用于编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the 100 (Continue) Status</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073031Z" creationid="pingfangx" creationdate="20190828T073031Z">
        <seg>使用 100(继续)状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T074403Z" creationid="pingfangx" creationdate="20190830T074403Z">
        <seg>使用 Max-Forwards 首部字段允许客户端限制请求链的长度，这对于测试在无限循环中转发消息的代理链是有用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the format "user:password" in the userinfo field is deprecated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T073627Z" creationid="pingfangx" creationdate="20190902T073627Z">
        <seg>不推荐在 userinfo 字段中使用“user:password”格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the slash character to indicate hierarchy is only required when a URI will be used as the context for relative references.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T082239Z" creationid="pingfangx" creationdate="20190902T082239Z">
        <seg>仅当 URI 将用作相对引用的上下文时，才需要使用斜杠字符来指示层次结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the term `variant' does not necessarily imply that the resource is subject to content negotiation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T081250Z" creationid="pingfangx" creationdate="20190828T081250Z">
        <seg>使用术语“变体”并不一定意味着资源受内容协商的约束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use that variable and its new value to do something useful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053026Z" creationid="pingfangx" creationdate="20190620T053026Z">
        <seg>使用该变量及其新值来做一些有用的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User configuration of these values SHOULD also be limited in this fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154239Z" creationid="pingfangx" creationdate="20190828T154239Z">
        <seg>这些值的用户配置也应该以这种方式受到限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Userinfo (i.e., username and password) are now disallowed in HTTP and HTTPS URIs, because of security issues related to their transmission on the wire.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T091709Z" creationid="pingfangx" creationdate="20190830T091709Z">
        <seg>现在，HTTP 和 HTTPS URI 中不允许 Userinfo(即用户名和密码)，因为与它们在线路上的传输有关的安全问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users must keep reading connections they close for sending until the TCP says no more data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063142Z" creationid="pingfangx" creationdate="20190828T063142Z">
        <seg>用户必须继续读取他们关闭发送的连接，直到 TCP 说不再有数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users switching from 1.x to 2.x have to re-organize their imports, but carefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052645Z" creationid="pingfangx" creationdate="20190618T052645Z">
        <seg>从 1.x 切换到 2.x 的用户必须重新组织他们的导入，但要小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091922Z" creationid="pingfangx" creationdate="20190620T091922Z">
        <seg>使用调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using `Observable` has lower overhead in general than `Flowable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054816Z" creationid="pingfangx" creationdate="20190618T054816Z">
        <seg>使用 `Observable` 通常比 `Flowable' 具有更低的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utility Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072003Z" creationid="pingfangx" creationdate="20190620T072003Z">
        <seg>辅助操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Validation Model</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073907Z" creationid="pingfangx" creationdate="20190828T073907Z">
        <seg>验证模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Validator Header Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T115912Z" creationid="pingfangx" creationdate="20190831T115912Z">
        <seg>验证器首部字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Varieties of Scheduler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090908Z" creationid="pingfangx" creationdate="20190620T090908Z">
        <seg>调度器的种类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Varieties of Subject</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083727Z" creationid="pingfangx" creationdate="20190620T083727Z">
        <seg>Subject 的种类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various ad hoc limitations on individual header field length are found in practice, often depending on the specific field semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T085247Z" creationid="pingfangx" creationdate="20190831T085247Z">
        <seg>在实践中发现了对各个首部字段长度的各种临时限制，通常取决于特定的字段语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various ad hoc limitations on request-line length are found in practice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T080951Z" creationid="pingfangx" creationdate="20190831T080951Z">
        <seg>在实践中发现了对请求行长度的各种临时限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 1.x will be supported for several years along with 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104654Z" creationid="pingfangx" creationdate="20190617T104654Z">
        <seg>版本 1.x 将与 2.x 一起支持多年。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 2.x and 1.x will live side-by-side for several years.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065457Z" creationid="pingfangx" creationdate="20190617T065457Z">
        <seg>版本 2.x 和 1.x 将并存数年。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 2.x is now considered stable and final.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104650Z" creationid="pingfangx" creationdate="20190617T104650Z">
        <seg>版本 2.x 现在被认为是稳定且最终的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wait either for an error response from the server, or for T seconds (whichever comes first)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T030447Z" creationid="pingfangx" creationdate="20190830T030447Z">
        <seg>等待来自服务器的错误响应，或等待 T 秒(以先到者为准)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warnings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073239Z" creationid="pingfangx" creationdate="20190828T073239Z">
        <seg>警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume that the TCP will signal a user, even if no RECEIVEs are outstanding, that the other side has closed, so the user can terminate his side gracefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062904Z" creationid="pingfangx" creationdate="20190828T062904Z">
        <seg>我们假设 TCP 将向用户发出信号，即使没有 RECEIVE 是未完成的，另一方已关闭，因此用户可以优雅地终止他的一方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can distinguish two kinds of factory methods: cold "generators" that either return and generate elements based on downstream demand and hot "pushers" that usually bridge non-reactive and/or non-backpressurable data sources and layer some backpressure handling on top of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015614Z" creationid="pingfangx" creationdate="20190624T015614Z">
        <seg>我们可以区分两种工厂方法：基于下游需求返回和生成元素的冷“generators”和通常桥接非响应和/或非背压数据源并在他们上面层叠一些背压处理的热“pushers”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T111441Z" creationid="pingfangx" creationdate="20190827T111441Z">
        <seg>我们设想这些变量存储在称为传输控制块或 TCB 的连接记录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define the most common forms of reference syntax in this specification because they impact and depend upon the design of the generic syntax, requiring a uniform parsing algorithm in order to be interpreted consistently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T084002Z" creationid="pingfangx" creationdate="20190902T084002Z">
        <seg>我们在本规范中定义了最常见的引用语法形式，因为它们影响并依赖于通用语法的设计，需要统一的解析算法才能被一致地解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this latter case under "half-open" connections below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T042639Z" creationid="pingfangx" creationdate="20190828T042639Z">
        <seg>我们在下面的“半开”连接下讨论后一种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We followed the naming convention of Java 8 by defining `io.reactivex.functions.Function` and `io.reactivex.functions.BiFunction`, plus renaming `Func3` - `Func9` into `Function3` - `Function9` respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065000Z" creationid="pingfangx" creationdate="20190618T065000Z">
        <seg>我们遵循 Java 8 的命名约定，定义了 `io.reactivex.functions.Function` 和 `io.reactivex.functions.BiFunction`，并分别将 `Func3`  - `Func9` 重命名为 `Function3`  - `Function9`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have chosen to treat CLOSE in a simplex fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T062609Z" creationid="pingfangx" creationdate="20190828T062609Z">
        <seg>我们选择以单一的方式对待 CLOSE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have taken advantage of the numbering scheme to protect certain control information as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022517Z" creationid="pingfangx" creationdate="20190828T022517Z">
        <seg>我们也利用编号方案来保护某些控制信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need something that defers the evaluation of this `Single` source until **runtime** when the main source completes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092517Z" creationid="pingfangx" creationdate="20190617T092517Z">
        <seg>我们需要一些推迟计算这个 `Single` 源的东西直到 **runtime**，当主源完成时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We try to remedy this situation in 2.x by having `io.reactivex.Observable` non-backpressured and the new `io.reactivex.Flowable` be the backpressure-enabled base reactive class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053358Z" creationid="pingfangx" creationdate="20190618T053358Z">
        <seg>我们尝试在 2.x 中纠正这种情况，通过使基本响应类 `io.reactivex.Observable` 非背压并且新的 `io.reactivex.Flowable` 支持背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use the generic term "path component" to describe the URI substring matched by the parser to one of these rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T081744Z" creationid="pingfangx" creationdate="20190902T081744Z">
        <seg>我们使用通用术语“路径组件”来描述解析器与其中一个规则匹配的 URI 子字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use the name "host" for the ABNF rule because that is its most common purpose, not its only purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T074147Z" creationid="pingfangx" creationdate="20190902T074147Z">
        <seg>我们使用名称“host”作为 ABNF 规则，因为这是它最常见的目的，而不是它的唯一目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We want to assure this, even if a TCP crashes and loses all knowledge of the sequence numbers it has been using.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023256Z" creationid="pingfangx" creationdate="20190828T023256Z">
        <seg>我们想要确保这一点，即使 TCP 崩溃并且失去了它一直使用的序列号的所有知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak and Strong Validators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T073928Z" creationid="pingfangx" creationdate="20190828T073928Z">
        <seg>弱和强的验证器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134119Z" creationid="pingfangx" creationdate="20190831T134119Z">
        <seg>然而，重要的是客户没有要求其他行为，也不能对其负责。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What people actually need is the method `fromCallable`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015858Z" creationid="pingfangx" creationdate="20190624T015858Z">
        <seg>人们真正需要的是 `fromCallable` 方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What the authority component determines is who has the right to respond authoritatively to requests that target the identified resource.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044400Z" creationid="pingfangx" creationdate="20190831T044400Z">
        <seg>权限组件确定的是谁有权以针对所识别资源的请求进行权威响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Content-Length is used, however, the client may have already sent the closure alert and dropped the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103052Z" creationid="pingfangx" creationdate="20190901T103052Z">
        <seg>但是，当使用 Content-Length 时，客户端可能已经发送了关闭警报并删除了连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When HTTP/TLS is being run over a TCP/IP connection, the default port is 443.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T103259Z" creationid="pingfangx" creationdate="20190901T103259Z">
        <seg>当通过 TCP/IP 连接运行 HTTP/TLS 时，默认端口为 443。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.1) that contains an "upgrade" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113602Z" creationid="pingfangx" creationdate="20190831T113602Z">
        <seg>发送升级时，发送方还必须发送包含“upgrade”连接选项的连接首部字段(第 6.1 节)，以防止升级被可能未实现所列协议的中介意外转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a Content-Length is given in a message where a message-body is allowed, its field value MUST exactly match the number of OCTETs in the message-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T091114Z" creationid="pingfangx" creationdate="20190829T091114Z">
        <seg>当在允许消息体的消息中给出 Content-Length 时，其字段值必须与消息体中的八位字节数数完全匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a SYN is present then SEG.SEQ is the sequence number of the SYN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022848Z" creationid="pingfangx" creationdate="20190828T022848Z">
        <seg>当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a URI appears in a protocol element, the character encoding is defined by that protocol;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064930Z" creationid="pingfangx" creationdate="20190902T064930Z">
        <seg>当 URI 出现在协议元素中时，字符编码由该协议定义；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a URI reference refers to a URI that is, aside from its fragment component (if any), identical to the base URI (Section 5.1), that reference is called a "same-document" reference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085656Z" creationid="pingfangx" creationdate="20190902T085656Z">
        <seg>当 URI 引用引用的 URI 除了它的片段组件(如果有的话)之外，与基 URI(第 5.1 节)相同，该引用称为“同一文档”引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a cache is semantically transparent, the client receives exactly the same response (except for hop-by-hop headers) that it would have received had its request been handled directly by the origin server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T082216Z" creationid="pingfangx" creationdate="20190828T082216Z">
        <seg>当缓存在语义上是透明的时，客户端会收到完全相同的响应(逐跳头除外)，如果原始服务器直接处理了它的请求，它将收到该响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a client constructs an HTTP/1.1 request message, it sends the target URI in one of various forms, as defined in (Section 5.3 of [RFC7230]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122834Z" creationid="pingfangx" creationdate="20190831T122834Z">
        <seg>当客户端构造 HTTP/1.1 请求消息时，它以各种形式之一发送目标 URI，如 [RFC7230] 第 5.3 节中所定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a client or server wishes to time-out it SHOULD issue a graceful close on the transport connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T152148Z" creationid="pingfangx" creationdate="20190829T152148Z">
        <seg>当客户端或服务器希望超时时，应该在传输连接上发出正常关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only "*" (%x2A) as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125058Z" creationid="pingfangx" creationdate="20190831T125058Z">
        <seg>当客户端希望为整个服务器请求 OPTIONS 时，与该服务器的特定命名资源相反，客户端必须仅发送“*”(%x2A) 作为请求目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a header field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field-name within the Connection header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110248Z" creationid="pingfangx" creationdate="20190831T110248Z">
        <seg>当 Connection 之外的首部字段用于提供当前连接的控制信息时，发送者必须在 Connection 首部字段中列出相应的字段名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a message does not have a Transfer-Encoding header field, a Content-Length header field can provide the anticipated size, as a decimal number of octets, for a potential payload body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190831T094509Z">
        <seg>当消息没有 Transfer-Encoding 首部字段时，Content-Length 首部字段可以为潜在的有效载荷主体提供预期的大小，作为十进制的八位字节数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T032702Z" creationid="pingfangx" creationdate="20190902T024951Z">
        <seg>当消息包括有效载荷主体时，表示首部字段描述如何解释有效载荷主体中包含的表示数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a message-body is included with a message, the transfer-length of that body is determined by one of the following (in order of precedence):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T084937Z" creationid="pingfangx" creationdate="20190829T084937Z">
        <seg>当消息主体包含在消息中时，该主体的传输长度由以下之一确定(按优先顺序排列)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a non-ASCII registered name represents an internationalized domain name intended for resolution via the DNS, the name must be transformed to the IDNA encoding [RFC3490] prior to name lookup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T080050Z" creationid="pingfangx" creationdate="20190902T080050Z">
        <seg>当非 ASCII 注册名称表示要通过 DNS 解析的国际化域名时，必须在名称查找之前将名称转换为 IDNA 编码 [RFC3490]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T130105Z" creationid="pingfangx" creationdate="20190831T130105Z">
        <seg>当代理接收到具有绝对形式的请求目标的请求时，代理必须忽略收到的主机首部字段(如果有的话)，而是将其替换为请求目标的主机信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T042309Z" creationid="pingfangx" creationdate="20190830T042309Z">
        <seg>当代理收到允许请求转发的 absoluteURI 上的 OPTIONS 请求时，代理必须检查 Max-Forwards 字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a received protocol element is parsed, the recipient MUST be able to parse any value of reasonable length that is applicable to the recipient's role and that matches the grammar defined by the corresponding ABNF rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102700Z" creationid="pingfangx" creationdate="20190830T102700Z">
        <seg>当解析收到的协议元素时，接收者必须能够解析任何适用于接收者角色的合理长度的值，并且该值与相应的 ABN​​F 规则定义的语法相匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a request is received, the server reconstructs an effective request URI for the target resource (Section 5.5 of [RFC7230]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T122847Z" creationid="pingfangx" creationdate="20190831T122847Z">
        <seg>收到请求后，服务器会重建目标资源的有效请求 URI([RFC7230] 的第 5.5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133949Z" creationid="pingfangx" creationdate="20190831T133949Z">
        <seg>当接收到原始服务器已知但不允许目标资源的请求方法时，源服务器应该应该使用 405(Method Not Allowed)状态代码进行响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T133942Z" creationid="pingfangx" creationdate="20190831T133942Z">
        <seg>当收到无法识别或未由源服务器实现的请求方法时，源服务器应该响应 501(未实现)状态代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a resource is constructed such that parameters within the effective request URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T134238Z" creationid="pingfangx" creationdate="20190831T134238Z">
        <seg>当构造资源使得有效请求 URI 中的参数具有选择动作的效果时，资源所有者有责任确保该动作与请求方法语义一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a same-document reference is dereferenced for a retrieval action, the target of that reference is defined to be within the same entity (representation, document, or message) as the reference;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085855Z" creationid="pingfangx" creationdate="20190902T085855Z">
        <seg>当针对检索操作取消引用相同文档引用时，该引用的目标被定义为与引用在同一实体(表示，文档或消息)内；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T103701Z" creationid="pingfangx" creationdate="20190831T103701Z">
        <seg>当服务器仅侦听 HTTP 请求消息或处理从起始行显示为 HTTP 请求消息的内容时，除了上面列出的健壮性异常之外，还接收与 HTTP 消息语法不匹配的八位字节序列，服务器应该响应 400(错误请求)响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a valid closure alert is received, an implementation can be assured that no further data will be received on that connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091705Z" creationid="pingfangx" creationdate="20190901T091705Z">
        <seg>当收到有效的关闭警报时，实现可以确保不会在该连接上接收进一步的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When all segments preceding the FINs have been processed and acknowledged, each TCP can ACK the FIN it has received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063921Z" creationid="pingfangx" creationdate="20190828T063921Z">
        <seg>当 FIN 之前的所有报文段都已被处理和确认时，每个 TCP 都可以确认它收到的 FIN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an "http" URI is used within a context that calls for access to the indicated resource, a client MAY attempt access by resolving the host to an IP address, establishing a TCP connection to that address on the indicated port, and sending an HTTP request message (Section 3) containing the URI's identifying data (Section 5) to the server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T044600Z" creationid="pingfangx" creationdate="20190831T044600Z">
        <seg>当在要求访问指示资源的上下文中使用“http”URI 时，客户端可以通过将主机解析为 IP 地址，在指示端口上建立到该地址的 TCP 连接以及发送 HTTP 请求消息来尝试访问，请求消息(第 3 节)其中包含 URI 到服务器的标识数据(第 5 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an HTTP message is received with a major version number that the recipient implements, but a higher minor version number than what the recipient implements, the recipient SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T104156Z" creationid="pingfangx" creationdate="20190830T104156Z">
        <seg>当收到带有接收者实现的主要版本号的 HTTP 消息，但接收者实现的版本号较小时，接收者应该像处理接收者符合要求该主要版本中的最高次要版本一样处理该消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [RFC1945] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T103349Z" creationid="pingfangx" creationdate="20190830T103349Z">
        <seg>当 HTTP/1.1 消息发送到 HTTP/1.0 接收者 [RFC1945] 或版本未知的接收者时，构造 HTTP/1.1 消息，使得如果所有更新的消息都可以将其解释为有效的 HTTP/1.0 消息功能被忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an entity-body is included with a message, the data type of that body is determined via the header fields Content-Type and Content- Encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T121230Z" creationid="pingfangx" creationdate="20190829T121230Z">
        <seg>当实体主体包含在消息中时，该主体的数据类型通过首部字段 Content-Type 和 Content-Encoding 确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an inbound connection is closed prematurely, a client MAY open a new connection and automatically retransmit an aborted sequence of requests if all of those requests have idempotent methods (Section 4.2.2 of [RFC7231]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111421Z" creationid="pingfangx" creationdate="20190831T111421Z">
        <seg>当入站连接过早关闭时，如果所有这些请求都具有幂等方法，则客户端可以打开新连接并自动重新发送中止的请求序列([RFC7231] 的第 4.2.2 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an observer subscribes to a &lt;c0&gt;BehaviorSubject&lt;/c0&gt;, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084158Z" creationid="pingfangx" creationdate="20190620T084158Z">
        <seg>当观察者订阅 &lt;c0&gt;BehaviorSubject&lt;/c0&gt; 时，它首先发射源 Observable 最近发射的项（或者如果尚未发射则会发射种子/默认值），然后继续发射任何稍后由源 Observable 发射的其他项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applications make reference to a URI, they do not always use the full form of reference defined by the "URI" syntax rule.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T083927Z" creationid="pingfangx" creationdate="20190902T083927Z">
        <seg>当应用程序引用 URI 时，它们并不总是使用“URI”语法规则定义的完整引用形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When architecting dataflows (as an end-consumer of RxJava) or deciding upon what type your 2.x compatible library should take and return, you can consider a few factors that should help you avoid problems down the line such as `MissingBackpressureException` or `OutOfMemoryError`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053633Z" creationid="pingfangx" creationdate="20190618T053633Z">
        <seg>在构建数据流(作为 RxJava 的最终使用者)或决定 2.x 兼容库应该采用和返回的类型时，您可以考虑一些可以帮助您避免问题的因素，相关问题例如 `MissingBackpressureException` 或 ` OutOfMemoryError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When authority is not present, the path cannot begin with two slash characters ("//").</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072257Z" creationid="pingfangx" creationdate="20190902T072257Z">
        <seg>当权限不存在时，路径不能以两个斜杠字符(“//”)开头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When authority is present, the path must either be empty or begin with a slash ("/") character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072237Z" creationid="pingfangx" creationdate="20190902T072237Z">
        <seg>当存在权限时，路径必须为空或以斜杠(“/”)字符开头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When comparing two URIs to decide if they match or not, a client SHOULD use a case-sensitive octet-by-octet comparison of the entire URIs, with these exceptions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T112835Z" creationid="pingfangx" creationdate="20190828T112835Z">
        <seg>在比较两个 URI 以确定它们是否匹配时，客户端应该使用对整个 URI 进行区分大小写的八位字节比较，但有以下例外：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When considering the design of HTTP, it is easy to fall into a trap of thinking that all user agents are general-purpose browsers and all origin servers are large public websites.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T100529Z" creationid="pingfangx" creationdate="20190830T100529Z">
        <seg>在考虑 HTTP 的设计时，很容易陷入一种陷阱，认为所有用户代理都是通用浏览器，而所有源服务器都是大型公共网站。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When data is received the following comparisons are needed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T022122Z" creationid="pingfangx" creationdate="20190828T022122Z">
        <seg>收到数据时，需要进行以下比较：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining new connection options, specification authors ought to survey existing header field names and ensure that the new connection option does not share the same name as an already deployed header field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110823Z" creationid="pingfangx" creationdate="20190831T110823Z">
        <seg>定义新的连接选项时，规范作者应该调查现有的首部字段名称，并确保新连接选项与已部署的首部字段不共享同一名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When does an Observable begin emitting its sequence of items?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064950Z" creationid="pingfangx" creationdate="20190620T064950Z">
        <seg>Observable 何时开始发射其数据项序列？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When encountering a premature close, a client SHOULD treat as completed all requests for which it has received as much data as specified in the Content-Length header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093937Z" creationid="pingfangx" creationdate="20190901T093937Z">
        <seg>当遇到过早关闭时，客户端应该将已收到的所有请求视为已完成的 Content-Length 首部中指定的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in canonical form, media subtypes of the "text" type use CRLF as the text line break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151139Z" creationid="pingfangx" creationdate="20190828T151139Z">
        <seg>在规范形式中，“text”类型的媒体子类型使用 CRLF 作为文本换行符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the target URI's authority component (excluding any userinfo and its "@" delimiter) as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125030Z" creationid="pingfangx" creationdate="20190831T125030Z">
        <seg>当通过一个或多个代理建立隧道的 CONNECT 请求时，客户端必须只发送目标 URI 的权限组件(不包括任何 userinfo 及其“@”分隔符)作为请求目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send only the absolute path and query components of the target URI as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T123911Z" creationid="pingfangx" creationdate="20190831T123911Z">
        <seg>当直接向源服务器发出请求时，除了 CONNECT 或服务器范围的 OPTIONS 请求(如下所述)之外，客户端必须仅发送目标 URI 的绝对路径和查询组件作为请求目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in absolute-form as the request-target.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124314Z" creationid="pingfangx" creationdate="20190831T124314Z">
        <seg>当向代理发出请求时，除了 CONNECT 或服务器范围的 OPTIONS 请求(如下所述)之外，客户端必须以绝对形式发送目标 URI 作为请求目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T023313Z" creationid="pingfangx" creationdate="20190828T023313Z">
        <seg>当创建新连接时，使用初始序列号(ISN)生成器，其选择新的 32 位 ISN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When no explicit charset parameter is provided by the sender, media subtypes of the "text" type are defined to have a default charset value of "ISO-8859-1" when received via HTTP.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T151726Z" creationid="pingfangx" creationdate="20190828T151726Z">
        <seg>当发送方未提供显式字符集参数时，“text”类型的媒体子类型被定义为在通过 HTTP 接收时具有默认字符集值“ISO-8859-1”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When not being used in absolute form as the request target of an OPTIONS request, an empty path component is equivalent to an absolute path of "/", so the normal form is to provide a path of "/" instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060953Z" creationid="pingfangx" creationdate="20190831T060953Z">
        <seg>当不以绝对形式用作 OPTIONS 请求的请求目标时，空路径组件等同于“/”的绝对路径，因此正常形式是提供“/”的路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When presented with a URI that violates one or more scheme-specific restrictions, the scheme-specific resolution process should flag the reference as an error rather than ignore the unused parts; doing so reduces the number of equivalent URIs and helps detect abuses of the generic syntax, which might indicate that the URI has been constructed to mislead the user (Section 7.6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T072702Z" creationid="pingfangx" creationdate="20190902T072702Z">
        <seg>当呈现违反一个或多个特定于方案的限制的 URI 时，特定于方案的解析过程应该将引用标记为错误而不是忽略未使用的部分；这样做可以减少等效 URI 的数量，并有助于检测泛型语法的滥用，这可能表明 URI 已被构造为误导用户(第 7.6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 6.6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111829Z" creationid="pingfangx" creationdate="20190831T111829Z">
        <seg>在连接失败后重新连接流水线请求(服务器在其上一个完整响应中未明确关闭的连接)，客户端必须在连接建立后不立即进行流水线，因为先前流水线中的第一个剩余请求可能导致错误响应如果在过早关闭的连接上发送多个请求，则可能会再次丢失(请参阅第 6.6 节中描述的 TCP 重置问题)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When sending data to older HTTP applications, implementations SHOULD only use media type parameters when they are required by that type/subtype definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T145958Z" creationid="pingfangx" creationdate="20190828T145958Z">
        <seg>当向旧的 HTTP 应用程序发送数据时，实现只应在该类型/子类型定义需要时使用媒体类型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When simultaneous attempt occurs, each TCP receives a "SYN" segment which carries no acknowledgment after it has sent a "SYN".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T031523Z" creationid="pingfangx" creationdate="20190828T031523Z">
        <seg>当同时尝试发生时，每个 TCP 都会收到一个“SYN”报文段，在发送“SYN”后，该报文段不包含确认信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the "chunked" transfer- coding is used, it MUST be the last transfer-coding applied to the message-body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142747Z" creationid="pingfangx" creationdate="20190828T142747Z">
        <seg>当使用“分块”传输编码时，它必须是应用于消息体的最后一个传输编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the SYN arrives at line 3, TCP B, being in a synchronized state, and the incoming segment outside the window, responds with an acknowledgment indicating what sequence it next expects to hear (ACK 100).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T060037Z" creationid="pingfangx" creationdate="20190828T060037Z">
        <seg>当 SYN 到达第 3 行时，处于同步状态的 TCP B 和窗口外的传入报文段响应确认，指示接下来希望听到的序列(ACK 100)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the TCP is up again, A is likely to start again from the beginning or from a recovery point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T055743Z" creationid="pingfangx" creationdate="20190828T055743Z">
        <seg>当 TCP 再次启动时，A 很可能从开始或从恢复点再次启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the TLS handshake has finished.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T091424Z" creationid="pingfangx" creationdate="20190901T091424Z">
        <seg>TLS 握手完成后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the dataflow runs through asynchronous steps, each step may perform different things with different speed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071154Z" creationid="pingfangx" creationdate="20190617T071154Z">
        <seg>当数据流通过异步步骤时，每个步骤可以以不同的速度执行不同的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the original SYN (pun intended) finally arrives at line 6, the synchronization proceeds normally.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T043327Z" creationid="pingfangx" creationdate="20190828T043327Z">
        <seg>当原始 SYN(双关语)最终到达第 6 行时，同步正常进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the other TCP has both acknowledged the FIN and sent a FIN of its own, the first TCP can ACK this FIN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T063614Z" creationid="pingfangx" creationdate="20190828T063614Z">
        <seg>当另一个 TCP 同时确认了 FIN 并发送了自己的 FIN 时，第一个 TCP 可以确认此 FIN。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When to Encode or Decode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T042809Z" creationid="pingfangx" creationdate="20190902T042809Z">
        <seg>何时编码或解码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include "chunked", unless the message is terminated by closing the connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T142731Z" creationid="pingfangx" creationdate="20190828T142731Z">
        <seg>每当传输编码应用于消息体时，传输编码集必须包括“分块”，除非通过关闭连接终止消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever the downstream is not ready to receive values, this operator will drop that elemenet from the sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014731Z" creationid="pingfangx" creationdate="20190624T014731Z">
        <seg>每当下游未准备好接收值时，此操作符将从序列中删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wherever this construct is used, null elements are allowed, but do not contribute to the count of elements present.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T094031Z" creationid="pingfangx" creationdate="20190828T094031Z">
        <seg>无论在何处使用此构造，都允许使用 null 元素，但不会对存在的元素数量做出贡献。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which looks something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055915Z" creationid="pingfangx" creationdate="20190620T055915Z">
        <seg>看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While computing the checksum, the checksum field itself is replaced with zeros.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110021Z" creationid="pingfangx" creationdate="20190827T110021Z">
        <seg>在计算校验和时，校验和字段本身将替换为零。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While in some cases the HTTP protocol allows the client to find out whether truncation took place so that, if it received the complete reply, it may tolerate such errors following the principle to "[be] strict when sending and tolerant when receiving" [RFC1958], often truncation does not show in the HTTP protocol data; two cases in particular deserve special note:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T093239Z" creationid="pingfangx" creationdate="20190901T093239Z">
        <seg>虽然在某些情况下 HTTP 协议允许客户端查明是否发生了截断，因此，如果收到完整的答复，它可以容忍这样的错误，遵循“发送时严格和接收时容忍”[RFC1958]，经常在 HTTP 协议数据中没有显示截断；特别值得注意的是两个案例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>White space is not allowed within the tag and all tags are case- insensitive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T154904Z" creationid="pingfangx" creationdate="20190828T154904Z">
        <seg>标签内不允许有空格，所有标签都不区分大小写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>White space is only significant in that indentation of continuation lines is used to indicate a rule definition that spans more than one line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T092648Z" creationid="pingfangx" creationdate="20190828T092648Z">
        <seg>空白区域的重要意义在于延续行的缩进用于指示跨越多行的规则定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090730Z" creationid="pingfangx" creationdate="20190830T090730Z">
        <seg>空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why Use Observables?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034112Z" creationid="pingfangx" creationdate="20190620T034112Z">
        <seg>为什么要使用 Observables？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the two examples before, the 2.x code can now look like this since `ResourceSubscriber` implements `Disposable` directly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070804Z" creationid="pingfangx" creationdate="20190618T070804Z">
        <seg>使用前面的两个例子，2.x 代码现在看起来像这样，因为 `ResourceSubscriber` 直接实现 `Disposable`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With these additions, ReactiveX harmonizes the Iterable and Observable types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042451Z" creationid="pingfangx" creationdate="20190620T042451Z">
        <seg>通过这些添加，ReactiveX 使得 Iterable 和 Observable 类型保持一致了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T102640Z" creationid="pingfangx" creationdate="20190830T102640Z">
        <seg>在给定的消息中，发送方不得生成仅允许由其他角色的参与者生成的协议元素或语法备选方案(即，发送方对该消息没有的角色)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a specific handler, RxJava defaults to printing the `Throwable`'s stacktrace to the console and calls the current thread's uncaught exception handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090305Z" creationid="pingfangx" creationdate="20190618T090305Z">
        <seg>如果没有特定的处理程序，RxJava 默认将 `Throwable` 的堆栈跟踪打印到控制台并调用当前线程的未捕获异常处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025219Z" creationid="pingfangx" creationdate="20190828T025219Z">
        <seg>如果没有这样的假设，可以想象两个不同的 TCP 报文段被分配相同或重叠的序列号，从而导致接收器对哪些数据是新的以及哪些是旧的混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22] only when encoded according to the rules of RFC 2047 [14].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T100027Z" creationid="pingfangx" creationdate="20190828T100027Z">
        <seg>* TEXT 的字只有在符合 RFC 2047 [14] 的规则编码时才包含 ISO-8859-1 [22] 以外的字符集中的字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with this new base reactive type is practically the same as the others as it offers a modest subset of the `Flowable` operators that make sense with a 0 or 1 item sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061038Z" creationid="pingfangx" creationdate="20190618T061038Z">
        <seg>使用这种新的基本响应类型实际上与其他类型相同，因为它提供了一个适用于 0 或 1 项序列的 `Flowable` 运算符的适度子集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write-Through Mandatory</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T074054Z" creationid="pingfangx" creationdate="20190828T074054Z">
        <seg>直写强制性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing such state machines as `Iterable`s is somewhat complicated (but still easier than writing an `Flowable` for consuming it) and unlike C#, Java doesn't have any support from the compiler to build such state machines by simply writing classically looking code (with `yield return` and `yield break`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020416Z" creationid="pingfangx" creationdate="20190624T020416Z">
        <seg>编写像 `Iterable` 这样的状态机有点复杂(但是比编写一个 `Flowable` 更容易使用它)并且与 C＃不同，Java 没有任何编译器支持通过简单编写经典外观来构建这样的状态机代码(带有 `yield return` 和 `yield break`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yet another example is `Catch` which was named `onErrorResumeNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101913Z" creationid="pingfangx" creationdate="20190617T101913Z">
        <seg>另一个例子是 `Catch`，它命名为 `onErrorResumeNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify a particular &lt;a0&gt;Scheduler&lt;/a0&gt; for the timer to operate on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075655Z" creationid="pingfangx" creationdate="20190620T075655Z">
        <seg>您还可以为要运行的计时器指定特定的 &lt;a0&gt;Scheduler&lt;/a0&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use &lt;a0&gt;a version of &lt;c1&gt;schedule&lt;/c1&gt;&lt;/a0&gt; that delays your action on the given Scheduler until a certain timespan has passed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092431Z" creationid="pingfangx" creationdate="20190620T092431Z">
        <seg>您还可以使用 &lt;a0&gt;&lt;c1&gt;schedule&lt;/c1&gt; 的版本&lt;/a0&gt;，该版本会在给定调度器上延时你的操作，直到超过某个时间跨度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061700Z" creationid="pingfangx" creationdate="20190620T061700Z">
        <seg>您可以调用此方法来指示订阅服务器不再对其当前订阅的任何 Observable 感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the class and add your own custom `subscribeActual` behavior to achieve something similar to the 1.x features:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063923Z" creationid="pingfangx" creationdate="20190618T063923Z">
        <seg>您可以继承类并添加自己的自定义 `subscribeActual` 行为，以实现类似于 1.x 功能的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of the Observable class as a “push” equivalent to &lt;a0&gt;Iterable&lt;/a0&gt;, which is a “pull.” With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042125Z" creationid="pingfangx" creationdate="20190620T042125Z">
        <seg>您可以将 Observable 类的“推”，视为等同于 &lt;a0&gt;Iterable&lt;/a0&gt; 的“拉”。对于 Iterable，消费者从生产者拉取值，并且线程阻塞直到这些值到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use `Subject.toSerialized()` and `FlowableProcessor.toSerialized()` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063632Z" creationid="pingfangx" creationdate="20190618T063632Z">
        <seg>您必须使用 `Subject.toSerialized()` 和 `FlowableProcessor.toSerialized()` 代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to handle an element frequency of 1000 Hz or less with Observable but consider using sampling/debouncing anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054651Z" creationid="pingfangx" creationdate="20190618T054651Z">
        <seg>您可以使用 Observable 处理 1000 Hz 或更低的元素频率，但无论如何都要考虑使用 sampling/debouncing。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You obtain a Scheduler from the factory methods described in &lt;a0&gt;the &lt;c1&gt;Schedulers&lt;/c1&gt; class&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090922Z" creationid="pingfangx" creationdate="20190620T090922Z">
        <seg>您可以从 &lt;a0&gt;&lt;c1&gt;Schedulers&lt;/c1&gt; 类&lt;/a0&gt; 中描述的工厂方法获取 Scheduler。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use or rely on them in any production code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105326Z" creationid="pingfangx" creationdate="20190617T105326Z">
        <seg>您不应该在任何生产代码中使用或依赖它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your observer implements some subset of the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060237Z" creationid="pingfangx" creationdate="20190620T060237Z">
        <seg>你的观察者实现以下方法的某些子集：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[... data stream switches to HTTP/2.0 with an appropriate response (as defined by new protocol) to the "GET /hello.txt" request ...]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T113540Z" creationid="pingfangx" creationdate="20190831T113540Z">
        <seg>[...数据流切换到带有适当响应的 HTTP/2.0(由新协议定义)到“GET /hello.txt”请求...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Action1` has been renamed to `Consumer` and `Action2` is called `BiConsumer`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064844Z" creationid="pingfangx" creationdate="20190618T064844Z">
        <seg>`Action1` 已重命名为 `Consumer`，`Action2` 被称为 `BiConsumer`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ActionN` is replaced by the `Consumer&lt;Object[]&gt;` type declaration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064910Z" creationid="pingfangx" creationdate="20190618T064910Z">
        <seg>`ActionN` 被 `Consumer&lt;Object[]&gt;` 类型声明所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Flowable` can be tested with `io.reactivex.subscribers.TestSubscriber` whereas the non-backpressured `Observable`, `Single`, `Maybe` and `Completable` can be tested with `io.reactivex.observers.TestObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095806Z" creationid="pingfangx" creationdate="20190618T095806Z">
        <seg>`Flowable` 可以使用 `io.reactivex.subscribers.TestSubscriber` 进行测试，而非背压的 `Observable`，`Single`，`Maybe` 和 `Completable` 可以使用 `io.reactivex.observers.TestObserver` 进行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061253Z" creationid="pingfangx" creationdate="20190619T061253Z">
        <seg>`Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Observable&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061251Z" creationid="pingfangx" creationdate="20190619T061251Z">
        <seg>`Observable&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061302Z" creationid="pingfangx" creationdate="20190619T061302Z">
        <seg>`Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`TestSubscriber` has the `test(long initialRequest)` and `test(long initialRequest, boolean cancel)` overloads to specify the initial request amount and whether the `TestSubscriber` should be also immediately cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101738Z" creationid="pingfangx" creationdate="20190618T101738Z">
        <seg>`TestSubscriber` 有 `test(long initialRequest)` 和 `test(long initialRequest，boolean cancel)` 重载来指定初始请求数量以及是否应立即取消 `TestSubscriber`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`flatMap` is a powerful operator and helps in a lot of situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083339Z" creationid="pingfangx" creationdate="20190617T083339Z">
        <seg>`flatMap` 是一个功能强大的运算符，可以在很多情况下提供帮助。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`just` is great when there is a constant value we'd like to jump-start a sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015708Z" creationid="pingfangx" creationdate="20190624T015708Z">
        <seg>当有一个恒定的值我们想要跳过一个序列时，`just` 很棒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`just` won't emit its constant value until requested when it is mapped to the result of the `computeValue`, still called for each subscriber individually.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020123Z" creationid="pingfangx" creationdate="20190624T020123Z">
        <seg>`just` 在被映射到 `computeValue` 的结果之前被请求时不会发射它的常量值，仍然单独为每个用户调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a Single passes this method the Throwable that caused the Single to be unable to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073728Z" creationid="pingfangx" creationdate="20190620T073728Z">
        <seg>Single 将导致 Single 无法发射项目的 Throwable 传递给此方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a Single passes this method the sole item that the Single emits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073630Z" creationid="pingfangx" creationdate="20190620T073630Z">
        <seg>Single 将发射的唯一项目传递给此方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a variety of operators that enforce particular flow-control policies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072125Z" creationid="pingfangx" creationdate="20190620T072125Z">
        <seg>各种执行特定流量控制策略的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a)the request included a TE header field that indicates "trailers" is acceptable in the transfer-coding of the  response, as described in section 14.39; or,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144214Z" creationid="pingfangx" creationdate="20190828T144214Z">
        <seg>a)请求包括一个 TE 首部字段，表示在响应的传输编码中可以接受“trailers”，如第 14.39 节所述；要么，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `amb(ObservableSource...)` overload, 2-9 argument versions dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112016Z" creationid="pingfangx" creationdate="20190618T112016Z">
        <seg>添加了 `amb(ObservableSource...)` 重载，2-9 个参数的版本被删除了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `concatArrayEager` and `concatArrayEagerDelayError`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112940Z" creationid="pingfangx" creationdate="20190618T112940Z">
        <seg>添加 `concatArrayEager` 和 `concatArrayEagerDelayError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `concatArray` and `concatArrayDelayError`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112930Z" creationid="pingfangx" creationdate="20190618T112930Z">
        <seg>添加 `concatArray` 和 `concatArrayDelayError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `doOnLifecylce` to handle `onSubscribe`, `request` and `cancel` peeking</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052545Z" creationid="pingfangx" creationdate="20190619T052545Z">
        <seg>添加 `doOnLifecylce` 来处理 `onSubscribe`，`request` 和 `cancel` peeking</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `forEachWhile(Predicate&lt;T&gt;, [Consumer&lt;Throwable&gt;, [Action]])` for conditionally stopping consumption</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053032Z" creationid="pingfangx" creationdate="20190619T053032Z">
        <seg>添加 `forEachWhile(Predicate&lt;T&gt;, [Consumer&lt;Throwable&gt;, [Action]])` 以有条件地停止消费</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `fromPublisher`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114304Z" creationid="pingfangx" creationdate="20190618T114304Z">
        <seg>添加 `fromPublisher`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `intervalRange()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114315Z" creationid="pingfangx" creationdate="20190618T114315Z">
        <seg>添加 `intervalRange()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `reduceWith(Callable, BiFunction)` to reduce in a Subscriber-individual manner, returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053555Z" creationid="pingfangx" creationdate="20190619T053415Z">
        <seg>添加 `reduceWith(Callable, BiFunction)` 以订阅者个人的方式减少，返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `repeatUntil(BooleanSupplier)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053425Z" creationid="pingfangx" creationdate="20190619T053425Z">
        <seg>添加 `repeatUntil(BooleanSupplier)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `retry(Predicate)`, `retry(int, Predicate)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053442Z" creationid="pingfangx" creationdate="20190619T053442Z">
        <seg>添加了 `retry(Predicate)`，`retry(int，Predicate)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `retryUntil(BooleanSupplier)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053445Z" creationid="pingfangx" creationdate="20190619T053445Z">
        <seg>添加了 `retryUntil(BooleanSupplier)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `scanWith(Callable, BiFunction)` to scan in a Subscriber-individual manner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053540Z" creationid="pingfangx" creationdate="20190619T053540Z">
        <seg>添加了 `scanWith(Callable, BiFunction)` 来以订阅者个人的方式进行扫描</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `startWithArray` to disambiguate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053729Z" creationid="pingfangx" creationdate="20190619T053729Z">
        <seg>添加了 `startWithArray` 来消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `subscribeWith` that returns its input after subscription</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053822Z" creationid="pingfangx" creationdate="20190619T053822Z">
        <seg>添加了 `subscribeWith`，在订阅后返回其输入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `test()` (returns TestSubscriber subscribed to this) with overloads to fluently test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053900Z" creationid="pingfangx" creationdate="20190619T053900Z">
        <seg>添加了 `test()` (返回 TestSubscriber 订阅了这个)，带有重载以流畅地测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `toFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054030Z" creationid="pingfangx" creationdate="20190619T054030Z">
        <seg>添加了 `toFuture`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `toObservable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054032Z" creationid="pingfangx" creationdate="20190619T054032Z">
        <seg>添加了 `toObservable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `bufferSize`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061908Z" creationid="pingfangx" creationdate="20190618T114358Z">
        <seg>添加带 `bufferSize` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `bufferSize` and `delayError` option, *the custom internal map version didn't make it into RC1*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053105Z" creationid="pingfangx" creationdate="20190619T053105Z">
        <seg>添加带有 `bufferSize` 和 'delayerror' 选项的重载，*自定义内部映射版本没有将其转换为 RC1*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053316Z" creationid="pingfangx" creationdate="20190618T114415Z">
        <seg>添加带 `prefetch` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch` argument</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053832Z" creationid="pingfangx" creationdate="20190619T053832Z">
        <seg>添加了带有 `prefetch` 参数的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch` argument, 5-9 source overloads dropped, use `concatArray` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112702Z" creationid="pingfangx" creationdate="20190618T112702Z">
        <seg>添加带 `prefetch` 参数的重载，删除了 5-9 个源的重载，使用 `concatArray` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `bufferSize` and `delayError` options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053708Z" creationid="pingfangx" creationdate="20190619T053708Z">
        <seg>添加了带有 `bufferSize` 和 `delayError` 选项的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `bufferSize` and `delayErrors` capabilities, disambiguated to `zipArray` and `zipIterable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114528Z" creationid="pingfangx" creationdate="20190618T114528Z">
        <seg>添加带 `bufferSize` 和 `delayErrors` 功能的重载，使用 `zipArray` 和 `zipIterable` 消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061853Z" creationid="pingfangx" creationdate="20190618T114338Z">
        <seg>添加带 `prefetch` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch` and `delayErrors` options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T055924Z" creationid="pingfangx" creationdate="20190619T054541Z">
        <seg>添加了带有 `prefetch` 和 `delayErrors` 选项的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch`, option to delay till the current ends or till the very end</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T051728Z" creationid="pingfangx" creationdate="20190619T051728Z">
        <seg>添加带 `prefetch` 的重载，可选择延迟到当前结束或直到最后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with option to delay till the current ends or till the very end</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113044Z" creationid="pingfangx" creationdate="20190618T113044Z">
        <seg>添加了重载，可选择延迟到当前结束或直到最后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added varargs overload, added overloads with `bufferSize` argument, `combineLatest(List)` dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112450Z" creationid="pingfangx" creationdate="20190618T112450Z">
        <seg>添加了可变参数重载，添加了 `bufferSize` 参数的重载，删除了 `combineLatest(List)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>advances the Scheduler’s clock forward by a particular amount of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091835Z" creationid="pingfangx" creationdate="20190620T091835Z">
        <seg>将调度器的时钟向前推进一段特定的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>advances the Scheduler’s clock to a particular point in time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091831Z" creationid="pingfangx" creationdate="20190620T091831Z">
        <seg>将调度器的时钟提前到特定时间点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after a specified delay</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104344Z" creationid="pingfangx" creationdate="20190620T104344Z">
        <seg>在指定的延迟后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after connecting to port 8001 of host "www.example.org".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125244Z" creationid="pingfangx" creationdate="20190831T125244Z">
        <seg>在连接到主机“www.example.org”的端口 8001 之后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow further customization of the backpressure behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100500Z" creationid="pingfangx" creationdate="20190617T100500Z">
        <seg>允许进一步定制背压行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allows you create a custom operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074015Z" creationid="pingfangx" creationdate="20190620T074015Z">
        <seg>允许创建自定义操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a number indicating how many items were in the sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105901Z" creationid="pingfangx" creationdate="20190620T105901Z">
        <seg>并发射一个数字，表示序列中有多少项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if &lt;e0&gt;all&lt;/e0&gt; of the items pass some test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105808Z" creationid="pingfangx" creationdate="20190620T105808Z">
        <seg>并发射一个布尔值，表明项目的 &lt;e0&gt;全部&lt;/e0&gt; 是否通过了一些测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the Observable emitted &lt;e0&gt;any&lt;/e0&gt; item (that passes some test)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105820Z" creationid="pingfangx" creationdate="20190620T105820Z">
        <seg>并发射一个布尔值，指示 Observable 是否发射了 &lt;e0&gt;任何&lt;/e0&gt; 项(通过了一些测试)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the Observable emitted &lt;e0&gt;no&lt;/e0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105843Z" creationid="pingfangx" creationdate="20190620T105843Z">
        <seg>并发射一个布尔值，指示 Observable 是否 &lt;e0&gt;没有&lt;/e0&gt; 发射项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105848Z" creationid="pingfangx" creationdate="20190620T105848Z">
        <seg>并发射一个布尔值，指示序列是否与第二个 Observable 发射的序列相同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the average of all of their values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105854Z" creationid="pingfangx" creationdate="20190620T105854Z">
        <seg>并发射所有值的平均值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the item with the maximum value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105904Z" creationid="pingfangx" creationdate="20190620T105904Z">
        <seg>并发射具有最大值的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the item with the minimum value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105935Z" creationid="pingfangx" creationdate="20190620T105914Z">
        <seg>并发射具有最小值的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the sum of all of their values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105856Z" creationid="pingfangx" creationdate="20190620T105856Z">
        <seg>并发射所有值的总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting all of the items from all of the Observables in whatever order they are received</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104544Z" creationid="pingfangx" creationdate="20190620T104544Z">
        <seg>按照收到的顺序从所有 Observable 中发射所有项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting all of the items from all of the Observables, one Observable at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104553Z" creationid="pingfangx" creationdate="20190620T104553Z">
        <seg>从所有的 Observable 中发射所有物品，一次一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting the items from only the most-recently emitted of those Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104757Z" creationid="pingfangx" creationdate="20190620T104757Z">
        <seg>仅从最近发射的那些 Observables 中发射项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and follows the protocol `onSubscribe (onSuccess | onError)?`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055918Z" creationid="pingfangx" creationdate="20190618T055918Z">
        <seg>并遵循协议 `onSubscribe (onSuccess | onError)?`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for Ivy:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105531Z" creationid="pingfangx" creationdate="20190617T105531Z">
        <seg>对于 Ivy：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for Maven:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105526Z" creationid="pingfangx" creationdate="20190617T105526Z">
        <seg>对于 Maven：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and still follows the protocol `onSubscribe (onComplete | onError)?`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060131Z" creationid="pingfangx" creationdate="20190618T060131Z">
        <seg>并且仍遵循协议 `onSubscribe (onComplete | onError)?`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then I want to ask it to start</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110202Z" creationid="pingfangx" creationdate="20190620T110202Z">
        <seg>然后我想要它开始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then emits the complete sequence, even to those who subscribe after the sequence has begun</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110150Z" creationid="pingfangx" creationdate="20190620T110150Z">
        <seg>然后发射完整的序列，甚至是那些在序列开始后订阅的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then only emits the last item in its sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110138Z" creationid="pingfangx" creationdate="20190620T110138Z">
        <seg>然后只发射序列中的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100732Z" creationid="pingfangx" creationdate="20190620T095948Z">
        <seg>将函数应用于 Observable 发射的每个项目，按顺序，并发射每个连续的值（译注：与 Map 区别于函数会使用上一次函数值）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a function to each item emitted by an Observable, sequentially, and emit the final value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103018Z" creationid="pingfangx" creationdate="20190620T103018Z">
        <seg>将函数按顺序应用于 Observable 发射的每个项目，并发射最终值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>asynchronous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033704Z" creationid="pingfangx" creationdate="20190620T033704Z">
        <seg>异步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>at particular intervals of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104502Z" creationid="pingfangx" creationdate="20190620T104502Z">
        <seg>在特定的时间间隔</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>attach a timestamp to each item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102352Z" creationid="pingfangx" creationdate="20190620T102352Z">
        <seg>将时间戳附加到 Observable 发射的每个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b)the server is the origin server for the response, the trailer fields consist entirely of optional metadata, and the recipient could use the message (in a manner acceptable to the origin server) without receiving this metadata.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T144236Z" creationid="pingfangx" creationdate="20190828T144236Z">
        <seg>b)服务器是响应的原始服务器，trailer 字段完全由可选元数据组成，并且接收者可以使用该消息(以原始服务器可接受的方式)而不接收该元数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>based on all of the items that preceded them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104957Z" creationid="pingfangx" creationdate="20190620T104957Z">
        <seg>基于它们之前的所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but I want it to go away once all of its subscribers unsubscribe</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110157Z" creationid="pingfangx" creationdate="20190620T110157Z">
        <seg>但是，一旦所有订阅者取消订阅，我希望它能够消失</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by applying an aggregation function to each item in turn and emitting the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105942Z" creationid="pingfangx" creationdate="20190620T105942Z">
        <seg>通过依次对每个项目应用聚合函数并发射结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by attaching a timestamp to them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105002Z" creationid="pingfangx" creationdate="20190620T105002Z">
        <seg>通过附加时间戳给他们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by attempting to resubscribe to the upstream Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110106Z" creationid="pingfangx" creationdate="20190620T110106Z">
        <seg>试图重新订阅上游的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by combining the items from two or more Observables sequentially to come up with new items to emit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104612Z" creationid="pingfangx" creationdate="20190620T104612Z">
        <seg>通过顺序组合来自两个或多个 Observable 的项目来提出要发射的新项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by delaying my subscription to it for some time after it begins emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105714Z" creationid="pingfangx" creationdate="20190620T105714Z">
        <seg>在开始发布项目后的一段时间内延迟我的订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by emitting all of the items emitted by corresponding Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104946Z" creationid="pingfangx" creationdate="20190620T104946Z">
        <seg>通过发射相应的 Observables 发射的所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by filtering out those that do not match some predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105304Z" creationid="pingfangx" creationdate="20190620T105304Z">
        <seg>通过过滤掉那些与某些谓词不匹配的东西</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by means of &lt;c0&gt;Pattern&lt;/c0&gt; and &lt;c1&gt;Plan&lt;/c1&gt; intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104716Z" creationid="pingfangx" creationdate="20190620T104716Z">
        <seg>通过 &lt;c0&gt;Pattern&lt;/c0&gt; 和 &lt;c1&gt;Plan&lt;/c1&gt; 中介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by only emitting items that are not followed by other items within some duration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105649Z" creationid="pingfangx" creationdate="20190620T105649Z">
        <seg>通过仅在一段时间内发射未跟随其他项目的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by retrieving it from a Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104407Z" creationid="pingfangx" creationdate="20190620T104407Z">
        <seg>通过从 Future 中获取</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by sampling the Observable periodically</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105632Z" creationid="pingfangx" creationdate="20190620T105632Z">
        <seg>通过定期对 Observable 进行抽样</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by suppressing items that are duplicates of already-emitted items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105655Z" creationid="pingfangx" creationdate="20190620T105655Z">
        <seg>通过抑制与已发射项目重复的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by wrapping them in &lt;c0&gt;Notification&lt;/c0&gt; objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105059Z" creationid="pingfangx" creationdate="20190620T105059Z">
        <seg>将它们包装在 &lt;c0&gt;Notification&lt;/c0&gt; 对象中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculate the sum of numbers emitted by an Observable and emit this sum</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103028Z" creationid="pingfangx" creationdate="20190620T103028Z">
        <seg>计算 Observable 发射的数字之和并发射此总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculates the average of numbers emitted by an Observable and emits this average</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102858Z" creationid="pingfangx" creationdate="20190620T102858Z">
        <seg>计算 Observable 发射的数字的平均值并发射此平均值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `List`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061444Z" creationid="pingfangx" creationdate="20190619T061444Z">
        <seg>将所有元素收集到 `List` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `List` and sorts it</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061457Z" creationid="pingfangx" creationdate="20190619T061457Z">
        <seg>将所有元素收集到 `List` 中并对其进行排序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `Map`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061448Z" creationid="pingfangx" creationdate="20190619T061448Z">
        <seg>将所有元素收集到 `Map` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `Map` with collection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061453Z" creationid="pingfangx" creationdate="20190619T061453Z">
        <seg>将所有元素收集到带有集合的 `Map` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101457Z" creationid="pingfangx" creationdate="20190620T101457Z">
        <seg>在根据另一个 Observable 发射的项目定义的时间窗口期间发射一个 Observable 中的项目时，组合两个 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine multiple Observables into one by merging their emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101553Z" creationid="pingfangx" creationdate="20190620T101553Z">
        <seg>通过合并它们的发射，将多个 Observable 组合成一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine sets of items emitted by two or more Observables by means of `Pattern` and `Plan` intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101248Z" creationid="pingfangx" creationdate="20190620T101248Z">
        <seg>通过 `Pattern` 和 `Plan` 中介组合两个或多个 Observable 发射的项目集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101737Z" creationid="pingfangx" creationdate="20190620T101737Z">
        <seg>通过指定的函数将多个 Observable 的发射组合在一起，并根据此函数的结果为每个组合发射单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>concatenates the items emitted by multiple Singles as Observable emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074050Z" creationid="pingfangx" creationdate="20190620T074050Z">
        <seg>将多个 Singles 发射的项目连接为 Observable 的发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containing only the last items emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105215Z" creationid="pingfangx" creationdate="20190620T105215Z">
        <seg>仅包含最后发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable into another object or data structure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103726Z" creationid="pingfangx" creationdate="20190620T103726Z">
        <seg>将 Observable 转换为另一个对象或数据结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101651Z" creationid="pingfangx" creationdate="20190620T101651Z">
        <seg>将发射 Observables 的 Observable 转换为单个 Observable，该 Observable 发射最近发射的 Observables 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102326Z" creationid="pingfangx" creationdate="20190620T102326Z">
        <seg>将发射数据项的 Observable 转换为发射这些发射项之间经过的时间量的指示的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an object or a set of objects into an Observable that emits that or those objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095323Z" creationid="pingfangx" creationdate="20190620T095323Z">
        <seg>将对象或一组对象转换为发射该对象或那些对象的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an ordinary Observable into a connectable Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103616Z" creationid="pingfangx" creationdate="20190620T103616Z">
        <seg>将普通的 Observable 转换为可连接的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert some other object or data structure into an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095214Z" creationid="pingfangx" creationdate="20190620T095214Z">
        <seg>将一些其他对象或数据结构转换为 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Future into a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074449Z" creationid="pingfangx" creationdate="20190620T074449Z">
        <seg>将 Future 转化为 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single into an Observable that emits the item emitted by the Single and then completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074839Z" creationid="pingfangx" creationdate="20190620T074839Z">
        <seg>将 Single 转换为 Observable，它发射 Single 发射的项，然后完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single that emits a second Single into a Single that emits the item emitted by the second Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074616Z" creationid="pingfangx" creationdate="20190620T074616Z">
        <seg>将发射第二个 Single 的 Single 转换为发射第二个 Single 发射的项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single that makes an error notification into a Single that emits a specified item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074728Z" creationid="pingfangx" creationdate="20190620T074728Z">
        <seg>将发射错误通知的 Single 转换为发射指定项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts an Observable that emits a single item into a Single that emits that item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074827Z" creationid="pingfangx" creationdate="20190620T074827Z">
        <seg>将发射单个项目的 Observable 转换为发射该项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>count the number of items emitted by the source Observable and emit only this value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102934Z" creationid="pingfangx" creationdate="20190620T102934Z">
        <seg>计算源 Observable 发射的项目数，并仅发射此值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create Observables that have very precise and limited behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095200Z" creationid="pingfangx" creationdate="20190620T095200Z">
        <seg>创建具有非常精确和有限行为的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create a Single from scratch by calling subscriber methods explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074105Z" creationid="pingfangx" creationdate="20190620T074105Z">
        <seg>通过显式调用订阅者方法从头创建 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create a disposable resource that has the same lifespan as the Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102425Z" creationid="pingfangx" creationdate="20190620T102425Z">
        <seg>创建一个与 Observable 具有相同生命周期的可释放资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable from scratch by calling observer methods programmatically</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095124Z" creationid="pingfangx" creationdate="20190620T095124Z">
        <seg>通过以编程方式调用 observer 方法从头创建一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a particular item or sequence of items repeatedly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095341Z" creationid="pingfangx" creationdate="20190620T095341Z">
        <seg>创建一个 Observable，重复发射特定项目或项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a range of sequential integers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095332Z" creationid="pingfangx" creationdate="20190620T095332Z">
        <seg>创建一个发射一系列连续整数的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a sequence of integers spaced by a particular time interval</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095309Z" creationid="pingfangx" creationdate="20190620T095309Z">
        <seg>创建一个 Observable，它以特定时间间隔发射一系列整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a single item after a given delay</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095356Z" creationid="pingfangx" creationdate="20190620T095356Z">
        <seg>创建一个在给定延迟后发射单个项目的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits the return value of a function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095348Z" creationid="pingfangx" creationdate="20190620T095348Z">
        <seg>创建一个发射函数返回值的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>creates a new thread for each unit of work</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091301Z" creationid="pingfangx" creationdate="20190620T091301Z">
        <seg>为每个工作单元创建一个新线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deprecated and dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115754Z" creationid="pingfangx" creationdate="20190618T115754Z">
        <seg>弃用并删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deprecated overloads dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114441Z" creationid="pingfangx" creationdate="20190618T114441Z">
        <seg>已删除弃用的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether all items emitted by an Observable meet some criteria</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102529Z" creationid="pingfangx" creationdate="20190620T102529Z">
        <seg>确定 Observable 发射的所有项目是否符合某些标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether an Observable emits a particular item or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102737Z" creationid="pingfangx" creationdate="20190620T102737Z">
        <seg>确定 Observable 是否发射特定项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether two Observables emit the same sequence of items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102753Z" creationid="pingfangx" creationdate="20190620T102753Z">
        <seg>确定两个 Observable 是否发射相同的项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine, and emit, the maximum-valued item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102942Z" creationid="pingfangx" creationdate="20190620T102942Z">
        <seg>确定并发射 Observable 发射的最大值项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine, and emit, the minimum-valued item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102948Z" creationid="pingfangx" creationdate="20190620T102948Z">
        <seg>确定并发射 Observable 发射的最小值项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>directly from the origin server would open (or reuse) a TCP connection to port 80 of the host "www.example.org" and send the lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124204Z" creationid="pingfangx" creationdate="20190831T124204Z">
        <seg>将直接从源服务器打开(或重用)TCP 连接到主机“www.example.org”的端口 80 并发送行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disambiguated into `fromArray`, `fromIterable`, `fromFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114255Z" creationid="pingfangx" creationdate="20190618T114255Z">
        <seg>通过 `fromArray`，`fromIterable`，`fromFuture` 消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disambiguated to `collectInto` and **RC3** returns `Single&lt;U&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115854Z" creationid="pingfangx" creationdate="20190618T115854Z">
        <seg>修改为 `collectInto` 以消除歧义且 **RC3** 返回 `Single&lt;U&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable after a second Observable emits an item or terminates</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102825Z" creationid="pingfangx" creationdate="20190620T102825Z">
        <seg>在第二个 Observable 发射项目或终止后，丢弃 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable after a specified condition becomes false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102833Z" creationid="pingfangx" creationdate="20190620T102833Z">
        <seg>在指定条件变为 false 后，丢弃 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable until a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102802Z" creationid="pingfangx" creationdate="20190620T102802Z">
        <seg>丢弃 Observable 发射的项目，直到第二个 Observable 发射项目为止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable until a specified condition becomes false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102811Z" creationid="pingfangx" creationdate="20190620T102811Z">
        <seg>丢弃 Observable 发射的项目，直到指定的条件变为 false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095819Z" creationid="pingfangx" creationdate="20190620T095819Z">
        <seg>将一个 Observable 划分为一组 Observable，每个 Observable 从原始 Observable 中发射一组不同的项目，按 key 组织</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095149Z" creationid="pingfangx" creationdate="20190620T095149Z">
        <seg>在观察者订阅之前不要创建 Observable，并为每个观察者创建一个新的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not emit any items from an Observable but mirror its termination notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100958Z" creationid="pingfangx" creationdate="20190620T100958Z">
        <seg>不从 Observable 中发射任何项目，但镜像其终止通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it divide its work over multiple threads that may return data to the caller in any order?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040703Z" creationid="pingfangx" creationdate="20190620T040703Z">
        <seg>它是否将其工作划分为多个线程，这些线程可能以任何顺序将数据返回给调用者？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use NIO with an event-loop to do asynchronous network access?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040718Z" creationid="pingfangx" creationdate="20190620T040718Z">
        <seg>它是否使用 NIO 和事件循环来进行异步网络访问？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use an Actor (or multiple Actors) instead of a thread pool?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040709Z" creationid="pingfangx" creationdate="20190620T040709Z">
        <seg>它使用 Actor(或多个 Actors)而不是线程池？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use an event-loop to separate the work thread from the callback thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040725Z" creationid="pingfangx" creationdate="20190620T040725Z">
        <seg>它是否使用事件循环将工作线程与回调线程分开？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it work asynchronously on a distinct thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040653Z" creationid="pingfangx" creationdate="20190620T040653Z">
        <seg>它是否在一个不同的线程上异步工作？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it work synchronously on the same thread as the caller?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040649Z" creationid="pingfangx" creationdate="20190620T040649Z">
        <seg>它是否与调用者在同一个线程上同步工作？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>doesn't emit the very last item if the upstream completes within the period, added overloads with `emitLast` parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053506Z" creationid="pingfangx" creationdate="20190619T053506Z">
        <seg>如果上游在句点内完成，则不会发出最后一项，使用 `emitLast` 参数添加重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>doesn't emit the very last item if the upstream completes within the period, use `sample` with the `emitLast` parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053913Z" creationid="pingfangx" creationdate="20190619T053913Z">
        <seg>如果上游在句点内完成，则不会发出最后一项，请使用带有 `emitLast` 参数的 `sample`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053845Z" creationid="pingfangx" creationdate="20190619T053845Z">
        <seg>删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped the overload, use `subscribeOn(Scheduler).repeatWhen(Function)` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053435Z" creationid="pingfangx" creationdate="20190619T053435Z">
        <seg>删除了重载，使用 `subscribeOn(Scheduler).repeatWhen(Function)` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped the overload, use `subscribeOn(Scheduler).retryWhen(Function)` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053451Z" creationid="pingfangx" creationdate="20190619T053451Z">
        <seg>删除了重载，使用 `subscribeOn(Scheduler).retryWhen(Function)` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `count`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052322Z" creationid="pingfangx" creationdate="20190619T052322Z">
        <seg>删除，使用 `count`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).elementAt(int)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052636Z" creationid="pingfangx" creationdate="20190619T052636Z">
        <seg>删除，使用 `filter(predicate).elementAt(int)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).elementAt(int, T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052928Z" creationid="pingfangx" creationdate="20190619T052928Z">
        <seg>删除，使用 `filter(predicate).elementAt(int, T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).first()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052943Z" creationid="pingfangx" creationdate="20190619T052943Z">
        <seg>删除，使用 `filter(predicate).first()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).first(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053014Z" creationid="pingfangx" creationdate="20190619T053014Z">
        <seg>删除，使用 `filter(predicate).first(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).last()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053145Z" creationid="pingfangx" creationdate="20190619T053145Z">
        <seg>删除，使用 `filter(predicate).last()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).last(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053237Z" creationid="pingfangx" creationdate="20190619T053237Z">
        <seg>删除，使用 `filter(predicate).last(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).single()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053613Z" creationid="pingfangx" creationdate="20190619T053613Z">
        <seg>删除，使用 `filter(predicate).single()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053654Z" creationid="pingfangx" creationdate="20190619T053654Z">
        <seg>删除，使用 `filter(predicate).single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `take`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114325Z" creationid="pingfangx" creationdate="20190618T114325Z">
        <seg>删除，使用 ` take`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use manual `just`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053307Z" creationid="pingfangx" creationdate="20190619T053307Z">
        <seg>删除，使用 manual `just`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit a specified sequence of items before beginning to emit the items from the source Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101632Z" creationid="pingfangx" creationdate="20190620T101632Z">
        <seg>在开始从源 Observable 中发射项之前，发射指定的项序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit items from the source Observable, or a default item if the source Observable emits nothing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102747Z" creationid="pingfangx" creationdate="20190620T102747Z">
        <seg>从源 Observable 发射项，如果源 Observable 没有发射任何内容，则发射默认项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only item &lt;i0&gt;n&lt;/i0&gt; emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100914Z" creationid="pingfangx" creationdate="20190620T100914Z">
        <seg>仅发射 Observable 发射的 &lt;i0&gt;n&lt;/i0&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the first &lt;i3&gt;n&lt;/i3&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101059Z" creationid="pingfangx" creationdate="20190620T101059Z">
        <seg>仅发射 Observable 发射的前 &lt;i3&gt;n&lt;/i3&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the first item, or the first item that meets a condition, from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100934Z" creationid="pingfangx" creationdate="20190620T100934Z">
        <seg>从 Observable 中仅发射第一个项目或满足条件的第一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the last &lt;i4&gt;n&lt;/i4&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101117Z" creationid="pingfangx" creationdate="20190620T101117Z">
        <seg>仅发射 Observable 发射的最后 &lt;i4&gt;n&lt;/i4&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the last item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101003Z" creationid="pingfangx" creationdate="20190620T101003Z">
        <seg>仅发射 Observable 发射的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only those items from an Observable that pass a predicate test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100927Z" creationid="pingfangx" creationdate="20190620T100927Z">
        <seg>仅发射通过谓词测试的 Observable 中的那些项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit the emissions from two or more Observables without interleaving them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102926Z" creationid="pingfangx" creationdate="20190620T102926Z">
        <seg>发射两个或多个 Observable 的发射项而不交错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit the most recent item emitted by an Observable within periodic time intervals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101013Z" creationid="pingfangx" creationdate="20190620T101013Z">
        <seg>在周期性时间间隔内发射 Observable 发射的最新项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103713Z" creationid="pingfangx" creationdate="20190620T103713Z">
        <seg>确保所有观察者都看到相同的发射项序列，即使他们在 Observable 开始发射物品后才订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>even compile because at least 4 `concatWith` overloads exist and the compiler finds the code above ambiguous.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102620Z" creationid="pingfangx" creationdate="20190617T102620Z">
        <seg>它甚至不编译因为至少存在 4 个 `concatWith` 重载并且编译器发现上面的代码有歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>everything after the scheme component delimiter (":") is considered opaque to URI processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064537Z" creationid="pingfangx" creationdate="20190902T064537Z">
        <seg>方案组件分隔符(“:”)之后的所有内容都被视为对 URI 处理不透明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>f*.com matches foo.com but not bar.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190901T111331Z" creationid="pingfangx" creationdate="20190901T111331Z">
        <seg>f*.com 匹配 foo.com 但不匹配 bar.com。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>followed by the remainder of the Request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T101148Z" creationid="pingfangx" creationdate="20190829T101148Z">
        <seg>然后是请求的其余部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>followed by the remainder of the request message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T124207Z" creationid="pingfangx" creationdate="20190831T124207Z">
        <seg>然后是请求消息的其余部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for each observer that subscribes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104455Z" creationid="pingfangx" creationdate="20190620T104455Z">
        <seg>对于每个订阅的观察者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>force an Observable to make serialized calls and to be well-behaved</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102052Z" creationid="pingfangx" creationdate="20190620T102052Z">
        <seg>强制 Observable 进行序列化调用并保持良好状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from a timeout by switching to a backup Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110056Z" creationid="pingfangx" creationdate="20190620T110056Z">
        <seg>从超时切换到备份 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from an upstream error notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110101Z" creationid="pingfangx" creationdate="20190620T110101Z">
        <seg>来自上游错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from scratch, with custom logic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104443Z" creationid="pingfangx" creationdate="20190620T104443Z">
        <seg>从头开始，使用自定义逻辑</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from the perspective of `flatMapSingle`, `sourceObservable` is a multi-valued source and thus the mapping may result in multiple values as well).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091158Z" creationid="pingfangx" creationdate="20190617T091158Z">
        <seg>从 `flatMapSingle` 的角度来看，`sourceObservable` 是一个多值源，因此映射也可能导致多个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102731Z" creationid="pingfangx" creationdate="20190620T102731Z">
        <seg>给定两个或多个源 Observable，仅从第一个发射一个项目 Observable 中发射所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>has an effective request URI of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T131921Z" creationid="pingfangx" creationdate="20190831T131921Z">
        <seg>有一个有效的请求 URI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>however, the continuation in this case stays `Observable` instead of the likely more appropriate `Single`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T084004Z" creationid="pingfangx" creationdate="20190617T084004Z">
        <seg>然而，在这种情况下的延续仍然是 `Observable` 而不是可能更合适的 `Single`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http and https URI Normalization and Comparison</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T060844Z" creationid="pingfangx" creationdate="20190831T060844Z">
        <seg>http 和 https URI 规范化和比较</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http and https URI Normalization and Comparison ....19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190830T090704Z" creationid="pingfangx" creationdate="20190830T090704Z">
        <seg>http 和 https URI 规范化和比较 ....19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a source Observable sends an `onError` notification, resubscribe to it in the hopes that it will complete without error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101846Z" creationid="pingfangx" creationdate="20190620T101846Z">
        <seg>如果一个源 Observable 发送一个 `onError` 通知，重新订阅它，希望它能完成而不会出错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a specified period of time elapses without it emitting an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110045Z" creationid="pingfangx" creationdate="20190620T110045Z">
        <seg>如果指定的时间段过去而没有发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if they immediately follow the item they are duplicates of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105703Z" creationid="pingfangx" creationdate="20190620T105703Z">
        <seg>如果他们立即跟随该项目他们是重复的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in either the request or the response header fields indicates that the sender is going to close the connection after the current request/response is complete (Section 6.6).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T110855Z" creationid="pingfangx" creationdate="20190831T110855Z">
        <seg>在请求或响应首部字段中指示发送方将在当前请求/响应完成后关闭连接(第 6.6 节)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>indicates that the payload body has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T091759Z" creationid="pingfangx" creationdate="20190831T091759Z">
        <seg>表示有效载荷主体已经使用 gzip 编码压缩，然后在形成消息体时使用分块编码进行分块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inlined as `blockingY()` operators, except `toFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053947Z" creationid="pingfangx" creationdate="20190619T053947Z">
        <seg>内联为 `blockingY()` 操作符，除了 `toFuture`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instruct a connectable Observable to begin emitting items to its subscribers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103606Z" creationid="pingfangx" creationdate="20190620T103606Z">
        <seg>指示可连接的 Observable 开始向其订阅者发送项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instructs the Single to call the subscriber methods on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074718Z" creationid="pingfangx" creationdate="20190620T074718Z">
        <seg>指示 Single 在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上调用订阅者方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instructs the Single to operate on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074754Z" creationid="pingfangx" creationdate="20190620T074754Z">
        <seg>指示 Single 在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>into an indicator of the amount of time that lapsed before the emission of the item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105012Z" creationid="pingfangx" creationdate="20190620T105012Z">
        <seg>成为项目发射前经过的时间的指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it allows uniform semantic interpretation of common syntactic conventions across different types of resource identifiers; it allows introduction of new types of resource identifiers without interfering with the way that existing identifiers are used; and, it allows the identifiers to be reused in many different contexts, thus permitting new applications or protocols to leverage a pre-existing, large, and widely-used set of resource identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T040054Z" creationid="pingfangx" creationdate="20190902T040054Z">
        <seg>它允许跨不同类型的资源标识符对通用语法约定进行统一的语义解释；它允许引入新类型的资源标识符，而不会干扰现有标识符的使用方式；并且，它允许标识符在许多不同的上下文中重用，从而允许新的应用程序或协议利用预先存在的，大量且广泛使用的资源标识符集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it takes 4.5 hours to use up 2**32 octets of sequence space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T025410Z" creationid="pingfangx" creationdate="20190828T025410Z">
        <seg>用光 2 ** 32 个八位字节的序列空间需要 4.5 小时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make a Connectable Observable behave like an ordinary Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103654Z" creationid="pingfangx" creationdate="20190620T103654Z">
        <seg>使 Connectable Observable 的行为类似于普通的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to &lt;c0&gt;Schedulers.computation( )&lt;/c0&gt;; &lt;c1&gt;Schedulers.io( )&lt;/c1&gt; by default is a &lt;c2&gt;CachedThreadScheduler&lt;/c2&gt;, which is something like a new thread scheduler with thread caching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091257Z" creationid="pingfangx" creationdate="20190620T091257Z">
        <seg>对于 I/O 密集型工作，例如阻塞 I/O 的异步性能，此调度器由一个将根据需要增长的线程池支持；对于普通的计算工作，请切换到 &lt;c0&gt;Schedulers.computation( )&lt;/c0&gt;; &lt;c1&gt;Schedulers.io( )&lt;/c1&gt; 默认情况下是 &lt;c2&gt;CachedThreadScheduler&lt;/c2&gt;，类似于带有线程缓存的新线程调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use &lt;c0&gt;Schedulers.io( )&lt;/c0&gt; instead); the number of threads, by default, is equal to the number of processors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091037Z" creationid="pingfangx" creationdate="20190620T091037Z">
        <seg>用于计算工作，如事件循环和回调处理；不要将此调度器用于 I/O(请改用 &lt;c0&gt;Schedulers.io( )&lt;/c0&gt;);默认情况下，线程数等于处理器数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>merges the items emitted by multiple Singles as Observable emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074647Z" creationid="pingfangx" creationdate="20190620T074647Z">
        <seg>将多个 Singles 发射的数据项合并为 Observable 的发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102347Z" creationid="pingfangx" creationdate="20190620T102347Z">
        <seg>镜像源 Observable，但是如果在没有任何发射项目的情况下经过了特定的时间段，则发射错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>move the emission of an item from a Single forward in time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074211Z" creationid="pingfangx" creationdate="20190620T074211Z">
        <seg>延时 Single 发射项目的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>multiple items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033657Z" creationid="pingfangx" creationdate="20190620T033657Z">
        <seg>多个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not present</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113227Z" creationid="pingfangx" creationdate="20190618T113227Z">
        <seg>不存在</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Appending data to a resource's existing representation(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141502Z" creationid="pingfangx" creationdate="20190831T141502Z">
        <seg>o 将数据附加到资源的现有表示中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Creating a new resource that has yet to be identified by the origin server; and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141457Z" creationid="pingfangx" creationdate="20190831T141457Z">
        <seg>o 创建尚未由源服务器标识的新资源；以及</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  If the "close" connection option is present, the connection will not persist after the current response; else,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111029Z" creationid="pingfangx" creationdate="20190831T111029Z">
        <seg>o 如果存在“close”连接选项，则在当前响应之后连接将不会保留；否则，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  If the received protocol is HTTP/1.0, the "keep-alive" connection option is present, the recipient is not a proxy, and the recipient wishes to honor the HTTP/1.0 "keep-alive" mechanism, the connection will persist after the current response; otherwise,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111125Z" creationid="pingfangx" creationdate="20190831T111125Z">
        <seg>o 如果收到的协议是 HTTP/1.0，存在“keep-alive”连接选项，接收者不是代理，并且接收者希望遵守 HTTP/1.0“keep-alive”机制，连接将在之后保持目前的反应；否则，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111051Z" creationid="pingfangx" creationdate="20190831T111051Z">
        <seg>o 如果收到的协议是 HTTP/1.1(或更高版本)，则在当前响应之后连接将持久；否则，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141442Z" creationid="pingfangx" creationdate="20190831T141442Z">
        <seg>o 在公告栏，新闻组，消息列表，博客或类似文章组中发布消息；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T141431Z" creationid="pingfangx" creationdate="20190831T141431Z">
        <seg>o 向数据处理过程提供数据块，例如输入 HTML 表单的字段；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The connection will close after the current response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T111131Z" creationid="pingfangx" creationdate="20190831T111131Z">
        <seg>o 当前响应后连接将关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of the source `Observable`?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095510Z" creationid="pingfangx" creationdate="20190617T095510Z">
        <seg>来自源 `Observable`？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onNext, onCompleted, and onError</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055924Z" creationid="pingfangx" creationdate="20190620T055924Z">
        <seg>onNext，onCompleted 和 onError</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one Observable at a time, in the order they are emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104950Z" creationid="pingfangx" creationdate="20190620T104950Z">
        <seg>一个 Observable，按照它们发射的顺序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one at a time with a function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104938Z" creationid="pingfangx" creationdate="20190620T104938Z">
        <seg>一次一个使用函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>only emit an item from an Observable if a particular timespan has passed without it emitting another item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100816Z" creationid="pingfangx" creationdate="20190620T100302Z">
        <seg>从 Observable 中发射一个项目后，如果过了特定的时间而没有发射别的项目，才发送该项目（译注：防抖动）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>only if its sequence is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105201Z" creationid="pingfangx" creationdate="20190620T105201Z">
        <seg>只有当它的序列为空时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>operate upon the emissions and notifications from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102156Z" creationid="pingfangx" creationdate="20190620T102156Z">
        <seg>对观察者的发射和通知进行操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092652Z" creationid="pingfangx" creationdate="20190617T092652Z">
        <seg>或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or alternatively the `TestSubscriber` instance has to be captured to gain access to its `request()` method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101806Z" creationid="pingfangx" creationdate="20190618T101806Z">
        <seg>或者必须捕获 `TestSubscriber` 实例以获取对其 `request()` 方法的访问：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overload with custom `Collection` supplier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052335Z" creationid="pingfangx" creationdate="20190619T052335Z">
        <seg>使用自定义 `Collection` 提供者重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overloads with custom `Collection` supplier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115739Z" creationid="pingfangx" creationdate="20190618T115739Z">
        <seg>使用自定义 `Collection` 提供者重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100347Z" creationid="pingfangx" creationdate="20190620T095455Z">
        <seg>定期将 Observable 中的项目收集到包中并发射这些包，而不是一次发送一个项目（译注：缓存）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100030Z" creationid="pingfangx" creationdate="20190620T100030Z">
        <seg>定期将 Observable 中的项目细分为 Observable 窗口并发射这些窗口，而不是一次发射一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prefixed to the TCP header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190827T110052Z" creationid="pingfangx" creationdate="20190827T110052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>queues work to begin on the current thread after any already-queued work</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091335Z" creationid="pingfangx" creationdate="20190620T091335Z">
        <seg>当其它排队的任务完成后，在当前线程排队开始执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>recover from an `onError` notification by continuing the sequence without error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101833Z" creationid="pingfangx" creationdate="20190620T101833Z">
        <seg>通过继续序列而不出错来从 `onError` 通知中恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>register an action to take upon a variety of Observable lifecycle events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102021Z" creationid="pingfangx" creationdate="20190620T102021Z">
        <seg>注册一个动作来承担各种 Observable 生命周期事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `Flowable.doOnCancel` and `doOnDispose` for the others, [additional info](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052519Z" creationid="pingfangx" creationdate="20190619T052519Z">
        <seg>重命名为 `Flowable.doOnCancel` 和 `doOnDispose` 对于其他，[additional info](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `create()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114309Z" creationid="pingfangx" creationdate="20190618T114309Z">
        <seg>重命名为 `create()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `doOnComplete`, note the missing `d`!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052410Z" creationid="pingfangx" creationdate="20190619T052410Z">
        <seg>重命名为 `doOnComplete`，注意缺少的 `d`！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `elementAt(int, T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052906Z" creationid="pingfangx" creationdate="20190619T052739Z">
        <seg>重命名为 `elementAt(int, T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `first(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053000Z" creationid="pingfangx" creationdate="20190619T053000Z">
        <seg>重命名为 `first(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `hide()`, hides all identities now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115716Z" creationid="pingfangx" creationdate="20190618T115716Z">
        <seg>重命名为 `hide()`，现在隐藏所有身份</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `last(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053203Z" creationid="pingfangx" creationdate="20190619T053203Z">
        <seg>重命名为 `last(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `single(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053630Z" creationid="pingfangx" creationdate="20190619T053630Z">
        <seg>重命名为 `single(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replaced with `generate` + overloads (distinct interfaces, you can implement them all at once)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113215Z" creationid="pingfangx" creationdate="20190618T113215Z">
        <seg>替换为 `generate` + 重载(不同的接口，您可以一次实现它们)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>represent both the items emitted and the notifications sent as emitted items, or reverse this process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102033Z" creationid="pingfangx" creationdate="20190620T102033Z">
        <seg>表示发射的项目和作为发射项目发送的通知，或者反转此过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repurposed with safe `create(FlowableOnSubscribe, BackpressureStrategy)`, raw support via `unsafeCreate()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113314Z" creationid="pingfangx" creationdate="20190618T113314Z">
        <seg>使用安全的 `create(FlowableOnSubscribe, BackpressureStrategy)` 重新定位，通过 `unsafeCreate()` 提供原始支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that also calls a method you specify when it calls onError</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074251Z" creationid="pingfangx" creationdate="20190620T074251Z">
        <seg>返回在调用 OnError 时也调用指定方法的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that also calls a method you specify when it calls onSuccess</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074309Z" creationid="pingfangx" creationdate="20190620T074309Z">
        <seg>返回在调用 OnSuccess 时也调用指定方法的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits a specified item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074455Z" creationid="pingfangx" creationdate="20190620T074455Z">
        <seg>返回发射指定项的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074908Z" creationid="pingfangx" creationdate="20190620T074908Z">
        <seg>返回一个 Single，它发射一个项目，该项目是应用于两个或多个其他 Single 发射的项目的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits the result of a function applied to the item emitted by the source Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074523Z" creationid="pingfangx" creationdate="20190620T074523Z">
        <seg>返回一个 Single，它发射应用于源 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that immediately notifies subscribers of an error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074345Z" creationid="pingfangx" creationdate="20190620T074345Z">
        <seg>返回一个可立即通知订阅者错误的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that is the result of a function applied to an item emitted by a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074410Z" creationid="pingfangx" creationdate="20190620T074410Z">
        <seg>返回一个 Single，它是应用于 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that makes an error notification if the source Single does not emit a value in a specified time period</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074814Z" creationid="pingfangx" creationdate="20190620T074814Z">
        <seg>如果源 Single 在指定时间段内未发射值，则返回一个发射错误通知的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns an Observable that is the result of a function applied to an item emitted by a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074435Z" creationid="pingfangx" creationdate="20190620T074435Z">
        <seg>返回一个 Observable，它是应用于 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>schedules work to begin immediately in the current thread</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091109Z" creationid="pingfangx" creationdate="20190620T091109Z">
        <seg>立即在当前线程中开始工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift the emissions from an Observable forward in time by a particular amount</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102013Z" creationid="pingfangx" creationdate="20190620T102013Z">
        <seg>将 Observable 的发射向前转移一定量的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>signature changed to `timeout(Publisher, ...)` and dropped the function, use `defer(Callable&lt;Publisher&gt;&gt;)` if necessary</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053938Z" creationid="pingfangx" creationdate="20190619T053938Z">
        <seg>签名改为 `timeout(Publisher, ...)` 并删除了该函数，必要时使用 `defer(Callable&lt;Publisher&gt;&gt;)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>single items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033654Z" creationid="pingfangx" creationdate="20190620T033654Z">
        <seg>单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>so that similar items end up on the same Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105233Z" creationid="pingfangx" creationdate="20190620T105233Z">
        <seg>这样类似的项目最终会出现在同一个 Observable 上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify the scheduler an Observable should use when it is subscribed to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102210Z" creationid="pingfangx" creationdate="20190620T102210Z">
        <seg>指定 Observable 在订阅时应使用的调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify the scheduler on which an observer will observe this Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102045Z" creationid="pingfangx" creationdate="20190620T102045Z">
        <seg>指定观察者将观察此 Observable 的调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler’s clock</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091852Z" creationid="pingfangx" creationdate="20190620T091852Z">
        <seg>根据调度器的时钟启动任何已安排的时间等于或早于当前时间的未启动操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>strategies for coping with Observables that produce items more rapidly than their observers consume them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103456Z" creationid="pingfangx" creationdate="20190620T103456Z">
        <seg>当 Observables 生产数据项比观察者消耗数据项更快时的处理策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress duplicate items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100900Z" creationid="pingfangx" creationdate="20190620T100900Z">
        <seg>抑制 Observable 发射的重复项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress the first &lt;i1&gt;n&lt;/i1&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101039Z" creationid="pingfangx" creationdate="20190620T101019Z">
        <seg>抑制 Observable 发射的前 &lt;i1&gt;n&lt;/i1&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress the last &lt;i2&gt;n&lt;/i2&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101048Z" creationid="pingfangx" creationdate="20190620T101048Z">
        <seg>抑制 Observable 发射的最后 &lt;i2&gt;n&lt;/i2&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>synchronous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033700Z" creationid="pingfangx" creationdate="20190620T033700Z">
        <seg>同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that completes without emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104511Z" creationid="pingfangx" creationdate="20190620T104511Z">
        <seg>完成而不发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that does nothing at all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104514Z" creationid="pingfangx" creationdate="20190620T104514Z">
        <seg>什么都不做</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a particular item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104220Z" creationid="pingfangx" creationdate="20190620T104220Z">
        <seg>发射特定项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a sequence of integers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104459Z" creationid="pingfangx" creationdate="20190620T104459Z">
        <seg>发射一系列整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a sequence of items repeatedly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104425Z" creationid="pingfangx" creationdate="20190620T104425Z">
        <seg>重复发射一系列项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105546Z" creationid="pingfangx" creationdate="20190620T105546Z">
        <seg>在第二个 Observable 发射一个项目之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after an initial period of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105534Z" creationid="pingfangx" creationdate="20190620T105534Z">
        <seg>在最初的一段时间之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after the first &lt;i0&gt;n&lt;/i0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105518Z" creationid="pingfangx" creationdate="20190620T105518Z">
        <seg>前 &lt;i0&gt;n&lt;/i0&gt; 项之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except items emitted after a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105628Z" creationid="pingfangx" creationdate="20190620T105628Z">
        <seg>除了第二个 Observable 发射项目后发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except items emitted during a period of time before the source completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105617Z" creationid="pingfangx" creationdate="20190620T105617Z">
        <seg>除了在源完成之前的一段时间内发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except the last &lt;i0&gt;n&lt;/i0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105604Z" creationid="pingfangx" creationdate="20190620T105604Z">
        <seg>除了最后的 &lt;i0&gt;n&lt;/i0&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only item &lt;i0&gt;n&lt;/i0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105434Z" creationid="pingfangx" creationdate="20190620T105346Z">
        <seg>仅有项目 &lt;i0&gt;n&lt;/i0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the first item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105416Z" creationid="pingfangx" creationdate="20190620T105310Z">
        <seg>仅第一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the first item&lt;e0&gt;s&lt;/e0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105420Z" creationid="pingfangx" creationdate="20190620T105335Z">
        <seg>仅前几项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the last item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105430Z" creationid="pingfangx" creationdate="20190620T105341Z">
        <seg>仅最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only those items after the first items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105456Z" creationid="pingfangx" creationdate="20190620T105456Z">
        <seg>仅第一项之后的那些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, those items except the last items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105558Z" creationid="pingfangx" creationdate="20190620T105558Z">
        <seg>除了最后项之外的那些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, until one of those items matches a predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105527Z" creationid="pingfangx" creationdate="20190620T105527Z">
        <seg>直到其中一个项与谓词匹配</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that obtains its sequence from a Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104413Z" creationid="pingfangx" creationdate="20190620T104413Z">
        <seg>从 Future 获得序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that pulls its emissions from a particular &lt;c0&gt;Array&lt;/c0&gt;, &lt;c1&gt;Iterable&lt;/c1&gt;, or something like that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104401Z" creationid="pingfangx" creationdate="20190620T104401Z">
        <seg>从特定的 &lt;c0&gt;Array&lt;/c0&gt;，&lt;c1&gt;Iterable&lt;/c1&gt; 或类似的东西中拉取其发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that was returned from a function called at subscribe-time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104319Z" creationid="pingfangx" creationdate="20190620T104319Z">
        <seg>从订阅时调用的函数返回的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that was returned from an &lt;c0&gt;Action&lt;/c0&gt;, &lt;c1&gt;Callable&lt;/c1&gt;, &lt;c2&gt;Runnable&lt;/c2&gt;, or something of that sort, called at subscribe-time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104334Z" creationid="pingfangx" creationdate="20190620T104334Z">
        <seg>从 &lt;c0&gt;Action&lt;/c0&gt;，&lt;c1&gt;Callable&lt;/c1&gt;，&lt;c2&gt;Runnable&lt;/c2&gt; 或类似的东西返回，在订阅时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the ability for the producer to signal to the consumer that an error has occurred (an Iterable throws an exception if an error takes place during iteration; an Observable calls its observer’s &lt;c0&gt;onError&lt;/c0&gt; method)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042423Z" creationid="pingfangx" creationdate="20190620T042423Z">
        <seg>生产者向消费者发出错误信号的能力(如果在迭代期间发生错误，则 Iterable 抛出异常；Observable 调用其观察者的 &lt;c0&gt;onError&lt;/c0&gt; 方法)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the ability for the producer to signal to the consumer that there is no more data available (a foreach loop on an Iterable completes and returns normally in such a case; an Observable calls its observer’s &lt;c0&gt;onCompleted&lt;/c0&gt; method)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042400Z" creationid="pingfangx" creationdate="20190620T042400Z">
        <seg>生产者向消费者发出信号表明没有更多可用数据的能力(Iterable 上的 foreach 循环完成并在这种情况下正常返回；Observable 调用其观察者的 &lt;c0&gt;onCompleted&lt;/c0&gt; 方法)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the first item it emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105249Z" creationid="pingfangx" creationdate="20190620T105249Z">
        <seg>它发射的第一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the last item emitted before it completed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105243Z" creationid="pingfangx" creationdate="20190620T105243Z">
        <seg>完成之前发射的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sole item it emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105246Z" creationid="pingfangx" creationdate="20190620T105246Z">
        <seg>它发射的唯一项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>therefore, a dereference should not result in a new retrieval action.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T085904Z" creationid="pingfangx" creationdate="20190902T085904Z">
        <seg>因此，取消引用不应导致新的检索操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transform the items emitted by an Observable by applying a function to each item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095829Z" creationid="pingfangx" creationdate="20190620T095829Z">
        <seg>通过将函数应用于每个项目来转换 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100559Z" creationid="pingfangx" creationdate="20190620T095740Z">
        <seg>将 Observable 发射的项目转换为 Observables，然后将这些项目的发射变为单个 Observable（译注：扁平，一个项变为多个项，然后发出多个项(可能交错)）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unambiguous operator should have been `defer`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102915Z" creationid="pingfangx" creationdate="20190617T102915Z">
        <seg>因此是正确的明确的运算符应该是 `defer`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.ignoreElements()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061549Z" creationid="pingfangx" creationdate="20190619T061549Z">
        <seg>使用 `Flowable.ignoreElements()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061553Z" creationid="pingfangx" creationdate="20190619T061553Z">
        <seg>使用 `Flowable.single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.singleElement()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061555Z" creationid="pingfangx" creationdate="20190619T061555Z">
        <seg>使用 `Flowable.singleElement()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.ignoreElements()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061557Z" creationid="pingfangx" creationdate="20190619T061557Z">
        <seg>使用 `Observable.ignoreElements()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061659Z" creationid="pingfangx" creationdate="20190619T061659Z">
        <seg>使用 `Observable.single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.singleElement()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061702Z" creationid="pingfangx" creationdate="20190619T061702Z">
        <seg>使用 `Observable.singleElement()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uses the specified &lt;c0&gt;Executor&lt;/c0&gt; as a Scheduler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091042Z" creationid="pingfangx" creationdate="20190620T091042Z">
        <seg>使用指定的 &lt;c0&gt;Executor&lt;/c0&gt; 作为调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101309Z" creationid="pingfangx" creationdate="20190620T101309Z">
        <seg>当一个项目由两个 Observable 中的任何一个发射时，通过指定的函数组合每个 Observable 发射的最新项目，并根据此函数的结果发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when it notifies observers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110012Z" creationid="pingfangx" creationdate="20190620T110012Z">
        <seg>当它通知观察者时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever &lt;e0&gt;any&lt;/e0&gt; of the Observables has emitted a new item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104704Z" creationid="pingfangx" creationdate="20190620T104704Z">
        <seg>每当 Observables 的 &lt;e0&gt;任何&lt;/e0&gt; 发射新项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever &lt;e0&gt;each&lt;/e0&gt; of the Observables has emitted a new item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104646Z" creationid="pingfangx" creationdate="20190620T104646Z">
        <seg>每当 Observables 的 &lt;e0&gt;每个&lt;/e0&gt; 发射一个新项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever an item is emitted by one Observable in a window defined by an item emitted by another</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104712Z" creationid="pingfangx" creationdate="20190620T104712Z">
        <seg>每当一个 Observable 在由另一个项目发射的项目定义的窗口中发射一个项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where any two-letter primary-tag is an ISO-639 language abbreviation and any two-letter initial subtag is an ISO-3166 country code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T155341Z" creationid="pingfangx" creationdate="20190828T155341Z">
        <seg>其中任何两个字母的主要标签是 ISO-639 语言缩写，任何两个字母的初始子标签是 ISO-3166 国家代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which I can then unwrap again with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105110Z" creationid="pingfangx" creationdate="20190620T105110Z">
        <seg>我可以再解除包装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>without such a definition, a URI is assumed to be in the same character encoding as the surrounding text.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190902T064938Z" creationid="pingfangx" creationdate="20190902T064938Z">
        <seg>如果没有这样的定义，则假定 URI 与周围文本具有相同的字符编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would be forwarded by the final proxy as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190831T125237Z" creationid="pingfangx" creationdate="20190831T125237Z">
        <seg>将被最终代理转发为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111935Z" creationid="pingfangx" creationdate="20190618T111935Z">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>—</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095125Z" creationid="pingfangx" creationdate="20190620T095125Z">
        <seg>—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Hot” and “Cold” Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064846Z" creationid="pingfangx" creationdate="20190620T064846Z">
        <seg>“Hot” 和 “Cold” Observables</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
