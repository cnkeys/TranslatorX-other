<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.0.0_0_dev" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg># Base reactive interfaces</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061145Z" creationid="pingfangx" creationdate="20190618T061145Z">
        <seg># 基本响应接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052054Z" creationid="pingfangx" creationdate="20190618T052054Z">
        <seg># 内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Creating backpressured datasources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015345Z" creationid="pingfangx" creationdate="20190624T015345Z">
        <seg># 创建背压数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Entering the reactive world</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094146Z" creationid="pingfangx" creationdate="20190618T094146Z">
        <seg># 进入响应世界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Introduction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T062104Z" creationid="pingfangx" creationdate="20190621T062104Z">
        <seg># 介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Leaving the reactive world</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094913Z" creationid="pingfangx" creationdate="20190618T094913Z">
        <seg># 离开响应世界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Maven address and base package</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052542Z" creationid="pingfangx" creationdate="20190618T052542Z">
        <seg># Maven 地址和基础包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Miscellaneous changes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114733Z" creationid="pingfangx" creationdate="20190618T114733Z">
        <seg># 杂项更改</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Observable and Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053023Z" creationid="pingfangx" creationdate="20190618T053023Z">
        <seg># Observable 和 Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Operator differences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T103142Z" creationid="pingfangx" creationdate="20190618T103142Z">
        <seg># 操作符差异</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Other classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063638Z" creationid="pingfangx" creationdate="20190618T063638Z">
        <seg># 其他类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># RxJava: Reactive Extensions for the JVM</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103322Z" creationid="pingfangx" creationdate="20190617T103322Z">
        <seg># RxJava: Reactive Extensions for the JVM
原文 [ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The onBackpressureXXX operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084603Z" creationid="pingfangx" creationdate="20190621T084603Z">
        <seg># onBackpressureXXX 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## 1.x Observable to 2.x Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111342Z" creationid="pingfangx" creationdate="20190618T111342Z">
        <seg>## 1.x Observable 到 2.x Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Batching/skipping values with standard operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091136Z" creationid="pingfangx" creationdate="20190621T091136Z">
        <seg>## 使用标准操作符批处理/跳过值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Binaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105435Z" creationid="pingfangx" creationdate="20190617T105435Z">
        <seg>## 二进制文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Bugs and Feedback</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105627Z" creationid="pingfangx" creationdate="20190617T105627Z">
        <seg>## 错误和反馈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Build</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105554Z" creationid="pingfangx" creationdate="20190617T105554Z">
        <seg>## 构建</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Communication</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104636Z" creationid="pingfangx" creationdate="20190617T104636Z">
        <seg>## 沟通</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Full Documentation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105421Z" creationid="pingfangx" creationdate="20190617T105421Z">
        <seg>## 完整文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Getting started</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065829Z" creationid="pingfangx" creationdate="20190617T065829Z">
        <seg>## 入门</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Increasing the buffer sizes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090231Z" creationid="pingfangx" creationdate="20190621T090231Z">
        <seg>## 增加缓冲区大小</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Testing an async source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101814Z" creationid="pingfangx" creationdate="20190618T101814Z">
        <seg>## 测试异步源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Versioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104645Z" creationid="pingfangx" creationdate="20190617T104645Z">
        <seg>## 版本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## Which type to use?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053516Z" creationid="pingfangx" creationdate="20190618T053516Z">
        <seg>## 使用哪种类型？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>## cancel and request upfront</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101647Z" creationid="pingfangx" creationdate="20190618T101647Z">
        <seg>## 取消并提前请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Base classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070028Z" creationid="pingfangx" creationdate="20190617T065921Z">
        <seg>### 基类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Calling request from onSubscribe/onStart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070914Z" creationid="pingfangx" creationdate="20190618T070914Z">
        <seg>### 从 onSubscribe/onStart 调用请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Concurrency within a flow</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075248Z" creationid="pingfangx" creationdate="20190617T075248Z">
        <seg>### Concurrency within a flow (流中的并发)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Different return types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060112Z" creationid="pingfangx" creationdate="20190619T060112Z">
        <seg>### 不同的返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Factory methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111351Z" creationid="pingfangx" creationdate="20190618T111351Z">
        <seg>### 工厂方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Further reading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104614Z" creationid="pingfangx" creationdate="20190617T104614Z">
        <seg>### 扩展阅读</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Instance methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114532Z" creationid="pingfangx" creationdate="20190618T114532Z">
        <seg>### 实例方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Notable new assert methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100029Z" creationid="pingfangx" creationdate="20190618T100029Z">
        <seg>### 值得注意的新断言方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Operator naming conventions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100918Z" creationid="pingfangx" creationdate="20190617T100918Z">
        <seg>### 运算符命名约定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Parallel processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075735Z" creationid="pingfangx" creationdate="20190617T075735Z">
        <seg>### Parallel processing (并行处理)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Removals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061504Z" creationid="pingfangx" creationdate="20190619T061504Z">
        <seg>### 移除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava Libraries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113636Z" creationid="pingfangx" creationdate="20190617T113636Z">
        <seg>### RxJava 库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava is Lightweight</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113501Z" creationid="pingfangx" creationdate="20190617T113501Z">
        <seg>### RxJava 是轻量级的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### RxJava is a Polyglot Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113532Z" creationid="pingfangx" creationdate="20190617T113532Z">
        <seg>### RxJava 是一个多语言实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072905Z" creationid="pingfangx" creationdate="20190617T072905Z">
        <seg>### Schedulers (调度器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Setting up the dependency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065800Z" creationid="pingfangx" creationdate="20190617T065800Z">
        <seg>### 设置依赖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Simple background computation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072223Z" creationid="pingfangx" creationdate="20190617T072223Z">
        <seg>### 简单的后台计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Some terminology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070420Z" creationid="pingfangx" creationdate="20190617T070420Z">
        <seg>### 一些术语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### Type conversions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092701Z" creationid="pingfangx" creationdate="20190617T092701Z">
        <seg>### Type conversions (类型转换)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### When to use Flowable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054920Z" creationid="pingfangx" creationdate="20190618T054920Z">
        <seg>### 何时使用 Flowable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>### When to use Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053650Z" creationid="pingfangx" creationdate="20190618T053650Z">
        <seg>### 何时使用 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Assembly time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092336Z" creationid="pingfangx" creationdate="20190617T072124Z">
        <seg>#### Assembly time (编译时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Backpressure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071620Z" creationid="pingfangx" creationdate="20190617T071124Z">
        <seg>#### Backpressure (背压)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Converting to the desired type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092851Z" creationid="pingfangx" creationdate="20190617T092851Z">
        <seg>#### 转换为所需类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Error handling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103119Z" creationid="pingfangx" creationdate="20190617T103119Z">
        <seg>#### 错误处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Objects in motion</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071614Z" creationid="pingfangx" creationdate="20190617T071032Z">
        <seg>#### Objects in motion (运动中的对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Runtime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072154Z" creationid="pingfangx" creationdate="20190617T072154Z">
        <seg>#### Runtime (运行时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Subscription time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092347Z" creationid="pingfangx" creationdate="20190617T072132Z">
        <seg>#### Subscription time (订阅时)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Type ambiguities</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102207Z" creationid="pingfangx" creationdate="20190617T102207Z">
        <seg>#### 类型歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Type erasure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101921Z" creationid="pingfangx" creationdate="20190617T101921Z">
        <seg>#### 类型擦除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Unusable keywords</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101509Z" creationid="pingfangx" creationdate="20190617T101509Z">
        <seg>#### 不可用的关键字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Upstream, downstream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071556Z" creationid="pingfangx" creationdate="20190617T070428Z">
        <seg>#### Upstream, downstream (上游，下游)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#### Using an overload with the desired type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100644Z" creationid="pingfangx" creationdate="20190617T100644Z">
        <seg>#### 使用所需类型的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the source Observable does not emit any values, the &lt;c1&gt;AsyncSubject&lt;/c1&gt; also completes without emitting any values.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083942Z" creationid="pingfangx" creationdate="20190620T083942Z">
        <seg>(如果源 Observable 未发射任何值，则 &lt;c1&gt;AsyncSubject&lt;/c1&gt; 也会完成而不会发射任何值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The Reactive-Streams specification allows throwing `NullPointerException` if the `onSubscribe`, `onNext` or `onError` receives a `null` value, but RxJava doesn't let `null`s in any way.) This means the following code is no longer legal:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095546Z" creationid="pingfangx" creationdate="20190618T095546Z">
        <seg>（如果 `onSubscribe`，`onNext` 或 `onError` 接收到 `null` 值，Reactive-Streams 规范允许抛出 `NullPointerException`，但 RxJava 不以任何方式接受 `null`。这意味着以下代码不再合法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The reason for this is twofold: performance and ease of use of the library as a synchronous Java 8 Streams-like processor.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095320Z" creationid="pingfangx" creationdate="20190618T095320Z">
        <seg>(原因有两个：作为同步 Java 8 Streams 类似处理器的库的性能和易用性。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The same approach works with `GroupedFlowable` as well.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064010Z" creationid="pingfangx" creationdate="20190618T064010Z">
        <seg>(同样的方法也适用于 `GroupedFlowable`。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is understandable because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091144Z" creationid="pingfangx" creationdate="20190617T091144Z">
        <seg>(这是可以理解的，因为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We never had a use for it in 1.x and the original `Subject&lt;T, R&gt;` came from .NET where there is a `Subject&lt;T&gt;` overload because .NET allows the same class name with a different number of type arguments.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062556Z" creationid="pingfangx" creationdate="20190618T062556Z">
        <seg>(我们从来没有在 1.x 中使用它，原来的 `Subject&lt;T, R&gt;` 来自 .NET，其中有一个 `Subject&lt;T&gt;` 重载，因为 .NET 允许相同的类名具有不同数量的类型参数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*(Remark: this is "experimental" in RC2 and RC3 to see how it feels to program with such mixed-type sequences and whether or not there has to be too much `toObservable`/`toFlowable` back-conversion.)*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060231Z" creationid="pingfangx" creationdate="20190619T060231Z">
        <seg>*(注：这在 RC2 和 RC3 中是“实验性的”，看看用这种混合型序列编程感觉如何，以及是否必须有太多 `toObservable`/`toFlowable` 反向转换。)*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*(You could also consider IxJava which is optimized for Iterable flows supporting Java 6+)*.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054849Z" creationid="pingfangx" creationdate="20190618T054849Z">
        <seg>*(您还可以考虑 IxJava，它针对支持 Java 6+ 的 Iterable 流程进行了优化)*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**Backpressure** is when in an `Flowable` processing pipeline, some asynchronous stages can't process the values fast enough and need a way to tell the upstream producer to slow down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T062429Z" creationid="pingfangx" creationdate="20190621T062429Z">
        <seg>**Backpressure (背压)** 是在 `Flowable` 外理管道中，某些异步阶段无法足够快地处理这些值，需要一种方法来告诉上游生产者减速。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** dropped, use `ignoreElements`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054007Z" creationid="pingfangx" creationdate="20190619T054007Z">
        <seg>**RC3** 删除，请使用 `ignoreElements`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** dropped, use `single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054042Z" creationid="pingfangx" creationdate="20190619T054042Z">
        <seg>**RC3** 已删除，请使用 `single(T)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** no longer signals NoSuchElementException if the source is shorter than the index</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052611Z" creationid="pingfangx" creationdate="20190619T052611Z">
        <seg>如果源短于索引，**RC3** 不再发出 NoSuchElementException 信号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `firstElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052939Z" creationid="pingfangx" creationdate="20190619T052939Z">
        <seg>**RC3** 重命名为 `firstElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `lastElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053135Z" creationid="pingfangx" creationdate="20190619T053135Z">
        <seg>**RC3** 重命名为 `lastElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** renamed to `singleElement` and returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053608Z" creationid="pingfangx" creationdate="20190619T053608Z">
        <seg>**RC3** 重命名为 `singleElement` 并返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Completable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053116Z" creationid="pingfangx" creationdate="20190619T053116Z">
        <seg>**RC3** 返回 `Completable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053323Z" creationid="pingfangx" creationdate="20190619T053323Z">
        <seg>**RC3** 返回 `Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Boolean&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053123Z" creationid="pingfangx" creationdate="20190619T053123Z">
        <seg>**RC3** 返回 `Single&lt;Boolean&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Boolean&gt;` now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115702Z" creationid="pingfangx" creationdate="20190618T115702Z">
        <seg>**RC3** 现在返回 `Single&lt;Boolean&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;List&lt;T&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054014Z" creationid="pingfangx" creationdate="20190619T054014Z">
        <seg>**RC3** 返回 `Single&lt;List&lt;T&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Long&gt;` now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052201Z" creationid="pingfangx" creationdate="20190619T052201Z">
        <seg>**RC3** 现直返回 `Single&lt;Long&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054027Z" creationid="pingfangx" creationdate="20190619T054027Z">
        <seg>**RC3** 返回 `Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;Map&lt;K, V&gt;&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054020Z" creationid="pingfangx" creationdate="20190619T054020Z">
        <seg>**RC3** 返回 `Single&lt;Map&lt;K, V&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**RC3** returns `Single&lt;U&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115759Z" creationid="pingfangx" creationdate="20190618T115759Z">
        <seg>**RC3** 返回 `Single&lt;U&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>**The `Flowable`-based sources and operators are, as of 2.0.7, fully Reactive-Streams version 1.0.0 specification compliant.**</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073813Z" creationid="pingfangx" creationdate="20190618T073813Z">
        <seg>**从 2.0.7 开始，基于 `Flowable` 的源和运算符完全符合 Reactive-Streams 版本 1.0.0 规范。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Dealing with 10k+ of elements that are generated in some fashion somewhere and thus the chain can tell the source to limit the amount it generates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055019Z" creationid="pingfangx" creationdate="20190618T055019Z">
        <seg>- 处理以某种方式在某处生成的 10k+ 元素，因此链可以告诉源限制它产生的量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Java 8 lambda-friendly API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065159Z" creationid="pingfangx" creationdate="20190617T065159Z">
        <seg>- Java 8 lambda 友好的 API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Many blocking and/or pull-based data sources which may eventually get a non-blocking reactive API/driver in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055442Z" creationid="pingfangx" creationdate="20190618T055442Z">
        <seg>- 许多阻塞和/或基于拉的数据源，最终可能会在未来获得非阻塞的响应 API/驱动程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Network (Streaming) IO where either the network helps or the protocol used supports requesting some logical amount.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055402Z" creationid="pingfangx" creationdate="20190618T055402Z">
        <seg>- 网络(流)IO，其中网络帮助或使用的协议支持请求一些逻辑量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Reading (parsing) files from disk is inherently blocking and pull-based which works well with backpressure as you control, for example, how many lines you read from this for a specified request amount).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055258Z" creationid="pingfangx" creationdate="20190618T055258Z">
        <seg>- 从磁盘读取（解析）文件本质上是阻塞和基于拉取的，当您控制时，它可以很好地处理背压，例如，您为指定的请求数量控制读取多少行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Reading from a database through JDBC is also blocking and pull-based and is controlled by you by calling `ResultSet.next()` for likely each downstream request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055324Z" creationid="pingfangx" creationdate="20190618T055324Z">
        <seg>- 通过 JDBC 从数据库读取也是阻塞和基于拉取的，并且可以通过调用 `ResultSet.next()` 来控制每个下游请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- You deal with GUI events such as mouse moves or touch events: these can rarely be backpressured reasonably and aren't that frequent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054621Z" creationid="pingfangx" creationdate="20190618T054621Z">
        <seg>- 您处理 GUI 事件，例如鼠标移动或触摸事件：这些事件很少能够合理地背压并且不那么频繁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- You have a flow of no more than 1000 elements at its longest: i.e., you have so few elements over time that there is practically no chance for OOME in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054407Z" creationid="pingfangx" creationdate="20190618T054407Z">
        <seg>- 最长流不超过 1000 个元素：即，随着时间的推移元素会很少，因此在您的应用程序中几乎不会出现 OOME。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Your flow is essentially synchronous but your platform doesn't support Java Streams or you miss features from it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054808Z" creationid="pingfangx" creationdate="20190618T054808Z">
        <seg>- 您的流基本上是同步的，但您的平台不支持 Java Streams，或者您错过了它的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Base reactive interfaces](#base-reactive-interfaces)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052438Z" creationid="pingfangx" creationdate="20190618T052438Z">
        <seg>- [基本响应接口](#base-reactive-interfaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Maven address and base package](#maven-address-and-base-package)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052409Z" creationid="pingfangx" creationdate="20190618T052409Z">
        <seg>- [Maven 地址和基础包](#maven-address-and-base-package)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Miscellaneous changes](#miscellaneous-changes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052533Z" creationid="pingfangx" creationdate="20190618T052533Z">
        <seg>- [杂项更改](#miscellaneous-changes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Observable and Flowable](#observable-and-flowable)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052413Z" creationid="pingfangx" creationdate="20190618T052413Z">
        <seg>- [Observable 和 Flowable](#observable-and-flowable)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Other classes](#other-classes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052452Z" creationid="pingfangx" creationdate="20190618T052452Z">
        <seg>- [其他类](#other-classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [Subjects and Processors](#subjects-and-processors)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052444Z" creationid="pingfangx" creationdate="20190618T052444Z">
        <seg>- [Subjects 和 Processors](#subjects-and-processors)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): a flow without items but only a completion or error signal,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070349Z" creationid="pingfangx" creationdate="20190617T070349Z">
        <seg>- [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): 没有项目但只有完成或错误信号的流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Flowable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html): 0..N flows, supporting Reactive-Streams and backpressure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070240Z" creationid="pingfangx" creationdate="20190617T070240Z">
        <seg>- [`io.reactivex.Flowable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html): 0..N 流，支持响应式流和背压</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): a flow with no items, exactly one item or an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070416Z" creationid="pingfangx" creationdate="20190617T070416Z">
        <seg>- [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): 没有项目，只有一个项目或错误的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N flows, no backpressure,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070329Z" creationid="pingfangx" creationdate="20190617T070250Z">
        <seg>- [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N 流，无背压，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): a flow of exactly 1 item or an error,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070327Z" creationid="pingfangx" creationdate="20190617T070319Z">
        <seg>- [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): 仅 1 个项目或错误的流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `CompositeSubscription` to `CompositeDisposable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073146Z" creationid="pingfangx" creationdate="20190618T073146Z">
        <seg>- `CompositeSubscription` 变为 `CompositeDisposable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DEFAULT`: currently it is the same as `ON_OVERFLOW_ERROR`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014531Z" creationid="pingfangx" creationdate="20190624T014531Z">
        <seg>- `ON_OVERFLOW_DEFAULT`：目前它与 `ON_OVERFLOW_ERROR` 相同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DROP_LATEST` : if an overflow would happen, the current value will be simply ignored and only the old values will be delivered once the downstream requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014549Z" creationid="pingfangx" creationdate="20190624T014549Z">
        <seg>- `ON_OVERFLOW_DROP_LATEST`：如果发生溢出，将简单地忽略当前值，并且只有下游请求才会传递旧值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_DROP_OLDEST` : drops the oldest element in the buffer and adds the current value to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014614Z" creationid="pingfangx" creationdate="20190624T014614Z">
        <seg>- `ON_OVERFLOW_DROP_OLDEST`：删除缓冲区中最旧的元素并将当前值添加到缓冲区中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ON_OVERFLOW_ERROR`: this is the default behavior of the previous two overloads, signalling a `BufferOverflowException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014521Z" creationid="pingfangx" creationdate="20190624T014521Z">
        <seg>- `ON_OVERFLOW_ERROR`：这是前两个重载的默认行为，表示 `BufferOverflowException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `OnErrorNotImplementedException`: reintroduced to detect when the user forgot to add error handling to `subscribe()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091126Z" creationid="pingfangx" creationdate="20190618T091126Z">
        <seg>- `OnErrorNotImplementedException`：重新引入以检测用户何时忘记向 `subscribe()` 添加错误处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `ProtocolViolationException`: indicates a bug in an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091133Z" creationid="pingfangx" creationdate="20190618T091133Z">
        <seg>- `ProtocolViolationException`：表示运算符中的错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `RefCountSubscription` has been removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073214Z" creationid="pingfangx" creationdate="20190618T073214Z">
        <seg>- `RefCountSubscription` 已被移除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.computation()`: Run computation intensive work on a fixed number of dedicated threads in the background.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073217Z" creationid="pingfangx" creationdate="20190617T073217Z">
        <seg>- `Schedulers.computation()`: 在后台固定数量的专用线程上，运行计算密集型工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.io()`: Run I/O-like or blocking operations on a dynamically changing set of threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073321Z" creationid="pingfangx" creationdate="20190617T073321Z">
        <seg>- `Schedulers.io()`: 在动态变化的线程集上运行类似 I/O 或阻塞操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.single()`: Run work on a single thread in a sequential and FIFO manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073336Z" creationid="pingfangx" creationdate="20190617T073336Z">
        <seg>- `Schedulers.single()`: 以顺序和 FIFO 方式在单个线程上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `Schedulers.trampoline()`: Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073400Z" creationid="pingfangx" creationdate="20190617T073400Z">
        <seg>- `Schedulers.trampoline()`: 在一个参与线程中以顺序和 FIFO 方式运行，通常用于测试目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `SerialSubscription` and `MultipleAssignmentSubscription` have been merged into `SerialDisposable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073154Z" creationid="pingfangx" creationdate="20190618T073154Z">
        <seg>- `SerialSubscription` 和 `MultipleAssignmentSubscription` 已合并到 `SerialDisposable` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `UndeliverableException`: wraps the original exception that can't be delivered due to lifecycle restrictions on a `Subscriber`/`Observer`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091154Z" creationid="pingfangx" creationdate="20190618T091154Z">
        <seg>- `UndeliverableException`：包装因 `Subscriber`/`Observer` 的生命周期限制而无法传递的原始异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertFailure(Class&lt;? extends Throwable&gt; clazz, T... items)`: asserts if subscribed, received exactly the given items in the given order followed by a `Throwable` error of wich `clazz.isInstance()` returns true.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101401Z" creationid="pingfangx" creationdate="20190618T101401Z">
        <seg>- `assertFailure(Class&lt;? extends Throwable&gt; clazz, T... items)`：断言如果订阅，按给定顺序接收到给定项后，跟一个 `Throwable` 错误，其 `clazz.isInstance()` 返回 true。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertFailureAndMessage(Class&lt;? extends Throwable&gt; clazz, String message, T... items)`: same as `assertFailure` plus validates the `getMessage()` contains the specified message</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101434Z" creationid="pingfangx" creationdate="20190618T101434Z">
        <seg>- `assertFailureAndMessage(Class&lt;? extends Throwable&gt; clazz, String message, T... items)`：与 `assertFailure` 相同，加上验证 `getMessage()` 包含指定的消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertOf(Consumer&lt;TestSubscriber&lt;T&gt;&gt; consumer)` compose some assertions into the fluent chain (used internally for fusion test as operator fusion is not part of the public API right now).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101538Z" creationid="pingfangx" creationdate="20190618T101538Z">
        <seg>- `assertOf(Consumer&lt;TestSubscriber&lt;T&gt;&gt; consumer)` 将一些断言组合到流畅的链中(内部用于融合测试，因为运算符融合现在不是公共 API 的一部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `assertResult(T... items)`: asserts if subscribed, received exactly the given items in the given order followed by `onComplete` and no errors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100201Z" creationid="pingfangx" creationdate="20190618T100201Z">
        <seg>- `assertResult(T... items)`：断言如果已订阅，则在 `onComplete` 之后按给定顺序接收给定的项，并且没有错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `awaitDone(long time, TimeUnit unit)` awaits a terminal event (blockingly) and cancels the sequence if the timeout elapsed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101454Z" creationid="pingfangx" creationdate="20190618T101454Z">
        <seg>- `awaitDone(long time, TimeUnit unit)` 等待终端事件(阻塞)并在超时结束时取消序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `concatMapEager` which runs all inner flows "at once" but the output flow will be in the order those inner flows were created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083254Z" creationid="pingfangx" creationdate="20190617T083254Z">
        <seg>- `concatMapEager`，它“同时”运行所有内部流，但输出流将按照创建内部流的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- `concatMap` that maps and runs one inner flow at a time and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083218Z" creationid="pingfangx" creationdate="20190617T083218Z">
        <seg>- `concatMap` 一次映射并运行一个内部流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- a `BackpressureStrategy` enumeration that mandates the developer to specify the backpressure behavior to be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021957Z" creationid="pingfangx" creationdate="20190624T021957Z">
        <seg>- 一个 `BackpressureStrategy` 枚举，要求开发人员指定要应用的背压行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- a callback that will be called with an instance of the `Emitter&lt;T&gt;` interface for each incoming subscriber,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021941Z" creationid="pingfangx" creationdate="20190624T021941Z">
        <seg>-将为每个传入的订阅者调用的回调，回调时带 `Emitter&lt;T&gt;` 接口实例，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- async or synchronous execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065441Z" creationid="pingfangx" creationdate="20190617T065441Z">
        <seg> - 异步或同步执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- continued support for Java 6+ &amp; [Android](https://github.com/ReactiveX/RxAndroid) 2.3+</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065015Z" creationid="pingfangx" creationdate="20190617T065015Z">
        <seg>- 继续支持 Java 6+ 和 [Android](https://github.com/ReactiveX/RxAndroid) 2.3+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- performance gains through design changes learned through the 1.x cycle and through [Reactive-Streams-Commons](https://github.com/reactor/reactive-streams-commons) research project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065138Z" creationid="pingfangx" creationdate="20190617T065138Z">
        <seg>- 从 1.x 周期和 [Reactive-Streams-Commons](https://github.com/reactor/reactive-streams-commons) 研究项目获得的设计变更带来的性能提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- single dependency: [Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064948Z" creationid="pingfangx" creationdate="20190617T064943Z">
        <seg>- 单一依赖：[Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- virtual time and schedulers for parameterized concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065452Z" creationid="pingfangx" creationdate="20190617T065452Z">
        <seg> - 参数化并发的虚拟时间和调度程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §1.3 relaxation: `onSubscribe` may run concurrently with `onNext` in case the `FlowableSubscriber` calls `request()` from inside `onSubscribe` and it is the resposibility of `FlowableSubscriber` to ensure thread-safety between the remaining instructions in `onSubscribe` and `onNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084037Z" creationid="pingfangx" creationdate="20190618T074115Z">
        <seg>- §1.3 宽松：`onSubscribe` 可以与 `onNext` 同时运行，以防 `FlowableSubscriber` 从 `onSubscribe` 内部调用 `request()`，并且它是 `FlowableSubscriber` 的责任以确保在 `onSubscribe` 和 `onNext` 中的其余指令之间的线程安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §2.12 relaxation: if the same `FlowableSubscriber` instance is subscribed to multiple sources, it must ensure its `onXXX` methods remain thread safe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084111Z" creationid="pingfangx" creationdate="20190618T074147Z">
        <seg>- §2.12 宽松：如果同一个 `FlowableSubscriber` 实例订阅了多个源，它必须确保它的 `onXXX` 方法保持线程安全。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §2.3 relaxation: calling `Subscription.cancel` and `Subscription.request` from `FlowableSubscriber.onComplete()` or `FlowableSubscriber.onError()` is considered a no-operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084051Z" creationid="pingfangx" creationdate="20190618T074127Z">
        <seg>- §2.3 宽松：从 `FlowableSubscriber.onComplete()` 或 `FlowableSubscriber.onError()` 调用 `Subscription.cancel` 和 `Subscription.request` 被认为是无操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- §3.9 relaxation: issuing a non-positive `request()` will not stop the current stream but signal an error via `RxJavaPlugins.onError`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084133Z" creationid="pingfangx" creationdate="20190618T074156Z">
        <seg>- §3.9 宽松：发出一个非肯定的 `request()` 不会停止当前流，但会通过 `RxJavaPlugins.onError` 发出错误信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If Java 8 lambdas are supported</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090817Z" creationid="pingfangx" creationdate="20190618T090817Z">
        <seg>//如果支持 Java 8 lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If no Retrolambda or Jack</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090828Z" creationid="pingfangx" creationdate="20190618T090828Z">
        <seg>//如果没有 Retrolambda 或 Jack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2-9 argument version dropped, use `startWithArray` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053722Z" creationid="pingfangx" creationdate="20190619T053722Z">
        <seg>2-9 参数版本删除，使用 `startWithArray` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5-9 source overloads dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054154Z" creationid="pingfangx" creationdate="20190619T054154Z">
        <seg>5-9 源重载删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt; is a single abstraction that can be used for any of these use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035601Z" creationid="pingfangx" creationdate="20190620T035601Z">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt; 是一个可用于任何这些用例的抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;PublishSubject&lt;/c0&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084605Z" creationid="pingfangx" creationdate="20190620T084605Z">
        <seg>&lt;c0&gt;PublishSubject&lt;/c0&gt; 仅向观察者发射订阅时间之后由源 Observable 发射的那些项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ReplaySubject&lt;/c0&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084938Z" creationid="pingfangx" creationdate="20190620T084938Z">
        <seg>无论观察者何时订阅，&lt;c0&gt;ReplaySubject&lt;/c0&gt; 都会向任何观察者发射源 Observable 发射的所有项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;ObserveOn&lt;/s1&gt;, on the other hand, affects the thread that the Observable will use &lt;e2&gt;below&lt;/e2&gt; where that operator appears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090449Z" creationid="pingfangx" creationdate="20190620T090449Z">
        <seg>另一方面，&lt;s1&gt;ObserveOn&lt;/s1&gt; 会影响 Observable 将在 &lt;e2&gt;下面&lt;/e2&gt; 出现的操作符使用的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;1&lt;/sup&gt;: When turning a multi-valued source into a single valued source, one should decide which of the many source values should be considered as the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095426Z" creationid="pingfangx" creationdate="20190617T095426Z">
        <seg>&lt;sup&gt;1&lt;/sup&gt;：当将多值源转换为单值源时，应该决定应该将多个源值中的哪一个视为结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;1&lt;/sup&gt;The `org.reactivestreams.Publisher` is part of the external Reactive Streams library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104341Z" creationid="pingfangx" creationdate="20190617T104341Z">
        <seg>&lt;sup&gt;1&lt;/sup&gt; `org.reactivestreams.Publisher` 是外部 Reactive Streams 库的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;2&lt;/sup&gt;: Turning an `Observable` into `Flowable` requires an additional decision: what to do with the potential unconstrained flow</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095444Z" creationid="pingfangx" creationdate="20190617T095444Z">
        <seg>&lt;sup&gt;2&lt;/sup&gt;：将 `Observable` 转换为 `Flowable` 需要另外一个决定：如何处理潜在的无约束流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;2&lt;/sup&gt;The naming convention of the interface was to append `Source` to the semi-traditional class name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104446Z" creationid="pingfangx" creationdate="20190617T104446Z">
        <seg>&lt;sup&gt;2&lt;/sup&gt; 接口的命名约定是将 `Source` 附加到半传统类名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;sup&gt;3&lt;/sup&gt;: When there is only (at most) one source item, there is no problem with backpressure as it can be always stored until the downstream is ready to consume.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100635Z" creationid="pingfangx" creationdate="20190617T100635Z">
        <seg>&lt;sup&gt;3&lt;/sup&gt;：当只有(最多)一个源项时，背压没有问题，因为它可以一直存储，直到下游准备好消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Decision Tree of Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094409Z" creationid="pingfangx" creationdate="20190620T094409Z">
        <seg>Observable 操作符的决策树</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073414Z" creationid="pingfangx" creationdate="20190620T073414Z">
        <seg>Single 就像一个 Observable，但它不发射一系列值 - 从零个到无限个 - 它总是发射一个值或一个错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Single will call only one of these methods, and will only call it once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073740Z" creationid="pingfangx" creationdate="20190620T073740Z">
        <seg>Single 将只调用其中一个方法，并且只调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T082956Z" creationid="pingfangx" creationdate="20190620T082956Z">
        <seg>Subject 是一种桥梁或代理，在 ReactiveX 的某些实现中可用，它既充当观察者又充当 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;e0&gt;in turn&lt;/e0&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093948Z" creationid="pingfangx" creationdate="20190620T073225Z">
        <seg>链式 Observable 操作符不能在原始的 Observable 上独立运行，它们是依次 &lt;e0&gt;操作&lt;/e0&gt;，每个操作符操作的 Observable 由链中的前一个操作符生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;e1&gt;in turn&lt;/e1&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093956Z" creationid="pingfangx" creationdate="20190620T093858Z">
        <seg>链式 Observable 操作符不能在原始的 Observable 上独立运行，它们是依次 &lt;e1&gt;操作&lt;/e1&gt;，每个操作符操作的 Observable 由链中的前一个操作符生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more complete &lt;c0&gt;subscribe&lt;/c0&gt; call example looks like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060713Z" creationid="pingfangx" creationdate="20190620T060713Z">
        <seg>更完整的 &lt;c0&gt;subscribe&lt;/c0&gt; 调用示例如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more subtle bug happens if the call to `request(1)` triggers an asynchronous call to `onNext` on some other thread and reading `name` in `onNext` races writing it in `onStart` post `request`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084520Z" creationid="pingfangx" creationdate="20190621T083839Z">
        <seg>还可能发生更微妙的错误，如果对 `request(1)` 的调用在某个其他线程上触发对 `onNext` 的异步调用，该调用在 `onNext` 中读取 `name`，而在 `onStart` 中 `request` 之后才会写入。（译注：不知道对不对，太难了）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A small regret about introducing backpressure in RxJava 0.x is that instead of having a separate base reactive class, the `Observable` itself was retrofitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053113Z" creationid="pingfangx" creationdate="20190618T053113Z">
        <seg>关于在 RxJava 0.x 中引入背压的一个小遗憾是，不再使用单独的基础响应类，`Observable` 本身就进行了改造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A toolbox of useful Operators for working with Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101906Z" creationid="pingfangx" creationdate="20190620T101906Z">
        <seg>用于处理 Observable 的有用操作符的工具箱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T080523Z" creationid="pingfangx" creationdate="20190620T080523Z">
        <seg>超时操作符的一个版本允许你在超时到期时切换到备份的 Single，而不是发送错误通知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070005Z" creationid="pingfangx" creationdate="20190620T070005Z">
        <seg>另一方面，“冷” Observable 会一直等待，直到有观察者订阅它才开始发射数据项，因此观察者保证能从开头看到整个序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T065453Z" creationid="pingfangx" creationdate="20190620T065453Z">
        <seg>“热” Observable 可能在创建后立即开始发射项目，因此任何后来订阅该 Observable 的观察者可能会在序列中间某处开始观察。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API designers may instead choose to define `Observable&lt;Object&gt;` with no guarantee on what `Object` will be (which should be irrelevant anyway).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052849Z" creationid="pingfangx" creationdate="20190618T052849Z">
        <seg>API 设计者可能会选择定义 `Observable&lt;Object&gt;` 而不保证 `Object` 将是什么(无论如何都应该是无关的)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the [`@Beta`][beta source link] annotation at the class or method level are subject to change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105234Z" creationid="pingfangx" creationdate="20190617T105234Z">
        <seg>在类或方法级别标有 [`@Beta`][beta source link] 注释的 API 可能会发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the [`@Experimental`][experimental source link] annotation at the class or method level will almost certainly change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105322Z" creationid="pingfangx" creationdate="20190617T105322Z">
        <seg>在类或方法级别用 [`@Experimental`][experimental source link] 注释标记的 API 几乎肯定会改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>APIs marked with the `@Deprecated` annotation at the class or method level will remain supported until the next major release but it is recommended to stop using them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105356Z" creationid="pingfangx" creationdate="20190617T105356Z">
        <seg>在类或方法级别标记有 `@Deprecated` 注释的 API 将保持支持，直到下一个主要版本，但建议停止使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All code inside the `io.reactivex.internal.*` packages is considered private API and should not be relied upon at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105411Z" creationid="pingfangx" creationdate="20190617T105411Z">
        <seg>`io.reactivex.internal.*` 包中的所有代码都被视为私有 API，根本不应该依赖它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093759Z" creationid="pingfangx" creationdate="20190620T093759Z">
        <seg>此外，每个实现都倾向于将其操作符命名为类似于该语言中其他上下文已熟悉的类似方法的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the `Flowable.parallel()` operator and the `ParallelFlowable` type help achieve the same parallel processing pattern:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083319Z" creationid="pingfangx" creationdate="20190617T083319Z">
        <seg>或者，`Flowable.parallel()` 运算符和 `ParallelFlowable` 类型有助于实现相同的并行处理模式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the `doFinally` operator (introduced in 2.0.1 and standardized in 2.1) calls a developer specified `Action` that gets executed after a source completed, failed with an error or got cancelled/disposed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115415Z" creationid="pingfangx" creationdate="20190618T115415Z">
        <seg>或者，`doFinally` 操作符(在 2.0.1 中引入，在 2.1 中标准化)调用开发人员指定的 `Action`，它在源完成后，带错误失败或被取消/释放时执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can use the `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)` (and similar) methods to provide a callback/lambda that can throw:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095717Z" creationid="pingfangx" creationdate="20190618T095717Z">
        <seg>或者，您可以使用 `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)`(和类似的)方法来提供可以抛出的回调/lambda：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the `Flowable` infrastructure guarantees it will be called at most once on each `Subscriber`, the call to `request(1)` may trigger the emission of an element right away.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083229Z" creationid="pingfangx" creationdate="20190621T083229Z">
        <seg>虽然 `Flowable` 基础设施保证在每个 `Subscriber` 上最多只调用一次，但是对 `request(1)` 的调用可能会立即触发一个元素的发射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093543Z" creationid="pingfangx" creationdate="20190620T093543Z">
        <seg>虽然实现之间存在很多重叠，但也有一些操作符仅在某些实现中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;AsyncSubject&lt;/c0&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083933Z" creationid="pingfangx" creationdate="20190620T083933Z">
        <seg>&lt;c0&gt;AsyncSubject&lt;/c0&gt; 发射源 Observable 发射的最后一个值(且仅发射最后一个值)，并且只在该 Observable 源完成后才会发射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Alphabetical List of Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094441Z" creationid="pingfangx" creationdate="20190620T094441Z">
        <seg>按字母顺序排列的 Observable 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable &lt;d3&gt;emits&lt;/d3&gt; &lt;d4&gt;items&lt;/d4&gt; or sends &lt;d5&gt;notifications&lt;/d5&gt; to its observers by calling the observers’ methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045830Z" creationid="pingfangx" creationdate="20190620T045830Z">
        <seg>Observable(可观察对象) &lt;d3&gt;emits (发射)&lt;/d3&gt; &lt;d4&gt;items (数据项)&lt;/d4&gt; 或通过调用观察者的方法向其观察者发送 &lt;d5&gt;notifications (通知)&lt;/d5&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method after it has called &lt;c0&gt;onNext&lt;/c0&gt; for the final time, if it has not encountered any errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060356Z" creationid="pingfangx" creationdate="20190620T060356Z">
        <seg>如果 Observable 没有遇到任何错误，则在最后一次调用 &lt;c0&gt;onNext&lt;/c0&gt; 之后调用此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060301Z" creationid="pingfangx" creationdate="20190620T060301Z">
        <seg>Observable 调用此方法以指示它无法生成预期数据或遇到其他一些错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable calls this method whenever the Observable emits an item.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060243Z" creationid="pingfangx" creationdate="20190620T060243Z">
        <seg>只要 Observable 发射一个项目，Observable 就会调用此方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable has all of the flexibility and elegance associated with its mirror-image cousin the Iterable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035619Z" creationid="pingfangx" creationdate="20190620T035619Z">
        <seg>Observable 具有与 Iterable 镜像相关的所有灵活性和优雅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Observable is the asynchronous/push &lt;a0&gt;“dual”&lt;/a0&gt; to the synchronous/pull Iterable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040115Z" creationid="pingfangx" creationdate="20190620T035959Z">
        <seg>Observable 是异步的双向(&lt;a0&gt;“dual”&lt;/a0&gt;) push，Iterable 是同步的 pull</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one — that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045630Z" creationid="pingfangx" creationdate="20190620T045630Z">
        <seg>这种方法的一个优点是，当您有一堆不依赖于彼此的任务时，你可以同时启动所有任务，而不是等到每个任务完成后再开始下一个 - 这样，你的整个捆绑任务只会耗费与捆绑中最长的任务一样长的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of an enhancement that would classify as this is adding reactive pull backpressure support to an operator that previously did not support it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105030Z" creationid="pingfangx" creationdate="20190617T105030Z">
        <seg>可归类为此增强功能的一个示例是向先前不支持它的运算符添加反应性拉背压支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An important change regarding `Subject`s (and by extension, `FlowableProcessor`) that they no longer support `T -&gt; R` like conversion (that is, input is of type `T` and the output is of type `R`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062234Z" creationid="pingfangx" creationdate="20190618T062234Z">
        <seg>关于 `Subject` (以及扩展名 `FlowableProcessor`)的一个重要变化是它们不再支持类似 `T -&gt; R` 的转换(即输入类型为 `T` 且输出类型为 `R` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040922Z" creationid="pingfangx" creationdate="20190620T040922Z">
        <seg>而且重要的是：使用 ReactiveX，你可以改变你的观念，你可从根本上改变 Observable 的底层实现，而不会破坏 Observable 的使用者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another significant difference between `rx.Subscriber` (and co) and `org.reactivestreams.Subscriber` (and co) is that in 2.x, your `Subscriber`s and `Observer`s are not allowed to throw anything but fatal exceptions (see `Exceptions.throwIfFatal()`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095501Z" creationid="pingfangx" creationdate="20190618T095501Z">
        <seg>`rx.Subscriber`(及 co) 和 `org.reactivestreams.Subscriber`(及 co)之间的另一个显着区别是在 2.x 中，您的 `Subscriber`s 和 `Observer`s 不允许抛出任何异常，除了致命的异常(参见 `Exceptions.throwIfFatal()`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075544Z" creationid="pingfangx" creationdate="20190620T075544Z">
        <seg>另一个版本需要两个或更多 Singles 并将它们合并到一个 Observable 中，该 Observable 发射源 Singles 发射的项目(以任意顺序)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from subscribing to the base types with their respective consumers (`Subscriber`, `Observer`, `SingleObserver`, `MaybeObserver` and `CompletableObserver`) and functional-interface based consumers (such as `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)`), the formerly separate 1.x `BlockingObservable` (and similar classes for the others) has been integrated with the main reactive type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095158Z" creationid="pingfangx" creationdate="20190618T095158Z">
        <seg>除了订阅基本类型用他们各自的消费者（`Subscriber`，`Observer`，`SingleObserver`，`MaybeObserver` 和 `CompletableObserver`）和基于函数接口的消费者（例如 `subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action`），以前单独的 1.x `BlockingObservable`（以及其他类似的类）已经与主要的响应类型集成在一起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative, the 2.x `Observable` doesn't do backpressure at all and is available as a choice to switch over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073717Z" creationid="pingfangx" creationdate="20190618T073717Z">
        <seg>作为替代方案，2.x `Observable` 根本不做背压，可作为切换的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one of the primary goals of RxJava 2, the design focuses on performance and in order enable it, RxJava 2.0.7 adds a custom `io.reactivex.FlowableSubscriber` interface (extends `org.reactivestreams.Subscriber`) but adds no new methods to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073904Z" creationid="pingfangx" creationdate="20190618T073904Z">
        <seg>作为 RxJava 2 的主要目标之一，该设计侧重于性能，为了实现它，RxJava 2.0.7 增加了一个自定义的 `io.reactivex.FlowableSubscriber` 接口(扩展了 `org.reactivestreams.Subscriber`)，但没有添加新的它的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in this illustration, the &lt;s0&gt;SubscribeOn&lt;/s0&gt; operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090322Z" creationid="pingfangx" creationdate="20190620T090322Z">
        <seg>如图所示，&lt;s0&gt;SubscribeOn&lt;/s0&gt; 操作符指定 Observable 将开始操作的线程，无论操作符链中的哪个操作符被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the opportunity to reduce component count, 2.x doesn't define `Action3`-`Action9` and `ActionN` (these were unused within RxJava itself anyway).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064522Z" creationid="pingfangx" creationdate="20190618T064522Z">
        <seg>作为减少组件数量的机会，2.x 没有定义 `Action3`-`Action9` 和 `ActionN`(无论如何这些都在 RxJava 本身中未使用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the `Observable`/`Flowable` split, the backpressure-aware, Reactive-Streams compliant implementations are based on the `FlowableProcessor&lt;T&gt;` class (which extends `Flowable` to give a rich set of instance operators).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062103Z" creationid="pingfangx" creationdate="20190618T062103Z">
        <seg>与 `Observable`/`Flowable` 拆分一样，背压感知，Reactive-Streams 兼容实现基于 `FlowableProcessor&lt;T&gt;` 类(扩展 `Flowable` 以提供丰富的实例操作符集)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091954Z" creationid="pingfangx" creationdate="20190620T091954Z">
        <seg>除了将这些调度器传递给 RxJava Observable 操作符之外，您还可以使用它们来安排自己的订阅工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At each invocation, it has to call `onNext` at most once optionally followed by either `onError` or `onComplete`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021246Z" creationid="pingfangx" creationdate="20190624T021246Z">
        <seg>在每次调用时，它必须最多调用 `onNext` 一次，可选地后跟 `onError` 或 `onComplete`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the data is not flowing yet and no side-effects are happening.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071727Z" creationid="pingfangx" creationdate="20190617T071727Z">
        <seg>此时，数据尚未流动，并且没有发生任何副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attach the observer to that Observable by &lt;i0&gt;subscribing&lt;/i0&gt; it (this also initiates the actions of the Observable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055804Z" creationid="pingfangx" creationdate="20190620T055804Z">
        <seg>通过 &lt;i0&gt;subscribing (订阅)&lt;/i0&gt; 将观察者附加到该 Observable(这也启动了 Observable 的操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Background</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044531Z" creationid="pingfangx" creationdate="20190620T044531Z">
        <seg>背景</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backpressure Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072112Z" creationid="pingfangx" creationdate="20190620T072112Z">
        <seg>背压操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Reactive-Streams base interface, `org.reactivestreams.Publisher` defines the `subscribe()` method as `void`, `Flowable.subscribe(Subscriber)` no longer returns any `Subscription` (or `Disposable`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072916Z" creationid="pingfangx" creationdate="20190618T072916Z">
        <seg>因为 Reactive-Streams 基接口，`org.reactivestreams.Publisher` 将 `subscribe()` 方法定义为 `void`，`Flowable.subscribe(Subscriber)` 不再返回任何 `Subscription`(或 `Disposable`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Reactive-Streams has a different architecture, it mandates changes to some well known RxJava types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051847Z" creationid="pingfangx" creationdate="20190618T051847Z">
        <seg>由于 Reactive-Streams 具有不同的体系结构，因此它要求对一些众所周知的 RxJava 类型进行更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is “cold” — that is, if it waits for a subscription before it begins to emit items).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083553Z" creationid="pingfangx" creationdate="20190620T083553Z">
        <seg>因为 Subject 订阅了 Observable，它会触发 Observable 开始发射项目(如果 Observable 是“冷” - 也就是说，如果它在开始发射项目之前等待订阅)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because both 1.x and 2.x is aimed at Java 6+, we can't use the Java 8 functional interfaces such as `java.util.function.Function`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064046Z" creationid="pingfangx" creationdate="20190618T064046Z">
        <seg>因为 1.x 和 2.x 都是针对 Java 6+，所以我们不能使用 Java 8 的函数接口，例如 `java.util.function.Function`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083529Z" creationid="pingfangx" creationdate="20190620T083529Z">
        <seg>因为它是一个观察者，它可以订阅一个或多个 Observable，并且因为它是一个 Observable，它可以通过重新发送来传递它所观察的项目，并且它也可以发射新项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there could be at most 1 element emitted, the `Maybe` type has no notion of backpressure (because there is no buffer bloat possible as with unknown length `Flowable`s or `Observable`s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060825Z" creationid="pingfangx" creationdate="20190618T060825Z">
        <seg>因为最多可以发射 1 个元素，所以 `Maybe` 类型没有背压概念(因为没有缓冲膨胀可能，而未知长度的 `Flowable` 或 `Observable` 则有这种可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before 2.0.7, the operator `strict()` had to be applied in order to achieve the same level of compliance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073825Z" creationid="pingfangx" creationdate="20190618T073825Z">
        <seg>在 2.0.7 之前，必须应用运算符 `strict()` 才能达到相同的合规水平。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being unbounded means as long as the JVM doesn't run out of memory, it can handle almost any amount coming from a bursty source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092431Z" creationid="pingfangx" creationdate="20190621T092431Z">
        <seg>无限制意味着只要 JVM 没有内存耗尽，它几乎可以处理来自突发源的任何数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond the `PublishProcessor`above, there are other operators that don't support backpressure, mostly due to functional reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T073835Z" creationid="pingfangx" creationdate="20190621T073258Z">
        <seg>除了 `PublishProcessor` 之外，还有其他一些操作符不支持背压，主要是由于函数原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105518Z" creationid="pingfangx" creationdate="20190617T105518Z">
        <seg>可以在 [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava2) 上找到 Maven，Ivy，Gradle 和其他的二进制文件和依赖信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both `Publisher` and `SingleSource` appear as functional interfaces (types with one abstract method) and may encourage users to try to provide a lambda expression:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102531Z" creationid="pingfangx" creationdate="20190617T102531Z">
        <seg>`Publisher` 和 `SingleSource` 都显示为函数接口(具有一个抽象方法的类型)，并且可能鼓励用户尝试提供 lambda 表达式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a0&gt;with nested composition they become unwieldy&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041126Z" creationid="pingfangx" creationdate="20190620T041126Z">
        <seg>但与 Futures 一样，虽然回调很容易使用单层的异步执行，但是 &lt;a0&gt;对于嵌套组合，它们难以处理&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by “observers.” Rather than &lt;e0&gt;calling&lt;/e0&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an “Observable,” and then &lt;e1&gt;subscribe&lt;/e1&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045501Z" creationid="pingfangx" creationdate="20190620T045501Z">
        <seg>但是在 ReactiveX 中，许多指令可以并行执行，并且它们的结果稍后由“观察者”以任意顺序捕获。你不用 &lt;e0&gt;调用&lt;/e0&gt; 方法，而是定义一种获取和转换数据的机制，以“Observable”的形式，然后为它 &lt;e1&gt;subscribe (订阅)&lt;/e1&gt; 一个观察者，一旦 Observable 发射的数据准备好，先前定义的机制就会发射数据，观察者表示的哨兵捕捉并作出响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators &lt;e0&gt;order matters&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072946Z" creationid="pingfangx" creationdate="20190620T072946Z">
        <seg>但是在 Builder 模式中，方法在链中出现的顺序通常并不重要，而 Observable 操作符是 &lt;e0&gt;顺序重要的&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, with an Observable the producer pushes values to the consumer whenever values are available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042145Z" creationid="pingfangx" creationdate="20190620T042145Z">
        <seg>相比之下，对于 Observable，只要值可用，生产者就会将值推送给消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, in this document, calls to &lt;c4&gt;onNext&lt;/c4&gt; are usually called “emissions” of items, whereas calls to &lt;c5&gt;onCompleted&lt;/c5&gt; or &lt;c6&gt;onError&lt;/c6&gt; are called “notifications.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060707Z" creationid="pingfangx" creationdate="20190620T060707Z">
        <seg>按照惯例，在本文档中，对 &lt;c4&gt;onNext&lt;/c4&gt; 的调用通常称为项目的“发射 (emissions)”，而对 &lt;c5&gt;onCompleted&lt;/c5&gt; 或 &lt;c6&gt;onError&lt;/c6&gt; 的调用称为“通知 (notifications)”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;c0&gt;Subscribe&lt;/c0&gt; method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090042Z" creationid="pingfangx" creationdate="20190620T085923Z">
        <seg>默认情况下，Observable 和应用于它的操作符链将完成其工作，并通知其观察者，在调用其 &lt;c0&gt;Subscribe&lt;/c0&gt; 方法的同一线程上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By having `Publisher` as input this way, you can compose with other Reactive-Streams compliant libraries without the need to wrap them or convert them into `Flowable` first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061637Z" creationid="pingfangx" creationdate="20190618T061637Z">
        <seg>通过以这种方式输入 `Publisher`，您可以使用其他符合 Reactive-Streams 标准的库进行组合，而无需先将它们包装或转换为 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By the terms of &lt;a0&gt;the Observable contract&lt;/a0&gt;, it may call &lt;c1&gt;onNext&lt;/c1&gt; zero or more times, and then may follow those calls with a call to either &lt;c2&gt;onCompleted&lt;/c2&gt; or &lt;c3&gt;onError&lt;/c3&gt; but not both, which will be its last call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060553Z" creationid="pingfangx" creationdate="20190620T060553Z">
        <seg>根据 &lt;a0&gt;Observable 协议&lt;/a0&gt; 的定义，它可以调用 &lt;c1&gt;onNext&lt;/c1&gt; 零次或多次，然后这些调用可能跟随 &lt;c2&gt;onCompleted&lt;/c2&gt; 或 &lt;c3&gt;onError&lt;/c3&gt; ，但不会同时，这将是它的最后一次调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By themselves they’d be nothing more than a slight extension of the standard observer pattern, better suited to handling a sequence of events rather than a single callback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071412Z" creationid="pingfangx" creationdate="20190620T070347Z">
        <seg>它们本身只不过是标准观察者模式的轻微扩展，使其更适合处理一系列事件而不是单个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call a method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053007Z" creationid="pingfangx" creationdate="20190620T053007Z">
        <seg>调用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callbacks Have Their Own Problems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040949Z" creationid="pingfangx" creationdate="20190620T040937Z">
        <seg>使用回调会有问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Callbacks solve the problem of premature blocking on &lt;c0&gt;Future.get()&lt;/c0&gt; by not allowing anything to block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041019Z" creationid="pingfangx" creationdate="20190620T041019Z">
        <seg>回调通过不允许任何阻塞来解决 &lt;c0&gt;Future.get()&lt;/c0&gt; 上的过早阻塞问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072235Z" creationid="pingfangx" creationdate="20190620T072235Z">
        <seg>链接操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking or Setting Unsubscribed Status</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092143Z" creationid="pingfangx" creationdate="20190620T092143Z">
        <seg>检查或设置取消订阅状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client code treats all of its interactions with Observables as asynchronous, whether your underlying implementation is blocking or non-blocking and however you choose to implement it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040444Z" creationid="pingfangx" creationdate="20190620T040444Z">
        <seg>客户端代码将其与 Observable 的所有交互视为异步，无论您的底层实现是阻塞还是非阻塞，无论您选择什么实现它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071920Z" creationid="pingfangx" creationdate="20190620T071920Z">
        <seg>结合 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composition via Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070213Z" creationid="pingfangx" creationdate="20190620T070213Z">
        <seg>通过 Observable 操作符组合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composition via Single Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073849Z" creationid="pingfangx" creationdate="20190620T073849Z">
        <seg>Single 操作符组合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conceptually, it is a union of `Single` and `Completable` providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060448Z" creationid="pingfangx" creationdate="20190618T060448Z">
        <seg>从概念上讲，它是 `Single` 和 `Completable` 的结合，提供捕获发射模式的方法，这些模式可能存在 0 或 1 个项或由某些响应源发出的错误信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional and Boolean Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072009Z" creationid="pingfangx" creationdate="20190620T072009Z">
        <seg>条件和布尔操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connectable Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103640Z" creationid="pingfangx" creationdate="20190620T072045Z">
        <seg>Connectable Observable 操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072026Z" creationid="pingfangx" creationdate="20190620T072026Z">
        <seg>转换 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counts the number of elements in the sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061046Z" creationid="pingfangx" creationdate="20190619T061046Z">
        <seg>计算序列中的元素数量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071826Z" creationid="pingfangx" creationdate="20190620T071826Z">
        <seg>创建 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating backpressured data sources is the relatively easier task when dealing with backpressure in general because the library already offers static methods on `Flowable` that handle backpressure for the developer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015503Z" creationid="pingfangx" creationdate="20190624T015503Z">
        <seg>在处理背压时，创建背压数据源是相对容易的任务，因为库已经在 `Flowable` 上提供了静态方法，可以让开发人员处理背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflows can fail, at which point the error is emitted to the consumer(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103130Z" creationid="pingfangx" creationdate="20190617T103130Z">
        <seg>数据流可能会失败，此时错误会发送给消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Schedulers for RxGroovy Observable Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091353Z" creationid="pingfangx" creationdate="20190620T091353Z">
        <seg>RxGroovy Observable 操作符的默认调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define a method that does something useful with the return value from the asynchronous call; this method is part of the &lt;i0&gt;observer&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055742Z" creationid="pingfangx" creationdate="20190620T055742Z">
        <seg>定义一个方法，该方法对异步调用的返回值执行一些有用的操作；此方法是 &lt;i0&gt;observer&lt;/i0&gt; 的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define the asynchronous call itself as an &lt;i0&gt;Observable&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055748Z" creationid="pingfangx" creationdate="20190620T055748Z">
        <seg>将异步调用本身定义为 &lt;i0&gt;Observable&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delayed and Periodic Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092325Z" creationid="pingfangx" creationdate="20190620T092325Z">
        <seg>延迟和周期调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the Reactive-Streams specification, `Publisher.subscribe` returns void and the pattern by itself no longer works in 2.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070624Z" creationid="pingfangx" creationdate="20190618T070624Z">
        <seg>由于 Reactive-Streams 规范，`Publisher.subscribe` 返回 void，该模式本身不再适用于 2.0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the name conflict, replacing the package from `rx` to `org.reactivestreams` is not enough.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065709Z" creationid="pingfangx" creationdate="20190618T065709Z">
        <seg>由于名称冲突，将包从 `rx` 替换为 `org.reactivestreams` 是不够的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each language-specific implementation of ReactiveX has its own naming quirks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064528Z" creationid="pingfangx" creationdate="20190620T064528Z">
        <seg>ReactiveX 的每种语言特定实现都有自己的命名偏好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each language-specific implementation of ReactiveX implements a set of operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T093532Z" creationid="pingfangx" creationdate="20190620T093532Z">
        <seg>ReactiveX 的每个特定于语言的实现都实现了一组操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator in the chain modifies the Observable that results from the operation of the previous operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072434Z" creationid="pingfangx" creationdate="20190620T072434Z">
        <seg>链中的每个操作符都会修改由前一个操作符的运算产生的 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reactive base class features operators that can perform such conversions, including the protocol conversions, to match some other type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T093029Z" creationid="pingfangx" creationdate="20190617T093029Z">
        <seg>每个反应基类都具有可以执行此类转换的运算符，包括协议转换，以匹配其他类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reactive base type `Flowable`, `Observable`, `Single`, `Maybe` and `Completable` feature a safe `create` operator that does the right thing regarding backpressure (for `Flowable`) and cancellation (all):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094823Z" creationid="pingfangx" creationdate="20190618T094823Z">
        <seg>每个响应基类 `Flowable`，`Observable`，`Single`，`Maybe` 和 `Completable` 都有一个安全的 `create` 操作符，可以对背压(对于 `Flowable`)和取消(对于所有)执行正确的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each requested element triggers a state transition and computation of the returned value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020312Z" creationid="pingfangx" creationdate="20190624T020312Z">
        <seg>每个请求的元素触发状态转换并返回值的计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the element at the given index or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061100Z" creationid="pingfangx" creationdate="20190619T061100Z">
        <seg>在给定索引处发出元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the element at the given index or the default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061250Z" creationid="pingfangx" creationdate="20190619T061126Z">
        <seg>发出给定索引的元素或默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the first element or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061200Z" creationid="pingfangx" creationdate="20190619T061200Z">
        <seg>发出第一​​个元素或如果源为空，则 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the indexth element or a `NoSuchElementException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T062204Z" creationid="pingfangx" creationdate="20190619T062204Z">
        <seg>发出索引指示的元素或 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the lastelement or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061325Z" creationid="pingfangx" creationdate="20190619T061325Z">
        <seg>发出最后一个元素，或如果源为空，则 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the one and only element, IndexOutOfBoundsException if the source is longer than 1 item or a `NoSuchElementException` if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061440Z" creationid="pingfangx" creationdate="20190619T061440Z">
        <seg>发出唯一元素，如果源长度超过 1 个项，则发出 IndexOutOfBoundsException，如果源为空，则发出 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the only element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061356Z" creationid="pingfangx" creationdate="20190619T061356Z">
        <seg>发出唯一的元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the only element or the default item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061353Z" creationid="pingfangx" creationdate="20190619T061353Z">
        <seg>发出唯一元素或默认项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the reduced value (or the initial value)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061343Z" creationid="pingfangx" creationdate="20190619T061343Z">
        <seg>发出减少的值(或初始值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the reduced value or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061334Z" creationid="pingfangx" creationdate="20190619T061334Z">
        <seg>发出减少的价值或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very first element or `NoSuchElementException`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061133Z" creationid="pingfangx" creationdate="20190619T061133Z">
        <seg>发出第一个元素或 `NoSuchElementException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very first element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061140Z" creationid="pingfangx" creationdate="20190619T061140Z">
        <seg>发出第一个元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very last element or completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061301Z" creationid="pingfangx" creationdate="20190619T061301Z">
        <seg>发出最后一个元素或完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits the very last element or the default item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061221Z" creationid="pingfangx" creationdate="20190619T061221Z">
        <seg>发出最后一个元素或默认项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if all elements match the predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061036Z" creationid="pingfangx" creationdate="20190619T061036Z">
        <seg>如果所有元素都与谓词匹配，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if any elements match the predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061041Z" creationid="pingfangx" creationdate="20190619T061041Z">
        <seg>如果任何元素与谓词匹配，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits true if the source is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061212Z" creationid="pingfangx" creationdate="20190619T061212Z">
        <seg>如果源为空，则返回 true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enhancements and bugfixes will be synchronized between the two in a timely manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104702Z" creationid="pingfangx" creationdate="20190617T104702Z">
        <seg>增强功能和错误修正将在两者之间及时同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error Handling Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071925Z" creationid="pingfangx" creationdate="20190620T071925Z">
        <seg>错误处理操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Establishing Observers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T050058Z" creationid="pingfangx" creationdate="20190620T050058Z">
        <seg>创建观察者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though certain operators have no problems from type erasure, their signature may turn up being ambiguous, especially if one uses Java 8 and lambdas.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102233Z" creationid="pingfangx" creationdate="20190617T102233Z">
        <seg>即使某些操作符没有类型擦除的问题，它们的签名也可能变得有歧义，特别是如果使用 Java 8 和 lambdas。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042214Z" creationid="pingfangx" creationdate="20190620T042214Z">
        <seg>示例代码显示了如何将类似的高阶函数应用于 Iterable 和 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example for Gradle:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105522Z" creationid="pingfangx" creationdate="20190617T105522Z">
        <seg>Gradle 示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressing backpressure in end-consumers is rarely necessary (because they are synchronous in respect to their immediate upstream and backpressure naturally happens due to call-stack blocking), but it may be easier to understand the workings of it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083119Z" creationid="pingfangx" creationdate="20190621T083119Z">
        <seg>在最终消费者中很少需要表达背压(因为它们与上游是同步的，背压自然是由于调用堆栈阻塞而发生)，但是可能更容易理解它的工作原理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filtering Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071907Z" creationid="pingfangx" creationdate="20190620T071907Z">
        <seg>过滤 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094212Z" creationid="pingfangx" creationdate="20190620T094212Z">
        <seg>最后，有一个按字母顺序排列的操作符列表，表示在大多数 ReactiveX 的特定于语言的实现中可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flows in RxJava are sequential in nature split into processing stages that may run **concurrently** with each other:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075403Z" creationid="pingfangx" creationdate="20190617T075403Z">
        <seg>RxJava 中的流本质上是顺序的，分为处理阶段，这些阶段可以彼此 **并发** 运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following the style of extending the Reactive-Streams `Publisher&lt;T&gt;` in `Flowable`, the other base reactive classes now extend similar base interfaces (in package `io.reactivex`):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061442Z" creationid="pingfangx" creationdate="20190618T061442Z">
        <seg>遵循在 `Flowable` 中扩展 Reactive-Streams `Publisher&lt;T&gt;` 的方式，其他基本响应类现在继承了类似的基接口(在包 `io.reactivex` 中)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For bugs, questions and discussions please use the [Github Issues](https://github.com/ReactiveX/RxJava/issues).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105641Z" creationid="pingfangx" creationdate="20190617T105641Z">
        <seg>有关错误，问题和讨论，请使用 [Github Issues](https://github.com/ReactiveX/RxJava/issues)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For convenience (and avoiding warnings about generic array creation) there are 2 to 10 argument overloads to `just` that internally delegate to `from`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020236Z" creationid="pingfangx" creationdate="20190624T020236Z">
        <seg>为了方便(并避免关于泛型数组创建的警告)，内部委托给 `from` 的 `just` 有 2 到 10 个参数重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example there is the &lt;c0&gt;on&lt;i1&gt;Event&lt;/i1&gt;&lt;/c0&gt; naming pattern (e.g. &lt;c2&gt;onNext&lt;/c2&gt;, &lt;c3&gt;onCompleted&lt;/c3&gt;, &lt;c4&gt;onError&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064718Z" creationid="pingfangx" creationdate="20190620T064718Z">
        <seg>例如，有 &lt;c0&gt;on&lt;i1&gt;Event&lt;/i1&gt;&lt;/c0&gt; 命名模式上(例如 &lt;c2&gt;onNext&lt;/c2&gt;，&lt;c3&gt;onCompleted&lt;/c3&gt;，&lt;c4&gt;onError&lt;/c4&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a service that returns a `Flowable`, we'd like to call another service with values emitted by the first service:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083518Z" creationid="pingfangx" creationdate="20190617T083518Z">
        <seg>例如，给定一个返回 `Flowable` 的服务，我们想要使用第一个服务发出的值调用另一个服务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if one needs a signaller-like source, a shared enum can be defined and its solo instance `onNext`'d:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052921Z" creationid="pingfangx" creationdate="20190618T052921Z">
        <seg>例如，如果需要类似信号器的源，则可以定义共享枚举并将其独立实例 `onNext`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if one wants to perform some periodic background task but each iteration may last longer than the period, it is safe to drop the excess interval notification as there will be more later on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014924Z" creationid="pingfangx" creationdate="20190624T014924Z">
        <seg>例如，如果想要执行一些定期后台任务但每次迭代可能持续的时间超过后台任务周期，则可以安全地删除多余的间隔通知，因为稍后会有更多：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the user clicks a lot on the screen, we'd still want to react to its latest input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015255Z" creationid="pingfangx" creationdate="20190624T015255Z">
        <seg>例如，如果用户在屏幕上点击了很多地方，我们仍然希望对其最新的输入做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the inventory example above, `getDemandAsync` could return a `Single&lt;DemandRecord&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092742Z" creationid="pingfangx" creationdate="20190617T092742Z">
        <seg>例如，在上面的清单示例中，`getDemandAsync` 可以返回 `Single &lt;DemandRecord&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the operator `interval` emits values periodically, backpressuring it would lead to shifting in the period relative to a wall clock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T074254Z" creationid="pingfangx" creationdate="20190621T074254Z">
        <seg>例如，操作符 `interval` 周期性地发射值，背压它会导致相对于挂钟的周期偏移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there are several overloads of `concatWith` taking the various other reactive base types as arguments (for providing convenience and performance benefits in the underlying implementation):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102323Z" creationid="pingfangx" creationdate="20190617T102323Z">
        <seg>例如，有几个 `concatWith` 重载将各种其他响应基类型作为参数(为了在底层实现中提供方便和性能优势)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For further details, consult the [wiki](https://github.com/ReactiveX/RxJava/wiki).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104625Z" creationid="pingfangx" creationdate="20190617T104625Z">
        <seg>有关详细信息，请参阅 [wiki](https://github.com/ReactiveX/RxJava/wiki)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about ReactiveX, see the [Introduction to ReactiveX](http://reactivex.io/intro.html) page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113458Z" creationid="pingfangx" creationdate="20190617T113458Z">
        <seg>有关 ReactiveX 的详细信息，请参阅 [ReactiveX 简介](http://reactivex.io/intro.html) 页。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For technical details on how to write operators for 2.x, please visit the [Writing Operators](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0) wiki page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051956Z" creationid="pingfangx" creationdate="20190618T051932Z">
        <seg>有关如何为 2.x 编写运算符的技术细节，请访问 [编写运算符](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0) wiki 页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the rest, this gives an opportunity to "extend their internal buffer" by having a larger number with `onBackpressureBuffer` than their default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093329Z" creationid="pingfangx" creationdate="20190621T093329Z">
        <seg>对于其余操作符，这提供了一个“扩展其内部缓冲区”的机会，通过使用 `onBackpressureBuffer` 而不是默认值来扩展它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the same reason, `unsubscribeOn` is not called on the regular termination path but only when there is an actual `cancel` (or `dispose`) call on the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115016Z" creationid="pingfangx" creationdate="20190618T115016Z">
        <seg>出于同样的原因，`unsubscribeOn` 不会在常规终止路径上调用，而是仅在链上有一个实际的 `cancel`(或 `dispose`)调用时调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (&lt;t0&gt;onNext&lt;/t0&gt;, &lt;t1&gt;onError&lt;/t1&gt;, and &lt;t2&gt;onCompleted&lt;/t2&gt;), you only use two methods to subscribe:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073552Z" creationid="pingfangx" creationdate="20190620T073552Z">
        <seg>出于这个原因，不用使用三个方法订阅 Single，来响应来自 Observable 的通知(&lt;t0&gt;onNext&lt;/t0&gt;，&lt;t1&gt;onError&lt;/t1&gt; 和 &lt;t2&gt;onCompleted&lt;/t2&gt;)，你只需要使用两个方法进行订阅：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, you may call &lt;s3&gt;ObserveOn&lt;/s3&gt; multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090714Z" creationid="pingfangx" creationdate="20190620T090714Z">
        <seg>因此，您可以在 Observable 操作符链中的不同点多次调用 &lt;s3&gt;ObserveOn&lt;/s3&gt;，以便更改某些操作符运行的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From a user's perspective, if one was using the the `subscribe` methods other than `Flowable.subscribe(Subscriber&lt;? super T&gt;)`, there is no need to do anything regarding this change and there is no extra penalty for it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085030Z" creationid="pingfangx" creationdate="20190618T085030Z">
        <seg>从用户的角度来看，如果使用 `subscribe` 而不是 `Flowable.subscribe(Subscriber&lt;? super T&gt;)` 方法，则无需对此更改执行任何操作，也不会对其进行额外惩罚。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the Observer’s point of view, it doesn’t matter!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040634Z" creationid="pingfangx" creationdate="20190620T040634Z">
        <seg>从观察者的角度来看，这并不重要！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further details on building can be found on the [Getting Started](https://github.com/ReactiveX/RxJava/wiki/Getting-Started) page of the wiki.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105621Z" creationid="pingfangx" creationdate="20190617T105621Z">
        <seg>有关构建的更多详细信息，请参见 Wiki 的 [Getting Started](https://github.com/ReactiveX/RxJava/wiki/Getting-Started) 页面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064628Z" creationid="pingfangx" creationdate="20190620T064628Z">
        <seg>此外，这些名称中的一些在其他情境中具有不同的含义，或者在特定实现语言的习语中看起来很怪异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, `generate` uses 3 callbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021056Z" creationid="pingfangx" creationdate="20190624T021056Z">
        <seg>通常，`generate` 使用 3 个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, many operators gained overloads that now allow specifying the internal buffer size or prefetch amount they should run their upstream (or inner sources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111231Z" creationid="pingfangx" creationdate="20190618T111129Z">
        <seg>通常，许多操作符获得了重载，现在允许指定内部缓冲区大小或它们应该运行其上游(或内部源)的预取量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an asynchronous source, fluent blocking for a terminal event is now possible:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101831Z" creationid="pingfangx" creationdate="20190618T101831Z">
        <seg>给定异步源，现在可以对终端事件进行流畅阻塞：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the overflowing example in the introduction, we can just increase the buffer size of `observeOn` to have enough room for all values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090705Z" creationid="pingfangx" creationdate="20190621T090705Z">
        <seg>鉴于介绍中的溢出示例，我们可以增加 `observeOn` 的缓冲区大小，以便为所有值提供足够的空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go on with your business; whenever the call returns, the observer’s method will begin to operate on its return value or values — the &lt;i0&gt;items&lt;/i0&gt; emitted by the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055859Z" creationid="pingfangx" creationdate="20190620T055859Z">
        <seg>继续你的业务；每当调用返回时，观察者的方法将开始对其返回值或返回值值 -  Observable 发射的 &lt;i0&gt;items (数据项)&lt;/i0&gt; 进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the `computeValue` is executed only when a subscriber subscribes and for each of them, printing the expected 1 and 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015926Z" creationid="pingfangx" creationdate="20190624T015926Z">
        <seg>这里的 `computeValue` 仅在订阅者订阅时执行，并且每个订阅者都打印预期的 1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the `onStart` implementation indicates `range` to produce its first value, which is then received in `onNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082052Z" creationid="pingfangx" creationdate="20190621T082052Z">
        <seg>这里 `onStart` 实现指示 `range` 产生它的第一个值，然后在 `onNext` 中接收它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, `flatMap` works as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083927Z" creationid="pingfangx" creationdate="20190617T083927Z">
        <seg>这里，`flatMap` 也适用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, if we imagine ourselves on `operator2`, looking to the left towards the source, is called the **upstream**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070815Z" creationid="pingfangx" creationdate="20190617T070815Z">
        <seg>在这里，如果我们想象自己在 `operator2`，向左看向源，则称为 **upstream**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the original `value` will be available inside the inner `flatMap`, courtesy of lambda variable capture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083803Z" creationid="pingfangx" creationdate="20190617T083803Z">
        <seg>在这里，原始的 `value` 将在内部 `flatMap` 中可用，由 lambda 变量捕获提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is this Observable implemented?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040459Z" creationid="pingfangx" creationdate="20190620T040459Z">
        <seg>Observable 是如何实现的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Android is more strict and terminates the application in such uncaught exception cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090336Z" creationid="pingfangx" creationdate="20190618T090336Z">
        <seg>但是，Android 更严格，并在此类未捕获的异常情况下终止应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, RxJava's reactive types are immutable; each of the method calls returns a new `Flowable` with added behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072714Z" creationid="pingfangx" creationdate="20190617T072714Z">
        <seg>但是，RxJava 的反应类型是不可变的；每个方法调用都返回一个带有添加行为的新的 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, backpressure is present more subtly in regular cold sequences (which don't and shouldn't yield `MissingBackpressureException`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080321Z" creationid="pingfangx" creationdate="20190621T080321Z">
        <seg>然而，背压在常规冷序列中更微妙地存在(它不会也不应该产生 `MissingBackpressureException`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source Observable terminates with an error, the &lt;c0&gt;AsyncSubject&lt;/c0&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084042Z" creationid="pingfangx" creationdate="20190620T084042Z">
        <seg>但是，如果源 Observable 以错误终止，则 &lt;c0&gt;AsyncSubject&lt;/c0&gt; 将不会发射任何项，而只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source Observable terminates with an error, the &lt;c0&gt;BehaviorSubject&lt;/c0&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084214Z" creationid="pingfangx" creationdate="20190620T084214Z">
        <seg>但是，如果源 Observable 以错误终止，则 &lt;c0&gt;BehaviorSubject&lt;/c0&gt; 将不会向后续观察者发射任何项，而只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the following will call since the `take` operator cancels after the set amount of `onNext` events have been delivered:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115236Z" creationid="pingfangx" creationdate="20190618T115236Z">
        <seg>但是，以下内容将调用，因为 `take` 操作符在已经传递了 `onNext` 事件的设定数量后取消：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the lambda `v -&gt; v * v` doesn't run in parallel for this flow; it receives the values 1 to 10 on the same computation thread one after the other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075726Z" creationid="pingfangx" creationdate="20190617T075726Z">
        <seg>但是，lambda `v -&gt; v * v` 不会并行运行；它一个接一个地在同一个计算线程上接收值 1 到 10。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the producing thread with the for loop can't know this and keeps `onNext`ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072156Z" creationid="pingfangx" creationdate="20190621T072156Z">
        <seg>但是，带有 for 循环的生产线程无法知道这一点，并保持调用 `onNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is not true for `onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083151Z" creationid="pingfangx" creationdate="20190621T083151Z">
        <seg>但是，对于 `onStart` 来说，情况并非如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable that does not start emitting items to subscribers until asked</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110131Z" creationid="pingfangx" creationdate="20190620T110131Z">
        <seg>我想要一个 Observable，直到被问到才开始向订阅者发送项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable that will notify observers of an error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110039Z" creationid="pingfangx" creationdate="20190620T110039Z">
        <seg>我想要一个 Observable 来通知观察者一个错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable to invoke a particular action when certain events occur</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110026Z" creationid="pingfangx" creationdate="20190620T110026Z">
        <seg>我希望 Observable 在发生某些事件时调用特定的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an Observable to recover gracefully</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110050Z" creationid="pingfangx" creationdate="20190620T110050Z">
        <seg>我希望 Observable 能够优雅地恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want an operator to operate on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110007Z" creationid="pingfangx" creationdate="20190620T105954Z">
        <seg>我希望操作符在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to collect items from an Observable and reemit them as buffers of items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105208Z" creationid="pingfangx" creationdate="20190620T105208Z">
        <seg>我想从 Observable 收集项目并将它们重新作为项目的缓冲区重新提交</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to convert the entire sequence of items emitted by an Observable into some other data structure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105950Z" creationid="pingfangx" creationdate="20190620T105950Z">
        <seg>我想将 Observable 发射的整个项目序列转换为其他一些数据结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create a new Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104859Z" creationid="pingfangx" creationdate="20190620T104216Z">
        <seg>我想创建一个新 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create a resource that has the same lifespan as the Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110113Z" creationid="pingfangx" creationdate="20190620T110113Z">
        <seg>我想创建一个与 Observable 具有相同生命周期的资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to create an Observable by combining other Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104904Z" creationid="pingfangx" creationdate="20190620T104525Z">
        <seg>我想通过组合其他 Observable 来创建一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to emit the items from an Observable after transforming them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104848Z" creationid="pingfangx" creationdate="20190620T104848Z">
        <seg>我希望在转换后从 Observable 中发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to evaluate the entire sequence of items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105736Z" creationid="pingfangx" creationdate="20190620T105736Z">
        <seg>我想计算 Observable 发射的整个项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105119Z" creationid="pingfangx" creationdate="20190620T105119Z">
        <seg>我想忽略 Observable 发射的所有项目，只传递完成/错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to mirror an Observable but prefix items to its sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105157Z" creationid="pingfangx" creationdate="20190620T105157Z">
        <seg>我想镜像 Observable 仅要它的序列前缀项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105726Z" creationid="pingfangx" creationdate="20190620T105726Z">
        <seg>我想重新发射 Observable 中的项目，条件是它是 Observables 的第一个发射项目的条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to reemit only certain items from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105256Z" creationid="pingfangx" creationdate="20190620T105256Z">
        <seg>我想仅重新提交 Observable 中的某些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to retrieve a particular item emitted by an Observable:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105238Z" creationid="pingfangx" creationdate="20190620T105238Z">
        <seg>我想检索一个 Observable 发射的特定项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to shift the items emitted by an Observable forward in time before reemitting them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105033Z" creationid="pingfangx" creationdate="20190620T105033Z">
        <seg>我希望在重新发送之前向前移动 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to split one Observable into multiple Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105222Z" creationid="pingfangx" creationdate="20190620T105222Z">
        <seg>我想将一个 Observable 拆分成多个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to subscribe to an Observable and receive a &lt;c0&gt;Future&lt;/c0&gt; that blocks until the Observable completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110122Z" creationid="pingfangx" creationdate="20190620T110122Z">
        <seg>我想订阅一个 Observable 并接收一个阻塞的 &lt;c0&gt;Future&lt;/c0&gt;，直到 Observable 完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I want to transform items &lt;e0&gt;and&lt;/e0&gt; notifications from an Observable into items and reemit them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105054Z" creationid="pingfangx" creationdate="20190620T105054Z">
        <seg>我想将来自 Observable 的项目 &lt;e0&gt;和&lt;/e0&gt; 通知转换为项目并重新发送它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifying the source and reason for these exceptions can be tiresome, especially if they originate from a source and get routed to `RxJavaPlugins.onError` somewhere lower the chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091000Z" creationid="pingfangx" creationdate="20190618T091000Z">
        <seg>识别这些异常的来源和原因可能很烦人，特别是如果它们来自一个源并且在链的某个地方被路由到 `RxJavaPlugins.onError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a custom class implementing `Subscriber` was employed before, subscribing it to a `Flowable` adds an internal wrapper that ensures observing the Flowable is 100% compliant with the specification at the cost of some per-item overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085333Z" creationid="pingfangx" creationdate="20190618T085333Z">
        <seg>如果之前使用了实现 `Subscriber` 的自定义类，则将它订阅到 `Flowable` 会添加一个内部包装器，以确保观察 Flowable 100% 符合规范，代价是每个项目的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has to offer a reactive base type, however, the user will receive the full reactive class (as giving out an `XSource` is practically useless as it doesn't have operators on it):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061740Z" creationid="pingfangx" creationdate="20190618T061740Z">
        <seg>但是，如果操作符必须提供响应型基类型，则用户将收到完整的响应类(因为它没有运算符，因此发出 `XSource` 实际上是无用的)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an undeliverable exception is an instance/descendant of `NullPointerException`, `IllegalStateException` (`UndeliverableException` and `ProtocolViolationException` extend this), `IllegalArgumentException`, `CompositeException`, `MissingBackpressureException` or `OnErrorNotImplementedException`, the `UndeliverableException` wrapping doesn't happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091305Z" creationid="pingfangx" creationdate="20190618T091305Z">
        <seg>如果一个无法传递的异常是 `NullPointerException` 的实例/后代，`IllegalStateException`(`UndeliverableException` 和 `ProtocolViolationException` 扩展了它)，`IllegalArgumentException`，`CompositeException`，`MissingBackpressureException` 或 `OnErrorNotImplementedException`，那么 `UndeliverableException` 包装不会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one decides to add a non-empty global error consumer, here is an example that manages the typical undeliverable exceptions based on whether they represent a likely bug or an ignorable application/network state:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092931Z" creationid="pingfangx" creationdate="20190618T092931Z">
        <seg>如果决定添加一个非空的全局错误消费者，这里有一个例子来管理典型的无法传递的异常，具体取决于它们是代表可能的错误还是可忽略的应用程序/网络状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one has initialization logic after the call to `request(1)` which is needed by `onNext`, you may end up with exceptions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083433Z" creationid="pingfangx" creationdate="20190621T083433Z">
        <seg>如果在调用 `request(1)` 之后有 `onNext` 所需的初始化逻辑，则可能会以异常结束：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one has to handle multiple resources, create a `CompositeSubscription`, associate it with the emitter and then add further resources to the `CompositeSubscription` itself:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022827Z" creationid="pingfangx" creationdate="20190624T022827Z">
        <seg>如果必须处理多个资源，创建一个 `CompositeSubscription`，将它与发射器关联，然后将更多资源添加到 `CompositeSubscription` 本身：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one needs those customization, using `NONE` as the backpressure mode and applying the relevant `onBackpressureXXX` on the resulting `Flowable` is the way to go.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022124Z" creationid="pingfangx" creationdate="20190624T022124Z">
        <seg>如果需要那些定制，使用 `NONE` 作为背压模式并在生成的 `Flowable` 上应用相关的 `onBackpressureXXX` 是可行的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one was using `Flowable.subscribe(Subscriber&lt;? super T&gt;)` with the built-in RxJava `Subscriber` implementations such as `DisposableSubscriber`, `TestSubscriber` and `ResourceSubscriber`, there is a small runtime overhead (one `instanceof` check) associated when the code is not recompiled against 2.0.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085238Z" creationid="pingfangx" creationdate="20190618T085238Z">
        <seg>如果使用 `Flowable.subscribe(Subscriber&lt;? super T&gt;)` 和内置的 RxJava `Subscriber` 实现，如 `DisposableSubscriber`，`TestSubscriber` 和 `ResourceSubscriber`，那么在不根据 2.0.7 重新编译代码时，会有一个较小的运行时开销（一个 `instanceof` 检查）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If some of the values can be safely ignored, one can use the sampling (with time or another `Flowable`) and throttling operators (`throttleFirst`, `throttleLast`, `throttleWithTimeout`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091633Z" creationid="pingfangx" creationdate="20190621T091633Z">
        <seg>如果可以安全地忽略某些值，可以使用采样(使用时间或其他 `Flowable`)和限制操作符(`throttleFirst`，`throttleLast`，`throttleWithTimeout`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the `initialRequest` is given, the `TestSubscriber` offers the `requestMore(long)` method to keep requesting in a fluent manner:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101754Z" creationid="pingfangx" creationdate="20190618T101754Z">
        <seg>如果给出 `initialRequest`，那么 `TestSubscriber` 提供 `requestMore(long)` 方法来以流畅的方式继续请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the call is rewritten, it becomes obvious why it works so:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015836Z" creationid="pingfangx" creationdate="20190624T015806Z">
        <seg>如果调用被重写，为什么它会这样的原因就很明显：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code example is left unchanged, this will result in a compile time error (however, often with misleading error message about lack of overload).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092815Z" creationid="pingfangx" creationdate="20190617T092815Z">
        <seg>如果代码示例保持不变，这将导致编译时错误(但是，通常会出现关于缺少重载的误导性错误消息)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the data is already available as an array of objects, a list of objects or any `Iterable` source, the respective `from` overloads will handle the backpressure and emission of such sources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020156Z" creationid="pingfangx" creationdate="20190624T020156Z">
        <seg>如果数据已经作为一个对象数组，一个对象列表或任何 `Iterable` 源提供，则相应的 `from` 重载将处理这些源的背压和发射：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the file doesn't exist or can't be read properly, the end consumer will print out `IOException` directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064328Z" creationid="pingfangx" creationdate="20190618T064328Z">
        <seg>如果文件不存在或无法正确读取，最终消费者将直接打印出 `IOException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first example is rewritten:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080334Z" creationid="pingfangx" creationdate="20190621T080334Z">
        <seg>如果第一个示例被重写为：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the library/code already did this, the undeliverable `InterruptedException`s should stop now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092847Z" creationid="pingfangx" creationdate="20190618T092847Z">
        <seg>如果库/代码已经这样做了，那么无法传递的 `InterruptedException` 应该立即停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the source Observable terminates with an error, the &lt;c0&gt;PublishSubject&lt;/c0&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084906Z" creationid="pingfangx" creationdate="20190620T084906Z">
        <seg>如果源 Observable 以错误终止，则 &lt;c0&gt;PublishSubject&lt;/c0&gt; 将不会向后续观察者发射任何项，但只会传递来自源 Observable 的错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this behavior is desirable can be debated, but in any case, if you want to avoid such calls to the uncaught exception handler, the **final application** that uses RxJava 2 (directly or transitively) should set a no-op handler:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090732Z" creationid="pingfangx" creationdate="20190618T090647Z">
        <seg>如果这种行为值得商榷，但无论如何，如果您想避免对未捕获的异常处理程序的这种调用，使用 RxJava 2(直接或传递)的 **最终应用程序** 应该设置一个无操作处理程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this pattern was not employed before, we encourage updating the code/library in question.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092855Z" creationid="pingfangx" creationdate="20190618T092855Z">
        <seg>如果之前没有使用此模式，我们鼓励更新相关代码/库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we'd consume the `iterator` via classic for-loop, that would result in an infinite loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020542Z" creationid="pingfangx" creationdate="20190624T020542Z">
        <seg>如果我们通过经典的 for 循环使用 `iterator`，那将导致无限循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a &lt;c0&gt;Subject&lt;/c0&gt; and you want to pass it along to some other agent without exposing its &lt;c1&gt;Subscriber&lt;/c1&gt; interface, you can mask it by calling its &lt;c2&gt;asObservable&lt;/c2&gt; method, which will return the Subject as a pure &lt;c3&gt;Observable&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085411Z" creationid="pingfangx" creationdate="20190620T085411Z">
        <seg>如果您有一个 &lt;c0&gt;Subject&lt;/c0&gt; 并且想要将其传递给其他代理而不暴露其 &lt;c1&gt;Subscriber&lt;/c1&gt; 接口，则可以通过调用其 &lt;c2&gt;asObservable&lt;/c2&gt; 方法来掩盖它，它将 Subject 作为纯 &lt;c3&gt;Observable&lt;/c3&gt; 返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with &lt;a1&gt;&lt;c2&gt;Create&lt;/c2&gt;&lt;/a1&gt; so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a &lt;c3&gt;ReplaySubject&lt;/c3&gt; instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084854Z" creationid="pingfangx" creationdate="20190620T084854Z">
        <seg>如果您需要保证从 Observable 源传递所有项目，您需要使用 &lt;a1&gt;&lt;c2&gt;Create&lt;/c2&gt;&lt;/a1&gt; 形成 Observable，以便您可以手动重新引入“冷” Observable 行为(在开始发射项目之前检查所有观察者是否已订阅)，或转而使用 &lt;c3&gt;ReplaySubject&lt;/c3&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to perform cleanup on both regular termination or cancellation, consider the operator `using` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115251Z" creationid="pingfangx" creationdate="20190618T115251Z">
        <seg>如果您需要在常规终止或取消时执行清理，请考虑使用操作符 `using`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a &lt;c0&gt;ReplaySubject&lt;/c0&gt; as an observer, take care not to call its &lt;c1&gt;onNext&lt;/c1&gt; method (or its other &lt;c2&gt;on&lt;/c2&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a3&gt;the Observable contract&lt;/a3&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085148Z" creationid="pingfangx" creationdate="20190620T085148Z">
        <seg>如果您使用 &lt;c0&gt;ReplaySubject&lt;/c0&gt; 作为观察者，请注意不要从多个线程调用其 &lt;c1&gt;onNext&lt;/c1&gt; 方法(或其他 &lt;c2&gt;on&lt;/c2&gt; 方法)，这可能导致重合(非顺序)调用，这违反了 &lt;a3&gt;Observable 协议&lt;/a3&gt;，并在结果主题中产生了关于应首先重播哪个项目或通知的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to implement your own operator, see &lt;a1&gt;Implementing Your Own Operators&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094342Z" creationid="pingfangx" creationdate="20190620T094342Z">
        <seg>如果要实现自己的操作符，请参阅 &lt;a1&gt;Implementing Your Own Operators&lt;/a1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular &lt;d0&gt;Schedulers&lt;/d0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085651Z" creationid="pingfangx" creationdate="20190620T085651Z">
        <seg>如果要将多线程引入到 Observable 操作符链中，可以通过指示这些操作符(或特定的 Observable)在特定的 &lt;d0&gt;Schedulers (调度器)&lt;/d0&gt; 操作来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard, shading, etc).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105307Z" creationid="pingfangx" creationdate="20190617T105307Z">
        <seg>如果您的代码本身就是一个库(即它在您自己控制之外的用户的 CLASSPATH 上使用)，则不应使用 beta API，除非您重新打包它们(例如使用 ProGuard，shading 等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your platform doesn't support Java 8 lambdas (yet), you have to create an inner class of `Consumer` manually:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065916Z" creationid="pingfangx" creationdate="20190617T065916Z">
        <seg>如果您的平台(还)不支持 Java 8 lambdas，您必须手动创建一个内部类`Consumer`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore all but the terminal events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061209Z" creationid="pingfangx" creationdate="20190619T061209Z">
        <seg>忽略除终端事件之外的所有事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations of `request()` in operators ensure proper happens-before relation  (or in other terms, memory release or full fence) when necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T084142Z" creationid="pingfangx" creationdate="20190621T084142Z">
        <seg>操作符中 `request()` 的实现确保在必要时有正确的 happens-before 关系(或在其他术语中，内存释放或完全隔离)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.x, the `doOnUnsubscribe` was always executed on a terminal event because 1.x' `SafeSubscriber` called `unsubscribe` on itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114822Z" creationid="pingfangx" creationdate="20190618T114822Z">
        <seg>在 1.x 中，`doOnUnsubscribe` 总是在终端事件上执行，因为 1.x 的 `SafeSubscriber` 本身调用 `unsubscribe`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 1.x, you could create an instance with `GroupedObservable.from()` which was used internally by 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063829Z" creationid="pingfangx" creationdate="20190618T063829Z">
        <seg>在 1.x 中，您可以使用 `GroupedObservable.from()` 创建一个实例，该实例由 1.x 内部使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2.0.7, the operator `strict()` returns `this`, is deprecated and will be removed completely in 2.1.0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073837Z" creationid="pingfangx" creationdate="20190618T073837Z">
        <seg>在 2.0.7 中，运算符 `strict()` 返回 `this`，不推荐使用，将在 2.1.0 中完全删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In 2.x, all use cases now extend `GroupedObservable` directly thus the factory methods are no longer available; the whole class is now abstract.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063859Z" creationid="pingfangx" creationdate="20190618T063859Z">
        <seg>在 2.x 中，所有用例现在都直接继承了 `GroupedObservable`，因此工厂方法不再可用；整个类现在都是抽象的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ReactiveX an &lt;d0&gt;observer&lt;/d0&gt; &lt;d1&gt;subscribes&lt;/d1&gt; to an &lt;d2&gt;Observable&lt;/d2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043135Z" creationid="pingfangx" creationdate="20190620T042910Z">
        <seg>在 ReactiveX 中，一个&lt;d0&gt;observer (观察者)&lt;/d0&gt; &lt;d1&gt;subscribes (订阅)&lt;/d1&gt; 一个 &lt;d2&gt;Observable (可观察对象)&lt;/d2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ReactiveX, however, they name the event handlers themselves.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064811Z" creationid="pingfangx" creationdate="20190620T064811Z">
        <seg>但是，在 ReactiveX 中，它们是事件处理程序的名字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava 1.x, the interface `rx.Subscription` was responsible for stream and resource lifecycle management, namely unsubscribing a sequence and releasing general resources such as scheduled tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072636Z" creationid="pingfangx" creationdate="20190618T072636Z">
        <seg>在 RxJava 1.x 中，接口 `rx.Subscription` 负责流和资源生命周期管理，即取消订阅序列并释放一般资源(如计划任务)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava the default `Scheduler`s run on daemon threads, which means once the Java main thread exits, they all get stopped and background computations may never happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073938Z" creationid="pingfangx" creationdate="20190617T073938Z">
        <seg>在 RxJava 中，默认的 `Scheduler` 在守护线程上运行，这意味着一旦 Java 主线程退出，它们都会被停止并且后台计算可能永远不会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava's documentation, **emission**, **emits**, **item**, **event**, **signal**, **data** and **message** are considered synonyms and represent the object traveling along the dataflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071117Z" creationid="pingfangx" creationdate="20190617T071117Z">
        <seg>在 RxJava 的文档中，**emission**, **emits**, **item**, **event**, **signal**, **data** and **message** 被视为同义词并代表沿数据流传播的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In RxJava, the dedicated `Flowable` class is designated to support backpressure and `Observable` is dedicated for the non-backpressured operations (short sequences, GUI interactions, etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071432Z" creationid="pingfangx" creationdate="20190617T071432Z">
        <seg>在 RxJava 中，专用的“Flowable”类被指定为支持背压，而“Observable”专用于非背压操作(短序列，GUI 交互等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In `range`'s terms, it will remember that there was a `request(1)` call while it called `onNext()` and once `onNext()` returns, it will make another round and call `onNext()` with the next integer value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T032615Z" creationid="pingfangx" creationdate="20190621T082709Z">
        <seg>在 `range` 的术语中，它会记住在调用 `onNext()` 时有一个 `request(1)` 调用，一旦 `onNext()` 返回，它将进行另一轮，调用指定整数次数的 `onNext()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a naive implementation of `range`, such call would recursively call `onNext`, leading to `StackOverflowError` which is of course undesirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082214Z" creationid="pingfangx" creationdate="20190621T082214Z">
        <seg>在 `range` 的简单实现中，这样的调用将递归调用 `onNext`，导致 `StackOverflowError`，这当然是不可取的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, `org.reactivestreams.Subscriber` has no notion of adding resources to it, cancelling it or requesting from the outside.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065745Z" creationid="pingfangx" creationdate="20190618T065745Z">
        <seg>此外，`org.reactivestreams.Subscriber` 没有向其添加资源，取消或从外部请求的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, if the wrapped API supports cancellation (such as the listener removal in the example), one can use the `setCancellation` (or `setSubscription` for `Subscription`-like resources) to register a cancellation callback that gets invoked when the downstream unsubscribes or the `onError`/`onComplete` is called on the provided `Emitter`instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022718Z" creationid="pingfangx" creationdate="20190624T022718Z">
        <seg>此外，如果包装的 API 支持取消(例如示例中的侦听器删除)，则可以使用 `setCancellation`(或 `setSubscription` 用于类似 Subscription` 的资源)，来注册在下游取消订阅或在提供的 `Emitter` 实例上调用 `onError`/`onComplete` 时调用的取消回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, operators requiring a predicate no longer use `Func1&lt;T, Boolean&gt;` but have a separate, primitive-returning type of `Predicate&lt;T&gt;` (allows better inlining due to no autoboxing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065124Z" creationid="pingfangx" creationdate="20190618T065124Z">
        <seg>另外，需要谓词的运算符不再使用 `Func1&lt;T, Boolean&gt;`，但是有一个单独的，原始返回类型的 `Predicate&lt;T&gt;`(由于没有自动装箱，允许更好的内联)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, some 3rd party libraries/code throw when they get interrupted by a cancel/dispose call which leads to an undeliverable exception most of the time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091422Z" creationid="pingfangx" creationdate="20190618T091345Z">
        <seg>此外，一些第三方库/代码在被取消/dispose 调用中断时抛出，这导致大多数时间无法传递的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, there is option to wrap an existing `Executor` (and its subtypes such as `ExecutorService`) into a `Scheduler` via `Schedulers.from(Executor)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073659Z" creationid="pingfangx" creationdate="20190617T073659Z">
        <seg>此外，还可以选择通过 `Schedulers.from(Executor)` 将现有的 `Executor`(及其子类型，如 `ExecutorService`) 包装到 `Scheduler` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, they won't signal `BufferOverflowException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014658Z" creationid="pingfangx" creationdate="20190624T014658Z">
        <seg>另外，它们不会发出 `BufferOverflowException` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an ordinary method call — that is, &lt;e0&gt;not&lt;/e0&gt; the sort of asynchronous, parallel calls typical in ReactiveX — the flow is something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T052930Z" creationid="pingfangx" creationdate="20190620T052930Z">
        <seg>在一个普通的方法调用中 - 也就是说，&lt;e0&gt;非&lt;/e0&gt; ReactiveX 中典型的异步并行调用 - 流程是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the computation itself should be delayed until the downstream actually requests, we can use `just` with `map`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020054Z" creationid="pingfangx" creationdate="20190624T020040Z">
        <seg>如果计算本身应该延迟到下游实际请求时，我们可以使用 `just` 和 `map`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case the source data can be processed more efficiently in batch, one can reduce the likelihood of `MissingBackpressureException` by using one of the standard batching operators (by size and/or by time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091349Z" creationid="pingfangx" creationdate="20190621T091349Z">
        <seg>如果可以批量处理源数据，则可以通过使用标准批处理操作符(按大小和/或按时间)之一减少 `MissingBackpressureException` 的可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, since version 2.1.10, it doesn't</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102558Z" creationid="pingfangx" creationdate="20190617T102558Z">
        <seg>事实上，从版本 2.1.10 开始，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044643Z" creationid="pingfangx" creationdate="20190620T044643Z">
        <seg>在许多软件编程任务中，您或多或少地期望您编写的指令将按照您编写的顺序逐个执行并逐步完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In modern RxJava, most asynchronous operators now have a bounded internal buffer, like `observeOn` above and any attempt to overflow this buffer will terminate the whole sequence with `MissingBackpressureException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T075250Z" creationid="pingfangx" creationdate="20190621T075250Z">
        <seg>在现代的 RxJava 中，大多数异步操作符现在都有一个有界的内部缓冲区，如上面的 `observeOn`，任何溢出此缓冲区的尝试都将带 `MissingBackpressureException` 终止整个序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to help lift these extra overheads, a new method `Flowable.subscribe(FlowableSubscriber&lt;? super T&gt;)` has been added which exposes the original behavior from before 2.0.7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085441Z" creationid="pingfangx" creationdate="20190618T085441Z">
        <seg>为了帮助解除这些额外的开销，添加了一个新的方法 `Flowable.subscribe(FlowableSubscriber&lt;? super T&gt;)`，它暴露了 2.0.7 之前的原始行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other documents and other contexts, what we are calling an “observer” is sometimes called a “subscriber,” “watcher,” or “reactor.” This model in general is often referred to as the &lt;a0&gt;“reactor pattern”&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T050044Z" creationid="pingfangx" creationdate="20190620T050044Z">
        <seg>在其他文件和其他场景下，我们所谓的“观察者 (observer)”有时被称为“订阅者 (subscriber)”，“观察者 (watcher)”或“反应者 (reactor)”。这种模型通常被称为 &lt;a0&gt;“反应者模式 (reactor pattern)”&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other scenarios, the result(s) of the first source/dataflow is irrelevant and one would like to continue with a quasi independent another source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083915Z" creationid="pingfangx" creationdate="20190617T083915Z">
        <seg>在其他场景中，第一个源/数据流的结果是无关紧要的，并且人们希望继续使用准独立的另一个源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In return, the `observeOn` calls `Subscription.request(n)` with a value to tell the `range` it is allowed to produce (i.e., `onNext` it) that many **additional** elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081412Z" creationid="pingfangx" creationdate="20190621T081412Z">
        <seg>作为回应，`observeOn` 调用 `Subscription.request(n)`，其值为告诉 `range`，它允许生产(即 `onNext`)多少个**额外的**元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some ReactiveX implementations, there is a specialized observer interface, &lt;c0&gt;Subscriber&lt;/c0&gt;, that implements an &lt;c1&gt;unsubscribe&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061644Z" creationid="pingfangx" creationdate="20190620T061644Z">
        <seg>在一些 ReactiveX 实现中，有一个特殊的观察者​器接口 &lt;c0&gt;Subscriber&lt;/c0&gt;，它实现了 &lt;c1&gt;unsubscribe&lt;/c1&gt; 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some contexts such names would indicate methods by means of which event handlers are &lt;e5&gt;registered&lt;/e5&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064833Z" creationid="pingfangx" creationdate="20190620T064740Z">
        <seg>在某些场景中下，此类名称将指示通过哪个事件处理程序 &lt;e5&gt;registered (注册)&lt;/e5&gt; 的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some implementations of ReactiveX, there is also something called a “Connectable” Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070030Z" creationid="pingfangx" creationdate="20190620T070030Z">
        <seg>在 ReactiveX 的一些实现中，还存在称为“Connectable” 的 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such situations, there are usually two options to fix the transformation: 1) convert to the desired type or 2) find and use an overload of the specific operator supporting the different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092841Z" creationid="pingfangx" creationdate="20190617T092841Z">
        <seg>在这种情况下，通常有两个选项来修复转换：1)转换为所需类型或 2)查找并使用支持不同类型的特定运算符的重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Reactive-Streams specification, the `Subject`-like behavior, namely being a consumer and supplier of events at the same time, is done by the `org.reactivestreams.Processor` interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061946Z" creationid="pingfangx" creationdate="20190618T061946Z">
        <seg>在 Reactive-Streams 规范中，类似 `Subject` 的行为，即同时成为事件的消费者和供应者，由 `org.reactivestreams.Processor` 接口完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the asynchronous model the flow goes more like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053052Z" creationid="pingfangx" creationdate="20190620T053052Z">
        <seg>在异步模型中，流程更像是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the classical Rx.NET and early RxJava, these buffers were unbounded, meaning that they would likely hold nearly all 1 million elements from the example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072300Z" creationid="pingfangx" creationdate="20190621T072300Z">
        <seg>在经典的 Rx.NET 和早期的 RxJava 中，这些缓冲区是无界的，这意味着在该示例中，它们可能会持有几乎所有的 100 万个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example we call `onComplete()` if the read byte is negative, indicating and end of file, and call `onError` in case the read throws an `IOException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021304Z" creationid="pingfangx" creationdate="20190624T021304Z">
        <seg>在示例中，如果读取字节为负数，指示和文件结束，则调用 `onComplete()`，并在读取抛出 `IOException` 时调用 `onError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the original Rx.NET, the operator that emits a single item and then completes is called `Return(T)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101615Z" creationid="pingfangx" creationdate="20190617T101615Z">
        <seg>在原始的 Rx.NET 中，发出单个项然后完成的运算符称为 `Return(T)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, one can use one of the following operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091117Z" creationid="pingfangx" creationdate="20190621T091117Z">
        <seg>在这种情况下，可以使用以下操作符之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the delegation works the same way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022948Z" creationid="pingfangx" creationdate="20190624T022948Z">
        <seg>在这种情况下，委托以相同的方式工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the `observeOn` goes with a very low buffer size yet there is no `MissingBackpressureException` as `onBackpressureBuffer` soaks up all the 1 million values and hands over small batches of it to `observeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092532Z" creationid="pingfangx" creationdate="20190621T092532Z">
        <seg>在这个例子中，`observeOn` 的缓冲区大小非常低，但是不会产生 `MissingBackpressureException`，因为 `onBackpressureBuffer` 吸收了所有 100 万个值并将其小批量交给 `observeOn`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the main thread will produce 1 million items to an end consumer which is processing it on a background thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072031Z" creationid="pingfangx" creationdate="20190621T072031Z">
        <seg>在此示例中，主线程将向最终消费者生产 100 万个项目，该消费者在后台线程上处理项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this setup, the `current` starts out with `0` and next time the lambda is invoked, the parameter `current` now holds `1`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021541Z" creationid="pingfangx" creationdate="20190624T021541Z">
        <seg>在这个设置中，`current` 以 `0` 开始，下次调用 lambda 时，参数 `current` 现在保持 `1`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this synchronous case, a `NullPointerException` will be thrown immediately while still executing `onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083450Z" creationid="pingfangx" creationdate="20190621T083450Z">
        <seg>在这种同步的情况下，在执行 `onStart` 时会立即抛出 `NullPointerException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we defined our own functional interfaces in 1.x and 2.x follows this tradition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064103Z" creationid="pingfangx" creationdate="20190618T064103Z">
        <seg>相反，我们在 1.x 和 2.x 中定义了我们自己的函数接口遵循这一传统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal changes in 2.0.6 now consistently cancel or dispose a `Subscription`/`Disposable` before cancelling/disposing a task or worker (which causes the interrupt on the target thread).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T092743Z" creationid="pingfangx" creationdate="20190618T092743Z">
        <seg>2.0.6 中的内部更改现在在取消/释放任务或工作程序(导致目标线程上的中断)之前始终取消或释放 `Subscription`/“Disposable”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, asynchronous operators have buffers to hold such elements until they can be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072208Z" creationid="pingfangx" creationdate="20190621T072208Z">
        <seg>在内部，异步操作符具有缓冲区来保存这些元素，直到它们可以被处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T071846Z" creationid="pingfangx" creationdate="20190828T071846Z">
        <seg>介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can change at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105413Z" creationid="pingfangx" creationdate="20190617T105413Z">
        <seg>它可以随时改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It depends on the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064956Z" creationid="pingfangx" creationdate="20190620T064956Z">
        <seg>这取决于 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends &lt;a0&gt;the observer pattern&lt;/a0&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033455Z" creationid="pingfangx" creationdate="20190620T033244Z">
        <seg>它扩展了 &lt;a0&gt;观察者模式&lt;/a0&gt; 以支持数据和/或事件序列，并添加操作符，允许您以声明方式组合序列，而无需关注底层的线程，同步，线程安全，并发数据结构和非阻塞 I/O 等问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It extends the [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern) to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064839Z" creationid="pingfangx" creationdate="20190617T064839Z">
        <seg>它扩展了 [观察者模式](http://en.wikipedia.org/wiki/Observer_pattern) 以支持数据/事件序列，并添加运算符，允许您以声明方式组合序列，同时抽象出对低级别线程，同步，线程安全和并发数据结构等的关注。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034456Z" creationid="pingfangx" creationdate="20190620T034456Z">
        <seg>它使您摆脱了纠结的回调网络，从而使您的代码更具可读性，且不易出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the usual modes, similar to `onBackpressureXXX` in addition to signalling a `MissingBackpressureException` or simply ignoring such overflow inside it altogether.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022056Z" creationid="pingfangx" creationdate="20190624T022056Z">
        <seg>它具有通常的模式，类似于 `onBackpressureXXX`，除了发出 `MissingBackpressureException` 信号或完全忽略它内部的溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is &lt;a0&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a0&gt; (or impossible, since latencies of each request vary at runtime).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035228Z" creationid="pingfangx" creationdate="20190620T035228Z">
        <seg>&lt;a0&gt;使用 Futures 难以很好地组合带条件的异步执行流程&lt;/a0&gt;(或者可以说不可能，因为每个请求的延迟在运行时变化)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is automatically applied by `RxJavaPlugins.onError` with intact stacktrace that may help find which exact operator rerouted the original error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091225Z" creationid="pingfangx" creationdate="20190618T091225Z">
        <seg>它由 `RxJavaPlugins.onError` 自动应用，带有完整的堆栈跟踪，可以帮助找到哪个确切的运算符重新路由了原始错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is implemented as a single JAR that is focused on just the Observable abstraction and related higher-order functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113521Z" creationid="pingfangx" creationdate="20190617T113521Z">
        <seg>它作为单个 JAR 实现，仅关注 Observable 抽象和相关的高阶函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is likely the `compute(int)` method takes some time but the overhead of the `Flowable` operator chain may also add to the time it takes to process items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072107Z" creationid="pingfangx" creationdate="20190621T072107Z">
        <seg>`compute(int)` 方法可能需要一些时间，但 `Flowable` 操作链的开销也可能增加处理项目所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not advised intermediate libraries change the error handler outside their own testing environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090838Z" creationid="pingfangx" creationdate="20190618T090838Z">
        <seg>不建议中间库在自己的测试环境之外更改错误处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often the case also that later sequences would require values from earlier mappings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083734Z" creationid="pingfangx" creationdate="20190617T083734Z">
        <seg>通常情况也是后来的序列需要来自早期映射的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended that new custom consumer implementations extend `FlowableSubscriber` instead of just `Subscriber`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085457Z" creationid="pingfangx" creationdate="20190618T085457Z">
        <seg>建议新的自定义消费者实现继承 `FlowableSubscriber` 而不仅仅是 `Subscriber`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes called “functional reactive programming” but this is a misnomer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033739Z" creationid="pingfangx" creationdate="20190620T033739Z">
        <seg>它有时被称为“函数响应式编程”，但这是用词不当。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the main type to interact with other reactive libraries through a standardized mechanism governed by the [Reactive Streams specification](https://github.com/reactive-streams/reactive-streams-jvm#specification).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104412Z" creationid="pingfangx" creationdate="20190617T104412Z">
        <seg>它是通过由 [Reactive Streams 规范 ](https://github.com/reactive-streams/reactive-streams-jvm#specification) 管理的标准化机制与其他响应库交互的主要类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then the `observeOn`'s responsibility to call the `request` method in the right time and with the right value to keep the data flowing but not overflowing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081443Z" creationid="pingfangx" creationdate="20190621T081443Z">
        <seg>然后，`observeOn` 有责任在正确的时间调用 `request` 方法并使用正确的值来保持数据流动但不会溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may be useful in conjunction with the source operator `interval()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014834Z" creationid="pingfangx" creationdate="20190624T014834Z">
        <seg>它可能与源操作符 `interval()` 结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes two parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021722Z" creationid="pingfangx" creationdate="20190624T021722Z">
        <seg>它需要两个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was already designed along the Reactive-Streams style for 1.x so no user-level changes there.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060028Z" creationid="pingfangx" creationdate="20190618T060028Z">
        <seg>它已经按照 Reactive-Streams 样式设计了 1.x，因此没有用户级别的更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It was frequently misused and didn't implement the `Scheduler` specification correctly anyway; it contained blocking sleep for delayed action and didn't support recursive scheduling at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093611Z" creationid="pingfangx" creationdate="20190618T093611Z">
        <seg>它经常被滥用，并且无论如何都没有正确实现 `Scheduler` 规范；它包含阻塞睡眠以延迟操作，并且根本不支持递归调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will also emit this same final value to any subsequent observers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083957Z" creationid="pingfangx" creationdate="20190620T083957Z">
        <seg>它还将向任何后续观察者发射相同的最终值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not make further calls to &lt;c0&gt;onNext&lt;/c0&gt; or &lt;c1&gt;onCompleted&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060309Z" creationid="pingfangx" creationdate="20190620T060309Z">
        <seg>它不会进一步调用 &lt;c0&gt;onNext&lt;/c0&gt; 或 &lt;c1&gt;onCompleted&lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its architecture now derives from the Reactive-Streams design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055625Z" creationid="pingfangx" creationdate="20190618T055625Z">
        <seg>它的架构现在来自 Reactive-Streams 设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its consumer type (`rx.Single.SingleSubscriber&lt;T&gt;`) has been changed from being a class that accepts `rx.Subscription` resources to be an interface `io.reactivex.SingleObserver&lt;T&gt;` that has only 3 methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055825Z" creationid="pingfangx" creationdate="20190618T055825Z">
        <seg>它的消费者类型(`rx.Single.SingleSubscriber&lt;T&gt;`)变化了，从接受 `rx.Subscription` 资源的类，变为只有 3 个方法的接口 `io.reactivex.SingleObserver&lt;T&gt;`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its functionality can be achieved via `TestScheduler`, `PublishProcessor`/`PublishSubject` and `observeOn(testScheduler)`/scheduler parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063603Z" creationid="pingfangx" creationdate="20190618T063603Z">
        <seg>它的功能可以通过 `TestScheduler`，`PublishProcessor`/`PublishSubject` 和 `observeOn(testScheduler)`/scheduler 参数来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its usefulness is rather limited as there is no other information provided about the overflow than the current call stack.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093512Z" creationid="pingfangx" creationdate="20190621T093512Z">
        <seg>它的实用性相当有限，因为除了当前调用堆栈之外，没有其他关于溢出的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java doesn't consider signatures such as `operator(Function&lt;T, Single&lt;R&gt;&gt;)` and `operator(Function&lt;T, Maybe&lt;R&gt;&gt;)` different (unlike C#) and due to erasure, the two `operator`s would end up as duplicate methods with the same signature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100903Z" creationid="pingfangx" creationdate="20190617T100903Z">
        <seg>由于擦除，Java 不认为 `operator(Function &lt;T，Single &lt;R &gt;&gt;)` 和 `operator(Function &lt;T，Maybe &lt;R &gt;&gt;)` 的签名是不同的(与 C# 不同)，这两个 ` operator` 最终会成为具有相同签名的重复方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language-Specific Information:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090906Z" creationid="pingfangx" creationdate="20190620T090906Z">
        <seg>语言特定信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn more about RxJava in general on the &lt;a href="https://github.com/ReactiveX/RxJava/wiki"&gt;Wiki Home&lt;/a&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065616Z" creationid="pingfangx" creationdate="20190617T065616Z">
        <seg>有关 RxJava 的更多信息可参阅 &lt;a href="https://github.com/ReactiveX/RxJava/wiki"&gt;Wiki Home&lt;/a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like Observables, Singles can be manipulated by means of a variety of operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073856Z" creationid="pingfangx" creationdate="20190620T073856Z">
        <seg>像 Observables 一样，Singles 可以通过各种操作符进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking to the right towards the subscriber/consumer, is called the **downstream**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070953Z" creationid="pingfangx" creationdate="20190617T070908Z">
        <seg>向右侧的订阅者/消费者看，称为 **downstream**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many frequently used operator has overloads that can deal with the other types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100658Z" creationid="pingfangx" creationdate="20190617T100658Z">
        <seg>许多经常使用的运算符具有可以处理其他类型的重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators that expect the user to provide some function returning a reactive type can't be overloaded because the type erasure around a `Function&lt;T, X&gt;` turns such method signatures into duplicates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102139Z" creationid="pingfangx" creationdate="20190617T102139Z">
        <seg>许多期望用户提供返回反应类型的函数的运算符不能被重载，因为围绕 `Function&lt;T, X&gt;` 的类型擦除将这样的方法签名变成重复的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many value generation can be expressed in a form of a state-machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020256Z" creationid="pingfangx" creationdate="20190624T020256Z">
        <seg>许多值生成可以以状态机的形式表达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mathematical and Aggregate Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072016Z" creationid="pingfangx" creationdate="20190620T072016Z">
        <seg>数学和集合操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minor 2.x increments (such as 2.1, 2.2, etc) will occur when non-trivial new functionality is added or significant enhancements or bug fixes occur that may have behavioral changes that may affect some edge cases (such as dependence on behavior resulting from a bug).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104949Z" creationid="pingfangx" creationdate="20190617T104949Z">
        <seg>当添加非平凡的新功能或重大增强或发生可能影响某些边缘情况的行为变化（例如，对错误导致的行为的依赖）的错误修复时，将发生次要 2.x 升级（例如 2.1,2.2 等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most asynchronous operator use this as their default `Scheduler`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073243Z" creationid="pingfangx" creationdate="20190617T073243Z">
        <seg>大多数异步操作符使用它作为它们的默认 `Scheduler`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most backpressure-sensitive operators in the recent versions of RxJava now allow programmers to specify the size of their internal buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090433Z" creationid="pingfangx" creationdate="20190621T090433Z">
        <seg>最近版本的 RxJava 中的大多数背压敏感操作符现在允许程序员指定其内部缓冲区的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most developers encounter backpressure when their application fails with `MissingBackpressureException` and the exception usually points to the `observeOn` operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T085845Z" creationid="pingfangx" creationdate="20190621T085845Z">
        <seg>大多数开发人员在应用程序因 `MissingBackpressureException` 而失败时都会遇到背压，而该异常通常指向 `observeOn` 操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators are still there in 2.x and practically all of them have the same behavior as they had in 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T110949Z" creationid="pingfangx" creationdate="20190618T110949Z">
        <seg>大多数操作符仍然在 2.x 中，并且几乎所有操作符都具有与 1.x 中相同的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators operate on an Observable and return an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072320Z" creationid="pingfangx" creationdate="20190620T072320Z">
        <seg>大多数操作符都在 Observable 上操作并返回一个 Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming in programming is one of the hardest things as names are expected to be not long, expressive, capturing and easily memorable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101332Z" creationid="pingfangx" creationdate="20190617T101332Z">
        <seg>编程中的命名是最困难的事情之一，因为名称不宜太长，表达清楚，容易捕捉且容易记忆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, `fromCallable` also properly supports backpressure and won't emit the computed value unless requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020008Z" creationid="pingfangx" creationdate="20190624T020008Z">
        <seg>当然，`fromCallable` 也能正确支持背压，除非有要求，否则不会发射计算值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New functionality marked with an [`@Beta`][beta source link] or [`@Experimental`][experimental source link] annotation can also be added in patch releases to allow rapid exploration and iteration of unstable new functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105214Z" creationid="pingfangx" creationdate="20190617T105214Z">
        <seg>标记有 [`@Beta`][beta source link] 或 [`@Experimental`][experimental source link] 注释的新功能也可以添加到补丁版本中，以便快速探索和迭代不稳定的新功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061022Z" creationid="pingfangx" creationdate="20190619T061022Z">
        <seg>新返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next is a “decision tree” that may help you choose the operator that is most appropriate to your use case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094107Z" creationid="pingfangx" creationdate="20190620T094107Z">
        <seg>接下来是一个“决策树”，可以帮助您选择最适合您的用例的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further development, support, maintenance, PRs and updates will happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065638Z" creationid="pingfangx" creationdate="20190617T065638Z">
        <seg>不会进一步开发，支持，维护，PR 和更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No longer wraps all consumer types (i.e., `Observer`) with a safety wrapper, (just like the 1.x `unsafeSubscribe` no longer available).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053805Z" creationid="pingfangx" creationdate="20190619T053805Z">
        <seg>不再用安全包装器包装所有消费者类型(即 `Observer`)(就像 1.x 中的 `unsafeSubscribe` 不再可用)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a “PublishSubject” here is known simply as a “Subject”):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083851Z" creationid="pingfangx" creationdate="20190620T083851Z">
        <seg>并非所有这些种类都在所有实现中可用，并且一些实现使用其他命名约定(例如，在 RxScala 中，在这里简称为“Subject”的被称为的“PublishSubject”)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that due to Reactive-Streams compatibility, the method `onCompleted` has been renamed to `onComplete` without the trailing `d`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070522Z" creationid="pingfangx" creationdate="20190618T070522Z">
        <seg>另请注意，由于 Reactive-Streams 兼容性，方法 `onCompleted` 已重命名为 `onComplete` 而没有尾随的 `d`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also the `Files.readLines(name)` invoked without try-catch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064342Z" creationid="pingfangx" creationdate="20190618T064342Z">
        <seg>另请注意，在没有 try-catch 的情况下调用 `Files.readLines(name)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note hovewer that these operators only reduce the rate of value reception by the downstream and thus they may still lead to `MissingBackpressureException`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091703Z" creationid="pingfangx" creationdate="20190621T091703Z">
        <seg>但请注意，这些操作符仅降低了下游的值接收速率，因此它们仍可能导致 `MissingBackpressureException`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that `onBackpressureBuffer` consumes its source in an unbounded manner, that is, without applying any backpressure to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092853Z" creationid="pingfangx" creationdate="20190621T092853Z">
        <seg>但请注意，`onBackpressureBuffer` 以无限制的方式消耗其来源，即不对其施加任何背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that generally, this may be only a temporary fix as the overflow can still happen if the source overproduces the predicted buffer size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T091109Z" creationid="pingfangx" creationdate="20190621T091109Z">
        <seg>但请注意，通常情况下，这可能只是一个临时修复，因为如果源过量生产超出预测的缓冲区大小，仍可能发生溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that the computation does happen anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020014Z" creationid="pingfangx" creationdate="20190624T020014Z">
        <seg>但请注意，无论如何计算确实会发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a &lt;c0&gt;PublishSubject&lt;/c0&gt; may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084738Z" creationid="pingfangx" creationdate="20190620T084738Z">
        <seg>请注意，&lt;c0&gt;PublishSubject&lt;/c0&gt; 可能会在创建后立即开始发射项目(除非您已采取措施防止此情况)，因此在创建 Subject 和观察者订阅它之间的时间段内，可能会丢失一个或多个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that due to how request management works, calling `request(n)` from `Subscriber.onSubscribe` or `ResourceSubscriber.onStart` may trigger calls to `onNext` immediately before the `request()` call itself returns to the `onSubscribe`/`onStart` method of yours:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072258Z" creationid="pingfangx" creationdate="20190618T071233Z">
        <seg>请注意，由于请求管理的工作方式，从 `Subscriber.onSubscribe` 或 `ResourceSubscriber.onStart` 调用 `request(n)` 可能会立即触发对 `onNext` 的调用，该调用在 `request()` 调用本身返回 `onSubscribe`/`onStart` 方法之前：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it currently doesn't support additional parameters to those backpressure modes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022104Z" creationid="pingfangx" creationdate="20190624T022104Z">
        <seg>请注意，它目前不支持那些背压模式的附加参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the last two strategies cause discontinuity in the stream as they drop out elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014649Z" creationid="pingfangx" creationdate="20190624T014649Z">
        <seg>请注意，最后两个策略会导致流不连续，因为它们会删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of the `LATEST` backpressure mode; if we know there will be only a single value, we don't need the `BUFFER` strategy as it allocates a default 128 element long buffer (that grows as necessary) that is never going to be fully utilized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T023107Z" creationid="pingfangx" creationdate="20190624T023107Z">
        <seg>注意使用 `LATEST` 背压模式；如果我们知道只有一个值，我们不需要 `BUFFER` 策略，因为它分配一个永远不会被充分利用的默认 128 元素长缓冲区(必要时增长)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that `flatMap` doesn't guarantee any order and the end result from the inner flows may end up interleaved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083110Z" creationid="pingfangx" creationdate="20190617T083110Z">
        <seg>但请注意，`flatMap` 不保证任何顺序，内部流的最终结果可能会交错出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can directly block for some results by invoking a `blockingX` operation directly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095232Z" creationid="pingfangx" creationdate="20190618T095232Z">
        <seg>现在，您可以通过直接调用 `blockingX` 操作直接阻塞某些结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects of the &lt;c0&gt;Worker&lt;/c0&gt; class implement &lt;a1&gt;the &lt;c2&gt;Subscription&lt;/c2&gt; interface&lt;/a1&gt;, with its &lt;a3&gt;&lt;c4&gt;isUnsubscribed&lt;/c4&gt;&lt;/a3&gt; and &lt;a5&gt;&lt;c6&gt;unsubscribe&lt;/c6&gt;&lt;/a5&gt; methods, so you can stop work when a subscription is cancelled, or you can cancel the subscription from within the scheduled task:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092237Z" creationid="pingfangx" creationdate="20190620T092237Z">
        <seg>&lt;c0&gt;Worker&lt;/c0&gt; 类的对象实现 &lt;a1&gt;&lt;c2&gt;Subscription&lt;/c2&gt; 接口&lt;/a1&gt;，使用他的 &lt;a3&gt;&lt;c4&gt;isUnsubscribed&lt;/c4&gt;&lt;/a3&gt; 和 &lt;a5&gt;&lt;c6&gt;unsubscribe&lt;/c6&gt;&lt;/a5&gt; 方法，因此你可以在取消订阅时停止工作，也可以从计划任务中取消订阅：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observable Utility Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101858Z" creationid="pingfangx" creationdate="20190620T101858Z">
        <seg>Observable 辅助操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Composable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034539Z" creationid="pingfangx" creationdate="20190620T034517Z">
        <seg>Observables 是可组合的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Flexible</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034528Z" creationid="pingfangx" creationdate="20190620T034528Z">
        <seg>Observables 是灵活的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables Are Less Opinionated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034607Z" creationid="pingfangx" creationdate="20190620T034607Z">
        <seg>Observables 是无偏见的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables and observers are only the start of ReactiveX.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071352Z" creationid="pingfangx" creationdate="20190620T070226Z">
        <seg>对于 ReactiveX 来说，Observable 和观察者仅仅是个开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables can be implemented using thread-pools, event loops, non-blocking I/O, actors (such as from Akka), or whatever implementation suits your needs, your style, or your expertise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040404Z" creationid="pingfangx" creationdate="20190620T040312Z">
        <seg>可以用任何方式来实现 Observable，使用线程池，事件循环，非阻塞 I/O，actor(例如来自 Akka)或任何适合您的需求，风格或专业知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observables fill the gap by being the ideal way to access asynchronous sequences of multiple items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033647Z" creationid="pingfangx" creationdate="20190620T033647Z">
        <seg>Observable 通过理想方式访问多个项的异步序列来填补空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, suffixes of various kinds may appear together:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103554Z" creationid="pingfangx" creationdate="20190617T103554Z">
        <seg>当然，各种后缀可能会一起出现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, we can imitate other typical sources, such as an unbounded range with it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021515Z" creationid="pingfangx" creationdate="20190624T021515Z">
        <seg>当然，我们可以模仿其他典型的来源，例如无限范围：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often though there is a way that is somewhat more expressive (and also lower overhead) by using `Completable` as the mediator and its operator `andThen` to resume with something else:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091925Z" creationid="pingfangx" creationdate="20190617T091925Z">
        <seg>通常有一种方式更具表现力(也更低开销)，使用 `Completable` 作为调解器及其运算符 `andThen` 继续使用其他内容：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061019Z" creationid="pingfangx" creationdate="20190619T061019Z">
        <seg>旧返回类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On desktop Java, this latter handler does nothing on an `ExecutorService` backed `Scheduler` and the application can keep running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090323Z" creationid="pingfangx" creationdate="20190618T090323Z">
        <seg>在桌面 Java 上，后一个处理程序对 `ExecutorService` 支持的 `Scheduler` 什么都不做，应用程序可以继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the `compute(int)` finishes, the another value is then requested from `range`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082132Z" creationid="pingfangx" creationdate="20190621T082132Z">
        <seg>一旦 `compute(int)` 完成，就会从 `range` 请求另一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data is ready, you can make sure they get processed on the foreground or GUI thread via `observeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072853Z" creationid="pingfangx" creationdate="20190617T072853Z">
        <seg>数据准备好后，您可以确保通过 `observeOn` 在前台或 GUI 线程上处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can think of it as a 0 capacity `onBackpressureBuffer` with strategy `ON_OVERFLOW_DROP_LATEST`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014750Z" creationid="pingfangx" creationdate="20190624T014750Z">
        <seg>可以将其视为具有策略 `ON_OVERFLOW_DROP_LATEST` 的 0 容量 `onBackpressureBuffer`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can think of this as a variant of the `onBackpressureBuffer` with a capacity of 1 and strategy of `ON_OVERFLOW_DROP_OLDEST`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015135Z" creationid="pingfangx" creationdate="20190624T015135Z">
        <seg>可以将其视为 `onBackpressureBuffer` 的变体，其容量为 1，策略为 `ON_OVERFLOW_DROP_OLDEST`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One could, of course, turn that into an `Iterable` but when such sources are associated with resources, we may leak those resources if the downstream unsubscribes the sequence before it would end.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021000Z" creationid="pingfangx" creationdate="20190624T021000Z">
        <seg>当然，可以将其转换为 `Iterable`，但是当这些源与资源相关联时，如果下游在序列结束之前取消订阅序列，我们可能会泄漏这些资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important design requirement for 2.x is that no `Throwable` errors should be swallowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085938Z" creationid="pingfangx" creationdate="20190618T085938Z">
        <seg>2.x 的一个重要设计要求是不应忽略任何 `Throwable` 的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One main point of difference is that functional reactive programming operates on values that change &lt;e0&gt;continuously&lt;/e0&gt; over time, while ReactiveX operates on &lt;e1&gt;discrete&lt;/e1&gt; values that are emitted over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034024Z" creationid="pingfangx" creationdate="20190620T034024Z">
        <seg>一个主要的不同点是函数性响应式编程对随时间变化的 &lt;e0&gt;continuously (连续)&lt;/e0&gt; 值进行操作，而 ReactiveX 对随时间发射的 &lt;e1&gt;discrete (离散)&lt;/e1&gt; 值进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One notable difference is that all our functional interfaces now define `throws Exception`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064131Z" creationid="pingfangx" creationdate="20190618T064131Z">
        <seg>一个值得注意的区别是我们所有的函数接口现在都定义了 `throws Exception`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the benefits is that changing `Flowable` to `Observable` here the test code part doesn't have to change at all due to the implicit type change of the `TestSubscriber` to `TestObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101614Z" creationid="pingfangx" creationdate="20190618T101614Z">
        <seg>其中一个好处是将 `Flowable` 改为 `Observable`，测试代码部分根本不需要改变，因为 `TestSubscriber` 隐式改为 `TestObserver`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the common use cases for RxJava is to run some computation, network request on a background thread and show the results (or error) on the UI thread:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072246Z" creationid="pingfangx" creationdate="20190617T072246Z">
        <seg>RxJava 的一个常见用例是在后台线程上运行一些计算，网络请求并在 UI 线程上显示结果(或错误)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the design flaws of RxJava 1.x was the exposure of the `rx.Observable.create()` method that while powerful, not the typical operator you want to use to enter the reactive world.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094300Z" creationid="pingfangx" creationdate="20190618T094300Z">
        <seg>RxJava 1.x 的一个设计缺陷是 `rx.Observable.create()` 方法的曝光，虽然功能强大，但不是您想要用来进入响应世界的典型操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One version allows you to set this time out by means of a number of specified time units:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075647Z" creationid="pingfangx" creationdate="20190620T075647Z">
        <seg>一个版本允许您通过许多指定的时间单位设置此时间：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One version of merge takes a Single that emits a second Single and converts it into a Single that emits the item emitted by that second Single:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075522Z" creationid="pingfangx" creationdate="20190620T075522Z">
        <seg>一个合并的版本，需要一个 Single 发射第二个 Single 并将其转换为 Single，它发射第二个 Single 发射的项目：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One would be inclined to write such continuations as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092156Z" creationid="pingfangx" creationdate="20190617T092156Z">
        <seg>人们倾向于写下如下的延续：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators By Category</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094354Z" creationid="pingfangx" creationdate="20190620T094354Z">
        <seg>操作符分类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators marked as `@Beta` or `@Experimental` in 1.x are promoted to standard.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111329Z" creationid="pingfangx" creationdate="20190618T111329Z">
        <seg>在 1.x 中标记为 `@Beta` 或 `@Experimental` 的操作符将升级为标准操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators of the new `Flowable` base reactive type now consider downstream request amounts properly, however, this doesn't mean `MissingBackpressureException` is gone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073550Z" creationid="pingfangx" creationdate="20190618T073550Z">
        <seg>新的 `Flowable` 基本响应类型的运算符现在正确考虑下游请求数量，但是，这并不意味着 `MissingBackpressureException` 消失了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that evaluate one or more Observables or items emitted by Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102521Z" creationid="pingfangx" creationdate="20190620T102521Z">
        <seg>计算一个或多个 Observables 或 Observable 发射的项目的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that help to recover from error notifications from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101819Z" creationid="pingfangx" creationdate="20190620T101819Z">
        <seg>有助于从 Observable 发出的错误通知中恢复的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that operate on the entire sequence of items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102846Z" creationid="pingfangx" creationdate="20190620T102846Z">
        <seg>操作 Observable 发射的整个项目序列的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that originate new Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094459Z" creationid="pingfangx" creationdate="20190620T094459Z">
        <seg>创建新 Observables 的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that selectively emit items from a source Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100037Z" creationid="pingfangx" creationdate="20190620T100037Z">
        <seg>有选择地从源 Observable 中发射项的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that transform items that are emitted by an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095438Z" creationid="pingfangx" creationdate="20190620T095438Z">
        <seg>转换 Observable 发射的数据项的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that work with multiple source Observables to create a single Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101232Z" creationid="pingfangx" creationdate="20190620T101232Z">
        <seg>使用多个源 Observable 创建单个 Observable 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators to Convert Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103717Z" creationid="pingfangx" creationdate="20190620T103717Z">
        <seg>转换 Observables 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or, something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053036Z" creationid="pingfangx" creationdate="20190620T053036Z">
        <seg>或者，像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other pages show how you use &lt;a0&gt;the variety of Observable operators&lt;/a0&gt; to link Observables together and change their behaviors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044205Z" creationid="pingfangx" creationdate="20190620T044205Z">
        <seg>其他页面显示了如何使用 &lt;a0&gt;各种 Observable 运算符&lt;/a0&gt; 将 Observable 链接在一起并更改其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others do not operate on any particular Scheduler, or operate on a particular default Scheduler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091415Z" creationid="pingfangx" creationdate="20190620T091415Z">
        <seg>其他人不在任何特定的调度器上运行，或在特定的默认调度器上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patch 2.x.y increments (such as 2.0.0 -&gt; 2.0.1, 2.3.1 -&gt; 2.3.2, etc) will occur for bug fixes and trivial functionality (like adding a method overload).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105139Z" creationid="pingfangx" creationdate="20190617T105139Z">
        <seg>补丁 2.x.y 增量(如 2.0.0-&gt;2.0.1、2.3.1-&gt;2.3.2 等)将出现在 bug 修复和琐碎功能(如添加方法重载)上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, parallelism in RxJava means running independent flows and merging their results back into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075816Z" creationid="pingfangx" creationdate="20190617T075816Z">
        <seg>实际上，RxJava 中的并行性意味着运行独立流并将其结果合并回单个流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, the 1.x `fromEmitter` (formerly `fromAsync`) has been renamed to `Flowable.create`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094844Z" creationid="pingfangx" creationdate="20190618T094844Z">
        <seg>实际上，1.x 的 `fromEmitter`(以前称为 fromAsync`)已被重命名为 `Flowable.create`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practically, this is when the body of the given example above executes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072207Z" creationid="pingfangx" creationdate="20190617T072207Z">
        <seg>实际上，这是在上面给出的示例的主体执行时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing the numbers 1 to 10 in parallel is a bit more involved:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075758Z" creationid="pingfangx" creationdate="20190617T075758Z">
        <seg>并行处理数字 1 到 10 涉及更多：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RC3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061550Z" creationid="pingfangx" creationdate="20190619T061550Z">
        <seg>RC3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reactive Programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041620Z" creationid="pingfangx" creationdate="20190620T041620Z">
        <seg>响应式编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Is a Polyglot Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034622Z" creationid="pingfangx" creationdate="20190620T034622Z">
        <seg>ReactiveX 是一种多语言实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Observables support not just the emission of single scalar values (as Futures do), but also of sequences of values or even infinite streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035551Z" creationid="pingfangx" creationdate="20190620T035545Z">
        <seg>ReactiveX Observables 不仅支持单个标量值的发射(如 Futures 那样)，还支持值序列甚至无限流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX Observables, on the other hand, are &lt;e0&gt;intended&lt;/e0&gt; for &lt;a1&gt;composing flows and sequences of asynchronous data&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035425Z" creationid="pingfangx" creationdate="20190620T035425Z">
        <seg>另一方面，ReactiveX Observables &lt;e0&gt;旨在&lt;/e0&gt; 用于 &lt;a1&gt;组合异步数据流和序列&lt;/a1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T025919Z" creationid="pingfangx" creationdate="20190620T025919Z">
        <seg>ReactiveX 是一个库，通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is currently implemented in a variety of languages, in ways that respect those languages’ idioms, and more languages are being added at a rapid clip.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041309Z" creationid="pingfangx" creationdate="20190620T041309Z">
        <seg>ReactiveX 在大量的编程语言中都有实现，并尊重实现语言的风格，而且更多的实现正在飞速增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX is not biased toward some particular source of concurrency or asynchronicity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040233Z" creationid="pingfangx" creationdate="20190620T040233Z">
        <seg>ReactiveX 不偏向某些特定的并发或异步性源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX may be functional, and it may be reactive, but “functional reactive programming” is a different animal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033853Z" creationid="pingfangx" creationdate="20190620T033853Z">
        <seg>ReactiveX 可能是函数式的，它可能是响应式的，但“函数响应式编程”是一种不同的动物。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReactiveX provides &lt;a0&gt;a collection of operators&lt;/a0&gt; with which you can filter, select, transform, combine, and compose Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041826Z" creationid="pingfangx" creationdate="20190620T041826Z">
        <seg>ReactiveX 提供了 &lt;a0&gt;一系列操作符&lt;/a0&gt;，你可以使用它们来过滤(filter)，选择(select)，转换(transform)，结合(combine)和组合(compose) Observable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursive Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092103Z" creationid="pingfangx" creationdate="20190620T092103Z">
        <seg>递归调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061028Z" creationid="pingfangx" creationdate="20190619T061028Z">
        <seg>备注</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed as the Reactive Streams specification mandates the `onXXX` methods don't crash and therefore the default is to not have a safety net in `subscribe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054131Z" creationid="pingfangx" creationdate="20190619T054131Z">
        <seg>在 Reactive Streams 规范要求删除 `onXXX` 方法不会崩溃，因此默认是在 `subscribe` 中没有安全网。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed in version</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061536Z" creationid="pingfangx" creationdate="20190619T061536Z">
        <seg>在版本移除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava (and its derivatives like RxGroovy &amp; RxScala) has developed an &lt;a0&gt;Observable&lt;/a0&gt; variant called “Single.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073327Z" creationid="pingfangx" creationdate="20190620T073327Z">
        <seg>RxJava(及其衍生品，如 RxGroovy 和 RxScala)开发了一种名为“Single”的 &lt;a0&gt;Observable&lt;/a0&gt; 变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2 features several base classes you can discover operators on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065936Z" creationid="pingfangx" creationdate="20190617T065936Z">
        <seg>RxJava 2 具有几个可以发现运算符的基类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2 features several standard schedulers accessible via `Schedulers` utility class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073108Z" creationid="pingfangx" creationdate="20190617T073108Z">
        <seg>RxJava 2 具有几个可通过 `Schedulers` 实用程序类访问的标准调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2's design was heavily influenced by the [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams) specification, therefore, the library features a class and an interface per each reactive type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103741Z" creationid="pingfangx" creationdate="20190617T103741Z">
        <seg>RxJava 2 的设计深受 [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams) 规范的影响，因此，该库为每种反应类型提供了一个类和一个接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.0 has been completely rewritten from scratch on top of the Reactive-Streams specification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T015500Z" creationid="pingfangx" creationdate="20190618T015500Z">
        <seg>RxJava 2.0 已经根据 Reactive-Streams 规范从头开始完全重写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.0.0-RC2 introduced a new base reactive type called `Maybe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060309Z" creationid="pingfangx" creationdate="20190618T060309Z">
        <seg>RxJava 2.0.0-RC2 引入了一个名为 `Maybe` 的新的基本响应类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava 2.x no longer accepts `null` values and the following will yield `NullPointerException` immediately or as a signal to downstream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052728Z" creationid="pingfangx" creationdate="20190618T052728Z">
        <seg>RxJava 2.x 不再接受 `null` 值，以下将立即产生 `NullPointerException` 或作为下游的信号：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava chose to name such operators by appending the type as suffix as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102150Z" creationid="pingfangx" creationdate="20190617T102150Z">
        <seg>RxJava 选择通过将类型附加为后缀来命名此类运算符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is a Java VM implementation of [Reactive Extensions](http://reactivex.io): a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T064503Z" creationid="pingfangx" creationdate="20190617T064503Z">
        <seg>RxJava 是 [Reactive Extensions](http://reactivex.io) 的 Java VM 实现：其用于通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is a Java VM implementation of [ReactiveX (Reactive Extensions)](https://reactivex.io): a library for composing asynchronous and event-based programs by using observable sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113439Z" creationid="pingfangx" creationdate="20190617T113439Z">
        <seg>RxJava 是 [ReactiveX(Reactive Extensions)](https://reactivex.io) 的 Java VM 实现：其通过使用可观察序列来编写异步和基于事件的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava is meant for a more polyglot environment than just Java/Scala, and it is being designed to respect the idioms of each JVM-based language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113631Z" creationid="pingfangx" creationdate="20190617T113631Z">
        <seg>RxJava 用于比 Java/Scala 更多的多语言环境，它被设计为尊重每种基于 JVM 的语言的习语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava operators don't work with `Thread`s or `ExecutorService`s directly but with so called `Scheduler`s that abstract away sources of concurrency behind a uniform API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073048Z" creationid="pingfangx" creationdate="20190617T073048Z">
        <seg>RxJava 运算符不能直接使用 `Thread` 或 `ExecutorService`，而是使用所谓的 `Scheduler` 来抽象统一 API 背后的并发源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava supports Java 6 or higher and JVM-based languages such as [Groovy](https://github.com/ReactiveX/RxGroovy), [Clojure](https://github.com/ReactiveX/RxClojure), [JRuby](https://github.com/ReactiveX/RxJRuby), [Kotlin](https://github.com/ReactiveX/RxKotlin) and [Scala](https://github.com/ReactiveX/RxScala).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113556Z" creationid="pingfangx" creationdate="20190617T113556Z">
        <seg>RxJava 支持 Java 6 或更高版本以及基于 JVM 的语言，如 [Groovy](https://github.com/ReactiveX/RxGroovy)，[Clojure](https://github.com/ReactiveX/RxClojure)，[JRuby] (https://github.com/ReactiveX/RxJRuby)，[Kotlin](https://github.com/ReactiveX/RxKotlin) 和 [Scala](https://github.com/ReactiveX/RxScala)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RxJava tries to be very lightweight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113503Z" creationid="pingfangx" creationdate="20190617T113503Z">
        <seg>RxJava 试图非常轻量级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044335Z" creationid="pingfangx" creationdate="20190620T044335Z">
        <seg>相关参考</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the differences between version 1.x and 2.x in the wiki article [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065542Z" creationid="pingfangx" creationdate="20190617T065542Z">
        <seg>请参阅 wiki 文章中的版本 1.x 和 2.x 之间的差异 [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to how error-handling became a first-class citizen and received operators to deal with it (via `onErrorXXX` operators), backpressure is another property of dataflows that the programmer has to think about and handle (via `onBackpressureXXX` operators).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T073237Z" creationid="pingfangx" creationdate="20190621T073237Z">
        <seg>类似于错误处理成为一等公民并接受操作符处理它(通过 `onErrorXXX` 操作符)，背压是数据流的另一个属性，程序员必须考虑和处理(通过 `onBackpressureXXX` 操作符)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the naming changes, `rx.Completable.CompletableSubscriber` has become `io.reactivex.CompletableObserver` with `onSubscribe(Disposable)`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060056Z" creationid="pingfangx" creationdate="20190618T060056Z">
        <seg>与命名更改类似，`rx.Completable.CompletableSubscriber` 已变为 `io.reactivex.CompletableObserver`，带有 `onSubscribe(Disposable)`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since 1.x `Observable.subscribe(Subscriber)` returned `Subscription`, users often added the `Subscription` to a `CompositeSubscription` for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070549Z" creationid="pingfangx" creationdate="20190618T070549Z">
        <seg>由于 1.x `Observable.subscribe(Subscriber)` 返回 `Subscription`，用户经常将 `Subscription` 添加到 `CompositeSubscription` 中，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since 2.x is a fresh start, we won't make that mistake again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094650Z" creationid="pingfangx" creationdate="20190618T094650Z">
        <seg>由于 2.x 是一个新的开始，我们不会再犯这个错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since many of the existing code targeting 1.x do such things, the method `safeSubscribe` has been introduced that does handle these non-conforming consumers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095633Z" creationid="pingfangx" creationdate="20190618T095633Z">
        <seg>由于许多针对 1.x 的现有代码都是这样做的，因此引入了 `safeSubscribe` 方法来处理这些不符合要求的消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since not all sources need all these features, the static methods of `Flowable.generate` let's one create instances without them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021428Z" creationid="pingfangx" creationdate="20190624T021428Z">
        <seg>由于并非所有源都需要所有这些功能，因此 `Flowable.generate` 的静态方法可以创建没有它们的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the Java convention is to have a lowercase letter start a method name, this would have been `return(T)` which is a keyword in Java and thus not available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101634Z" creationid="pingfangx" creationdate="20190617T101634Z">
        <seg>由于 Java 约定是以小写字母开始一个方法名称，这将是 `return(T)`，它是 Java 中的关键字，因此不可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we build an `Flowable` out of it, we can express our will to consume only the first 5 of it and then stop requesting anything.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020557Z" creationid="pingfangx" creationdate="20190624T020557Z">
        <seg>由于我们构建了一个 `Flowable`，我们可以表达我们的意愿，只消耗它的前 5 个，然后停止请求任何东西。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we explicitly don't request in `onStart`, this will not print anything.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015652Z" creationid="pingfangx" creationdate="20190624T015652Z">
        <seg>由于我们明确地不在 `onStart` 中请求，因此不会打印任何内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sleeping for some time in this example situations lets you see the output of the flow on the console with time to spare.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T074030Z" creationid="pingfangx" creationdate="20190617T074030Z">
        <seg>在此示例情况下休眠一段时间，使您可以在留出的时间在控制台上查看流的输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Snapshots are available via https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105550Z" creationid="pingfangx" creationdate="20190617T105550Z">
        <seg>可通过 https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/ 获取快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Notes on Naming Conventions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064512Z" creationid="pingfangx" creationdate="20190620T064512Z">
        <seg>关于命名约定的一些注释</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091407Z" creationid="pingfangx" creationdate="20190620T091407Z">
        <seg>RxGroovy 中的一些 Observable 操作符具有替代形式，允许您设置操作符将用于(至少某些部分)其操作的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091921Z" creationid="pingfangx" creationdate="20190620T091921Z">
        <seg>RxJava 中的一些 Observable 操作符具有替代形式，允许您设置操作符将用于(至少某些部分)其操作的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085701Z" creationid="pingfangx" creationdate="20190620T085701Z">
        <seg>一些 ReactiveX Observable 操作符具有将 Scheduler 作为参数的变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some libraries offer some help, such as Google Guava's `AbstractIterable` and IxJava's `Ix.generate()` and `Ix.forloop()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020434Z" creationid="pingfangx" creationdate="20190624T020434Z">
        <seg>一些库提供了一些帮助，例如 Google Guava 的 `AbstractIterable` 和 IxJava 的 `Ix.generate()` 和 `Ix.forloop()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operator overloads have been renamed with a postfix, such as `fromArray`, `fromIterable` etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111237Z" creationid="pingfangx" creationdate="20190618T111140Z">
        <seg>一些操作符重载已使用后缀重命名，例如 `fromArray`，`fromIterable` 等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators also allow for an interface between the Observable world and the Single world so that you can mix the two varieties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073958Z" creationid="pingfangx" creationdate="20190620T073958Z">
        <seg>一些操作符还允许 Obse​​rvable 世界和 Single 世界之间的接口，以便您可以混合两种变体：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operators that produced exactly one value or an error now return `Single` in 2.x (or `Maybe` if an empty source is allowed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T060131Z" creationid="pingfangx" creationdate="20190619T060131Z">
        <seg>一些只生成一个值或错误的操作符现在在 2.x 中返回 `Single`(如果允许空源，则返回 `Maybe`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some sources block or start emitting items right away in this state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072007Z" creationid="pingfangx" creationdate="20190617T072007Z">
        <seg>某些来源在此状态下会立即阻止或开始发射项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes such overflows happen due to bursty sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090237Z" creationid="pingfangx" creationdate="20190621T090237Z">
        <seg>有时这种溢出是由于突发源而发生的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes though, multiple sources may fail at which point there is a choice whether or not wait for all of them to complete or fail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103451Z" creationid="pingfangx" creationdate="20190617T103451Z">
        <seg>但有时候，多个来源可能会失败，此时可以选择是否等待所有来源完成或失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, a source or service returns a different type than the flow that is supposed to work with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092728Z" creationid="pingfangx" creationdate="20190617T092728Z">
        <seg>有时，源或服务返回的类型与应该使用它的流不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, a suffix is added to avoid logical ambiguities that may compile but produce the wrong type in a flow:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103058Z" creationid="pingfangx" creationdate="20190617T103058Z">
        <seg>有时，会添加一个后缀以避免可能编译但在流中产生错误类型的逻辑歧义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, the data source to be converted into the reactive world itself is synchronous (blocking) and pull-like, that is, we have to call some `get` or `read` method to get the next piece of data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020722Z" creationid="pingfangx" creationdate="20190624T020722Z">
        <seg>有时，要转换为响应世界本身的数据源是同步的(阻塞)和拉式的，也就是说，我们必须调用一些 `get` 或 `read` 方法来获取下一个数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, the source to be wrapped into an `Flowable` is already hot (such as mouse moves) or cold but not backpressurable in its API (such as an asynchronous network callback).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021709Z" creationid="pingfangx" creationdate="20190624T021709Z">
        <seg>有时，被包装成 `Flowable` 的源已经是热源(例如鼠标移动)或是冷源但在其 API 中不能背压(例如异步网络回调)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, there is an implicit data dependency between the previous sequence and the new sequence that, for some reason, was not flowing through the "regular channels".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092144Z" creationid="pingfangx" creationdate="20190617T092144Z">
        <seg>有时，前一个序列和新序列之间存在隐含的数据依赖性，由于某种原因，它不会流经“常规通道”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, when an item has become available, one would like to perform some dependent computations on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083533Z" creationid="pingfangx" creationdate="20190617T083533Z">
        <seg>有时，当项目可用时，人们希望对其执行一些依赖计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specialty Observables that have more precisely-controlled subscription dynamics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103546Z" creationid="pingfangx" creationdate="20190620T103546Z">
        <seg>具有更精确控制的订阅动态的特殊 Observables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Store the return value from that method in a variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053011Z" creationid="pingfangx" creationdate="20190620T053011Z">
        <seg>将该方法的返回值存储在变量中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such an Observable does not begin emitting items until its &lt;a0&gt;&lt;s1&gt;Connect&lt;/s1&gt;&lt;/a0&gt; method is called, whether or not any observers have subscribed to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T070147Z" creationid="pingfangx" creationdate="20190620T070147Z">
        <seg>这样的 Observable 在调用 &lt;a0&gt;&lt;s1&gt;Connect&lt;/s1&gt;&lt;/a0&gt; 方法之前不会开始发射项目，无论是否有任何观察者订阅了它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such errors are routed to the `RxJavaPlugins.onError` handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090058Z" creationid="pingfangx" creationdate="20190618T090058Z">
        <seg>这些错误被路由到 `RxJavaPlugins.onError` 处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suddenly, the user taps the screen too quickly and `observeOn`'s default 16-element internal buffer on Android overflows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090257Z" creationid="pingfangx" creationdate="20190621T090257Z">
        <seg>突然，用户太快地点击了屏幕，Android 上的 `observeOn` 的默认 16 元素内部缓冲区溢出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Surprising to some, this prints 1 twice instead of printing 1 and 2 respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015800Z" creationid="pingfangx" creationdate="20190624T015800Z">
        <seg>令某些人感到惊讶的是，这打印 1 次，而不是分别打印 1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Techniques like &lt;a0&gt;Java Futures&lt;/a0&gt; are straightforward to use for &lt;a1&gt;a single level of asynchronous execution&lt;/a1&gt; but they start to add &lt;a2&gt;non-trivial complexity&lt;/a2&gt; when they’re nested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034736Z" creationid="pingfangx" creationdate="20190620T034736Z">
        <seg>诸如 &lt;a0&gt;Java Futures&lt;/a0&gt; 之类的技术可以直接用于 &lt;a1&gt;单层的异步操作&lt;/a1&gt;，但是当它们嵌套时，它们开始变得 &lt;a2&gt;异常的复杂&lt;/a2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test developers are now encouraged to simply `new TestScheduler()` in their code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093750Z" creationid="pingfangx" creationdate="20190618T093750Z">
        <seg>现在鼓励测试开发人员在他们的代码中简单地使用 `new TestScheduler()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing RxJava 2.x works the same way as it does in 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095744Z" creationid="pingfangx" creationdate="20190618T095744Z">
        <seg>测试 RxJava 2.x 的工作方式与 1.x 相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests that want to override the schedulers and the lifecycle of the base reactive types can do it on a case-by-case basis through callback functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085756Z" creationid="pingfangx" creationdate="20190618T085756Z">
        <seg>想要覆盖调度器和基本响应类型生命周期的测试可以通过回调函数逐个进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 1.x `TestSubject` has been dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063524Z" creationid="pingfangx" creationdate="20190618T063524Z">
        <seg>1.x 的 `TestSubject` 已被删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x API still supports the main default scheduler types: `computation`, `io`, `newThread` and `trampoline`, accessible through `io.reactivex.schedulers.Schedulers` utility class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093502Z" creationid="pingfangx" creationdate="20190618T093502Z">
        <seg>2.x API 仍支持主要的默认调度器类型：`calculate`，`io`，`newThread` 和 `trampoline`，可通过 `io.reactivex.schedulers.Schedulers` 实用程序类访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x `Single` reactive base type, which can emit a single `onSuccess` or `onError` has been redesigned from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055616Z" creationid="pingfangx" creationdate="20190618T055616Z">
        <seg>2.x 重新设计的 `Single` 响应基类型，它可以发出单个 `onSuccess` 或 `onError` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2.x redesigned the `RxJavaPlugins` class which now supports changing the hooks at runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085718Z" creationid="pingfangx" creationdate="20190618T085718Z">
        <seg>2.x 重新设计了 `RxJavaPlugins` 类，它现在支持在运行时更改钩子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Worker&lt;/c0&gt; is also a &lt;c1&gt;Subscription&lt;/c1&gt; and so you can (and should, eventually) call its &lt;c2&gt;unsubscribe&lt;/c2&gt; method to signal that it can halt work and release resources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092316Z" creationid="pingfangx" creationdate="20190620T092316Z">
        <seg>&lt;c0&gt;Worker&lt;/c0&gt; 也是 &lt;c1&gt;Subscription&lt;/c1&gt;，因此您可以(通常也应该)调用其 &lt;c2&gt;unsubscribe&lt;/c2&gt; 方法来表示它可以停止工作和释放资源：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;onError&lt;/c2&gt; method takes as its parameter an indication of what caused the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060342Z" creationid="pingfangx" creationdate="20190620T060342Z">
        <seg>&lt;c2&gt;onError&lt;/c2&gt; 方法将导致错误的原因作为其参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;s1&gt;SubscribeOn&lt;/s1&gt; operator changes this behavior by specifying a different Scheduler on which the Observable should operate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085953Z" creationid="pingfangx" creationdate="20190620T085953Z">
        <seg>&lt;s1&gt;SubscribeOn&lt;/s1&gt; 操作符通过指定 Observable 应在其上运行的其他 Scheduler 来更改此行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;s2&gt;ObserveOn&lt;/s2&gt; operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090251Z" creationid="pingfangx" creationdate="20190620T090251Z">
        <seg>&lt;s2&gt;ObserveOn&lt;/s2&gt; 操作符指定 Observable 将用于向其观察者发送通知的另一个 Scheduler。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Observable type adds two missing semantics to &lt;a0&gt;the Gang of Four’s Observer pattern&lt;/a0&gt;, to match those that are available in the Iterable type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042308Z" creationid="pingfangx" creationdate="20190620T042308Z">
        <seg>Observable 类型为 &lt;a0&gt;Gang of Four 的观察者模式&lt;/a0&gt; 添加了两个缺少的语义，以匹配 Iterable 类型中可用的语义：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Operators of ReactiveX</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094002Z" creationid="pingfangx" creationdate="20190620T094002Z">
        <seg>ReactiveX 的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification has its own Subscriber as an interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065304Z" creationid="pingfangx" creationdate="20190618T065304Z">
        <seg>Reactive-Streams 规范有自己的订阅者作为接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification mandates operators supporting backpressure, specifically via the guarantee that they don't overflow their consumers when those don't request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073359Z" creationid="pingfangx" creationdate="20190618T073359Z">
        <seg>Reactive-Streams 规范要求操作符支持背压，特别是通过保证在没有请求时它们不会溢出消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Reactive-Streams specification took this name for specifying an interaction point between a source and a consumer: `org.reactivestreams.Subscription` allows requesting a positive amount from the upstream and allows cancelling the sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072735Z" creationid="pingfangx" creationdate="20190618T072735Z">
        <seg>Reactive-Streams 规范使用此名称来指定源和消费者之间的交互点：`org.reactivestreams.Subscription` 允许从上游请求正数量并允许取消序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034410Z" creationid="pingfangx" creationdate="20190620T034410Z">
        <seg>ReactiveX Observable 模型允许您使用简单，可组合的操作来处理异步事件流，就像用于数据项集合(如数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `BackpressureOverflow.Strategy` is an interface actually but the class `BackpressureOverflow` offers 4 static fields with implementations of it representing typical actions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014454Z" creationid="pingfangx" creationdate="20190624T014454Z">
        <seg>`BackpressureOverflow.Strategy` 实际上是一个接口，但是 `BackpressureOverflow` 类提供了 4 个静态字段，其实现代表了典型的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `BehaviorProcessor` and `PublishProcessor` don't coordinate requests (use `Flowable.publish()` for that) of their downstream subscribers and will signal them `MissingBackpressureException` if the downstream can't keep up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063040Z" creationid="pingfangx" creationdate="20190618T063040Z">
        <seg>`BehaviorProcessor` 和 `PublishProcessor` 不协调下游订阅者的请求(如果需要则使用 `Flowable.publish()`)，如果下游无法跟上，则会发出 `MissingBackpressureException` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Completable` type remains largely the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T055938Z" creationid="pingfangx" creationdate="20190618T055938Z">
        <seg>`Completable` 类型基本保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Emitter` is relatively straightforward to use; one can call `onNext`, `onError` and `onComplete` on it and the operator handles backpressure and unsubscription management on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022550Z" creationid="pingfangx" creationdate="20190624T022550Z">
        <seg>`Emitter` 的使用相对简单；可以在其上调用 `onNext`，`onError` 和 `onComplete`，操作符可以自己处理背压和取消订阅管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `FuncN` is replaced by the `Function&lt;Object[], R&gt;` type declaration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065013Z" creationid="pingfangx" creationdate="20190618T065013Z">
        <seg>`FuncN` 被 `Function&lt;Object[], R&gt;` 类型声明所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Schedulers.test()` has been removed as well to avoid the conceptional difference with the rest of the default schedulers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093658Z" creationid="pingfangx" creationdate="20190618T093658Z">
        <seg>`Schedulers.test()` 也已被移除，以避免与其他默认调度器的概念差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `SerializedSubject` is no longer a public class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063614Z" creationid="pingfangx" creationdate="20190618T063614Z">
        <seg>`SerializedSubject` 不再是公共类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `Thread.sleep(2000);` at the end is no accident.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073846Z" creationid="pingfangx" creationdate="20190617T073846Z">
        <seg>最后的 `Thread.sleep(2000);`  不是偶然的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `computeValue` is called as part of the main routine and not in response to the subscribers subscribing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015849Z" creationid="pingfangx" creationdate="20190624T015849Z">
        <seg>`computeValue` 作为主程序的一部分被调用，而不是响应订阅者的订阅。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `fromIterable` also gives an interesting opportunity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020241Z" creationid="pingfangx" creationdate="20190624T020241Z">
        <seg>`fromIterable` 也提供了一个有趣的机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `immediate` scheduler is not present in 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093540Z" creationid="pingfangx" creationdate="20190618T093540Z">
        <seg>`immediate` 调度器不存在于 2.x 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.Scheduler` abstract base class now supports scheduling tasks directly without the need to create and then destroy a `Worker` (which is often forgotten):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093812Z" creationid="pingfangx" creationdate="20190618T093812Z">
        <seg>`io.reactivex.Scheduler` 抽象基类现在支持直接调度任务，而不需要创建然后销毁 `Worker`(经常被遗忘)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.processors.AsyncProcessor`, `io.reactivex.processors.BehaviorProcessor`, `io.reactivex.processors.PublishProcessor`, `io.reactivex.processors.ReplayProcessor` and `io.reactivex.processors.UnicastProcessor` are backpressure-aware.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062905Z" creationid="pingfangx" creationdate="20190618T062905Z">
        <seg>`io.reactivex.processors.AsyncProcessor`，`io.reactivex.processors.BehaviorProcessor`，`io.reactivex.processors.PublishProcessor`，`io.reactivex.processors.ReplayProcessor` 和 `io.reactivex.processors.UnicastProcessor` 是背压感知的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `io.reactivex.subjects.AsyncSubject`, `io.reactivex.subjects.BehaviorSubject`, `io.reactivex.subjects.PublishSubject`, `io.reactivex.subjects.ReplaySubject` and `io.reactivex.subjects.UnicastSubject` in 2.x don't support backpressure (as part of the 2.x `Observable` family).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T062846Z" creationid="pingfangx" creationdate="20190618T062846Z">
        <seg>`io.reactivex.subjects.AsyncSubject`，`io.reactivex.subjects.BehaviorSubject`，`io.reactivex.subjects.PublishSubject`，`io.reactivex.subjects.ReplaySubject` 和 `io.reactivex.subjects.UnicastSubject` 在 2.x 中不支持背压(作为 2.x `Observable` 系列的一部分)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `rx.observables.ConnectableObservable` is now `io.reactivex.observables.ConnectableObservable&lt;T&gt;` and `io.reactivex.flowables.ConnectableFlowable&lt;T&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063659Z" creationid="pingfangx" creationdate="20190618T063659Z">
        <seg>`rx.observables.ConnectableObservable` 现在是 `io.reactivex.observables.ConnectableObservable&lt;T&gt;` 和 `io.reactivex.flowables.ConnectableFlowable&lt;T&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `rx.observables.GroupedObservable` is now `io.reactivex.observables.GroupedObservable&lt;T&gt;` and `io.reactivex.flowables.GroupedFlowable&lt;T&gt;`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063807Z" creationid="pingfangx" creationdate="20190618T063807Z">
        <seg>`rx.observables.GroupedObservable` 现在是 `io.reactivex.observables.GroupedObservable&lt;T&gt;` 和 `io.reactivex.flowables.GroupedFlowable&lt;T&gt;`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `set()` method disposes the old value and `replace()` method does not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073205Z" creationid="pingfangx" creationdate="20190618T073205Z">
        <seg>`set()` 方法处理旧值，而 'replace()` 方法则不处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `test()` method on `TestObserver` has a `test(boolean cancel)` overload which cancels/disposes the `TestSubscriber`/`TestObserver` before it even gets subscribed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101725Z" creationid="pingfangx" creationdate="20190618T101725Z">
        <seg>`TestObserver` 上的 `test()` 方法有一个 `test(boolean cancel)` 重载，在它被订阅之前取消/释放 `TestSubscriber`/`TestObserver`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual cause is usually the non-backpressured use of `PublishProcessor`, `timer()` or `interval()` or custom operators created via `create()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090210Z" creationid="pingfangx" creationdate="20190621T090210Z">
        <seg>实际原因通常是使用 `PublishProcessor`，`timer()` 或 `interval()` 或通过 `create()` 创建的自定义操作符的非背压使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bad news is that one should be careful when performing 'organize imports' as it may select the non-backpressured `io.reactivex.Observable` unintended.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053501Z" creationid="pingfangx" creationdate="20190618T053501Z">
        <seg>坏消息是，在执行“组织导入”时应该小心，因为它可能会无意中选择非背压的 `io.reactivex.Observable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base classes can be considered heavy due to the sheer number of static and instance methods on them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103625Z" creationid="pingfangx" creationdate="20190617T103625Z">
        <seg>由于基类的静态和实例方法数量庞大，因此可以认为基类很重。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class-based `RxJavaObservableHook` and friends are now gone and `RxJavaHooks` functionality is incorporated into `RxJavaPlugins`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T085830Z" creationid="pingfangx" creationdate="20190618T085830Z">
        <seg>基于类 `RxJavaObservableHook` 和朋友现在已经不在了，`RxJavaHooks` 函数被整合到 `RxJavaPlugins` 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classic case of the need for backpressure is when the producer is a hot source:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T071555Z" creationid="pingfangx" creationdate="20190621T071555Z">
        <seg>需要背压的经典案例是当生产者是热源时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dataflows in RxJava consist of a source, zero or more intermediate steps followed by a data consumer or combinator step (where the step is responsible to consume the dataflow by some means):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T070925Z" creationid="pingfangx" creationdate="20190617T070735Z">
        <seg>RxJava 中的数据流由源，零个或多个中间步骤，后跟数据消费者或组合器步骤(其中步骤负责通过某种方式消费数据流)组成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation of each operator has a description about its backpressure behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080246Z" creationid="pingfangx" creationdate="20190621T080246Z">
        <seg>每个操作符的文档都有关于其背压行为的描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception is still there but this time, the operator that can't signal more `onNext` will signal this exception instead (allowing better identification of who is not properly backpressured).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073650Z" creationid="pingfangx" creationdate="20190618T073650Z">
        <seg>例外情况仍然存在，但这一次，无法发出更多 `onNext` 信号的操作符将发出异常信号(允许更好地识别谁没有正确背压)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final callback gets invoked when the downstream unsubscribes (closing the inputstream) or when the previous callback called the terminal methods; it allows freeing up resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021408Z" creationid="pingfangx" creationdate="20190624T021408Z">
        <seg>当下游取消​​订阅(关闭输入流)或前一个回调调用终端方法时，将调用最终的回调；它允许释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final operator keeps only the latest value and practically overwrites older, undelivered values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015125Z" creationid="pingfangx" creationdate="20190624T015125Z">
        <seg>最后一个操作符只保留最新的值，实际上覆盖了旧的、未传递的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first callbacks allows one to create a per-subscriber state, such as the `FileInputStream` in the example; the file will be opened independently to each individual subscriber.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021149Z" creationid="pingfangx" creationdate="20190624T021149Z">
        <seg>第一个回调允许创建一个每个订阅者独立的状态，例如示例中的 `FileInputStream`;该文件将为每个订阅者独立打开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first step is to include RxJava 2 into your project, for example, as a Gradle compile dependency:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065845Z" creationid="pingfangx" creationdate="20190617T065845Z">
        <seg>第一步是将 RxJava 2 包含到您的项目中，例如，作为 Gradle 编译依赖项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first typical case for its use when one wants to interact with a push-based source, such as GUI events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022214Z" creationid="pingfangx" creationdate="20190624T022214Z">
        <seg>当人们想要与基于推的源（例如 GUI 事件）交互时使用的第一个典型案例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example schedules &lt;c2&gt;someAction&lt;/c2&gt; to be performed on &lt;c3&gt;someScheduler&lt;/c3&gt; after 500ms have passed according to that Scheduler’s clock:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092445Z" creationid="pingfangx" creationdate="20190620T092445Z">
        <seg>以下示例根据调度器的时钟调度 500ms 后，在 &lt;c3&gt;someScheduler&lt;/c3&gt; 上调度 &lt;c2&gt;someAction&lt;/c2&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example schedules &lt;c2&gt;someAction&lt;/c2&gt; to be performed on &lt;c3&gt;someScheduler&lt;/c3&gt; after 500ms have passed, and then every 250ms thereafter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092640Z" creationid="pingfangx" creationdate="20190620T092640Z">
        <seg>以下示例调度在经过 500ms 后在 &lt;c3&gt;someScheduler&lt;/c3&gt; 上执行 &lt;c2&gt;someAction&lt;/c2&gt;，然后每隔 250ms 执行一次：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses &lt;a0&gt;the &lt;c1&gt;schedule&lt;/c1&gt; method&lt;/a0&gt; of &lt;a2&gt;the &lt;c3&gt;Scheduler.Worker&lt;/c3&gt; class&lt;/a2&gt; to schedule work on the &lt;c4&gt;newThread&lt;/c4&gt; Scheduler:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092100Z" creationid="pingfangx" creationdate="20190620T092100Z">
        <seg>以下示例使用&lt;a2&gt;&lt;c3&gt;Scheduler.Worker&lt;/c3&gt; 类&lt;/a2&gt; 的 &lt;a0&gt;&lt;c1&gt;schedule&lt;/c1&gt; 方法&lt;/a0&gt; 来安排 &lt;c4&gt;newThread&lt;/c4&gt; 调度器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following external libraries can work with RxJava:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T113641Z" creationid="pingfangx" creationdate="20190617T113641Z">
        <seg>以下外部库可以与 RxJava 一起使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following matrix shows the available conversion options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T093040Z" creationid="pingfangx" creationdate="20190617T093040Z">
        <seg>以下矩阵显示了可用的转换选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following sections of this page will give marble diagrams that explain these operators schematically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074923Z" creationid="pingfangx" creationdate="20190620T074923Z">
        <seg>本页的以下部分将给出 marble 图，可以示意性地解释这些操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following subsections list each base reactive type and the difference between 1.x and 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111012Z" creationid="pingfangx" creationdate="20190618T111012Z">
        <seg>以下小节列出了每个基本响应类型以及 1.x 和 2.x 之间的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090950Z" creationid="pingfangx" creationdate="20190620T090950Z">
        <seg>下表显示了在 RxGroovy 中通过这些方法可用的调度器的种类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091905Z" creationid="pingfangx" creationdate="20190620T091905Z">
        <seg>下表显示了在 RxJava 中通过这些方法可用的 Scheduler 的种类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The good news is that operator names remain (mostly) the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053420Z" creationid="pingfangx" creationdate="20190618T053420Z">
        <seg>好消息是操作符名称(大多数)保持不变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main issue with backpressure is that many hot sources, such as UI events, can't be reasonably backpressured and cause unexpected `MissingBackpressureException` (i.e., beginners don't expect them).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053209Z" creationid="pingfangx" creationdate="20190618T053209Z">
        <seg>背压的主要问题是许多热源，例如 UI 事件，不能合理地背压并导致意外的 `MissingBackpressureException`(即，初学者不期望它们)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main purpose is to avoid the tracking overhead of the `Worker`s for typically one-shot tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093953Z" creationid="pingfangx" creationdate="20190618T093953Z">
        <seg>主要目的是避免通常一次性任务的 `Worker` 的跟踪开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method that returns the scheduler's own notion of current time, `now()` has been changed to accept a `TimeUnit` to indicate the unit of measure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094029Z" creationid="pingfangx" creationdate="20190618T094029Z">
        <seg>返回调度器自己的当前时间概念 `now()` 的方法已被更改为接受 `TimeUnit` 来指示度量单位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods have a default implementation that reuses `createWorker` properly but can be overridden with more efficient implementations if necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094015Z" creationid="pingfangx" creationdate="20190618T094015Z">
        <seg>这些方法有一个默认实现，可以正确地重用 `createWorker`，但如果需要可以用更高效的实现覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most basic backpressure aware source is created via `just`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015628Z" creationid="pingfangx" creationdate="20190624T015628Z">
        <seg>最基本的背压感知源是通过 `just` 创建的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most typical scenario is to given a value, invoke another service, await and continue with its result:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083633Z" creationid="pingfangx" creationdate="20190617T083633Z">
        <seg>最典型的情况是给出一个值，调用另一个服务，等待其结果并继续：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new `safeSubscribe` method was introduced to explicitly add the safety wrapper around a consumer type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054140Z" creationid="pingfangx" creationdate="20190619T054140Z">
        <seg>引入了新的 `safeSubscribe` 方法，以明确地在消费者类型周围添加安全包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new interface is **constrained to RxJava 2** and represents a consumer to `Flowable` that is able to work in a mode that relaxes the Reactive-Streams version 1.0.0 specification in rules §1.3, §2.3, §2.12 and §3.9:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T084021Z" creationid="pingfangx" creationdate="20190618T074005Z">
        <seg>新接口被 **约束为 RxJava 2** 并且将消费者表示为 `Flowable`，它能够在 Reactive-Streams 版本 1.0.0 规范的规则 §1.3，§2.3，§2.12 和 §3.9 的宽松模式中工作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The no argument `Action0` is replaced by the `io.reactivex.functions.Action` for the operators and `java.lang.Runnable` for the `Scheduler` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064830Z" creationid="pingfangx" creationdate="20190618T064830Z">
        <seg>无参数 `Action0` 被替换为用于运算符的 `io.reactivex.functions.Action` 和用于 `Scheduler` 方法的 `java.lang.Runnable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The official Javadoc pages for 2.x is hosted at http://reactivex.io/RxJava/2.x/javadoc/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052658Z" creationid="pingfangx" creationdate="20190618T052658Z">
        <seg>2.x 的官方 Javadoc 页面托管在 http://reactivex.io/RxJava/2.x/javadoc/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only dependency between the `sourceObservable` and the `someSingleSource` is that the former should complete normally in order for the latter to be consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091956Z" creationid="pingfangx" creationdate="20190617T091956Z">
        <seg>`sourceObservable` 和 `someSingleSource` 之间唯一的依赖关系是前者应该正常完成，以便后者被消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference between them is the direction in which the data flows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042457Z" creationid="pingfangx" creationdate="20190620T042457Z">
        <seg>它们之间的唯一区别是数据流动的方向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator `flatMap` does this by first mapping each number from 1 to 10 into its own individual `Flowable`, runs them and merges the computed squares.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083001Z" creationid="pingfangx" creationdate="20190617T083001Z">
        <seg>运算符 `flatMap` 通过首先将 1 到 10 中的每个数字映射到它自己的 `Flowable` 中，运行它们并合并计算出的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator `range` sends a callback, in the form of an implementation of the `org.reactivestreams.Subscription` interface, to the `observeOn` by calling its (inner `Subscriber`'s) `onSubscribe`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T081157Z" creationid="pingfangx" creationdate="20190621T081157Z">
        <seg>操作符 `range` 以 `org.reactivestreams.Subscription` 接口的实现形式，通过调用其(内部 `Subscriber` 的) `onSubscribe` 向 `observeOn` 发送一个回调。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original `Subscription` container types have been renamed and updated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T073136Z" creationid="pingfangx" creationdate="20190618T073136Z">
        <seg>原始的 `Subscription` 容器类型已重命名和更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other `XProcessor` types honor backpressure of their downstream subscribers but otherwise, when subscribed to a source (optional), they consume it in an unbounded manner (requesting `Long.MAX_VALUE`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063226Z" creationid="pingfangx" creationdate="20190618T063226Z">
        <seg>其他 `XProcessor` 类型支持其下游订阅者的背压，但是当订阅源(可选)时，它们以无限制的方式消费它(请求 `Long.MAX_VALUE`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other base reactive types also follow this signature with their respective subscriber types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072930Z" creationid="pingfangx" creationdate="20190618T072930Z">
        <seg>其他基本响应类型也遵循此签名及其各自的订阅者类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other base reactive types have similar `create` methods (minus the backpressure strategy).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094904Z" creationid="pingfangx" creationdate="20190618T094904Z">
        <seg>其他基础响应类型具有类似的 `create` 方法(减去背压策略)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other overloads of `subscribe` now return `Disposable` in 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072939Z" creationid="pingfangx" creationdate="20190618T072939Z">
        <seg>`subscribe` 的其他重载现在在 2.x 中返回 `Disposable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other types, `Single`, `Maybe` and `Completable` don't support backpressure nor should they; there is always room to store one item temporarily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071515Z" creationid="pingfangx" creationdate="20190617T071515Z">
        <seg>其他类型，`Single`，`Maybe`和`Completable`不支持背压，也不应该支持背压；它们只是暂时存放单个项目的空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preparation of dataflows by applying various intermediate operators happens in the so-called **assembly time**:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071711Z" creationid="pingfangx" creationdate="20190617T071711Z">
        <seg>通过应用各种中间运算符来准备数据流发生在所谓的 **assembly time** 中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem comes when one does some initialization in `onSubscribe`/`onStart` after calling `request` there and `onNext` may or may not see the effects of the initialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071801Z" creationid="pingfangx" creationdate="20190618T071801Z">
        <seg>在调用 `request` 之后在 `onSubscribe`/`onStart` 中进行初始化时会出现问题，因为 `onNext` 可能看到或可能看不到初始化的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem starts when there are, for example, 1 billion elements or the same 1 million sequence appears 1000 times in a program, leading to `OutOfMemoryError` and generally slowdowns due to excessive GC overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T072930Z" creationid="pingfangx" creationdate="20190621T072930Z">
        <seg>例如，当一个程序中有 10 亿个元素或相同的 100 万个序列出现 1000 次时会出现这个问题，导致 `OutOfMemoryError`，并且通常由于过多的 GC 开销而导致变慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The real power comes with the “reactive extensions” (hence “ReactiveX”) — operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071557Z" creationid="pingfangx" creationdate="20190620T071557Z">
        <seg>“响应式扩展 (reactive extensions)”(这也是为什么称之为 “ReactiveX”) 真正强大的地方是 - 允许您转换，组合，操作和处理 Observable 发射的项目序列的操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is that many source operators can "generate" values on demand and thus the operator `observeOn` can tell the `range` generate at most so many values the `observeOn` buffer can hold at once without overflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080646Z" creationid="pingfangx" creationdate="20190621T080512Z">
        <seg>原因是许多源操作符可以按需“生成”值，因此操作符 `observeOn` 可以告诉 `range`，最多生成 `observeOn` 缓冲区可以立即保存而不会溢出的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is that when the library is compiled with Java 8, the javac often can't disambiguate between functional interface types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111255Z" creationid="pingfangx" creationdate="20190618T111255Z">
        <seg>原因是当使用 Java 8 编译库时，javac 通常无法消除函数接口类型之间的歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason these operators have a suffix instead of simply having the same name with different signature is type erasure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100728Z" creationid="pingfangx" creationdate="20190617T100728Z">
        <seg>这些运算符具有后缀而不是简单地具有不同签名的相同名称的原因是类型擦除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevance of this operator is decreasing as more and more operators now allow setting their buffer sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093239Z" creationid="pingfangx" creationdate="20190621T093239Z">
        <seg>随着越来越多的操作符现在允许设置其缓冲区大小，此操作符的相关性正在下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevant parameters are usually called `bufferSize`, `prefetch` or `capacityHint`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090454Z" creationid="pingfangx" creationdate="20190621T090454Z">
        <seg>相关参数通常称为 `bufferSize`，`prefetch` 或 `capacityHint`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining action interfaces were named according to the Java 8 functional types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064541Z" creationid="pingfangx" creationdate="20190618T064541Z">
        <seg>其余的操作接口根据 Java 8 函数类型命名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T062007Z" creationid="pingfangx" creationdate="20190620T061944Z">
        <seg>取消订阅的结果将通过应用于该观察者所订阅的 Observable 的操作符链级联，这将导致链中的每个链接停止发射项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same applies to `Observer`, `SingleObserver`, `MaybeObserver` and `CompletableObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095612Z" creationid="pingfangx" creationdate="20190618T095612Z">
        <seg>这同样适用于 `Observer`，`SingleObserver`，`MaybeObserver` 和 `CompletableObserver`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same limitation exists for the operator `Switch`, which had to be named `switchOnNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101839Z" creationid="pingfangx" creationdate="20190617T101839Z">
        <seg>运算符 `Switch` 也存在同样的限制，它必须命名为 `switchOnNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second callback takes this state object and provides an output `Observer` whose `onXXX` methods can be called to emit values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021221Z" creationid="pingfangx" creationdate="20190624T021221Z">
        <seg>第二个回调接受这个状态对象，并提供一个输出 `Observer`，可以调用其 `onXXX` 方法来发射值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second convenience is that most `TestSubscriber`/`TestObserver` methods return the instance itself allowing chaining the various `assertX` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095918Z" creationid="pingfangx" creationdate="20190618T095918Z">
        <seg>第二个方便是大多数 `TestSubscriber`/`TestObserver` 方法返回实例本身，允许链式调用各种 `assertX` 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second is to write the **Hello World** program:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065858Z" creationid="pingfangx" creationdate="20190617T065858Z">
        <seg>第二个是编写 ** Hello World ** 程序：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second scenario usually involves some asynchronous, callback-based API that has to be converted into an `Flowable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022924Z" creationid="pingfangx" creationdate="20190624T022924Z">
        <seg>第二种情况通常涉及一些异步的，基于回调的 API，必须将其转换为 `Flowable`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specification itself has evolved out of RxJava 1.x and provides a common baseline for reactive systems and libraries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051835Z" creationid="pingfangx" creationdate="20190618T051835Z">
        <seg>规范本身已经从 RxJava 1.x 发展而来，并为响应式系统和库提供了一个共同的基线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third convenience is that you can now fluently test your sources without the need to create or introduce `TestSubscriber`/`TestObserver` instance in your code:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T100013Z" creationid="pingfangx" creationdate="20190618T100013Z">
        <seg>第三个方便是您现在可以流畅地测试您的源，而无需在代码中创建或引入 `TestSubscriber`/`TestObserver` 实例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of `onBackpressureDrop` in this case would lead to a situation where the very last click gets dropped and leaves the user wondering why the business logic wasn't executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015341Z" creationid="pingfangx" creationdate="20190624T015341Z">
        <seg>在这种情况下使用 `onBackpressureDrop` 会导致最后一次点击被删除，并会使用户疑惑为什么没有执行业务逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user in such situations probably wanted to defer some computation until the `someSource` has completed, thus the correct</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102855Z" creationid="pingfangx" creationdate="20190617T102855Z">
        <seg>在这种情况下的用户可能想要推迟一些计算，直到 `someSource` 完成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then that observer reacts to whatever item or sequence of items the Observable &lt;d3&gt;emits&lt;/d3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043345Z" creationid="pingfangx" creationdate="20190620T043345Z">
        <seg>然后该观察者对 Observable &lt;d3&gt;emits (发射)&lt;/d3&gt;的数据或数据序列作出响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are 4 additional overloads of `onBackpressureBuffer`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093033Z" creationid="pingfangx" creationdate="20190621T093033Z">
        <seg>`onBackpressureBuffer` 还有 4 个额外的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also versions of &lt;c0&gt;ReplaySubject&lt;/c0&gt; that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085024Z" creationid="pingfangx" creationdate="20190620T085024Z">
        <seg>还有一些 &lt;c0&gt;ReplaySubject&lt;/c0&gt; 的版本，一旦重放缓冲区超过一定大小，或者自项目最初发射以来已经过了指定的时间跨度，它们将丢弃旧项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are alternative operators:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083144Z" creationid="pingfangx" creationdate="20190617T083144Z">
        <seg>还有其他可选运算符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four varieties of &lt;c0&gt;Subject&lt;/c0&gt; that are designed for particular use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083734Z" creationid="pingfangx" creationdate="20190620T083734Z">
        <seg>有四种 &lt;c0&gt;Subject&lt;/c0&gt; 专为特定用例而设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many terms used to describe this model of asynchronous programming and design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045654Z" creationid="pingfangx" creationdate="20190620T045654Z">
        <seg>有许多术语用于描述这种异步编程和设计模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072833Z" creationid="pingfangx" creationdate="20190620T072833Z">
        <seg>还有其他模式，如 Builder 模式，其中特定类的各种方法对同一类的项进行操作，通过方法的操作修改该项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several strategies available (such as buffering, dropping, keeping the latest) via the `BackpressureStrategy` parameter or via standard `Flowable` operators such as `onBackpressureBuffer`, `onBackpressureDrop`, `onBackpressureLatest` which also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100520Z" creationid="pingfangx" creationdate="20190617T100520Z">
        <seg>有几种策略可用(例如缓冲，丢弃，保持最新)通过 `BackpressureStrategy` 参数或通过标准的 `Flowable` 操作符，如 `onBackpressureBuffer`，`onBackpressureDrop`，`onBackpressureLatest` 它们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several ways of dealing with such situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T090224Z" creationid="pingfangx" creationdate="20190621T090224Z">
        <seg>有几种方法可以处理这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There exist one overload of this operator: `onBackpressureDrop(Consumer&lt;? super T&gt; onDrop)`  where the (shared) action is called with the value being dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015000Z" creationid="pingfangx" creationdate="20190624T015000Z">
        <seg>这个操作符有一个重载：`onBackpressureDrop(Consumer&lt;? super T&gt; onDrop)`，其中调用(共享)动作并删除该值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a variety that takes a &lt;a0&gt;Scheduler&lt;/a0&gt; as an argument:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075402Z" creationid="pingfangx" creationdate="20190620T075402Z">
        <seg>还有一个变种采用 &lt;a0&gt;Scheduler&lt;/a0&gt; 作为参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a version of this operator that allows you to perform the delay on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075341Z" creationid="pingfangx" creationdate="20190620T075341Z">
        <seg>还有一个此操作符的版本，允许您对特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 执行延迟：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also an instance version of this operator:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075313Z" creationid="pingfangx" creationdate="20190620T075313Z">
        <seg>还有这个操作符的实例版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no `FlowableSource` since `Publisher` is provided by the Reactive Streams library (and subtyping it wouldn't have helped with interoperation either).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104518Z" creationid="pingfangx" creationdate="20190617T104518Z">
        <seg>没有 `FlowableSource`，因为 `Publisher` 是由 Reactive Streams 库提供的(子类型化也不会有助于互操作)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no canonical naming standard, though there are many commonalities between implementations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064538Z" creationid="pingfangx" creationdate="20190620T064538Z">
        <seg>虽然实现之间存在许多共性，但没有规范的命名标准。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no error and everything runs smoothly with small memory usage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T080515Z" creationid="pingfangx" creationdate="20190621T080432Z">
        <seg>这将没有错误，一切运行顺畅，内存使用量很少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, 2.0.6 introduces specific exception wrappers to help distinguish and track down what was happening the time of the error:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T091015Z" creationid="pingfangx" creationdate="20190618T091015Z">
        <seg>因此，2.0.6 引入了特定的异常包装器，以帮助区分和跟踪错误发生时的情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, RxJava chose to name this operator `just(T)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101822Z" creationid="pingfangx" creationdate="20190617T101822Z">
        <seg>因此，RxJava 选择将此运算符命名为 `just(T)`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, if the two are swapped, the example still works the same:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082820Z" creationid="pingfangx" creationdate="20190621T082820Z">
        <seg>因此，如果两者交换，示例仍然正常工作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, many operators that required some reactive base type from the user now accept `Publisher` and `XSource`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061451Z" creationid="pingfangx" creationdate="20190618T061451Z">
        <seg>因此，许多需要用户使用某种响应基类型的运算符现在接受 `Publisher` 和 `XSource`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, one should do all field initialization in `onStart` or even before that and call `request()` last.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T083947Z" creationid="pingfangx" creationdate="20190621T083947Z">
        <seg>因此，应该在 `onStart` 中甚至在此之前进行所有字段初始化，并最后调用 `request()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the following sequence won't call `doOnCancel`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115027Z" creationid="pingfangx" creationdate="20190618T115027Z">
        <seg>因此，以下序列不会调用 `doOnCancel`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071736Z" creationid="pingfangx" creationdate="20190620T071736Z">
        <seg>这些 Rx 操作符允许您以声明方式组合异步序列，它具有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are available on all JVM platforms but some specific platforms, such as Android, have their own typical `Scheduler`s defined: `AndroidSchedulers.mainThread()`, `SwingScheduler.instance()` or `JavaFXSchedulers.gui()`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073609Z" creationid="pingfangx" creationdate="20190617T073609Z">
        <seg>这些在所有 JVM 平台上都可用，但某些特定平台（如 Android）有自己典型的 `Scheduler`：`AndroidSchedulers.mainThread()`，`SwingScheduler.instance()` 或 `JavaFXSchedulers.gui()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are by themselves worthy of a full series so let's see some very basic `Iterable` source that repeats some constant value indefinitely:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020455Z" creationid="pingfangx" creationdate="20190624T020455Z">
        <seg>这些本身就值得一个完整的系列，所以让我们看一些非常基本的 `Iterable` 源，它无限地重复一些常量值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are usually named with the suffix of the target type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100713Z" creationid="pingfangx" creationdate="20190617T100713Z">
        <seg>这些通常以目标类型的后缀命名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These instruct the operator to do some or all of its work on a particular Scheduler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T085827Z" creationid="pingfangx" creationdate="20190620T085827Z">
        <seg>这会指示操作符在特定的调度器上完成部分或全部工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These interfaces are, however, not standard in the sense of the Reactive Streams specification and are currently RxJava specific only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104540Z" creationid="pingfangx" creationdate="20190617T104540Z">
        <seg>但是，这些接口在 Reactive Streams 规范的意义上并不是标准的，并且目前仅针对 RxJava。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET “SelectMany” operator links to the documentation of the &lt;s0&gt;FlatMap&lt;/s0&gt; ReactiveX operator, of which “SelectMany” is the Rx.NET implementation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094320Z" creationid="pingfangx" creationdate="20190620T094320Z">
        <seg>这些链接到记录核心操作符的页面，该核心操作符最类似于特定于语言的操作符（例如，Rx.NET “SelectMany” 操作符链接到 &lt;s0&gt;FlatMap&lt;/s0&gt; ReactiveX 操作符的文档，其中“SelectMany”是 Rx.NET 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods allow only a single resource to be associated with the emitter at a time and setting a new one unsubscribes the old one automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022745Z" creationid="pingfangx" creationdate="20190624T022745Z">
        <seg>这些方法一次只允许一个源与 emitter 相关联，并且设置一个新资源会自动取消订阅旧资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072226Z" creationid="pingfangx" creationdate="20190620T072226Z">
        <seg>这些页面包含的一些操作符的信息，这些操作符不属于 ReactiveX 的核心，而是在一个或多个特定于语言的实现和/或可选模块中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These patterns also allow you to chain the methods in a similar way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072842Z" creationid="pingfangx" creationdate="20190620T072842Z">
        <seg>这些模式也允许您以类似的方式链接方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are naturally efficient because they execute when the response is ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041028Z" creationid="pingfangx" creationdate="20190620T041028Z">
        <seg>它们自然有效，因为它们在响应准备就绪时执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are purely to allow broad testing and feedback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105331Z" creationid="pingfangx" creationdate="20190617T105331Z">
        <seg>它们纯粹是为了进行广泛的测试和反馈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be modified in any way, or even removed, at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105240Z" creationid="pingfangx" creationdate="20190617T105240Z">
        <seg>它们可以随时以任何方式进行修改，甚至可以删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They will have different group ids (`io.reactivex.rxjava2` vs `io.reactivex`) and namespaces (`io.reactivex` vs `rx`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065528Z" creationid="pingfangx" creationdate="20190617T065528Z">
        <seg>他们将拥有不同的组 ID (`io.reactivex.rxjava2` vs `io.reactivex`) 和名称空间 (`io.reactivex` vs `rx`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;a1&gt;can be done&lt;/a1&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;c2&gt;Future.get()&lt;/c2&gt;, which eliminates the benefit of asynchronous execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T035327Z" creationid="pingfangx" creationdate="20190620T035327Z">
        <seg>当然，这 &lt;a1&gt;可以实现&lt;/a1&gt;，但它很快变得复杂(因而容易出错)或者过早地阻塞了 &lt;c2&gt;Future.get()&lt;/c2&gt;，这消除了异步执行的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This Scheduler has three additional methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091825Z" creationid="pingfangx" creationdate="20190620T091825Z">
        <seg>此调度器还有三种方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows constraining the memory usage of the dataflows in situations where there is generally no way for a step to know how many items the upstream will send to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071409Z" creationid="pingfangx" creationdate="20190617T071409Z">
        <seg>这允许在通常无法知道上游将向其发送多少项的步骤的情况下约束数据流的存储器使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows creating stream consumers with less internal state than the quite heavy `rx.Subscriber` of 1.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065453Z" creationid="pingfangx" creationdate="20190618T065453Z">
        <seg>这允许创建具有比 1.x 的非常重​​的 `rx.Subscriber` 更少的内部状态的流消费者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows for efficient execution and composition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T041859Z" creationid="pingfangx" creationdate="20190620T041859Z">
        <seg>这些操作符让执行和复合变得非常高效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to apply these operators one after the other, in a chain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072332Z" creationid="pingfangx" creationdate="20190620T072332Z">
        <seg>这允许您在链中一个接一个地应用这些操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is more flexible, because values can arrive synchronously or asynchronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042157Z" creationid="pingfangx" creationdate="20190620T042157Z">
        <seg>这种方法更灵活，因为值可以同步或异步到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior differs from 1.x where a `request` call went through a deferred logic that accumulated requests until an upstream `Producer` arrived at some time (This nature adds overhead to all operators and consumers in 1.x.) In 2.x, there is always a `Subscription` coming down first and 90% of the time there is no need to defer requesting.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072117Z" creationid="pingfangx" creationdate="20190618T072117Z">
        <seg>这种行为不同于 1.x，其中 `request` 调用通过延迟逻辑累积请求，直到上游 `Producer` 在某个时间到达(这种性质增加了 1.x 中所有运算符和消费者的开销)。在 2.x 中，总是有一个 `Subscription` 首先出现，90% 的时间不需要延迟请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This callback is executed as many times as the downstream requested.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021228Z" creationid="pingfangx" creationdate="20190624T021228Z">
        <seg>此回调的执行次数与下游请求的次数相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be achieved by moving the outer `flatMap` into the inner parts of the previous `flatMap` for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083752Z" creationid="pingfangx" creationdate="20190617T083752Z">
        <seg>这可以通过将外部 `flatMap` 移动到前一个 `flatMap` 的内部部分来实现，例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be used, for example, to have a larger but still fixed pool of threads (unlike `computation()` and `io()` respectively).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T073827Z" creationid="pingfangx" creationdate="20190617T073827Z">
        <seg>例如，这可用于拥有更大但仍然固定的线程池(分别与 `calculation()` 和 `io()` 不同)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful for testing interactions that depend on precise arrangements of actions in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091822Z" creationid="pingfangx" creationdate="20190620T091822Z">
        <seg>这对于测试依赖于及时精确的动作安排的交互是有用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful in some telemetry-like situations where the data may come in some bursty pattern but only the very latest is interesting for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015225Z" creationid="pingfangx" creationdate="20190624T015225Z">
        <seg>这在类似遥测的情况下非常有用，在这种情况下，数据可能会以某种突发模式出现，但只有最新的数据才会对处理感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can get also ambiguous when functional interface types get involved as the type argument `T`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103113Z" creationid="pingfangx" creationdate="20190617T103113Z">
        <seg>当函数接口类型作为类型参数 `T` 参与时，这也会变得有歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can have the effect of making the resulting Subject a “hot” Observable variant of the original “cold” Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083654Z" creationid="pingfangx" creationdate="20190620T083654Z">
        <seg>这可以使得到的 Subject 成为原始“冷” Observable 的“热” Observable 变体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This diagram explains how Singles are represented in marble diagrams:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075156Z" creationid="pingfangx" creationdate="20190620T075156Z">
        <seg>此图解释了 Single 如何在 marble 图中表示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document will use the following terms: An &lt;d0&gt;observer&lt;/d0&gt; &lt;d1&gt;subscribes&lt;/d1&gt; to an &lt;d2&gt;Observable&lt;/d2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T045732Z" creationid="pingfangx" creationdate="20190620T045732Z">
        <seg>本文档将使用以下术语：&lt;d0&gt;observer (观察者)&lt;/d0&gt; &lt;d1&gt;subscribes (订阅)&lt;/d1&gt; 到 &lt;d2&gt;Observable (可观察对象)&lt;/d2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation accompanies its explanations with “marble diagrams.” Here is how marble diagrams represent Observables and transformations of Observables:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T044318Z" creationid="pingfangx" creationdate="20190620T044318Z">
        <seg>本文档的说明会带有“marble 图”。以下是 marble 图如何表示 Observables 的 Observables 的转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation groups information about &lt;a0&gt;the various operators&lt;/a0&gt; and examples of their usage into the following pages:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071815Z" creationid="pingfangx" creationdate="20190620T071815Z">
        <seg>本文档将有关 &lt;a0&gt;各种操作符&lt;/a0&gt; 的信息及其用法示例分组到以下页面中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example flow squares the numbers from 1 to 10 on the **computation** `Scheduler` and consumes the results on the "main" thread (more precisely, the caller thread of `blockingSubscribe`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T075535Z" creationid="pingfangx" creationdate="20190617T075535Z">
        <seg>这个示例流在 **computation** `Scheduler` 上将数字 1 到 10 计算平方，并在 "main" 线程上消费结果(更确切地说，是 `blockingSubscribe` 的调用者线程)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This handler can be overridden with the method `RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090229Z" creationid="pingfangx" creationdate="20190618T090229Z">
        <seg>可以使用方法 `RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)` 覆盖此处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the consequence that even a backpressure-supporting source such as `range` will be completely realized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093127Z" creationid="pingfangx" creationdate="20190621T093030Z">
        <seg>这样的结果是，即使是一个支持背压的源，如 `range` ，也将完全 realized。（译注：不知道怎么译）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface is lightweight and combines request management with cancellation into a single interface `org.reactivestreams.Subscription` instead of having `rx.Producer` and `rx.Subscription` separately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065405Z" creationid="pingfangx" creationdate="20190618T065405Z">
        <seg>这个接口是轻量级的，它将请求管理和取消组合到单个接口 `org.reactivestreams.Subscription` 中，而不是单独使用 `rx.Producer` 和 `rx.Subscription`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a bounded version that signals `BufferOverflowError`in case its buffer reaches the given capacity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093138Z" creationid="pingfangx" creationdate="20190621T093138Z">
        <seg>这是一个有界版本，在其缓冲区达到给定容量的情况下发出 `BufferOverflowError` 信号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a large convenience for consumers and mappers that otherwise throw and would need `try-catch` to transform or suppress a checked exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064255Z" creationid="pingfangx" creationdate="20190618T064255Z">
        <seg>这对于消费者和映射器来说是一个很大的便利，否则会抛出并且需要 `try-catch` 来转换或抑制检查型异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a temporary state when `subscribe()` is called on a flow that establishes the chain of processing steps internally:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072138Z" creationid="pingfangx" creationdate="20190617T071850Z">
        <seg>当在内部建立处理步骤链的流上调用 `subscribe()` 时，这是一个临时状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064500Z" creationid="pingfangx" creationdate="20190620T064500Z">
        <seg>但是，这并不能保证立即发生，即使在没有观察者观察这些发射之后，Observable 也有可能在一段时间内产生并尝试发射数据项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often more apparent when each element is written on a separate line:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071017Z" creationid="pingfangx" creationdate="20190617T071017Z">
        <seg>当每个元素写在一个单独的行上时，这通常更明显：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is sometimes called **continuations** and, depending on what should happen and what types are involved, may involve various operators to accomplish.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083603Z" creationid="pingfangx" creationdate="20190617T083603Z">
        <seg>这有时被称为 **continuations** ，并且取决于应该发生什么以及涉及什么类型，可能涉及各种操作符来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the state when the flows are actively emitting items, errors or completion signals:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072024Z" creationid="pingfangx" creationdate="20190617T072024Z">
        <seg>这是流主动发出项目，错误或完成信号时的状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the true power of lazily evaluating and computing inside `Flowable`s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020651Z" creationid="pingfangx" creationdate="20190624T020651Z">
        <seg>这是 `Flowable` 内部的懒评估和计算的真正力量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very important because now any operation you can perform on an Iterable, you can also perform on an Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042520Z" creationid="pingfangx" creationdate="20190620T042520Z">
        <seg>这非常重要，因为现在您可以在 Iterable 上执行的任何操作，都可以在 Observable 上执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is when the **subscription side-effects** are triggered (see `doOnSubscribe`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072144Z" creationid="pingfangx" creationdate="20190617T071932Z">
        <seg>这是 **subscription side-effects (订阅副作用)** 的触发时机(参见 `doOnSubscribe`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means errors that can't be emitted because the downstream's lifecycle already reached its terminal state or the downstream cancelled a sequence which was about to emit an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090043Z" creationid="pingfangx" creationdate="20190618T090043Z">
        <seg>这意味着无法发出的错误，因为下游的生命周期已达到其终端状态，或者下游取消了将要发出错误的序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that `Observable&lt;Void&gt;` can no longer emit any values but only terminate normally or with an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052823Z" creationid="pingfangx" creationdate="20190618T052823Z">
        <seg>这意味着 `Observable&lt;Void&gt;` 不能再发出任何值，只能正常终止或带异常终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that an invocation of `onSubscribe(Disposable)` is potentially followed by one of the other `onXXX` methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060840Z" creationid="pingfangx" creationdate="20190618T060840Z">
        <seg>这意味着 `onSubscribe(Disposable)` 的调用可能跟随其他 `onXXX` 方法之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method takes as a parameter the item emitted by the Observable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060250Z" creationid="pingfangx" creationdate="20190620T060250Z">
        <seg>此方法将 Observable 发射的项作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This negotiation is based on the computer science concept of co-routines (I call you, you call me).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190829T150449Z" creationid="pingfangx" creationdate="20190621T081011Z">
        <seg>这个协商是基于计算机科学的 co-routines (译注：协程？)概念(我调用你，你调用我)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator in its parameterless form reintroduces an unbounded buffer between the upstream source and the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T092414Z" creationid="pingfangx" creationdate="20190621T092414Z">
        <seg>此操作符以无参数形式在上游源和下游操作符之间重新引入无边界缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator is useful when one can safely ignore values from a source (such as mouse moves or current GPS location signals) as there will be more up-to-date values later on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014819Z" creationid="pingfangx" creationdate="20190624T014819Z">
        <seg>当可以安全地忽略来自源的值(例如鼠标移动或当前 GPS 位置信号)时，此操作符非常有用，因为稍后会有更多的最新值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This overload calls a (shared) action in case an overflow happens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093437Z" creationid="pingfangx" creationdate="20190621T093437Z">
        <seg>如果发生溢出，此重载会调用(共享)操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This overload is actually more useful as it let's one define what to do in case the capacity has been reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T093534Z" creationid="pingfangx" creationdate="20190621T093534Z">
        <seg>这种重载实际上更有用，因为我们可以定义在达到容量时要做什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043840Z" creationid="pingfangx" creationdate="20190620T043840Z">
        <seg>这个页面解释了什么是响应模式(reactive pattern)？以及什么是可观察对象(Observables)和观察者(observers)？(以及观察者如何订阅 Observables)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page first lists what could be considered the “core” operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T094045Z" creationid="pingfangx" creationdate="20190620T094045Z">
        <seg>该页面首先列出了可以被视为 ReactiveX 中的“核心”操作符的内容，以及指向这些页面的链接，这些页面具有关于这些操作符如何工作以及特定语言特定的 ReactiveX 版本如何实现这些操作符的更深入信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T052909Z" creationid="pingfangx" creationdate="20190620T052909Z">
        <seg>此页面使用类似 Groovy 的伪代码作为示例，但在许多语言中都有 ReactiveX 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T043646Z" creationid="pingfangx" creationdate="20190620T043534Z">
        <seg>这种模式有利于并发操作，因为它不需要在等待 Observable 发射对象时阻塞，而是以观察者的形式创建一个哨兵，随时准备在 Observable 发射对象做出适当的反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be backwards compatible but does behave differently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105035Z" creationid="pingfangx" creationdate="20190617T105035Z">
        <seg>这应该是向后兼容的，但表现不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This style of chaining methods is called a **fluent API** which resembles the **builder pattern**.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072620Z" creationid="pingfangx" creationdate="20190617T072620Z">
        <seg>这种链式方法称为 **fluent API (流式 API)**，类似于 **builder pattern (建造者模式)**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tree can help you find the ReactiveX Observable operator you’re looking for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103812Z" creationid="pingfangx" creationdate="20190620T103812Z">
        <seg>此树可以帮助你找到你正在寻找的 ReactiveX Observable 操作符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variant allows cleaning up the values themselves (e.g., releasing associated resources).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015008Z" creationid="pingfangx" creationdate="20190624T015008Z">
        <seg>该变体允许清除值本身(例如，释放相关资源)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This was practically unnecessary and the Reactive-Streams specification states that when a terminal event arrives at a `Subscriber`, the upstream `Subscription` should be considered cancelled and thus calling `cancel()` is a no-op.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114952Z" creationid="pingfangx" creationdate="20190618T114952Z">
        <seg>这实际上是不必要的，Reactive-Streams 规范声明当终端事件到达 `Subscriber` 时，上游的 `Subscription` 应被视为取消，因此调用 `cancel()` 是无操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wiki page attempts to summarize what has changed and describes how to rewrite 1.x code into 2.x code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T051858Z" creationid="pingfangx" creationdate="20190618T051858Z">
        <seg>此 Wiki 页面试图总结已更改的内容，并描述如何将 1.x 代码重写为 2.x 代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will print:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071625Z" creationid="pingfangx" creationdate="20190618T071625Z">
        <seg>这将打印：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This, too, has a &lt;a0&gt;Scheduler&lt;/a0&gt;-specific version:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T080543Z" creationid="pingfangx" creationdate="20190620T080543Z">
        <seg>这也有一个 &lt;a0&gt;Scheduler&lt;/a0&gt; 特定版本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those APIs feature some form of `addListener`/`removeListener` calls that one can utilize:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T022400Z" creationid="pingfangx" creationdate="20190624T022400Z">
        <seg>这些 API 具有某种形式的 `addListener`/`removeListener` 调用，可以使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061715Z" creationid="pingfangx" creationdate="20190620T061715Z">
        <seg>那些 Observable 可以(如果他们没有其他感兴趣的观察者)选择停止生成要发射的新项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those return a "global" scheduler instance whereas `test()` returned always a new instance of the `TestScheduler`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093740Z" creationid="pingfangx" creationdate="20190618T093740Z">
        <seg>那些返回“全局”调度器实例，而 `test()` 总是返回 `TestScheduler` 的新实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that have a particular default Scheduler include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091455Z" creationid="pingfangx" creationdate="20190620T091455Z">
        <seg>具有特定默认调度器的包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those who are using Mockito and mocked `Observer` in 1.x has to mock the `Subscriber.onSubscribe` method to issue an initial request, otherwise, the sequence will hang or fail with hot sources:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101902Z" creationid="pingfangx" creationdate="20190618T101902Z">
        <seg>那些在 1.x 中使用 Mockito 并模拟 `Observer` 的人必须模拟 `Subscriber.onSubscribe` 方法来发出初始请求，否则，序列将因热源而挂起或失败：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075639Z" creationid="pingfangx" creationdate="20190620T075639Z">
        <seg>如果订阅后某个项目在指定的时间段内未发射该项目，则超时将导致 Single 中止并发射错误通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To allow having RxJava 1.x and RxJava 2.x side-by-side, RxJava 2.x is under the maven coordinates `io.reactivex.rxjava2:rxjava:2.x.y` and classes are accessible below `io.reactivex`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052632Z" creationid="pingfangx" creationdate="20190618T052632Z">
        <seg>为了允许 RxJava 1.x 和 RxJava 2.x 共存，RxJava 2.x 位于 maven 坐标 `io.reactivex.rxjava2:rxjava:2.x.y` 下，类可以在 `io.reactivex 下面访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid overwhelming such steps, which usually would manifest itself as increased memory usage due to temporary buffering or the need for skipping/dropping data, a so-called backpressure is applied, which is a form of flow control where the steps can express how many items are they ready to process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071348Z" creationid="pingfangx" creationdate="20190617T071348Z">
        <seg>为了避免 overwhelming 这些步骤，通常表现为由于临时缓冲或需要跳过/丢弃数据而增加内存，所以应用所谓的背压，这是流量控制的一种形式，其中步骤可以表达多少项目准备好了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid the name clash, the 1.x `rx.Subscription` has been renamed into `io.reactivex.Disposable` (somewhat resembling .NET's own IDisposable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T072820Z" creationid="pingfangx" creationdate="20190618T072820Z">
        <seg>为避免名称冲突，1.x 的 `rx .Subscription` 已重命名为 `io .reactivex .Disposable`(有点类似于 .NET 自己的 IDisposable)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this situation, make sure you call `request` **after** all initialization have been done in `onSubscribe`/`onStart`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T071838Z" creationid="pingfangx" creationdate="20190618T071838Z">
        <seg>为了避免这种情况，请确保在 `onSubscribe`/`onStart` 中完成所有初始化 **之后** 调用 `request`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To bridge the gap we defined abstract classes `DefaultSubscriber`, `ResourceSubscriber` and `DisposableSubscriber` (plus their `XObserver` variants) for `Flowable` (and `Observable`) respectively that offers resource tracking support (of `Disposable`s) just like `rx.Subscriber` and can be cancelled/disposed externally via `dispose()`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070302Z" creationid="pingfangx" creationdate="20190618T070302Z">
        <seg>为弥合这一差距，我们分别为 `Flowable`(和 `Observable`)定义了抽象类 `DefaultSubscriber`，`ResourceSubscriber` 和 `DisposableSubscriber`(加上它们的 `XObserver` 变体)，提供了资源跟踪支持(`Disposable`)就像 `rx.Subscriber` 一样，并可以通过 `dispose()` 从外部取消/处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105603Z" creationid="pingfangx" creationdate="20190617T105603Z">
        <seg>要构建：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle such cases, RxJava has the `generate` factory method family.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021012Z" creationid="pingfangx" creationdate="20190624T021012Z">
        <seg>为了处理这种情况，RxJava 有 `generate` 工厂方法系列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle such cases, a recent version of RxJava introduced the `create(emitter)` factory method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021719Z" creationid="pingfangx" creationdate="20190624T021719Z">
        <seg>为了处理这种情况，最新版本的 RxJava 引入了 `create(emitter)` 工厂方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate, the example can be rewritten as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072726Z" creationid="pingfangx" creationdate="20190617T072726Z">
        <seg>为了说明，该示例可以重写如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate this opportunity, many operator names are suffixed with the `DelayError` words (while others feature a `delayError` or `delayErrors` boolean flag in one of their overloads):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T103545Z" creationid="pingfangx" creationdate="20190617T103545Z">
        <seg>为了表明这个机会，许多运算符名称后缀为 `DelayError` (而其他运算符名称在其中一个重载中具有 `delayError` 或 `delayErrors` 布尔标志)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make sure the final API of 2.0 is clean as possible, we remove methods and other components between release candidates without deprecating them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061528Z" creationid="pingfangx" creationdate="20190619T061528Z">
        <seg>为了确保 2.0 的最终 API 尽可能干净，我们在发布候选版本之间删除方法和其他组件而不弃用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent this, operators use so-called trampolining logic that prevents such reentrant calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190621T082411Z" creationid="pingfangx" creationdate="20190621T082411Z">
        <seg>为了防止这种情况，操作符使用所谓的 trampolining 逻辑来阻止这种可重入的调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remedy this, the method `E subscribeWith(E subscriber)` has been added to each base reactive class which returns its input subscriber/observer as is.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070729Z" creationid="pingfangx" creationdate="20190618T070729Z">
        <seg>为了解决这个问题，方法 `E subscribeWith(E subscriber)` 被添加到每个基本响应类中，该方法按原样返回其输入的订阅者/观察者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To schedule recursive calls, you can use &lt;c0&gt;schedule&lt;/c0&gt; and then &lt;c1&gt;schedule(this)&lt;/c1&gt; on the Worker object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092138Z" creationid="pingfangx" creationdate="20190620T092138Z">
        <seg>要调度递归调用，可以在 Worker 对象上使用 &lt;c0&gt;schedule&lt;/c0&gt; 然后 &lt;c1&gt;schedule(this)&lt;/c1&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support our internal testing, all base reactive types now feature `test()` methods (which is a huge convenience for us) returning `TestSubscriber` or `TestObserver`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095836Z" creationid="pingfangx" creationdate="20190618T095836Z">
        <seg>为了支持我们的内部测试，所有基本响应类型现在都有 `test()` 方法(这对我们来说非常方便)返回 `TestSubscriber` 或 `TestObserver`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transforming Observable Items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T071854Z" creationid="pingfangx" creationdate="20190620T071854Z">
        <seg>转换 Observable 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transforming Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095411Z" creationid="pingfangx" creationdate="20190620T095411Z">
        <seg>转换 Observables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190828T072948Z" creationid="pingfangx" creationdate="20190828T072948Z">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you can move computations or blocking IO to some other thread via `subscribeOn`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T072819Z" creationid="pingfangx" creationdate="20190617T072819Z">
        <seg>通常，您可以通过 `subscribeOn` 将计算或阻塞 IO 移动到其他线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, RxJava can't tell which of these out-of-lifecycle, undeliverable exceptions should or shouldn't crash your app.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090909Z" creationid="pingfangx" creationdate="20190618T090909Z">
        <seg>不幸的是，RxJava 无法分辨这些生命周期中的哪些，无法传递的异常应该或不应该使您的应用程序崩溃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, `just` is often mistaken for a way to compute something dynamically to be consumed by `Subscriber`s:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015754Z" creationid="pingfangx" creationdate="20190624T015722Z">
        <seg>不幸的是，`just` 经常被误认为是一种供订阅者使用的动态计算东西的方式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, many method calls across the JVM and other libraries throw checked exceptions and need to be wrapped into `try-catch`es as the functional interfaces used by this class don't allow throwing checked exceptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T021458Z" creationid="pingfangx" creationdate="20190624T021458Z">
        <seg>不幸的是，JVM 和其他库中的许多方法调用抛出了检查型异常，需要将其包装到 `try-catch` 中，因为此类使用的函数接口不允许抛出检查型异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, so many depend on it that we couldn't remove or rename it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T094311Z" creationid="pingfangx" creationdate="20190618T094311Z">
        <seg>不幸的是，很多人依赖它，我们无法移除或重命名它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, the target language (and pre-existing conventions) may not give too much help in this regard (unusable keywords, type erasure, type ambiguities, etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101401Z" creationid="pingfangx" creationdate="20190617T101401Z">
        <seg>不幸的是，目标语言(以及预先存在的约定)在这方面可能不会提供太多帮助(不可用的关键字，类型擦除，类型歧义等)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this approach doesn't work and the example does not print `2` at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102539Z" creationid="pingfangx" creationdate="20190617T102539Z">
        <seg>不幸的是，这种方法不起作用，该示例根本不打印 `2`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this prints `0` because `Single.just(count.get())` is evaluated at **assembly time** when the dataflow hasn't even run yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092426Z" creationid="pingfangx" creationdate="20190617T092324Z">
        <seg>不幸的是，这会输出 `0`，`Single.just(count.get())` 计算于 **assembly time**，数据流尚未运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, usually, these classical callback-style APIs don't support cancellation, but if they do, one can setup their cancellation just like in the previoius examples (with perhaps a more involved way though).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T023047Z" creationid="pingfangx" creationdate="20190624T023047Z">
        <seg>不幸的是，通常，这些经典的回调式 API 不支持取消，但是如果它们这样支持，就可以像在上一示例中那样设置取消(尽管可能采用更复杂的方式)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike `Flowable`, if there is only a single value to be signalled, only `onSuccess` is called and `onComplete` is not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T060927Z" creationid="pingfangx" creationdate="20190618T060927Z">
        <seg>与 `Flowable` 不同，如果只有一个值要发出信号，则只调用 `onSuccess` 而不调用 `onComplete`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike `onBackpressureDrop` there is always a value available for consumption if the downstream happened to be lagging behind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015151Z" creationid="pingfangx" creationdate="20190624T015151Z">
        <seg>与 `onBackpressureDrop` 不同，如果下游恰好落后，总有一个值可供消费。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsubscribing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061437Z" creationid="pingfangx" creationdate="20190620T061437Z">
        <seg>取消订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon calling either method, the Single terminates and the subscription to it ends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073823Z" creationid="pingfangx" creationdate="20190620T073823Z">
        <seg>在调用任一方法时，Single 终止并且对它的订阅结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use `Schedulers.trampoline()` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T093614Z" creationid="pingfangx" creationdate="20190618T093614Z">
        <seg>请改用 `Schedulers.trampoline()`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use `safeSubscribe` to get an explicit safety wrapper around a consumer type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053814Z" creationid="pingfangx" creationdate="20190619T053814Z">
        <seg>使用 `safeSubscribe` 获取消费者类型的显式安全包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use that variable and its new value to do something useful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T053026Z" creationid="pingfangx" creationdate="20190620T053026Z">
        <seg>使用该变量及其新值来做一些有用的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users switching from 1.x to 2.x have to re-organize their imports, but carefully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T052645Z" creationid="pingfangx" creationdate="20190618T052645Z">
        <seg>从 1.x 切换到 2.x 的用户必须重新组织他们的导入，但要小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Schedulers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091922Z" creationid="pingfangx" creationdate="20190620T091922Z">
        <seg>使用调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using `Observable` has lower overhead in general than `Flowable`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054816Z" creationid="pingfangx" creationdate="20190618T054816Z">
        <seg>使用 `Observable` 通常比 `Flowable' 具有更低的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utility Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072003Z" creationid="pingfangx" creationdate="20190620T072003Z">
        <seg>辅助操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Varieties of Scheduler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090908Z" creationid="pingfangx" creationdate="20190620T090908Z">
        <seg>调度器的种类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Varieties of Subject</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T083727Z" creationid="pingfangx" creationdate="20190620T083727Z">
        <seg>Subject 的种类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 1.x will be supported for several years along with 2.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104654Z" creationid="pingfangx" creationdate="20190617T104654Z">
        <seg>版本 1.x 将与 2.x 一起支持多年。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 2.x and 1.x will live side-by-side for several years.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T065457Z" creationid="pingfangx" creationdate="20190617T065457Z">
        <seg>版本 2.x 和 1.x 将并存数年。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version 2.x is now considered stable and final.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T104650Z" creationid="pingfangx" creationdate="20190617T104650Z">
        <seg>版本 2.x 现在被认为是稳定且最终的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can distinguish two kinds of factory methods: cold "generators" that either return and generate elements based on downstream demand and hot "pushers" that usually bridge non-reactive and/or non-backpressurable data sources and layer some backpressure handling on top of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015614Z" creationid="pingfangx" creationdate="20190624T015614Z">
        <seg>我们可以区分两种工厂方法：基于下游需求返回和生成元素的冷“generators”和通常桥接非响应和/或非背压数据源并在他们上面层叠一些背压处理的热“pushers”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We followed the naming convention of Java 8 by defining `io.reactivex.functions.Function` and `io.reactivex.functions.BiFunction`, plus renaming `Func3` - `Func9` into `Function3` - `Function9` respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T065000Z" creationid="pingfangx" creationdate="20190618T065000Z">
        <seg>我们遵循 Java 8 的命名约定，定义了 `io.reactivex.functions.Function` 和 `io.reactivex.functions.BiFunction`，并分别将 `Func3`  - `Func9` 重命名为 `Function3`  - `Function9`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need something that defers the evaluation of this `Single` source until **runtime** when the main source completes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092517Z" creationid="pingfangx" creationdate="20190617T092517Z">
        <seg>我们需要一些推迟计算这个 `Single` 源的东西直到 **runtime**，当主源完成时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We try to remedy this situation in 2.x by having `io.reactivex.Observable` non-backpressured and the new `io.reactivex.Flowable` be the backpressure-enabled base reactive class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053358Z" creationid="pingfangx" creationdate="20190618T053358Z">
        <seg>我们尝试在 2.x 中纠正这种情况，通过使基本响应类 `io.reactivex.Observable` 非背压并且新的 `io.reactivex.Flowable` 支持背压。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What people actually need is the method `fromCallable`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015858Z" creationid="pingfangx" creationdate="20190624T015858Z">
        <seg>人们真正需要的是 `fromCallable` 方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an observer subscribes to a &lt;c0&gt;BehaviorSubject&lt;/c0&gt;, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T084158Z" creationid="pingfangx" creationdate="20190620T084158Z">
        <seg>当观察者订阅 &lt;c0&gt;BehaviorSubject&lt;/c0&gt; 时，它首先发射源 Observable 最近发射的项（或者如果尚未发射则会发射种子/默认值），然后继续发射任何稍后由源 Observable 发射的其他项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When architecting dataflows (as an end-consumer of RxJava) or deciding upon what type your 2.x compatible library should take and return, you can consider a few factors that should help you avoid problems down the line such as `MissingBackpressureException` or `OutOfMemoryError`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T053633Z" creationid="pingfangx" creationdate="20190618T053633Z">
        <seg>在构建数据流(作为 RxJava 的最终使用者)或决定 2.x 兼容库应该采用和返回的类型时，您可以考虑一些可以帮助您避免问题的因素，相关问题例如 `MissingBackpressureException` 或 ` OutOfMemoryError`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When does an Observable begin emitting its sequence of items?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064950Z" creationid="pingfangx" creationdate="20190620T064950Z">
        <seg>Observable 何时开始发射其数据项序列？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the dataflow runs through asynchronous steps, each step may perform different things with different speed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T071154Z" creationid="pingfangx" creationdate="20190617T071154Z">
        <seg>当数据流通过异步步骤时，每个步骤可以以不同的速度执行不同的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever the downstream is not ready to receive values, this operator will drop that elemenet from the sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T014731Z" creationid="pingfangx" creationdate="20190624T014731Z">
        <seg>每当下游未准备好接收值时，此操作符将从序列中删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which looks something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055915Z" creationid="pingfangx" creationdate="20190620T055915Z">
        <seg>看起来像这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why Use Observables?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T034112Z" creationid="pingfangx" creationdate="20190620T034112Z">
        <seg>为什么要使用 Observables？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the two examples before, the 2.x code can now look like this since `ResourceSubscriber` implements `Disposable` directly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T070804Z" creationid="pingfangx" creationdate="20190618T070804Z">
        <seg>使用前面的两个例子，2.x 代码现在看起来像这样，因为 `ResourceSubscriber` 直接实现 `Disposable`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With these additions, ReactiveX harmonizes the Iterable and Observable types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042451Z" creationid="pingfangx" creationdate="20190620T042451Z">
        <seg>通过这些添加，ReactiveX 使得 Iterable 和 Observable 类型保持一致了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a specific handler, RxJava defaults to printing the `Throwable`'s stacktrace to the console and calls the current thread's uncaught exception handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T090305Z" creationid="pingfangx" creationdate="20190618T090305Z">
        <seg>如果没有特定的处理程序，RxJava 默认将 `Throwable` 的堆栈跟踪打印到控制台并调用当前线程的未捕获异常处理程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with this new base reactive type is practically the same as the others as it offers a modest subset of the `Flowable` operators that make sense with a 0 or 1 item sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T061038Z" creationid="pingfangx" creationdate="20190618T061038Z">
        <seg>使用这种新的基本响应类型实际上与其他类型相同，因为它提供了一个适用于 0 或 1 项序列的 `Flowable` 运算符的适度子集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing such state machines as `Iterable`s is somewhat complicated (but still easier than writing an `Flowable` for consuming it) and unlike C#, Java doesn't have any support from the compiler to build such state machines by simply writing classically looking code (with `yield return` and `yield break`).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020416Z" creationid="pingfangx" creationdate="20190624T020416Z">
        <seg>编写像 `Iterable` 这样的状态机有点复杂(但是比编写一个 `Flowable` 更容易使用它)并且与 C＃不同，Java 没有任何编译器支持通过简单编写经典外观来构建这样的状态机代码(带有 `yield return` 和 `yield break`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yet another example is `Catch` which was named `onErrorResumeNext`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T101913Z" creationid="pingfangx" creationdate="20190617T101913Z">
        <seg>另一个例子是 `Catch`，它命名为 `onErrorResumeNext`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify a particular &lt;a0&gt;Scheduler&lt;/a0&gt; for the timer to operate on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T075655Z" creationid="pingfangx" creationdate="20190620T075655Z">
        <seg>您还可以为要运行的计时器指定特定的 &lt;a0&gt;Scheduler&lt;/a0&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use &lt;a0&gt;a version of &lt;c1&gt;schedule&lt;/c1&gt;&lt;/a0&gt; that delays your action on the given Scheduler until a certain timespan has passed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T092431Z" creationid="pingfangx" creationdate="20190620T092431Z">
        <seg>您还可以使用 &lt;a0&gt;&lt;c1&gt;schedule&lt;/c1&gt; 的版本&lt;/a0&gt;，该版本会在给定调度器上延时你的操作，直到超过某个时间跨度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T061700Z" creationid="pingfangx" creationdate="20190620T061700Z">
        <seg>您可以调用此方法来指示订阅服务器不再对其当前订阅的任何 Observable 感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the class and add your own custom `subscribeActual` behavior to achieve something similar to the 1.x features:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063923Z" creationid="pingfangx" creationdate="20190618T063923Z">
        <seg>您可以继承类并添加自己的自定义 `subscribeActual` 行为，以实现类似于 1.x 功能的操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of the Observable class as a “push” equivalent to &lt;a0&gt;Iterable&lt;/a0&gt;, which is a “pull.” With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042125Z" creationid="pingfangx" creationdate="20190620T042125Z">
        <seg>您可以将 Observable 类的“推”，视为等同于 &lt;a0&gt;Iterable&lt;/a0&gt; 的“拉”。对于 Iterable，消费者从生产者拉取值，并且线程阻塞直到这些值到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to use `Subject.toSerialized()` and `FlowableProcessor.toSerialized()` instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T063632Z" creationid="pingfangx" creationdate="20190618T063632Z">
        <seg>您必须使用 `Subject.toSerialized()` 和 `FlowableProcessor.toSerialized()` 代替。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to handle an element frequency of 1000 Hz or less with Observable but consider using sampling/debouncing anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T054651Z" creationid="pingfangx" creationdate="20190618T054651Z">
        <seg>您可以使用 Observable 处理 1000 Hz 或更低的元素频率，但无论如何都要考虑使用 sampling/debouncing。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You obtain a Scheduler from the factory methods described in &lt;a0&gt;the &lt;c1&gt;Schedulers&lt;/c1&gt; class&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T090922Z" creationid="pingfangx" creationdate="20190620T090922Z">
        <seg>您可以从 &lt;a0&gt;&lt;c1&gt;Schedulers&lt;/c1&gt; 类&lt;/a0&gt; 中描述的工厂方法获取 Scheduler。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use or rely on them in any production code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105326Z" creationid="pingfangx" creationdate="20190617T105326Z">
        <seg>您不应该在任何生产代码中使用或依赖它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your observer implements some subset of the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T060237Z" creationid="pingfangx" creationdate="20190620T060237Z">
        <seg>你的观察者实现以下方法的某些子集：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Action1` has been renamed to `Consumer` and `Action2` is called `BiConsumer`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064844Z" creationid="pingfangx" creationdate="20190618T064844Z">
        <seg>`Action1` 已重命名为 `Consumer`，`Action2` 被称为 `BiConsumer`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ActionN` is replaced by the `Consumer&lt;Object[]&gt;` type declaration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T064910Z" creationid="pingfangx" creationdate="20190618T064910Z">
        <seg>`ActionN` 被 `Consumer&lt;Object[]&gt;` 类型声明所取代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Flowable` can be tested with `io.reactivex.subscribers.TestSubscriber` whereas the non-backpressured `Observable`, `Single`, `Maybe` and `Completable` can be tested with `io.reactivex.observers.TestObserver`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T095806Z" creationid="pingfangx" creationdate="20190618T095806Z">
        <seg>`Flowable` 可以使用 `io.reactivex.subscribers.TestSubscriber` 进行测试，而非背压的 `Observable`，`Single`，`Maybe` 和 `Completable` 可以使用 `io.reactivex.observers.TestObserver` 进行测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Maybe&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061253Z" creationid="pingfangx" creationdate="20190619T061253Z">
        <seg>`Maybe&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Observable&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061251Z" creationid="pingfangx" creationdate="20190619T061251Z">
        <seg>`Observable&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061302Z" creationid="pingfangx" creationdate="20190619T061302Z">
        <seg>`Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`TestSubscriber` has the `test(long initialRequest)` and `test(long initialRequest, boolean cancel)` overloads to specify the initial request amount and whether the `TestSubscriber` should be also immediately cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101738Z" creationid="pingfangx" creationdate="20190618T101738Z">
        <seg>`TestSubscriber` 有 `test(long initialRequest)` 和 `test(long initialRequest，boolean cancel)` 重载来指定初始请求数量以及是否应立即取消 `TestSubscriber`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`flatMap` is a powerful operator and helps in a lot of situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T083339Z" creationid="pingfangx" creationdate="20190617T083339Z">
        <seg>`flatMap` 是一个功能强大的运算符，可以在很多情况下提供帮助。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`just` is great when there is a constant value we'd like to jump-start a sequence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T015708Z" creationid="pingfangx" creationdate="20190624T015708Z">
        <seg>当有一个恒定的值我们想要跳过一个序列时，`just` 很棒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`just` won't emit its constant value until requested when it is mapped to the result of the `computeValue`, still called for each subscriber individually.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190624T020123Z" creationid="pingfangx" creationdate="20190624T020123Z">
        <seg>`just` 在被映射到 `computeValue` 的结果之前被请求时不会发射它的常量值，仍然单独为每个用户调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a Single passes this method the Throwable that caused the Single to be unable to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073728Z" creationid="pingfangx" creationdate="20190620T073728Z">
        <seg>Single 将导致 Single 无法发射项目的 Throwable 传递给此方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a Single passes this method the sole item that the Single emits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T073630Z" creationid="pingfangx" creationdate="20190620T073630Z">
        <seg>Single 将发射的唯一项目传递给此方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a variety of operators that enforce particular flow-control policies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T072125Z" creationid="pingfangx" creationdate="20190620T072125Z">
        <seg>各种执行特定流量控制策略的操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `amb(ObservableSource...)` overload, 2-9 argument versions dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112016Z" creationid="pingfangx" creationdate="20190618T112016Z">
        <seg>添加了 `amb(ObservableSource...)` 重载，2-9 个参数的版本被删除了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `concatArrayEager` and `concatArrayEagerDelayError`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112940Z" creationid="pingfangx" creationdate="20190618T112940Z">
        <seg>添加 `concatArrayEager` 和 `concatArrayEagerDelayError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `concatArray` and `concatArrayDelayError`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112930Z" creationid="pingfangx" creationdate="20190618T112930Z">
        <seg>添加 `concatArray` 和 `concatArrayDelayError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `doOnLifecylce` to handle `onSubscribe`, `request` and `cancel` peeking</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052545Z" creationid="pingfangx" creationdate="20190619T052545Z">
        <seg>添加 `doOnLifecylce` 来处理 `onSubscribe`，`request` 和 `cancel` peeking</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `forEachWhile(Predicate&lt;T&gt;, [Consumer&lt;Throwable&gt;, [Action]])` for conditionally stopping consumption</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053032Z" creationid="pingfangx" creationdate="20190619T053032Z">
        <seg>添加 `forEachWhile(Predicate&lt;T&gt;, [Consumer&lt;Throwable&gt;, [Action]])` 以有条件地停止消费</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `fromPublisher`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114304Z" creationid="pingfangx" creationdate="20190618T114304Z">
        <seg>添加 `fromPublisher`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `intervalRange()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114315Z" creationid="pingfangx" creationdate="20190618T114315Z">
        <seg>添加 `intervalRange()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `reduceWith(Callable, BiFunction)` to reduce in a Subscriber-individual manner, returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053555Z" creationid="pingfangx" creationdate="20190619T053415Z">
        <seg>添加 `reduceWith(Callable, BiFunction)` 以订阅者个人的方式减少，返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `repeatUntil(BooleanSupplier)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053425Z" creationid="pingfangx" creationdate="20190619T053425Z">
        <seg>添加 `repeatUntil(BooleanSupplier)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `retry(Predicate)`, `retry(int, Predicate)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053442Z" creationid="pingfangx" creationdate="20190619T053442Z">
        <seg>添加了 `retry(Predicate)`，`retry(int，Predicate)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `retryUntil(BooleanSupplier)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053445Z" creationid="pingfangx" creationdate="20190619T053445Z">
        <seg>添加了 `retryUntil(BooleanSupplier)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `scanWith(Callable, BiFunction)` to scan in a Subscriber-individual manner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053540Z" creationid="pingfangx" creationdate="20190619T053540Z">
        <seg>添加了 `scanWith(Callable, BiFunction)` 来以订阅者个人的方式进行扫描</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `startWithArray` to disambiguate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053729Z" creationid="pingfangx" creationdate="20190619T053729Z">
        <seg>添加了 `startWithArray` 来消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `subscribeWith` that returns its input after subscription</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053822Z" creationid="pingfangx" creationdate="20190619T053822Z">
        <seg>添加了 `subscribeWith`，在订阅后返回其输入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `test()` (returns TestSubscriber subscribed to this) with overloads to fluently test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053900Z" creationid="pingfangx" creationdate="20190619T053900Z">
        <seg>添加了 `test()` (返回 TestSubscriber 订阅了这个)，带有重载以流畅地测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `toFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054030Z" creationid="pingfangx" creationdate="20190619T054030Z">
        <seg>添加了 `toFuture`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added `toObservable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T054032Z" creationid="pingfangx" creationdate="20190619T054032Z">
        <seg>添加了 `toObservable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `bufferSize`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061908Z" creationid="pingfangx" creationdate="20190618T114358Z">
        <seg>添加带 `bufferSize` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `bufferSize` and `delayError` option, *the custom internal map version didn't make it into RC1*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053105Z" creationid="pingfangx" creationdate="20190619T053105Z">
        <seg>添加带有 `bufferSize` 和 'delayerror' 选项的重载，*自定义内部映射版本没有将其转换为 RC1*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053316Z" creationid="pingfangx" creationdate="20190618T114415Z">
        <seg>添加带 `prefetch` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch` argument</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053832Z" creationid="pingfangx" creationdate="20190619T053832Z">
        <seg>添加了带有 `prefetch` 参数的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overload with `prefetch` argument, 5-9 source overloads dropped, use `concatArray` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112702Z" creationid="pingfangx" creationdate="20190618T112702Z">
        <seg>添加带 `prefetch` 参数的重载，删除了 5-9 个源的重载，使用 `concatArray` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `bufferSize` and `delayError` options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053708Z" creationid="pingfangx" creationdate="20190619T053708Z">
        <seg>添加了带有 `bufferSize` 和 `delayError` 选项的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `bufferSize` and `delayErrors` capabilities, disambiguated to `zipArray` and `zipIterable`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114528Z" creationid="pingfangx" creationdate="20190618T114528Z">
        <seg>添加带 `bufferSize` 和 `delayErrors` 功能的重载，使用 `zipArray` 和 `zipIterable` 消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061853Z" creationid="pingfangx" creationdate="20190618T114338Z">
        <seg>添加带 `prefetch` 的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch` and `delayErrors` options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T055924Z" creationid="pingfangx" creationdate="20190619T054541Z">
        <seg>添加了带有 `prefetch` 和 `delayErrors` 选项的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with `prefetch`, option to delay till the current ends or till the very end</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T051728Z" creationid="pingfangx" creationdate="20190619T051728Z">
        <seg>添加带 `prefetch` 的重载，可选择延迟到当前结束或直到最后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added overloads with option to delay till the current ends or till the very end</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113044Z" creationid="pingfangx" creationdate="20190618T113044Z">
        <seg>添加了重载，可选择延迟到当前结束或直到最后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added varargs overload, added overloads with `bufferSize` argument, `combineLatest(List)` dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T112450Z" creationid="pingfangx" creationdate="20190618T112450Z">
        <seg>添加了可变参数重载，添加了 `bufferSize` 参数的重载，删除了 `combineLatest(List)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>advances the Scheduler’s clock forward by a particular amount of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091835Z" creationid="pingfangx" creationdate="20190620T091835Z">
        <seg>将调度器的时钟向前推进一段特定的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>advances the Scheduler’s clock to a particular point in time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091831Z" creationid="pingfangx" creationdate="20190620T091831Z">
        <seg>将调度器的时钟提前到特定时间点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after a specified delay</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104344Z" creationid="pingfangx" creationdate="20190620T104344Z">
        <seg>在指定的延迟后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allow further customization of the backpressure behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T100500Z" creationid="pingfangx" creationdate="20190617T100500Z">
        <seg>允许进一步定制背压行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allows you create a custom operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074015Z" creationid="pingfangx" creationdate="20190620T074015Z">
        <seg>允许创建自定义操作符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a number indicating how many items were in the sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105901Z" creationid="pingfangx" creationdate="20190620T105901Z">
        <seg>并发射一个数字，表示序列中有多少项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if &lt;e0&gt;all&lt;/e0&gt; of the items pass some test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105808Z" creationid="pingfangx" creationdate="20190620T105808Z">
        <seg>并发射一个布尔值，表明项目的 &lt;e0&gt;全部&lt;/e0&gt; 是否通过了一些测试</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the Observable emitted &lt;e0&gt;any&lt;/e0&gt; item (that passes some test)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105820Z" creationid="pingfangx" creationdate="20190620T105820Z">
        <seg>并发射一个布尔值，指示 Observable 是否发射了 &lt;e0&gt;任何&lt;/e0&gt; 项(通过了一些测试)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the Observable emitted &lt;e0&gt;no&lt;/e0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105843Z" creationid="pingfangx" creationdate="20190620T105843Z">
        <seg>并发射一个布尔值，指示 Observable 是否 &lt;e0&gt;没有&lt;/e0&gt; 发射项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105848Z" creationid="pingfangx" creationdate="20190620T105848Z">
        <seg>并发射一个布尔值，指示序列是否与第二个 Observable 发射的序列相同</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the average of all of their values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105854Z" creationid="pingfangx" creationdate="20190620T105854Z">
        <seg>并发射所有值的平均值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the item with the maximum value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105904Z" creationid="pingfangx" creationdate="20190620T105904Z">
        <seg>并发射具有最大值的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the item with the minimum value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105935Z" creationid="pingfangx" creationdate="20190620T105914Z">
        <seg>并发射具有最小值的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emit the sum of all of their values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105856Z" creationid="pingfangx" creationdate="20190620T105856Z">
        <seg>并发射所有值的总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting all of the items from all of the Observables in whatever order they are received</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104544Z" creationid="pingfangx" creationdate="20190620T104544Z">
        <seg>按照收到的顺序从所有 Observable 中发射所有项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting all of the items from all of the Observables, one Observable at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104553Z" creationid="pingfangx" creationdate="20190620T104553Z">
        <seg>从所有的 Observable 中发射所有物品，一次一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting the items from only the most-recently emitted of those Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104757Z" creationid="pingfangx" creationdate="20190620T104757Z">
        <seg>仅从最近发射的那些 Observables 中发射项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for Ivy:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105531Z" creationid="pingfangx" creationdate="20190617T105531Z">
        <seg>对于 Ivy：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and for Maven:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T105526Z" creationid="pingfangx" creationdate="20190617T105526Z">
        <seg>对于 Maven：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then I want to ask it to start</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110202Z" creationid="pingfangx" creationdate="20190620T110202Z">
        <seg>然后我想要它开始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then emits the complete sequence, even to those who subscribe after the sequence has begun</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110150Z" creationid="pingfangx" creationdate="20190620T110150Z">
        <seg>然后发射完整的序列，甚至是那些在序列开始后订阅的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then only emits the last item in its sequence</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110138Z" creationid="pingfangx" creationdate="20190620T110138Z">
        <seg>然后只发射序列中的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100732Z" creationid="pingfangx" creationdate="20190620T095948Z">
        <seg>将函数应用于 Observable 发射的每个项目，按顺序，并发射每个连续的值（译注：与 Map 区别于函数会使用上一次函数值）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a function to each item emitted by an Observable, sequentially, and emit the final value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103018Z" creationid="pingfangx" creationdate="20190620T103018Z">
        <seg>将函数按顺序应用于 Observable 发射的每个项目，并发射最终值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>asynchronous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033704Z" creationid="pingfangx" creationdate="20190620T033704Z">
        <seg>异步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>at particular intervals of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104502Z" creationid="pingfangx" creationdate="20190620T104502Z">
        <seg>在特定的时间间隔</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>attach a timestamp to each item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102352Z" creationid="pingfangx" creationdate="20190620T102352Z">
        <seg>将时间戳附加到 Observable 发射的每个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>based on all of the items that preceded them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104957Z" creationid="pingfangx" creationdate="20190620T104957Z">
        <seg>基于它们之前的所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but I want it to go away once all of its subscribers unsubscribe</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110157Z" creationid="pingfangx" creationdate="20190620T110157Z">
        <seg>但是，一旦所有订阅者取消订阅，我希望它能够消失</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by applying an aggregation function to each item in turn and emitting the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105942Z" creationid="pingfangx" creationdate="20190620T105942Z">
        <seg>通过依次对每个项目应用聚合函数并发射结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by attaching a timestamp to them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105002Z" creationid="pingfangx" creationdate="20190620T105002Z">
        <seg>通过附加时间戳给他们</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by attempting to resubscribe to the upstream Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110106Z" creationid="pingfangx" creationdate="20190620T110106Z">
        <seg>试图重新订阅上游的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by combining the items from two or more Observables sequentially to come up with new items to emit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104612Z" creationid="pingfangx" creationdate="20190620T104612Z">
        <seg>通过顺序组合来自两个或多个 Observable 的项目来提出要发射的新项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by delaying my subscription to it for some time after it begins emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105714Z" creationid="pingfangx" creationdate="20190620T105714Z">
        <seg>在开始发布项目后的一段时间内延迟我的订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by emitting all of the items emitted by corresponding Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104946Z" creationid="pingfangx" creationdate="20190620T104946Z">
        <seg>通过发射相应的 Observables 发射的所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by filtering out those that do not match some predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105304Z" creationid="pingfangx" creationdate="20190620T105304Z">
        <seg>通过过滤掉那些与某些谓词不匹配的东西</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by means of &lt;c0&gt;Pattern&lt;/c0&gt; and &lt;c1&gt;Plan&lt;/c1&gt; intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104716Z" creationid="pingfangx" creationdate="20190620T104716Z">
        <seg>通过 &lt;c0&gt;Pattern&lt;/c0&gt; 和 &lt;c1&gt;Plan&lt;/c1&gt; 中介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by only emitting items that are not followed by other items within some duration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105649Z" creationid="pingfangx" creationdate="20190620T105649Z">
        <seg>通过仅在一段时间内发射未跟随其他项目的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by retrieving it from a Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104407Z" creationid="pingfangx" creationdate="20190620T104407Z">
        <seg>通过从 Future 中获取</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by sampling the Observable periodically</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105632Z" creationid="pingfangx" creationdate="20190620T105632Z">
        <seg>通过定期对 Observable 进行抽样</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by suppressing items that are duplicates of already-emitted items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105655Z" creationid="pingfangx" creationdate="20190620T105655Z">
        <seg>通过抑制与已发射项目重复的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by wrapping them in &lt;c0&gt;Notification&lt;/c0&gt; objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105059Z" creationid="pingfangx" creationdate="20190620T105059Z">
        <seg>将它们包装在 &lt;c0&gt;Notification&lt;/c0&gt; 对象中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculate the sum of numbers emitted by an Observable and emit this sum</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103028Z" creationid="pingfangx" creationdate="20190620T103028Z">
        <seg>计算 Observable 发射的数字之和并发射此总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculates the average of numbers emitted by an Observable and emits this average</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102858Z" creationid="pingfangx" creationdate="20190620T102858Z">
        <seg>计算 Observable 发射的数字的平均值并发射此平均值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `List`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061444Z" creationid="pingfangx" creationdate="20190619T061444Z">
        <seg>将所有元素收集到 `List` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `List` and sorts it</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061457Z" creationid="pingfangx" creationdate="20190619T061457Z">
        <seg>将所有元素收集到 `List` 中并对其进行排序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `Map`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061448Z" creationid="pingfangx" creationdate="20190619T061448Z">
        <seg>将所有元素收集到 `Map` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all elements into a `Map` with collection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061453Z" creationid="pingfangx" creationdate="20190619T061453Z">
        <seg>将所有元素收集到带有集合的 `Map` 中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101457Z" creationid="pingfangx" creationdate="20190620T101457Z">
        <seg>在根据另一个 Observable 发射的项目定义的时间窗口期间发射一个 Observable 中的项目时，组合两个 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine multiple Observables into one by merging their emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101553Z" creationid="pingfangx" creationdate="20190620T101553Z">
        <seg>通过合并它们的发射，将多个 Observable 组合成一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine sets of items emitted by two or more Observables by means of `Pattern` and `Plan` intermediaries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101248Z" creationid="pingfangx" creationdate="20190620T101248Z">
        <seg>通过 `Pattern` 和 `Plan` 中介组合两个或多个 Observable 发射的项目集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101737Z" creationid="pingfangx" creationdate="20190620T101737Z">
        <seg>通过指定的函数将多个 Observable 的发射组合在一起，并根据此函数的结果为每个组合发射单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>concatenates the items emitted by multiple Singles as Observable emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074050Z" creationid="pingfangx" creationdate="20190620T074050Z">
        <seg>将多个 Singles 发射的项目连接为 Observable 的发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containing only the last items emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105215Z" creationid="pingfangx" creationdate="20190620T105215Z">
        <seg>仅包含最后发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable into another object or data structure</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103726Z" creationid="pingfangx" creationdate="20190620T103726Z">
        <seg>将 Observable 转换为另一个对象或数据结构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101651Z" creationid="pingfangx" creationdate="20190620T101651Z">
        <seg>将发射 Observables 的 Observable 转换为单个 Observable，该 Observable 发射最近发射的 Observables 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102326Z" creationid="pingfangx" creationdate="20190620T102326Z">
        <seg>将发射数据项的 Observable 转换为发射这些发射项之间经过的时间量的指示的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an object or a set of objects into an Observable that emits that or those objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095323Z" creationid="pingfangx" creationdate="20190620T095323Z">
        <seg>将对象或一组对象转换为发射该对象或那些对象的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert an ordinary Observable into a connectable Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103616Z" creationid="pingfangx" creationdate="20190620T103616Z">
        <seg>将普通的 Observable 转换为可连接的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert some other object or data structure into an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095214Z" creationid="pingfangx" creationdate="20190620T095214Z">
        <seg>将一些其他对象或数据结构转换为 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Future into a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074449Z" creationid="pingfangx" creationdate="20190620T074449Z">
        <seg>将 Future 转化为 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single into an Observable that emits the item emitted by the Single and then completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074839Z" creationid="pingfangx" creationdate="20190620T074839Z">
        <seg>将 Single 转换为 Observable，它发射 Single 发射的项，然后完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single that emits a second Single into a Single that emits the item emitted by the second Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074616Z" creationid="pingfangx" creationdate="20190620T074616Z">
        <seg>将发射第二个 Single 的 Single 转换为发射第二个 Single 发射的项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts a Single that makes an error notification into a Single that emits a specified item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074728Z" creationid="pingfangx" creationdate="20190620T074728Z">
        <seg>将发射错误通知的 Single 转换为发射指定项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>converts an Observable that emits a single item into a Single that emits that item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074827Z" creationid="pingfangx" creationdate="20190620T074827Z">
        <seg>将发射单个项目的 Observable 转换为发射该项目的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>count the number of items emitted by the source Observable and emit only this value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102934Z" creationid="pingfangx" creationdate="20190620T102934Z">
        <seg>计算源 Observable 发射的项目数，并仅发射此值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create Observables that have very precise and limited behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095200Z" creationid="pingfangx" creationdate="20190620T095200Z">
        <seg>创建具有非常精确和有限行为的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create a Single from scratch by calling subscriber methods explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074105Z" creationid="pingfangx" creationdate="20190620T074105Z">
        <seg>通过显式调用订阅者方法从头创建 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create a disposable resource that has the same lifespan as the Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102425Z" creationid="pingfangx" creationdate="20190620T102425Z">
        <seg>创建一个与 Observable 具有相同生命周期的可释放资源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable from scratch by calling observer methods programmatically</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095124Z" creationid="pingfangx" creationdate="20190620T095124Z">
        <seg>通过以编程方式调用 observer 方法从头创建一个 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a particular item or sequence of items repeatedly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095341Z" creationid="pingfangx" creationdate="20190620T095341Z">
        <seg>创建一个 Observable，重复发射特定项目或项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a range of sequential integers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095332Z" creationid="pingfangx" creationdate="20190620T095332Z">
        <seg>创建一个发射一系列连续整数的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a sequence of integers spaced by a particular time interval</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095309Z" creationid="pingfangx" creationdate="20190620T095309Z">
        <seg>创建一个 Observable，它以特定时间间隔发射一系列整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits a single item after a given delay</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095356Z" creationid="pingfangx" creationdate="20190620T095356Z">
        <seg>创建一个在给定延迟后发射单个项目的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>create an Observable that emits the return value of a function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095348Z" creationid="pingfangx" creationdate="20190620T095348Z">
        <seg>创建一个发射函数返回值的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>creates a new thread for each unit of work</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091301Z" creationid="pingfangx" creationdate="20190620T091301Z">
        <seg>为每个工作单元创建一个新线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deprecated and dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115754Z" creationid="pingfangx" creationdate="20190618T115754Z">
        <seg>弃用并删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deprecated overloads dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114441Z" creationid="pingfangx" creationdate="20190618T114441Z">
        <seg>已删除弃用的重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether all items emitted by an Observable meet some criteria</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102529Z" creationid="pingfangx" creationdate="20190620T102529Z">
        <seg>确定 Observable 发射的所有项目是否符合某些标准</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether an Observable emits a particular item or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102737Z" creationid="pingfangx" creationdate="20190620T102737Z">
        <seg>确定 Observable 是否发射特定项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine whether two Observables emit the same sequence of items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102753Z" creationid="pingfangx" creationdate="20190620T102753Z">
        <seg>确定两个 Observable 是否发射相同的项目序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine, and emit, the maximum-valued item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102942Z" creationid="pingfangx" creationdate="20190620T102942Z">
        <seg>确定并发射 Observable 发射的最大值项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>determine, and emit, the minimum-valued item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102948Z" creationid="pingfangx" creationdate="20190620T102948Z">
        <seg>确定并发射 Observable 发射的最小值项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disambiguated into `fromArray`, `fromIterable`, `fromFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114255Z" creationid="pingfangx" creationdate="20190618T114255Z">
        <seg>通过 `fromArray`，`fromIterable`，`fromFuture` 消除歧义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disambiguated to `collectInto` and **RC3** returns `Single&lt;U&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115854Z" creationid="pingfangx" creationdate="20190618T115854Z">
        <seg>修改为 `collectInto` 以消除歧义且 **RC3** 返回 `Single&lt;U&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable after a second Observable emits an item or terminates</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102825Z" creationid="pingfangx" creationdate="20190620T102825Z">
        <seg>在第二个 Observable 发射项目或终止后，丢弃 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable after a specified condition becomes false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102833Z" creationid="pingfangx" creationdate="20190620T102833Z">
        <seg>在指定条件变为 false 后，丢弃 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable until a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102802Z" creationid="pingfangx" creationdate="20190620T102802Z">
        <seg>丢弃 Observable 发射的项目，直到第二个 Observable 发射项目为止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>discard items emitted by an Observable until a specified condition becomes false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102811Z" creationid="pingfangx" creationdate="20190620T102811Z">
        <seg>丢弃 Observable 发射的项目，直到指定的条件变为 false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095819Z" creationid="pingfangx" creationdate="20190620T095819Z">
        <seg>将一个 Observable 划分为一组 Observable，每个 Observable 从原始 Observable 中发射一组不同的项目，按 key 组织</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095149Z" creationid="pingfangx" creationdate="20190620T095149Z">
        <seg>在观察者订阅之前不要创建 Observable，并为每个观察者创建一个新的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not emit any items from an Observable but mirror its termination notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100958Z" creationid="pingfangx" creationdate="20190620T100958Z">
        <seg>不从 Observable 中发射任何项目，但镜像其终止通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it divide its work over multiple threads that may return data to the caller in any order?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040703Z" creationid="pingfangx" creationdate="20190620T040703Z">
        <seg>它是否将其工作划分为多个线程，这些线程可能以任何顺序将数据返回给调用者？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use NIO with an event-loop to do asynchronous network access?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040718Z" creationid="pingfangx" creationdate="20190620T040718Z">
        <seg>它是否使用 NIO 和事件循环来进行异步网络访问？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use an Actor (or multiple Actors) instead of a thread pool?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040709Z" creationid="pingfangx" creationdate="20190620T040709Z">
        <seg>它使用 Actor(或多个 Actors)而不是线程池？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it use an event-loop to separate the work thread from the callback thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040725Z" creationid="pingfangx" creationdate="20190620T040725Z">
        <seg>它是否使用事件循环将工作线程与回调线程分开？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it work asynchronously on a distinct thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040653Z" creationid="pingfangx" creationdate="20190620T040653Z">
        <seg>它是否在一个不同的线程上异步工作？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does it work synchronously on the same thread as the caller?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T040649Z" creationid="pingfangx" creationdate="20190620T040649Z">
        <seg>它是否与调用者在同一个线程上同步工作？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>doesn't emit the very last item if the upstream completes within the period, added overloads with `emitLast` parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053506Z" creationid="pingfangx" creationdate="20190619T053506Z">
        <seg>如果上游在句点内完成，则不会发出最后一项，使用 `emitLast` 参数添加重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>doesn't emit the very last item if the upstream completes within the period, use `sample` with the `emitLast` parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053913Z" creationid="pingfangx" creationdate="20190619T053913Z">
        <seg>如果上游在句点内完成，则不会发出最后一项，请使用带有 `emitLast` 参数的 `sample`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053845Z" creationid="pingfangx" creationdate="20190619T053845Z">
        <seg>删除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped the overload, use `subscribeOn(Scheduler).repeatWhen(Function)` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053435Z" creationid="pingfangx" creationdate="20190619T053435Z">
        <seg>删除了重载，使用 `subscribeOn(Scheduler).repeatWhen(Function)` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped the overload, use `subscribeOn(Scheduler).retryWhen(Function)` instead</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053451Z" creationid="pingfangx" creationdate="20190619T053451Z">
        <seg>删除了重载，使用 `subscribeOn(Scheduler).retryWhen(Function)` 代替</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `count`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052322Z" creationid="pingfangx" creationdate="20190619T052322Z">
        <seg>删除，使用 `count`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).elementAt(int)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052636Z" creationid="pingfangx" creationdate="20190619T052636Z">
        <seg>删除，使用 `filter(predicate).elementAt(int)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).elementAt(int, T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052928Z" creationid="pingfangx" creationdate="20190619T052928Z">
        <seg>删除，使用 `filter(predicate).elementAt(int, T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).first()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052943Z" creationid="pingfangx" creationdate="20190619T052943Z">
        <seg>删除，使用 `filter(predicate).first()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).first(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053014Z" creationid="pingfangx" creationdate="20190619T053014Z">
        <seg>删除，使用 `filter(predicate).first(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).last()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053145Z" creationid="pingfangx" creationdate="20190619T053145Z">
        <seg>删除，使用 `filter(predicate).last()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).last(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053237Z" creationid="pingfangx" creationdate="20190619T053237Z">
        <seg>删除，使用 `filter(predicate).last(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).single()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053613Z" creationid="pingfangx" creationdate="20190619T053613Z">
        <seg>删除，使用 `filter(predicate).single()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `filter(predicate).single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053654Z" creationid="pingfangx" creationdate="20190619T053654Z">
        <seg>删除，使用 `filter(predicate).single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use `take`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114325Z" creationid="pingfangx" creationdate="20190618T114325Z">
        <seg>删除，使用 ` take`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dropped, use manual `just`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053307Z" creationid="pingfangx" creationdate="20190619T053307Z">
        <seg>删除，使用 manual `just`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit a specified sequence of items before beginning to emit the items from the source Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101632Z" creationid="pingfangx" creationdate="20190620T101632Z">
        <seg>在开始从源 Observable 中发射项之前，发射指定的项序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit items from the source Observable, or a default item if the source Observable emits nothing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102747Z" creationid="pingfangx" creationdate="20190620T102747Z">
        <seg>从源 Observable 发射项，如果源 Observable 没有发射任何内容，则发射默认项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only item &lt;i0&gt;n&lt;/i0&gt; emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100914Z" creationid="pingfangx" creationdate="20190620T100914Z">
        <seg>仅发射 Observable 发射的 &lt;i0&gt;n&lt;/i0&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the first &lt;i3&gt;n&lt;/i3&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101059Z" creationid="pingfangx" creationdate="20190620T101059Z">
        <seg>仅发射 Observable 发射的前 &lt;i3&gt;n&lt;/i3&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the first item, or the first item that meets a condition, from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100934Z" creationid="pingfangx" creationdate="20190620T100934Z">
        <seg>从 Observable 中仅发射第一个项目或满足条件的第一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the last &lt;i4&gt;n&lt;/i4&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101117Z" creationid="pingfangx" creationdate="20190620T101117Z">
        <seg>仅发射 Observable 发射的最后 &lt;i4&gt;n&lt;/i4&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only the last item emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101003Z" creationid="pingfangx" creationdate="20190620T101003Z">
        <seg>仅发射 Observable 发射的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit only those items from an Observable that pass a predicate test</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100927Z" creationid="pingfangx" creationdate="20190620T100927Z">
        <seg>仅发射通过谓词测试的 Observable 中的那些项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit the emissions from two or more Observables without interleaving them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102926Z" creationid="pingfangx" creationdate="20190620T102926Z">
        <seg>发射两个或多个 Observable 的发射项而不交错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emit the most recent item emitted by an Observable within periodic time intervals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101013Z" creationid="pingfangx" creationdate="20190620T101013Z">
        <seg>在周期性时间间隔内发射 Observable 发射的最新项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103713Z" creationid="pingfangx" creationdate="20190620T103713Z">
        <seg>确保所有观察者都看到相同的发射项序列，即使他们在 Observable 开始发射物品后才订阅</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>even compile because at least 4 `concatWith` overloads exist and the compiler finds the code above ambiguous.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102620Z" creationid="pingfangx" creationdate="20190617T102620Z">
        <seg>它甚至不编译因为至少存在 4 个 `concatWith` 重载并且编译器发现上面的代码有歧义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for each observer that subscribes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104455Z" creationid="pingfangx" creationdate="20190620T104455Z">
        <seg>对于每个订阅的观察者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>force an Observable to make serialized calls and to be well-behaved</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102052Z" creationid="pingfangx" creationdate="20190620T102052Z">
        <seg>强制 Observable 进行序列化调用并保持良好状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from a timeout by switching to a backup Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110056Z" creationid="pingfangx" creationdate="20190620T110056Z">
        <seg>从超时切换到备份 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from an upstream error notification</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110101Z" creationid="pingfangx" creationdate="20190620T110101Z">
        <seg>来自上游错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from scratch, with custom logic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104443Z" creationid="pingfangx" creationdate="20190620T104443Z">
        <seg>从头开始，使用自定义逻辑</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from the perspective of `flatMapSingle`, `sourceObservable` is a multi-valued source and thus the mapping may result in multiple values as well).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T091158Z" creationid="pingfangx" creationdate="20190617T091158Z">
        <seg>从 `flatMapSingle` 的角度来看，`sourceObservable` 是一个多值源，因此映射也可能导致多个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102731Z" creationid="pingfangx" creationdate="20190620T102731Z">
        <seg>给定两个或多个源 Observable，仅从第一个发射一个项目 Observable 中发射所有项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>however, the continuation in this case stays `Observable` instead of the likely more appropriate `Single`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T084004Z" creationid="pingfangx" creationdate="20190617T084004Z">
        <seg>然而，在这种情况下的延续仍然是 `Observable` 而不是可能更合适的 `Single`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a source Observable sends an `onError` notification, resubscribe to it in the hopes that it will complete without error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101846Z" creationid="pingfangx" creationdate="20190620T101846Z">
        <seg>如果一个源 Observable 发送一个 `onError` 通知，重新订阅它，希望它能完成而不会出错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if a specified period of time elapses without it emitting an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110045Z" creationid="pingfangx" creationdate="20190620T110045Z">
        <seg>如果指定的时间段过去而没有发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if they immediately follow the item they are duplicates of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105703Z" creationid="pingfangx" creationdate="20190620T105703Z">
        <seg>如果他们立即跟随该项目他们是重复的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inlined as `blockingY()` operators, except `toFuture`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053947Z" creationid="pingfangx" creationdate="20190619T053947Z">
        <seg>内联为 `blockingY()` 操作符，除了 `toFuture`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instruct a connectable Observable to begin emitting items to its subscribers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103606Z" creationid="pingfangx" creationdate="20190620T103606Z">
        <seg>指示可连接的 Observable 开始向其订阅者发送项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instructs the Single to call the subscriber methods on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074718Z" creationid="pingfangx" creationdate="20190620T074718Z">
        <seg>指示 Single 在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上调用订阅者方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instructs the Single to operate on a particular &lt;a0&gt;Scheduler&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074754Z" creationid="pingfangx" creationdate="20190620T074754Z">
        <seg>指示 Single 在特定的 &lt;a0&gt;Scheduler&lt;/a0&gt; 上操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>into an indicator of the amount of time that lapsed before the emission of the item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105012Z" creationid="pingfangx" creationdate="20190620T105012Z">
        <seg>成为项目发射前经过的时间的指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>make a Connectable Observable behave like an ordinary Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103654Z" creationid="pingfangx" creationdate="20190620T103654Z">
        <seg>使 Connectable Observable 的行为类似于普通的 Observable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to &lt;c0&gt;Schedulers.computation( )&lt;/c0&gt;; &lt;c1&gt;Schedulers.io( )&lt;/c1&gt; by default is a &lt;c2&gt;CachedThreadScheduler&lt;/c2&gt;, which is something like a new thread scheduler with thread caching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091257Z" creationid="pingfangx" creationdate="20190620T091257Z">
        <seg>对于 I/O 密集型工作，例如阻塞 I/O 的异步性能，此调度器由一个将根据需要增长的线程池支持；对于普通的计算工作，请切换到 &lt;c0&gt;Schedulers.computation( )&lt;/c0&gt;; &lt;c1&gt;Schedulers.io( )&lt;/c1&gt; 默认情况下是 &lt;c2&gt;CachedThreadScheduler&lt;/c2&gt;，类似于带有线程缓存的新线程调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use &lt;c0&gt;Schedulers.io( )&lt;/c0&gt; instead); the number of threads, by default, is equal to the number of processors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091037Z" creationid="pingfangx" creationdate="20190620T091037Z">
        <seg>用于计算工作，如事件循环和回调处理；不要将此调度器用于 I/O(请改用 &lt;c0&gt;Schedulers.io( )&lt;/c0&gt;);默认情况下，线程数等于处理器数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>merges the items emitted by multiple Singles as Observable emissions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074647Z" creationid="pingfangx" creationdate="20190620T074647Z">
        <seg>将多个 Singles 发射的数据项合并为 Observable 的发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102347Z" creationid="pingfangx" creationdate="20190620T102347Z">
        <seg>镜像源 Observable，但是如果在没有任何发射项目的情况下经过了特定的时间段，则发射错误通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>move the emission of an item from a Single forward in time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074211Z" creationid="pingfangx" creationdate="20190620T074211Z">
        <seg>延时 Single 发射项目的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>multiple items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033657Z" creationid="pingfangx" creationdate="20190620T033657Z">
        <seg>多个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not present</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113227Z" creationid="pingfangx" creationdate="20190618T113227Z">
        <seg>不存在</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of the source `Observable`?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T095510Z" creationid="pingfangx" creationdate="20190617T095510Z">
        <seg>来自源 `Observable`？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onNext, onCompleted, and onError</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T055924Z" creationid="pingfangx" creationdate="20190620T055924Z">
        <seg>onNext，onCompleted 和 onError</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one Observable at a time, in the order they are emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104950Z" creationid="pingfangx" creationdate="20190620T104950Z">
        <seg>一个 Observable，按照它们发射的顺序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one at a time with a function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104938Z" creationid="pingfangx" creationdate="20190620T104938Z">
        <seg>一次一个使用函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>only emit an item from an Observable if a particular timespan has passed without it emitting another item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100816Z" creationid="pingfangx" creationdate="20190620T100302Z">
        <seg>从 Observable 中发射一个项目后，如果过了特定的时间而没有发射别的项目，才发送该项目（译注：防抖动）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>only if its sequence is empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105201Z" creationid="pingfangx" creationdate="20190620T105201Z">
        <seg>只有当它的序列为空时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>operate upon the emissions and notifications from an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102156Z" creationid="pingfangx" creationdate="20190620T102156Z">
        <seg>对观察者的发射和通知进行操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T092652Z" creationid="pingfangx" creationdate="20190617T092652Z">
        <seg>或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or alternatively the `TestSubscriber` instance has to be captured to gain access to its `request()` method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T101806Z" creationid="pingfangx" creationdate="20190618T101806Z">
        <seg>或者必须捕获 `TestSubscriber` 实例以获取对其 `request()` 方法的访问：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overload with custom `Collection` supplier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052335Z" creationid="pingfangx" creationdate="20190619T052335Z">
        <seg>使用自定义 `Collection` 提供者重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>overloads with custom `Collection` supplier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115739Z" creationid="pingfangx" creationdate="20190618T115739Z">
        <seg>使用自定义 `Collection` 提供者重载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100347Z" creationid="pingfangx" creationdate="20190620T095455Z">
        <seg>定期将 Observable 中的项目收集到包中并发射这些包，而不是一次发送一个项目（译注：缓存）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100030Z" creationid="pingfangx" creationdate="20190620T100030Z">
        <seg>定期将 Observable 中的项目细分为 Observable 窗口并发射这些窗口，而不是一次发射一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>queues work to begin on the current thread after any already-queued work</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091335Z" creationid="pingfangx" creationdate="20190620T091335Z">
        <seg>当其它排队的任务完成后，在当前线程排队开始执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>recover from an `onError` notification by continuing the sequence without error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101833Z" creationid="pingfangx" creationdate="20190620T101833Z">
        <seg>通过继续序列而不出错来从 `onError` 通知中恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>register an action to take upon a variety of Observable lifecycle events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102021Z" creationid="pingfangx" creationdate="20190620T102021Z">
        <seg>注册一个动作来承担各种 Observable 生命周期事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `Flowable.doOnCancel` and `doOnDispose` for the others, [additional info](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052519Z" creationid="pingfangx" creationdate="20190619T052519Z">
        <seg>重命名为 `Flowable.doOnCancel` 和 `doOnDispose` 对于其他，[additional info](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `create()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T114309Z" creationid="pingfangx" creationdate="20190618T114309Z">
        <seg>重命名为 `create()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `doOnComplete`, note the missing `d`!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052410Z" creationid="pingfangx" creationdate="20190619T052410Z">
        <seg>重命名为 `doOnComplete`，注意缺少的 `d`！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `elementAt(int, T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T052906Z" creationid="pingfangx" creationdate="20190619T052739Z">
        <seg>重命名为 `elementAt(int, T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `first(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053000Z" creationid="pingfangx" creationdate="20190619T053000Z">
        <seg>重命名为 `first(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `hide()`, hides all identities now</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T115716Z" creationid="pingfangx" creationdate="20190618T115716Z">
        <seg>重命名为 `hide()`，现在隐藏所有身份</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `last(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053203Z" creationid="pingfangx" creationdate="20190619T053203Z">
        <seg>重命名为 `last(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>renamed to `single(T)` and **RC3** returns `Single&lt;T&gt;`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053630Z" creationid="pingfangx" creationdate="20190619T053630Z">
        <seg>重命名为 `single(T)` 且 **RC3** 返回 `Single&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replaced with `generate` + overloads (distinct interfaces, you can implement them all at once)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113215Z" creationid="pingfangx" creationdate="20190618T113215Z">
        <seg>替换为 `generate` + 重载(不同的接口，您可以一次实现它们)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>represent both the items emitted and the notifications sent as emitted items, or reverse this process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102033Z" creationid="pingfangx" creationdate="20190620T102033Z">
        <seg>表示发射的项目和作为发射项目发送的通知，或者反转此过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repurposed with safe `create(FlowableOnSubscribe, BackpressureStrategy)`, raw support via `unsafeCreate()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T113314Z" creationid="pingfangx" creationdate="20190618T113314Z">
        <seg>使用安全的 `create(FlowableOnSubscribe, BackpressureStrategy)` 重新定位，通过 `unsafeCreate()` 提供原始支持</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that also calls a method you specify when it calls onError</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074251Z" creationid="pingfangx" creationdate="20190620T074251Z">
        <seg>返回在调用 OnError 时也调用指定方法的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that also calls a method you specify when it calls onSuccess</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074309Z" creationid="pingfangx" creationdate="20190620T074309Z">
        <seg>返回在调用 OnSuccess 时也调用指定方法的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits a specified item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074455Z" creationid="pingfangx" creationdate="20190620T074455Z">
        <seg>返回发射指定项的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074908Z" creationid="pingfangx" creationdate="20190620T074908Z">
        <seg>返回一个 Single，它发射一个项目，该项目是应用于两个或多个其他 Single 发射的项目的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that emits the result of a function applied to the item emitted by the source Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074523Z" creationid="pingfangx" creationdate="20190620T074523Z">
        <seg>返回一个 Single，它发射应用于源 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that immediately notifies subscribers of an error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074345Z" creationid="pingfangx" creationdate="20190620T074345Z">
        <seg>返回一个可立即通知订阅者错误的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that is the result of a function applied to an item emitted by a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074410Z" creationid="pingfangx" creationdate="20190620T074410Z">
        <seg>返回一个 Single，它是应用于 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a Single that makes an error notification if the source Single does not emit a value in a specified time period</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074814Z" creationid="pingfangx" creationdate="20190620T074814Z">
        <seg>如果源 Single 在指定时间段内未发射值，则返回一个发射错误通知的 Single</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns an Observable that is the result of a function applied to an item emitted by a Single</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T074435Z" creationid="pingfangx" creationdate="20190620T074435Z">
        <seg>返回一个 Observable，它是应用于 Single 发射的项的函数的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>schedules work to begin immediately in the current thread</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091109Z" creationid="pingfangx" creationdate="20190620T091109Z">
        <seg>立即在当前线程中开始工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shift the emissions from an Observable forward in time by a particular amount</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102013Z" creationid="pingfangx" creationdate="20190620T102013Z">
        <seg>将 Observable 的发射向前转移一定量的时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>signature changed to `timeout(Publisher, ...)` and dropped the function, use `defer(Callable&lt;Publisher&gt;&gt;)` if necessary</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T053938Z" creationid="pingfangx" creationdate="20190619T053938Z">
        <seg>签名改为 `timeout(Publisher, ...)` 并删除了该函数，必要时使用 `defer(Callable&lt;Publisher&gt;&gt;)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>single items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033654Z" creationid="pingfangx" creationdate="20190620T033654Z">
        <seg>单个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>so that similar items end up on the same Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105233Z" creationid="pingfangx" creationdate="20190620T105233Z">
        <seg>这样类似的项目最终会出现在同一个 Observable 上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify the scheduler an Observable should use when it is subscribed to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102210Z" creationid="pingfangx" creationdate="20190620T102210Z">
        <seg>指定 Observable 在订阅时应使用的调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify the scheduler on which an observer will observe this Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T102045Z" creationid="pingfangx" creationdate="20190620T102045Z">
        <seg>指定观察者将观察此 Observable 的调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler’s clock</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091852Z" creationid="pingfangx" creationdate="20190620T091852Z">
        <seg>根据调度器的时钟启动任何已安排的时间等于或早于当前时间的未启动操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>strategies for coping with Observables that produce items more rapidly than their observers consume them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T103456Z" creationid="pingfangx" creationdate="20190620T103456Z">
        <seg>当 Observables 生产数据项比观察者消耗数据项更快时的处理策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress duplicate items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100900Z" creationid="pingfangx" creationdate="20190620T100900Z">
        <seg>抑制 Observable 发射的重复项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress the first &lt;i1&gt;n&lt;/i1&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101039Z" creationid="pingfangx" creationdate="20190620T101019Z">
        <seg>抑制 Observable 发射的前 &lt;i1&gt;n&lt;/i1&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>suppress the last &lt;i2&gt;n&lt;/i2&gt; items emitted by an Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101048Z" creationid="pingfangx" creationdate="20190620T101048Z">
        <seg>抑制 Observable 发射的最后 &lt;i2&gt;n&lt;/i2&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>synchronous</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T033700Z" creationid="pingfangx" creationdate="20190620T033700Z">
        <seg>同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that completes without emitting items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104511Z" creationid="pingfangx" creationdate="20190620T104511Z">
        <seg>完成而不发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that does nothing at all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104514Z" creationid="pingfangx" creationdate="20190620T104514Z">
        <seg>什么都不做</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a particular item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104220Z" creationid="pingfangx" creationdate="20190620T104220Z">
        <seg>发射特定项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a sequence of integers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104459Z" creationid="pingfangx" creationdate="20190620T104459Z">
        <seg>发射一系列整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that emits a sequence of items repeatedly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104425Z" creationid="pingfangx" creationdate="20190620T104425Z">
        <seg>重复发射一系列项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105546Z" creationid="pingfangx" creationdate="20190620T105546Z">
        <seg>在第二个 Observable 发射一个项目之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after an initial period of time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105534Z" creationid="pingfangx" creationdate="20190620T105534Z">
        <seg>在最初的一段时间之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, after the first &lt;i0&gt;n&lt;/i0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105518Z" creationid="pingfangx" creationdate="20190620T105518Z">
        <seg>前 &lt;i0&gt;n&lt;/i0&gt; 项之后</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except items emitted after a second Observable emits an item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105628Z" creationid="pingfangx" creationdate="20190620T105628Z">
        <seg>除了第二个 Observable 发射项目后发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except items emitted during a period of time before the source completes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105617Z" creationid="pingfangx" creationdate="20190620T105617Z">
        <seg>除了在源完成之前的一段时间内发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, except the last &lt;i0&gt;n&lt;/i0&gt; items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105604Z" creationid="pingfangx" creationdate="20190620T105604Z">
        <seg>除了最后的 &lt;i0&gt;n&lt;/i0&gt; 项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only item &lt;i0&gt;n&lt;/i0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105434Z" creationid="pingfangx" creationdate="20190620T105346Z">
        <seg>仅有项目 &lt;i0&gt;n&lt;/i0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the first item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105416Z" creationid="pingfangx" creationdate="20190620T105310Z">
        <seg>仅第一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the first item&lt;e0&gt;s&lt;/e0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105420Z" creationid="pingfangx" creationdate="20190620T105335Z">
        <seg>仅前几项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only the last item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105430Z" creationid="pingfangx" creationdate="20190620T105341Z">
        <seg>仅最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, only those items after the first items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105456Z" creationid="pingfangx" creationdate="20190620T105456Z">
        <seg>仅第一项之后的那些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, those items except the last items</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105558Z" creationid="pingfangx" creationdate="20190620T105558Z">
        <seg>除了最后项之外的那些项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, until one of those items matches a predicate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105527Z" creationid="pingfangx" creationdate="20190620T105527Z">
        <seg>直到其中一个项与谓词匹配</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that obtains its sequence from a Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104413Z" creationid="pingfangx" creationdate="20190620T104413Z">
        <seg>从 Future 获得序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that pulls its emissions from a particular &lt;c0&gt;Array&lt;/c0&gt;, &lt;c1&gt;Iterable&lt;/c1&gt;, or something like that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104401Z" creationid="pingfangx" creationdate="20190620T104401Z">
        <seg>从特定的 &lt;c0&gt;Array&lt;/c0&gt;，&lt;c1&gt;Iterable&lt;/c1&gt; 或类似的东西中拉取其发射</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that was returned from a function called at subscribe-time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104319Z" creationid="pingfangx" creationdate="20190620T104319Z">
        <seg>从订阅时调用的函数返回的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that was returned from an &lt;c0&gt;Action&lt;/c0&gt;, &lt;c1&gt;Callable&lt;/c1&gt;, &lt;c2&gt;Runnable&lt;/c2&gt;, or something of that sort, called at subscribe-time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104334Z" creationid="pingfangx" creationdate="20190620T104334Z">
        <seg>从 &lt;c0&gt;Action&lt;/c0&gt;，&lt;c1&gt;Callable&lt;/c1&gt;，&lt;c2&gt;Runnable&lt;/c2&gt; 或类似的东西返回，在订阅时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the ability for the producer to signal to the consumer that an error has occurred (an Iterable throws an exception if an error takes place during iteration; an Observable calls its observer’s &lt;c0&gt;onError&lt;/c0&gt; method)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042423Z" creationid="pingfangx" creationdate="20190620T042423Z">
        <seg>生产者向消费者发出错误信号的能力(如果在迭代期间发生错误，则 Iterable 抛出异常；Observable 调用其观察者的 &lt;c0&gt;onError&lt;/c0&gt; 方法)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the ability for the producer to signal to the consumer that there is no more data available (a foreach loop on an Iterable completes and returns normally in such a case; an Observable calls its observer’s &lt;c0&gt;onCompleted&lt;/c0&gt; method)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T042400Z" creationid="pingfangx" creationdate="20190620T042400Z">
        <seg>生产者向消费者发出信号表明没有更多可用数据的能力(Iterable 上的 foreach 循环完成并在这种情况下正常返回；Observable 调用其观察者的 &lt;c0&gt;onCompleted&lt;/c0&gt; 方法)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the first item it emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105249Z" creationid="pingfangx" creationdate="20190620T105249Z">
        <seg>它发射的第一个项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the last item emitted before it completed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105243Z" creationid="pingfangx" creationdate="20190620T105243Z">
        <seg>完成之前发射的最后一项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sole item it emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105246Z" creationid="pingfangx" creationdate="20190620T105246Z">
        <seg>它发射的唯一项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transform the items emitted by an Observable by applying a function to each item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095829Z" creationid="pingfangx" creationdate="20190620T095829Z">
        <seg>通过将函数应用于每个项目来转换 Observable 发射的项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T100559Z" creationid="pingfangx" creationdate="20190620T095740Z">
        <seg>将 Observable 发射的项目转换为 Observables，然后将这些项目的发射变为单个 Observable（译注：扁平，一个项变为多个项，然后发出多个项(可能交错)）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unambiguous operator should have been `defer`:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190617T102915Z" creationid="pingfangx" creationdate="20190617T102915Z">
        <seg>因此是正确的明确的运算符应该是 `defer`：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.ignoreElements()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061549Z" creationid="pingfangx" creationdate="20190619T061549Z">
        <seg>使用 `Flowable.ignoreElements()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061553Z" creationid="pingfangx" creationdate="20190619T061553Z">
        <seg>使用 `Flowable.single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Flowable.singleElement()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061555Z" creationid="pingfangx" creationdate="20190619T061555Z">
        <seg>使用 `Flowable.singleElement()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.ignoreElements()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061557Z" creationid="pingfangx" creationdate="20190619T061557Z">
        <seg>使用 `Observable.ignoreElements()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.single(T)`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061659Z" creationid="pingfangx" creationdate="20190619T061659Z">
        <seg>使用 `Observable.single(T)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>use `Observable.singleElement()`</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190619T061702Z" creationid="pingfangx" creationdate="20190619T061702Z">
        <seg>使用 `Observable.singleElement()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>uses the specified &lt;c0&gt;Executor&lt;/c0&gt; as a Scheduler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T091042Z" creationid="pingfangx" creationdate="20190620T091042Z">
        <seg>使用指定的 &lt;c0&gt;Executor&lt;/c0&gt; 作为调度器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T101309Z" creationid="pingfangx" creationdate="20190620T101309Z">
        <seg>当一个项目由两个 Observable 中的任何一个发射时，通过指定的函数组合每个 Observable 发射的最新项目，并根据此函数的结果发射项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when it notifies observers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T110012Z" creationid="pingfangx" creationdate="20190620T110012Z">
        <seg>当它通知观察者时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever &lt;e0&gt;any&lt;/e0&gt; of the Observables has emitted a new item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104704Z" creationid="pingfangx" creationdate="20190620T104704Z">
        <seg>每当 Observables 的 &lt;e0&gt;任何&lt;/e0&gt; 发射新项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever &lt;e0&gt;each&lt;/e0&gt; of the Observables has emitted a new item</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104646Z" creationid="pingfangx" creationdate="20190620T104646Z">
        <seg>每当 Observables 的 &lt;e0&gt;每个&lt;/e0&gt; 发射一个新项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whenever an item is emitted by one Observable in a window defined by an item emitted by another</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T104712Z" creationid="pingfangx" creationdate="20190620T104712Z">
        <seg>每当一个 Observable 在由另一个项目发射的项目定义的窗口中发射一个项目时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which I can then unwrap again with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T105110Z" creationid="pingfangx" creationdate="20190620T105110Z">
        <seg>我可以再解除包装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190618T111935Z" creationid="pingfangx" creationdate="20190618T111935Z">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>—</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T095125Z" creationid="pingfangx" creationdate="20190620T095125Z">
        <seg>—</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Hot” and “Cold” Observables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="pingfangx" changedate="20190620T064846Z" creationid="pingfangx" creationdate="20190620T064846Z">
        <seg>“Hot” 和 “Cold” Observables</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
